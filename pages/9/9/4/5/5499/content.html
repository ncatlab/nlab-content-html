
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      generalisation as an adjunction in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="http://localhost/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="http://localhost/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      generalisation as an adjunction
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussions/?CategoryID=0" title="Discuss this page on the nForum. It does not yet have a dedicated thread; feel free to create one, giving it the same name as the title of this page" style="color:black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Generalisation as an adjunction</title></head>
<body>
<h1 id="generalisation_as_an_adjunction">Generalisation as an adjunction</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#introduction'>Introduction</a></li>
<li><a href='#potential_uses_in_machine_learning'>Potential uses in machine learning</a></li>
<li><a href='#potential_use_in_category_theory'>Potential use in category theory</a></li>
<li><a href='#idea'>Idea</a></li>
<ul>
<li><a href='#interpretation_for_noncategorytheorists'>Interpretation for non–category-theorists</a></li>
<li><a href='#what_is_a_concept'>What is a concept?</a></li>
<li><a href='#what_is_generalisation'>What is generalisation?</a></li>
<li><a href='#what_other_structure_might_the_category_of_examples_have'>What other structure might the category of examples have?</a></li>
</ul>
<li><a href='#some_simple_examples_of_generalisation_in_more_detail'>Some simple examples of generalisation in more detail</a></li>
<ul>
<li><a href='#1_logical_induction_by_conjunction'>1. Logical induction by conjunction</a></li>
<li><a href='#2_logical_induction_by_quantification'>2. Logical induction by quantification</a></li>
<li><a href='#3_leastsquares_fitting'>3. Least-squares fitting</a></li>
<li><a href='#where_are_the_adjunctions'>Where are the adjunctions?</a></li>
<li><a href='#the_problem_of_noise_and_of_different_languages'>The problem of noise, and of different languages</a></li>
<li><a href='#another_example_learning_linear_transformations'>Another example: learning linear transformations</a></li>
<li><a href='#another_example_linear_associators'>Another example: linear associators</a></li>
<li><a href='#another_example_averages'>Another example: averages</a></li>
<li><a href='#another_example_generalisation_against_a_background'>Another example: generalisation against a background</a></li>
</ul>
<li><a href='#informal_justification'>Informal justification</a></li>
<ul>
<li><a href='#1_colimits'>1. Colimits</a></li>
<li><a href='#2_when_different_views_overlap'>2. When different views overlap</a></li>
<ul>
<li><a href='#interpretation_for_noncategorytheorists_2'>Interpretation for non–category-theorists</a></li>
</ul>
<li><a href='#3_when_different_overlaps_disagree'>3. When different overlaps disagree</a></li>
<li><a href='#4_adjoints_as_the_solution_to_optimisation_problems'>4. Adjoints as the solution to optimisation problems</a></li>
<li><a href='#5_but_concepts_are_not_physical_objects'>5. But concepts are not physical objects</a></li>
<li><a href='#6_which_may_be_related_to'>6. Which may be related to…</a></li>
<li><a href='#7_categorical_perception'>7. Categorical perception</a></li>
<li><a href='#8_concepts_as_sheaves'>8. Concepts as sheaves</a></li>
<li><a href='#9_the_least_general_generalisation'>9. The least general generalisation</a></li>
<li><a href='#10_implying_as_little_as_possible'>10. Implying as little as possible</a></li>
<li><a href='#11_generalisation_as_limitformation'>11. Generalisation as limit-formation</a></li>
<li><a href='#12_change_of_language'>12. Change of language.</a></li>
<li><a href='#13_change_of_language_because_we_want_to_learn_new_stuff'>13. Change of language because we want to learn new stuff</a></li>
<li><a href='#14_two_different_languages_therefore_two_different_categories'>14. Two different languages, therefore two different categories</a></li>
<li><a href='#15_universal_quantification_as_generalisation'>15. Universal quantification as generalisation?</a></li>
<li><a href='#16_the_impossibility_of_generalising_exactly'>16. The impossibility of generalising exactly</a></li>
<li><a href='#17_generalisation_as_a_left_adjoint_which_does_the_best_it_can'>17. Generalisation as a left adjoint which “does the best it can”</a></li>
<li><a href='#18_galois_connections_and_the_idea_of_smallest_enclosing_concept'>18. Galois connections and the idea of smallest enclosing concept</a></li>
<li><a href='#19_galois_connections_and_intension_versus_extension'>19. Galois Connections and intension versus extension</a></li>
<li><a href='#20_syntax_versus_semantics'>20. Syntax versus semantics</a></li>
<li><a href='#21_the_adjunction_between_minimal_realization_and_behaviour'>21. The adjunction between minimal realization and behaviour</a></li>
</ul>
</ul>
</div>

<h2 id="introduction">Introduction</h2>

<p>The hypothesis I want to explore is that generalisation can be represented as an <a class="existingWikiWord" href="/nlab/show/adjunction">adjunction</a>. More precisely, that generalisation and instantiation can be represented as an <a class="existingWikiWord" href="/nlab/show/adjoint+pair">adjoint pair</a>, generalisation being the <a class="existingWikiWord" href="/nlab/show/left+adjoint">left adjoint</a>.</p>

<p>By “generalisation”, I mean learning concepts from examples, e.g. in machine learning. I believe that this applies to many different topics in machine learning, including statistical curve-fitting (and its implementation in various kinds of neural net), symbolic vector architectures, instance-based learning, and logical induction. If I’m right, this could be an important unification of these apparently unrelated topics.</p>

<p>Because I don’t have funding to do research, I’ve had no time to develop these ideas. So the best I can do so far is to justify the hypothesis by appealing to various intuitions, and to related mathematical and computational phenomena. I’ve put this material into nLab because I think it’s interesting, and may well be important to machine learning: the categorists and machine-learning experts I’ve asked agree. So perhaps other readers can supply technical substantiation or refutation. If I can ever get funding then of course I’ll do so as well. By the way, most of them have also said that even if this result is known to categorists, it isn’t known within machine learning, and that publicising it would therefore be useful.</p>

<h2 id="potential_uses_in_machine_learning">Potential uses in machine learning</h2>

<p>These are similar to those that <a class="existingWikiWord" href="/nlab/show/Joseph+Goguen">Joseph Goguen</a> proposed for category theory in computing science in <a class="existingWikiWord" href="/nlab/show/A+Categorical+Manifesto">A Categorical Manifesto</a>. If much concept learning can be represented by the same phenomenon, namely an adjunction, this should make it easier to compare learning algorithms and to translate algorithms from one branch of machine learning to another. Moreover, algorithms that can be represented as adjunctions may be better — if only because they’re easier to reason about — than those that can’t.</p>

<h2 id="potential_use_in_category_theory">Potential use in category theory</h2>

<p>This is very speculative. But suppose that many kinds of generalisation can be formulated as adjunctions. Then what properties distinguish those adjunctions from others? If none, does this mean that all adjunctions can be regarded as generalisations? If so, does that tell us anything useful about adjunctions? Perhaps an information-theoretic way of thinking about them?</p>

<h2 id="idea">Idea</h2>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be a category of concepts, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> be a category of sets of examples.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">G \colon E \to C</annotation></semantics></math> be a “generalisation” functor that maps each set of examples to its generalisation as a concept.</p>

<p>Conversely, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">F \colon C\to E</annotation></semantics></math> be a forgetful functor that maps each concept to some canonical set of examples.</p>

<p>Then my hypothesis is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> form an adjunction, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> being left adjoint to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>.</p>

<h3 id="interpretation_for_noncategorytheorists">Interpretation for non–category-theorists</h3>

<p>Suppose we have a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> of sets of examples, and a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> of concepts. Then we can define a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> that maps each set of examples <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> to a concept <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, by generalisation. Conversely, we can define a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> that maps each concept <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> to a set of examples <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>.</p>

<p>I hope that we can then regard <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> as finding what might be called the smallest generalisation, or most efficient representation, of its argument. Conversely, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> ought to “forget” whatever extra structure <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math> gained by becoming a concept, turning it back into a “canonical” set of examples. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> may not be inverses, but they are, in some sense, the nearest one can get to inverses. I say what’s in this paragraph because (a) these are properties that I believe generalisation and forgetting should have; (b) adjoint functors often (always?) seem to work like this.</p>

<h3 id="what_is_a_concept">What is a concept?</h3>

<p>I haven’t said anything about what a concept is. One possibility, just to illustrate the idea, is the statistical regression line given by a least-squares fit. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>‘s objects would then be sets of 2-d points to be fitted, and C’s would be regression lines, probably equipped with goodness-of-fit information. This is a simple example; instances of other, more complicated, statistical models could also be concepts.</p>

<p>Some other possibilities for concepts are: high-dimensional vectors formed by superimposing vectors of property-value pairs in so-called “symbolic vector architectures” or “holographic reduced representations”; regions of classification space; logical propositions learnt by induction.</p>

<h3 id="what_is_generalisation">What is generalisation?</h3>

<p>Here are some examples.</p>

<ul>
<li>
<p>The examples are two-dimensional points (members of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math>). Generalisation is least-squares fitting, as above. The concept is a line giving the best least-squares fit to the points.</p>
</li>

<li>
<p>Generalisation is fitting of some other statistical model. The concept is an instance of that model.</p>
</li>

<li>
<p>The examples are logical sentences, classified as positive or negative. Generalisation is logical induction. The concept is a new sentence from which we can infer as many of the positive examples as possible (hopefully all) and as few of the negative examples (hopefully none) as possible.</p>
</li>

<li>
<p>The examples are pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mrow><mi>v</mi><mo>,</mo><mi>w</mi></mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle{v,w}\rangle</annotation></semantics></math> associating an element of the vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> with an element of the vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math>. Generalisation is training a linear-associator neural net. The concept is a linear transformation which, if possible, maps all the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math> to the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math>, and if that’s not possible, does the best it can by finding an optimum transform which minimises interference between different <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mrow><mi>v</mi><mo>,</mo><mi>w</mi></mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle{v,w}\rangle</annotation></semantics></math> associations.</p>
</li>

<li>
<p>The examples are pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mrow><mi>p</mi><mo>,</mo><mi>l</mi></mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle{p,l}\rangle</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math> is a point in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math> is a member of some set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math> of symbolic labels. For instance, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math> might be elements of some space whose dimensions measure a voter’s preference for various policies; the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math> could then be the possible parties, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>green</mi><mo>,</mo><mi>labour</mi><mo>,</mo><mi>libdem</mi><mo>,</mo><mi>tory</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{green,labour,libdem,tory\}</annotation></semantics></math>. Generalisation is nearest-neighbour prediction. The concept is a function which extends the set of pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mrow><mi>p</mi><mo>,</mo><mi>l</mi></mrow><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle{p,l}\rangle</annotation></semantics></math>, mapping every point in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">R^n</annotation></semantics></math> to a label. It can therefore be used to predict the preferred party of other voters. I’ve taken this example from <em>Truth from Trash</em> by Chris Thornton.</p>
</li>

<li>
<p>The examples are the instances of generalisation given in this write-up. Generalisation is fitting each to a notion in category theory. The concept is a categorical construct…!</p>
</li>
</ul>

<h3 id="what_other_structure_might_the_category_of_examples_have">What other structure might the category of examples have?</h3>

<p>Although I introduced <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> as a category of sets of examples, I’m sure there are other possibilities. An obvious one, though still set-related, is that the objects are weighted sets, where each weight tells the generaliser how important the corresponding example is. This probably ties up with fuzzy logic, fuzzy set theory, and stochastic logic programming. See also the following section.</p>

<h2 id="some_simple_examples_of_generalisation_in_more_detail">Some simple examples of generalisation in more detail</h2>

<p>These are taken from my short write-up <a href="http://www.j-paine.org/generalisation.html"><em>Generalisation is an adjunction</em></a>, recast into the naming convention I’m using here.</p>

<h3 id="1_logical_induction_by_conjunction">1. Logical induction by conjunction</h3>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be the category whose objects are the atomic propositions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>, … and their conjunctions. Let there be an arrow from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">P'</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> implies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">P'</annotation></semantics></math>. This makes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> into a partial ordering defined by implication.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> be the category whose objects are non-empty sets of the above atomic propositions. It has the obvious partial ordering by inclusion.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> map each set of propositions in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> to their conjunction in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>; let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> be its inverse. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> reverse arrows, as in the next example.</p>

<p>The above is trivial, but I find it suggestive. Because it seems reasonable to say that forming the conjunction of a set of propositions as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> does is one (crude) way of generalising from them. Informally speaking, the conjunction contains just enough information to imply them all, but none of the others in the category (unless they were implied by the originals anyway). Now, we also know that in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, their conjunction is their limit. (More correctly, it’s a limit of the diagram containing the propositions and the implication arrows between them.) But this formalises the notion expressed in the “just enough information” sentence, because of the universal mapping property of the limit. (That is, any other proposition which implies the originals also implies their conjunction.)</p>

<h3 id="2_logical_induction_by_quantification">2. Logical induction by quantification</h3>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>‘s objects be the non-empty sets of sentences <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(I)</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> is an integer. So one object would be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mi>e</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>e</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">{ e(1), e(2) }</annotation></semantics></math>. Interpret <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(I)</annotation></semantics></math> as meaning “the integer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> is an example of the concept”. Interpret the arrows in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> as set inclusion.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be the category whose objects are sentences: either the atomic sentences <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(I)</annotation></semantics></math> or the universally-quantified sentence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>X</mi><mo lspace="verythinmathspace">:</mo><mi>e</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall X \colon e(X)</annotation></semantics></math>. (Unlike the category of sentences in the earlier example, this category does not contain conjunctions.) Interpret the arrows as implication.</p>

<p>Now define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> as follows. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> maps each singleton <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(I)</annotation></semantics></math> to the sentence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(I)</annotation></semantics></math>. It maps sets with more than one element to the universally-quantified sentence. It also reverses arrows, mapping set inclusion to reverse implication.</p>

<p>We could say that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> implements a simple form of logical induction, rather more interesting than the earlier one. And there are two languages, that of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> restricted compared to that of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>, because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> cannot express conjunctions, and so has to approximate them by quantifying over all possible cases. The functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> is “doing the best it can” in these circumstances.</p>

<h3 id="3_leastsquares_fitting">3. Least-squares fitting</h3>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>‘s objects be the non-empty sets of colinear elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math>. Once again, let the arrows be set inclusion.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be the category whose objects are either the singletons <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><msup><mi>R</mi> <mn>2</mn></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ x \in R^2 \}</annotation></semantics></math> or infinite lines in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math>. Let the arrows be set inclusion.</p>

<p>Then let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> map each singleton to itself, and map each set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> with more than one element to the line going through all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>‘s points. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> maps inclusions to inclusions. As with the previous instance, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> flattens most of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<h3 id="where_are_the_adjunctions">Where are the adjunctions?</h3>

<p>All the instances above can be formalised as adjunctions. Here’s a summary of the proof, via <a class="existingWikiWord" href="/nlab/show/Galois+connection">Galois connections</a>: 1. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> are posets. 2. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> are order-preserving, which is a necessary condition in the definition of Galois connection. 3. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> satisfy the Galois connection condition. 4. A Galois connection is a special case of an adjunction.</p>

<p>The first point follows from the orderings I imposed on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. The second holds for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>, because it’s either an identity, as in the least-squares example, or equivalent to one, as in the conjunction and quantification examples. It holds also for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, because it can’t “cross over”. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>&lt;</mo><mi>e</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">e \lt e'</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">G e</annotation></semantics></math> may equal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mi>e</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">G e'</annotation></semantics></math>, but it can’t be greater. The third point follows by simple calculation with these orders. The fourth is a standard result.</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> can be regarded as a functor which maps a set of examples to an object which is in some sense the “completion” of that set: the good old “free completion”. It acquires a right adjoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> which maps this object back to the set of all possible examples derivable from this completion object.</p>

<p>I think of this in terms of the units and counits: an adjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is determined by the two functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> and by two natural transformations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo lspace="verythinmathspace">:</mo><msub><mi>I</mi> <mi>E</mi></msub><mo>⇒</mo><mi>G</mi><mo>;</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">i \colon I_E \Rightarrow G;E</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>;</mo><mi>G</mi><mo>⇒</mo><msub><mi>I</mi> <mi>G</mi></msub></mrow><annotation encoding="application/x-tex">e \colon E;G \Rightarrow I_G</annotation></semantics></math>. Given any object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, there is a morphism taking every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mi>F</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">G F c</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> to the set of all possible examples, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> should map that back to the original generalisation, this is the identity. Hence we get one natural transformation.</p>

<p>In the other direction, given any object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>, the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">F G</annotation></semantics></math> will map it to the set of all possible examples of which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> is a part. There is an inclusion from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mi>G</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">F G e</annotation></semantics></math>, and since this respects the other inclusions in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>, once again we get a natural transformation, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo lspace="verythinmathspace">:</mo><msub><mi>I</mi> <mi>E</mi></msub><mo>⇒</mo><mi>G</mi><mo>;</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">i \colon I_E \Rightarrow G;E</annotation></semantics></math>.</p>

<p>(I need to relate this to the notion of limiting amount of information, showing how that arises from the adjunction.)</p>

<h3 id="the_problem_of_noise_and_of_different_languages">The problem of noise, and of different languages</h3>

<p>In the least-squares example, I stipulated that the sets of points in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> must be colinear. This isn’t very realistic: in real life, most sets of examples will not exactly fit a line.</p>

<p>In general, given any useful generalisation method, some sets of examples will not have an exact generalisation. You can say that this is due to experimental error, or to an inadequate statistical model, or to an insufficiently powerful description language, or to restricted storage capacity, or whatever. See also sections on “Change of language” below.</p>

<p>I thought of fixing this by extending <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> so that it maps each set of non-colinear points to the line with the least least-squares distance from them. (But what if, in this or other examples, there is no unique best generalisation?)</p>

<p>The problem with this is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> then no longer respects the arrows between the sets in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>. Originally, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> was a subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">S'</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(S)</annotation></semantics></math> was a subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>S</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(S')</annotation></semantics></math>. But this is no longer necessarily true: if the points in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> are colinear, and we make <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">S'</annotation></semantics></math> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> by adding a point that isn’t on the line, then the best-fit line to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">S'</annotation></semantics></math> will be different from that to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, so the inclusion won’t hold.</p>

<p>Maybe the way to fix this is not to decide <em>a priori</em> that the morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> should be inclusions, but to let them be determined by the morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. Philosophically speaking, perhaps this is reasonable — we don’t perceive the raw data directly, but always fit it to a preconceived model. But I feel I’m missing something else.</p>

<p>What’s the essence? A least-squares fit maps a set of points <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>e</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math> as follows. Some points <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>e</mi> <mi>good</mi></msub></mrow><annotation encoding="application/x-tex">e_good</annotation></semantics></math> fall exactly onto the regression line. Others, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>e</mi> <mi>bad</mi></msub></mrow><annotation encoding="application/x-tex">e_bad</annotation></semantics></math>, don’t. In effect, it’s splitting the set into two parts, one of which needs added error information to describe it. Equivalently, it’s adding error information to every point, even though that’s 0 for some. Consider in the light of the FCA example <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>apple</mi><mo>,</mo><mi>orange</mi><mo stretchy="false">}</mo><mo>,</mo><mo stretchy="false">{</mo><mi>apple</mi><mo>,</mo><mi>pear</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{apple,orange\},
\{apple,pear\}</annotation></semantics></math> vs. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>round</mi><mo stretchy="false">}</mo><mo>,</mo><mo stretchy="false">{</mo><mi>green</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{round\},\{green\}</annotation></semantics></math>, and extension vs. intension. What <em>property</em> is common to all points on a regression line?</p>

<p>… I need fonts to distinguish between sets of examples and their elements…</p>

<p>That’s about as far as I’ve got; the examples I’ve so far constructed have the same structure as in 18, and seem to be missing something. I need to think about the structure of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>, and probably get away from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> being only a subcategory of Set. One possibility which feels promising (thanks to Victor Winschel for encouraging me on this) is to see whether stochastic logic programming can be formulated in terms of adjoints.</p>

<h3 id="another_example_learning_linear_transformations">Another example: learning linear transformations</h3>

<p>(I need to complete this and the following examples.) In this, I’m leading up to generalisation in simple neural networks. Think of learning a linear transformation. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> is the category of sets of pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle v,w \rangle</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is the category of linear transformations between vector spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> puts pairs together to make a linear transformation. (What does <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> do, and is it unique?) As with the least-squares example, this only works exactly if I restrict the sets in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>.</p>

<h3 id="another_example_linear_associators">Another example: linear associators</h3>

<p>The idea is as in the previous example, but where sets of examples aren’t restricted to being expressible as linear transformations. In this case, generalisation has to “do the best it can”, modulo interference between learnt associations. Question: what should <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be? Ought it to be some kind of completion of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> above? See http://www.syndar.org/PAdams/The%20Linear%20Associator.pdf for how the associator works. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> will depend very tightly on how the associator is trained. I’ll start by considering how a single learning phase, in the terminology of the above reference, maps pairs to a matrix: the matrix <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> in the notation of the reference’s Equations 1 onwards. (Also to be completed.)</p>

<h3 id="another_example_averages">Another example: averages</h3>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> be the category of real pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>h</mi><mo>,</mo><mi>t</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle h, t \rangle</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be the category of real pairs whose elements sum to 1. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>h</mi><mo>,</mo><mi>t</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle h, t \rangle</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>h</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mo>,</mo><mi>t</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle h/(h+t), t/(h+t) \rangle</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> be the identity. (Are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> discrete?) (I’m working towards the way that induction in stochastic logic programming induces weights for the learnt clauses.)</p>

<h3 id="another_example_generalisation_against_a_background">Another example: generalisation against a background</h3>

<p>I don’t know what to call this, but it feels relevant. It’s a picture that came to me. Imagine that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> is the category of subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math>. Now imagine that we have a real plane hatched by irregular intersecting lines, as if someone has been slashing a pencil across it again and again, or Jackson Pollock has been painting it. (I’m being intentionally vague.) Now let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">E'</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> also be the category of subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>G</mi> <mn>1</mn></msub><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><mi>E</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">G_1 \colon E \to E'</annotation></semantics></math> distort each set of examples by moving each point in it to the nearest intersection of these lines. (Assume there is a unique intersection.) Then let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>G</mi> <mn>2</mn></msub><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>′</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">G_2 \colon E' \to C</annotation></semantics></math> find the smallest enclosing grid square as in my section “Galois connections and the idea of smallest enclosing concept” below. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>=</mo><msub><mi>G</mi> <mn>1</mn></msub><mo>;</mo><msub><mi>G</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G = G_1 ; G_2</annotation></semantics></math>.</p>

<p>A little more generally, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be a category whose objects are either also subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math>, or something that’s easy to picture as derived, using elementary plane geometry, from these subsets. For example, their boundaries, or their centroids. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> translate each …..</p>

<p>Informally, the idea is that there’s a “background” which is not related to the examples, …..</p>

<h2 id="informal_justification">Informal justification</h2>

<h3 id="1_colimits">1. Colimits</h3>

<p>Imagine various views of a physical object such as a leather armchair. A view of the top of the left arm; a view of the seat; and so on. Then we can merge these to make a composite view. If the views are sets, the merging can be described as a <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a> in the category of sets.</p>

<p>By the way, I mention the leather armchair because Goguen used it as an example of merging views in a paper on <a class="existingWikiWord" href="/nlab/show/sheaf+semantics+of+concurrent+interacting+objects">sheaf semantics of concurrent interacting objects</a>: <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.4296"><em>Sheaf Semantics for Concurrent Interacting Objects</em></a>.</p>

<h3 id="2_when_different_views_overlap">2. When different views overlap</h3>

<p>Such a colimit automatically handles the situation where different views overlap and agree on their overlaps. In other words, it’s a way to reconstruct as much of the armchair as possible from partial views of it.</p>

<p>(The chart and atlas representation of manifolds is an example of this too E.g. page 38 of <a href="http://maths.dept.shef.ac.uk/magic/course_files/143/ctlecture6.pdf"><em>Category theory Lecture 6: Colimits</em>, Jonathan Kirby</a>. )</p>

<h4 id="interpretation_for_noncategorytheorists_2">Interpretation for non–category-theorists</h4>

<p>I should explain that colimit is a categorical construction. Set union is a special case of it. Goguen introduced the notion that colimits can model “putting together” components into a system. Many computer-science researchers use them to put together specifications or program modules into bigger specifications or modules.</p>

<h3 id="3_when_different_overlaps_disagree">3. When different overlaps disagree</h3>

<p>But in real life, different views might disagree on their overlaps. In this case, we must find a way to combine these views with as little disagreement as possible. That also feels like a colimit.</p>

<h3 id="4_adjoints_as_the_solution_to_optimisation_problems">4. Adjoints as the solution to optimisation problems</h3>

<p>This ties up with the idea that left adjoints can be regarded as finding the optimum, or most efficient, solution to a problem.</p>

<p>(This is an interpretation I came across in the Wikipedia entry for [Adjoint functors] (http://en.wikipedia.org/wiki/Adjoint_functors): possibly authored by the Wikipedian called “Functor salad”. We can regard the solution as being an initial object in a category of solutions. Its initiality models the fact that it contains the least disagreement about overlaps, or what I think of as the least “strain”, of any possible solution.)</p>

<h3 id="5_but_concepts_are_not_physical_objects">5. But concepts are not physical objects</h3>

<p>In the above, I’ve been talking about reconstructing a single physical object from different, possibly incompatible, views of it: six blind men feel an elephant. I don’t know whether one should call such reconstruction “generalisation”. But I strongly suspect that there’s an analogy with the construction of a concept from examples of it, if we think of the examples as different views of the concept.</p>

<h3 id="6_which_may_be_related_to">6. Which may be related to…</h3>

<p>This may be related to the use of colimits for merging ontologies, and for sensor fusion.</p>

<h3 id="7_categorical_perception">7. Categorical perception</h3>

<p>I’ll note that this also feels relevant to the topic of “categorical perception” introduced by cognitive scientist Stevan Harnad, and to similar methods of learning classifications. <a href="http://eprints.ecs.soton.ac.uk/397/"><em>Neural network modeling of categorical perception</em>, by R.I. Damper and S.R. Harnad</a> ; <a href="http://cogprints.org/3017/1/catperc.html"><em>Categorical Perception</em>, by S.R. Harnad</a>. This is something I need to think about further: for the moment, I’ll just quote from Harnad’s abstract to the second paper:</p>

<pre><code>  Differences can be perceived as gradual and quantitative, as with
  different shades of gray, or they can be perceived as more abrupt and
  qualitative, as with different colors. The first is called continuous
  perception and the second categorical perception. Categorical
  perception (CP) can be inborn or can be induced by learning. Formerly
  thought to be peculiar to speech and color perception, CP turns
  out to be far more general, and may be related to how the neural
  networks in our brains detect the features that allow us to sort the
  things in the world into their proper categories, "warping" perceived
  similarities and differences so as to compress some things into the
  same
  perception and the second categorical perception. Categorical
  perception (CP) can be inborn or can be induced by learning. Formerly
  thought to be peculiar to speech and color perception, CP turns
  out to be far more general, and may be related to how the neural
  networks in our brains detect the features that allow us to sort the
  things in the world into their proper categories, "warping" perceived
  similarities and differences so as to compress some things into the
  same
  category and separate others into different categories.</code></pre>

<p>(The “categorical” here is not connected with category theory but with categorisation.)</p>

<h3 id="8_concepts_as_sheaves">8. Concepts as sheaves</h3>

<p>Goguen’s leather-armchair example actually applies not just to views of the shape itself, but to views of attributes defined on it: e.g. colour, temperature. This is how he introduces his <a class="existingWikiWord" href="/nlab/show/sheaf+semantics+of+concurrent+interacting+objects">sheaf semantics of concurrent interacting objects</a>, in which he represents objects as <a class="existingWikiWord" href="/nlab/show/sheaf">sheaves</a> of local observations, these being mappings from a base space (e.g. the surface of the chair) to attributes. Perhaps there is a way to represent concepts as sheaves of properties of examples, or something related.</p>

<h3 id="9_the_least_general_generalisation">9. The least general generalisation</h3>

<p>Another idea that I want to capture is that of least general generalisation. This phrase is used in inductive logic programming, and was introduced by <a class="existingWikiWord" href="/nlab/show/Gordon+Plotkin">Gordon Plotkin</a> to describe anti-unification (_A note on inductive generalization_. In B. Meltzer and D. Michie, editors, “Machine Intelligence”, volume 5, 1970). But I want to think of it more generally. For instance, if we have a <a class="existingWikiWord" href="/nlab/show/poset">poset</a> of concepts, the least general generalisation of two concepts <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">c1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">c2</annotation></semantics></math> is a new concept <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> which implies as much as possible about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">c1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">c2</annotation></semantics></math>, but as little as possible about anything else. It contains the information we need to reconstruct the examples, but as little else as possible.</p>

<h3 id="10_implying_as_little_as_possible">10. Implying as little as possible</h3>

<p>Similarly, in a category of logical propositions, the product of two propositions (their conjunction) implies each one, but nothing else. It contains the information we need to reconstruct the examples, but nothing else. This property too is something that I believe a generalisation should have.</p>

<h3 id="11_generalisation_as_limitformation">11. Generalisation as limit-formation</h3>

<p>This leads me to the intuition that generalisation can be represented as a limit.</p>

<h3 id="12_change_of_language">12. Change of language.</h3>

<p>But, contrary to the previous three paragraphs, the language we normally use to describe concepts is different from that used to describe examples. For example, in statistical least-squares regression, the concept is a line plus error information, but the examples are points.</p>

<h3 id="13_change_of_language_because_we_want_to_learn_new_stuff">13. Change of language because we want to learn new stuff</h3>

<p>Moreover, we usually want the concept to be compressed or otherwise different from just being a conjunction or something analogous. I suppose there are various reasons for this: * Saving memory. * In some generalisers, including most neural nets, stored examples will interfere just because of the architecture. This may not be a good thing, but we need to be able to model it. * Automated discovery. We often want the discovered concept to say something new about the examples and their similarity. A mere conjunction can’t do that. * A special case of (c) is when, in inductive logic programming, we introduce new vocabulary: so-called background knowledge.</p>

<h3 id="14_two_different_languages_therefore_two_different_categories">14. Two different languages, therefore two different categories</h3>

<p>This difference between the language of examples and the language of concepts is why I have two categories, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. And it’s also why I want to model generalisation as an adjunction, rather than as only a limit or colimit.</p>

<h3 id="15_universal_quantification_as_generalisation">15. Universal quantification as generalisation?</h3>

<p>This may be related to the fact that in categorical logic, universal quantification can be represented as an adjunction. (See the section on “Lawvere quantifiers: Quantification as adjunction” in <a class="existingWikiWord" href="/nlab/show/quantifier">quantifier</a>). Can one regard that as a kind of generalisation?</p>

<h3 id="16_the_impossibility_of_generalising_exactly">16. The impossibility of generalising exactly</h3>

<p>Now that I’ve introduced the change of language, a very important point is that the generalisation functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> from examples to concepts, and the forgetful functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> from concepts to examples, may not be able to translate exactly. In particular, the language of concepts may not be able to summarise every set of examples exactly. For example, a linear regression line can’t represent non-colinear points exactly. A categorisation of animals into a class of animals that resemble sparrows and blackbirds, and another class of animals that resemble dogs, cats, and horses, will struggle to place duck-billed platypuses.</p>

<h3 id="17_generalisation_as_a_left_adjoint_which_does_the_best_it_can">17. Generalisation as a left adjoint which “does the best it can”</h3>

<p>In such cases, I think of the adjunction as “doing the best it can” to create concepts, or to reconstruct examples from concepts. I think intuitively of mapping from examples to concepts as creating a kind of “strain”. Imagine the sets of examples as points on a plane, and generalisation as trying to enclose each set with a springy piece of metal like an artist’s flexicurve. The flexicurve can’t bend sharply, so the “flexicurve concept language” makes the set boundaries smoother and wider than they should be. (Is this intuition worth formalising?)</p>

<h3 id="18_galois_connections_and_the_idea_of_smallest_enclosing_concept">18. Galois connections and the idea of smallest enclosing concept</h3>

<p>This is related to an explanation of adjunction in terms of <a class="existingWikiWord" href="/nlab/show/Galois+connection">Galois connections</a>, from a chapter in “The Logical foundations of cognition” edited by John Macnamara and Gonzalo E. Reyes (once accessible on Google Books, but they’ve blocked access). The authors describe a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> whose objects are sets in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math>, and a subcategory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> constructed as follows. Draw a grid on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>R</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math> of cells of side 1. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>‘s objects are shapes made by combining these grid cells: in other words, unions of squares of side 1. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">G:E\to C</annotation></semantics></math> map each set to the smallest union of squares enclosing it, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">F:C\to E</annotation></semantics></math> map each union of squares to itself. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> form a <a class="existingWikiWord" href="/nlab/show/Galois+connection">Galois connection</a>. That’s well known, but it’s a nice explanation, and perhaps a good “intuition pump” for concepts and examples. It makes me think of generalisation as finding the “smallest enclosing concept” for a set of examples.</p>

<h3 id="19_galois_connections_and_intension_versus_extension">19. Galois Connections and intension versus extension</h3>

<p>Jeremy Gibbons reminded me that <a class="existingWikiWord" href="/nlab/show/Galois+connection">Galois connections</a> are used in <a class="existingWikiWord" href="/nlab/show/Formal+Concept+Analysis">Formal Concept Analysis</a> to map between the intension (set of characterising attributes) and the extension (set of examples) of a concept. See e.g. <a href="http://www.alpheccar.org/fr/posts/show/32">http://www.alpheccar.org/fr/posts/show/32</a> (URL not currently accessible). Jeremy felt that this is morally the same as my machine learning scenario — inferring a concept from a set of examples and/or a set of properties.</p>

<h3 id="20_syntax_versus_semantics">20. Syntax versus semantics</h3>

<p>My idea probably also related to Lawvere’s comment about an adjunction between syntax and semantics, explained in Peter Smith’s article <a href="http://www.logicmatters.net/resources/pdfs/Galois.pdf"><em>The Galois connection between syntax and semantics</em></a>. As <a href="http://patternsinfp.wordpress.com"><em>Patterns in Functional Programming</em></a>‘s posting <a href="http://patternsinfp.wordpress.com/2011/02/15/universal-properties-and-galois-connections/"><em>Universal properties and Galois connections</em></a> puts it:</p>

<pre><code>This construction can be used to translate a problem about 
the extension  of a concept (that is, an enumeration of 
its instances) into one about the   intension (that is, the 
characteristic properties of its instances). It is related to 
the  observation that "syntax and semantics are adjoint"&amp;#8212;under the 
analogy that "objects" are sets of mathematical structures, 
"properties"   are axioms, and the relation is "satisfaction", 
the models of an axiomatic theory $T$ are included in a set of structures 
$S$ 
if and only if the theory $T$ logically entails the minimal 
axiomatization of $S$.</code></pre>

<p>Thanks to Jeremy and to Viktor Winschel for pointing this out.</p>

<h3 id="21_the_adjunction_between_minimal_realization_and_behaviour">21. The adjunction between minimal realization and behaviour</h3>

<p>Hendrik Hilberdink asked whether my generalisation adjunction is related to the adjunction between minimal realization and behaviour of an automaton. This is worth looking into. Perhaps the structure of those categories will give some clues about that of my categories of concepts and examples.</p>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on October  3, 2011 at 07:33:32.
    See the <a href="/nlab/history/generalisation+as+an+adjunction" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/generalisation+as+an+adjunction" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussions/?CategoryID=0">Discuss</a><span class="backintime"><a href="/nlab/revision/generalisation+as+an+adjunction/18" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/generalisation+as+an+adjunction" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/generalisation+as+an+adjunction" accesskey="S" class="navlink" id="history" rel="nofollow">History (18 revisions)</a>
  <a href="/nlab/show/generalisation+as+an+adjunction/cite" style="color: black">Cite</a>
  <a href="/nlab/print/generalisation+as+an+adjunction" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/generalisation+as+an+adjunction" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
