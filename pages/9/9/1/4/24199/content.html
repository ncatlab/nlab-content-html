
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      spectral sequences in homotopy type theory in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      spectral sequences in homotopy type theory
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/14549/#Item_3" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Spectral sequences in homotopy type theory</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="type_theory">Type theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></strong> <a class="existingWikiWord" href="/nlab/show/metalanguage">metalanguage</a>, <a class="existingWikiWord" href="/nlab/show/practical+foundations">practical foundations</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/judgement">judgement</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hypothetical+judgement">hypothetical judgement</a>, <a class="existingWikiWord" href="/nlab/show/sequent">sequent</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/antecedents">antecedents</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/consequent">consequent</a>, <a class="existingWikiWord" href="/nlab/show/succedents">succedents</a></li>
</ul>
</li>
</ul>

<ol>
<li><a class="existingWikiWord" href="/nlab/show/type+formation+rule">type formation rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+introduction+rule">term introduction rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+elimination+rule">term elimination rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/computation+rule">computation rule</a></li>
</ol>

<p><strong><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></strong> (<a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent</a>, <a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional</a>, <a class="existingWikiWord" href="/nlab/show/observational+type+theory">observational type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>)</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a></li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/syntax">syntax</a></strong> <a class="existingWikiWord" href="/nlab/show/object+language">object language</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/theory">theory</a>, <a class="existingWikiWord" href="/nlab/show/axiom">axiom</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>/<a class="existingWikiWord" href="/nlab/show/type">type</a> (<a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/definition">definition</a>/<a class="existingWikiWord" href="/nlab/show/proof">proof</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a> (<a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/theorem">theorem</a></p>
</li>
</ul>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></strong> = <br /> <strong><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/programs+as+proofs">programs as proofs</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation type theory/category theory</a></strong></p>

<table><thead><tr><th><a class="existingWikiWord" href="/nlab/show/logic">logic</a></th><th><a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a> (<a class="existingWikiWord" href="/nlab/show/internal+logic+of+set+theory">internal logic</a> of)</th><th><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></th><th><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></th></tr></thead><tbody><tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object">object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type">type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/predicate">predicate</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/family+of+sets">family of sets</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/display+morphism">display morphism</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+type">dependent type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof">proof</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/element">element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/term">term</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+rule">cut rule</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/composition">composition</a> of <a class="existingWikiWord" href="/nlab/show/classifying+morphisms">classifying morphisms</a> / <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of <a class="existingWikiWord" href="/nlab/show/display+maps">display maps</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/substitution">substitution</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/introduction+rule">introduction rule</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/counit">counit</a> for hom-tensor adjunction</td><td style="text-align: left;">lambda</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/elimination+rule">elimination rule</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/unit">unit</a> for hom-tensor adjunction</td><td style="text-align: left;">application</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+elimination">cut elimination</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;">one of the <a class="existingWikiWord" href="/nlab/show/zigzag+identities">zigzag identities</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/beta+reduction">beta reduction</a></td></tr>
<tr><td style="text-align: left;">identity elimination for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;">the other <a class="existingWikiWord" href="/nlab/show/zigzag+identity">zigzag identity</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/eta+conversion">eta conversion</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/true">true</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/singleton">singleton</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-2%29-truncated+object">(-2)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+0">h-level 0</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/unit+type">unit type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/false">false</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+set">empty set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>, <a class="existingWikiWord" href="/nlab/show/truth+value">truth value</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subterminal+object">subterminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncated+object">(-1)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-proposition">h-proposition</a>, <a class="existingWikiWord" href="/nlab/show/mere+proposition">mere proposition</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+conjunction">logical conjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cartesian+product">cartesian product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product">product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product+type">product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjunction">disjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjoint+union">disjoint union</a> (<a class="existingWikiWord" href="/nlab/show/support">support</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/sum+type">sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+set">function set</a> (into <a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a> (into <a class="existingWikiWord" href="/nlab/show/subterminal+object">subterminal object</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a> (into <a class="existingWikiWord" href="/nlab/show/h-proposition">h-proposition</a>)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/negation">negation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+set">function set</a> into <a class="existingWikiWord" href="/nlab/show/empty+set">empty set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a> into <a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a> into <a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universal+quantification">universal quantification</a></td><td style="text-align: left;">indexed <a class="existingWikiWord" href="/nlab/show/cartesian+product">cartesian product</a> (of family of <a class="existingWikiWord" href="/nlab/show/subsingletons">subsingletons</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a> (of family of <a class="existingWikiWord" href="/nlab/show/subterminal+objects">subterminal objects</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product+type">dependent product type</a> (of family of <a class="existingWikiWord" href="/nlab/show/h-propositions">h-propositions</a>)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/existential+quantification">existential quantification</a></td><td style="text-align: left;">indexed <a class="existingWikiWord" href="/nlab/show/disjoint+union">disjoint union</a> (<a class="existingWikiWord" href="/nlab/show/support">support</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+equivalence">logical equivalence</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/bijection+set">bijection set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object+of+isomorphisms">object of isomorphisms</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+type">equivalence type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/support+set">support set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/support+object">support object</a>/<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/propositional+truncation">propositional truncation</a>/<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/n-image">n-image</a> of <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a> into <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/n-truncation">n-truncation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/n-truncation+modality">n-truncation modality</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equality">equality</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/diagonal+function">diagonal function</a>/<a class="existingWikiWord" href="/nlab/show/diagonal+subset">diagonal subset</a>/<a class="existingWikiWord" href="/nlab/show/diagonal+relation">diagonal relation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/path+space+object">path space object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/identity+type">identity type</a>/<a class="existingWikiWord" href="/nlab/show/path+type">path type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/completely+presented+set">completely presented set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/discrete+object">discrete object</a>/<a class="existingWikiWord" href="/nlab/show/0-truncated+object">0-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+2">h-level 2</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/set">set</a>/<a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a> with <a class="existingWikiWord" href="/nlab/show/equivalence+relation">equivalence relation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/groupoid+object+in+an+%28infinity%2C1%29-category">internal 0-groupoid</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>/<a class="existingWikiWord" href="/nlab/show/setoid">setoid</a> with its <a class="existingWikiWord" href="/nlab/show/pseudo-equivalence+relation">pseudo-equivalence relation</a> an actual <a class="existingWikiWord" href="/nlab/show/equivalence+relation">equivalence relation</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+class">equivalence class</a>/<a class="existingWikiWord" href="/nlab/show/quotient+set">quotient set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient">quotient</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+type">quotient type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/W-type">W-type</a>, <a class="existingWikiWord" href="/nlab/show/M-type">M-type</a></td></tr>
<tr><td style="text-align: left;">higher <a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></td></tr>
<tr><td style="text-align: left;">-</td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/0-truncated">0-truncated</a> <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+inductive+type">quotient inductive type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinduction">coinduction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/limit">limit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinductive+type">coinductive type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/preset">preset</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type">type</a> without <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a> of <a class="existingWikiWord" href="/nlab/show/truth+values">truth values</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+of+propositions">type of propositions</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+of+discourse">domain of discourse</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universe">universe</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+universe">type universe</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modality">modality</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/closure+operator">closure operator</a>, (<a class="existingWikiWord" href="/nlab/show/idempotent+monad">idempotent</a>) <a class="existingWikiWord" href="/nlab/show/monad">monad</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modal+type+theory">modal type theory</a>, <a class="existingWikiWord" href="/nlab/show/monad+%28in+computer+science%29">monad (in computer science)</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+logic">linear logic</a></td><td style="text-align: left;"></td><td style="text-align: left;">(<a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric</a>, <a class="existingWikiWord" href="/nlab/show/closed+monoidal+category">closed</a>) <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal category</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+type+theory">linear type theory</a>/<a class="existingWikiWord" href="/nlab/show/quantum+computation">quantum computation</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof+net">proof net</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/string+diagram">string diagram</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quantum+circuit">quantum circuit</a></td></tr>
<tr><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/contraction+rule">contraction rule</a></td><td style="text-align: left;"></td><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/diagonal">diagonal</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/no-cloning+theorem">no-cloning theorem</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/synthetic+mathematics">synthetic mathematics</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+specific+embedded+programming+language">domain specific embedded programming language</a></td></tr>
</tbody></table>

</div>
<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+levels">homotopy levels</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-type+theory">2-type theory</a>, <a class="existingWikiWord" href="/michaelshulman/show/2-categorical+logic">2-categorical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory+-+contents">homotopy type theory - contents</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/univalence">univalence</a>, <a class="existingWikiWord" href="/nlab/show/function+extensionality">function extensionality</a>, <a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+type+theory">cohesive homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/directed+homotopy+type+theory">directed homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/HoTT+methods+for+homotopy+theorists">HoTT methods for homotopy theorists</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/semantics">semantics</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>, <a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/display+map">display map</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+a+topos">internal logic of a topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Mitchell-Benabou+language">Mitchell-Benabou language</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kripke-Joyal+semantics">Kripke-Joyal semantics</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type-theoretic+model+category">type-theoretic model category</a></li>
</ul>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/type+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>

<h4 id="homotopy_theory">Homotopy theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+theory">homotopy theory</a>, <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+theory">(∞,1)-category theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></strong></p>

<p>flavors: <a class="existingWikiWord" href="/nlab/show/stable+homotopy+theory">stable</a>, <a class="existingWikiWord" href="/nlab/show/equivariant+homotopy+theory">equivariant</a>, <a class="existingWikiWord" href="/nlab/show/rational+homotopy+theory">rational</a>, <a class="existingWikiWord" href="/nlab/show/p-adic+homotopy+theory">p-adic</a>, <a class="existingWikiWord" href="/nlab/show/proper+homotopy+theory">proper</a>, <a class="existingWikiWord" href="/nlab/show/geometric+homotopy+theory">geometric</a>, <a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+theory">cohesive</a>, <a class="existingWikiWord" href="/nlab/show/directed+homotopy+theory">directed</a>…</p>

<p>models: <a class="existingWikiWord" href="/nlab/show/topological+homotopy+theory">topological</a>, <a class="existingWikiWord" href="/nlab/show/simplicial+homotopy+theory">simplicial</a>, <a class="existingWikiWord" href="/nlab/show/localic+homotopy+theory">localic</a>, …</p>

<p>see also <strong><a class="existingWikiWord" href="/nlab/show/algebraic+topology">algebraic topology</a></strong></p>

<p><strong>Introductions</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Introduction+to+Topology+--+2">Introduction to Basic Homotopy Theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Introduction+to+Homotopy+Theory">Introduction to Abstract Homotopy Theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometry+of+physics+--+homotopy+types">geometry of physics – homotopy types</a></p>
</li>
</ul>

<p><strong>Definitions</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy">homotopy</a>, <a class="existingWikiWord" href="/nlab/show/higher+homotopy">higher homotopy</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Pi-algebra">Pi-algebra</a>, <a class="existingWikiWord" href="/nlab/show/spherical+object+and+Pi%28A%29-algebra">spherical object and Pi(A)-algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+coherent+category+theory">homotopy coherent category theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopical+category">homotopical category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+category">model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/category+of+fibrant+objects">category of fibrant objects</a>, <a class="existingWikiWord" href="/nlab/show/cofibration+category">cofibration category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Waldhausen+category">Waldhausen category</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Ho%28Top%29">Ho(Top)</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/homotopy+category+of+an+%28%E2%88%9E%2C1%29-category">homotopy category of an (∞,1)-category</a></li>
</ul>
</li>
</ul>

<p><strong>Paths and cylinders</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/left+homotopy">left homotopy</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cylinder+object">cylinder object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cone">mapping cone</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/right+homotopy">right homotopy</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/path+object">path object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cocone">mapping cocone</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/generalized+universal+bundle">universal bundle</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/interval+object">interval object</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+localization">homotopy localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/infinitesimal+interval+object">infinitesimal interval object</a></p>
</li>
</ul>
</li>
</ul>

<p><strong>Homotopy groups</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+group">homotopy group</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+group">fundamental group</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+group+of+a+topos">fundamental group of a topos</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Brown-Grossman+homotopy+group">Brown-Grossman homotopy group</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/categorical+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">categorical homotopy groups in an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">geometric homotopy groups in an (∞,1)-topos</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid">fundamental ∞-groupoid</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+groupoid">fundamental groupoid</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/path+groupoid">path groupoid</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+in+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">fundamental ∞-groupoid in a locally ∞-connected (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+of+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">fundamental ∞-groupoid of a locally ∞-connected (∞,1)-topos</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%28%E2%88%9E%2C1%29-category">fundamental (∞,1)-category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+category">fundamental category</a></li>
</ul>
</li>
</ul>

<p><strong>Basic facts</strong></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+group+of+the+circle+is+the+integers">fundamental group of the circle is the integers</a></li>
</ul>

<p><strong>Theorems</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+theorem+of+covering+spaces">fundamental theorem of covering spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Freudenthal+suspension+theorem">Freudenthal suspension theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Blakers-Massey+theorem">Blakers-Massey theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+homotopy+van+Kampen+theorem">higher homotopy van Kampen theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/nerve+theorem">nerve theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Whitehead%27s+theorem">Whitehead's theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Hurewicz+theorem">Hurewicz theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Galois+theory">Galois theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+hypothesis">homotopy hypothesis</a>-theorem</p>
</li>
</ul>
</div></div>
</div>
</div>

<blockquote>
<p>This page is about formalizing the notion of <a class="existingWikiWord" href="/nlab/show/spectral+sequences">spectral sequences</a> in <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>. For now, it contains mainly a fixed version of two blog posts, one at the <a href="http://golem.ph.utexas.edu/category/2013/08/what_is_a_spectral_sequence.html">n-category cafe</a> and the other on the <a href="http://homotopytypetheory.org/2013/08/08/spectral-sequences/">HoTT blog</a>. For more see the References <a href="#References">below</a>.</p>
</blockquote>

<h1 id="spectral_sequences_in_homotopy_type_theory">Spectral sequences in homotopy type theory</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#what_is_a_spectral_sequence'>What is a spectral sequence?</a></li>
<li><a href='#spectral_sequences_in_hott'>Spectral Sequences in HoTT</a></li>
<li><a href='#on_indexing_choices'>On indexing choices</a></li>
<li><a href='#notes'>Notes</a></li>
<li><a href='#References'>References</a></li>
</ul>
</div>

<h2 id="what_is_a_spectral_sequence">What is a spectral sequence?</h2>

<p>There are many answers to “what is a <a class="existingWikiWord" href="/nlab/show/spectral+sequence">spectral sequence</a>?”, but the one I’m proposing right now is the following analogy. (In my experience, category theorists tend to like analogies — possibly because, as John Baez once said, every sufficiently good analogy is yearning to become a functor. This one is no exception.)</p>

<blockquote>
<p>Spectral sequences are to long exact sequences as iterated extensions are to extensions.</p>
</blockquote>

<p>(Without knowing anything else, the terminology suggests that spectral sequences could also be called “iterated long exact sequences”.)</p>

<p>There are four phrases here that I need to explain, and two more concepts that have a ghostly presence (fibration sequences and iterated fibration sequences). First of all, an <em>extension</em> is a sequence of morphisms of abelian groups (for simplicity — more generally we could be in any abelian category):</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mover><mo>→</mo><mi>f</mi></mover><mi>B</mi><mover><mo>→</mo><mi>g</mi></mover><mi>C</mi></mrow><annotation encoding="application/x-tex"> A \xrightarrow{f} B \xrightarrow{g} C</annotation></semantics></math></div>
<p>such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is the inclusion of the kernel of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> is the quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> by the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>. Equivalently, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is injective, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> is surjective, and the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is equal to the kernel of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>. The simplest example is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mover><mo>→</mo><mrow><mo stretchy="false">(</mo><mi>id</mi><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mover><mi>A</mi><mo>⊕</mo><mi>C</mi><mover><mo>→</mo><mrow><msub><mi>proj</mi> <mn>2</mn></msub></mrow></mover><mi>C</mi><mo>.</mo></mrow><annotation encoding="application/x-tex"> A \xrightarrow{(id,0)} A\oplus C \xrightarrow{proj_2} C.</annotation></semantics></math></div>
<p>An extension that’s isomorphic to one of this form is said to be <em>split</em>. In general, we can regard an extension as exhibiting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> as “put together” in some more general way from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>; we say that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is an “extension of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>”. The underlying set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is always isomorphic to the cartesian product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A\times C</annotation></semantics></math>, so we can think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> as a sort of “twisted product” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. (In fact, as usual in this sort of situtaion, the twisting is measured by a cohomology class, living in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Ext</mi> <mn>1</mn></msup><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ext^1(C,A)</annotation></semantics></math>, but we won’t need that today.)</p>

<p>Thinking of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> as put together from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, we can draw certain conclusions about the one from the other, or the other from the one. The most obvious is that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mi>C</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=C=0</annotation></semantics></math>, then also <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B=0</annotation></semantics></math>. The converse also holds: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B=0</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mi>C</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=C=0</annotation></semantics></math>. If only <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A=0</annotation></semantics></math>, then we can conclude <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">B=C</annotation></semantics></math>, and similarly if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C=0</annotation></semantics></math> we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A=B</annotation></semantics></math>. We can also say fancier things of this sort, e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is finite, or finitely generated, if and only if both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> are.</p>

<p>Next, a <em>long exact sequence</em> (LES) is a longer sequence of morphisms of abelian groups</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mover><mo>→</mo><mrow><msub><mi>f</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mover><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mover><mo>→</mo><mrow><msub><mi>f</mi> <mi>n</mi></msub></mrow></mover><msub><mi>A</mi> <mi>n</mi></msub><mover><mo>→</mo><mrow><msub><mi>f</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mover><mi>⋯</mi></mrow><annotation encoding="application/x-tex"> \cdots \xrightarrow{f_{n+1}} A_{n+1} \xrightarrow{f_n} A_n \xrightarrow{f_{n-1}} \cdots </annotation></semantics></math></div>
<p>such that for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">f_n</annotation></semantics></math> is equal to the kernel of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{n-1}</annotation></semantics></math> (called “exactness at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math>”). The sequence might be infinite or finite in either direction. How are LES’s related to extensions? Well, one obvious relationship is that an extension can equivalently be described as an exact sequence of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>→</mo><mi>A</mi><mover><mo>→</mo><mi>f</mi></mover><mi>B</mi><mover><mo>→</mo><mi>g</mi></mover><mi>C</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> 0 \to A \xrightarrow{f} B \xrightarrow{g} C \to 0</annotation></semantics></math></div>
<p>(a “short exact sequence”), since in such a sequence, exactness at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> just means injectivity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>, and exactness at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> just means surjectivity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>. However, what I want to focus on instead is the basic homotopical origin of LES’s, namely fibration sequences. A <em>fibration sequence</em> is a sequence of maps of pointed spaces</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mover><mo>→</mo><mi>f</mi></mover><mi>Y</mi><mover><mo>→</mo><mi>g</mi></mover><mi>Z</mi></mrow><annotation encoding="application/x-tex"> X \xrightarrow{f} Y \xrightarrow{g} Z </annotation></semantics></math></div>
<p>such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is (up to homotopy) the inclusion of the homotopy fiber of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> over the basepoint. (By “space” I really mean “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groupoid”, which a classical topologist could read as “topological space up to weak homotopy equivalence” or “simplicial set up to weak homotopy equivalence”, and a homotopy type theorist could read as “type”.) The simplest example is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>→</mo><mi>X</mi><mo>×</mo><mi>Z</mi><mo>→</mo><mi>Z</mi><mo>,</mo></mrow><annotation encoding="application/x-tex"> X \to X\times Z \to Z,</annotation></semantics></math></div>
<p>the “trivial bundle” over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> with fiber <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. In general, we can think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> as being “put together” from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> in some more general way, as a “twisted product”. Note that this is very similar to how we think of an extension, except that we’ve replaced our abelian groups with spaces.</p>

<p>Of course, a space is not exactly an abelian group, but it contains many abelian groups, namely its homotopy groups. So we might expect that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is a twisted product of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> as above, that its homotopy groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math> would be twisted products of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Z)</annotation></semantics></math>, i.e. that there would be extensions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X) \to \pi_n(Y) \to \pi_n(Z)</annotation></semantics></math>. This is not true, since the various dimensions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> can “interact” in a nontrivial way; but instead we have a <em>long</em> exact sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>→</mo><mi>⋯</mi><mo>.</mo></mrow><annotation encoding="application/x-tex"> \cdots \to \pi_{n+1}(X) \to \pi_{n+1}(Y) \to \pi_{n+1}(Z) \to \pi_n(X) \to \pi_n(Y) \to \pi_n(Z) \to \cdots. </annotation></semantics></math></div>
<p>This LES can be regarded as expressing a way in which the groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math>, considered as a whole, are “put together” out of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X)</annotation></semantics></math>‘s and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Z)</annotation></semantics></math>’s. We get some of the same sorts of results, e.g. if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_n(X)=0</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y) = \pi_n(Z)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, and dually. But some different things happen, e.g. if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_n(Y)=0</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, rather than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X) = 0 = \pi_n(Z)</annotation></semantics></math> we get <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X) = \pi_{n+1}(Z)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> (and indeed, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is contractible, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>=</mo><mi>Ω</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">X = \Omega Z</annotation></semantics></math>).</p>

<p>Another way to express the LES of a fibration, which looks more like what we’ll see for spectral sequences later on, is that there exist maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>δ</mi> <mi>n</mi></msub><mo>:</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta_n : \pi_n(Z) \to \pi_{n-1}(X)</annotation></semantics></math> and extensions</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>im</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex"> im(\delta_{n+1}) \to \pi_n(Y) \to ker(\delta_n). </annotation></semantics></math></div>
<p>In other words, instead of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math> being put together from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Z)</annotation></semantics></math>, it’s put together from a <em>subgroup</em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Z)</annotation></semantics></math> and a <em>quotient</em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X)</annotation></semantics></math>. This allows us to fulfil the yearnings of the analogy between fibration sequences and extensions: for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> there’s a functor from the category of fibration sequences to the category of extensions, sending <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X\to Y\to Z</annotation></semantics></math> to the above extension.</p>

<p>Of course, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\pi_n</annotation></semantics></math> is only an abelian group for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n\ge 2</annotation></semantics></math>. Some of what we do with abelian groups can be extended to the case of groups (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math>) and pointed sets (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math>), but I don’t want to get into that. Feel free to assume all spaces are simply connected. Another way to avoid nonabelianness is to replace spaces with <em>spectra</em>, in which case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\pi_n</annotation></semantics></math> is an abelian group not only for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n\ge 0</annotation></semantics></math> but for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">n\in \mathbb{Z}</annotation></semantics></math>. In this case, the LES of a fibration sequence extends infinitely in both directions.</p>

<p>Now let’s move on to the other side of the analogy, starting with iterated extensions. By an <em>iterated extension</em> I mean a sequence of extensions of the following form:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msub><mi>A</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mi>s</mi></msub></mtd></mtr> <mtr><mtd><msub><mi>A</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>B</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>A</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  \vdots \\
  A_{s+1} \to B_{s+1} \to B_s\\
  A_s \to B_{s} \to B_{s-1} \\
  A_{s-1} \to B_{s-1} \to B_{s-2}\\
  \vdots
}
</annotation></semantics></math></div>
<p>The intent here is to regard <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>:</mo><mo>≡</mo><mi>lim</mi><mo stretchy="false">(</mo><mi>⋯</mi><mo>→</mo><msub><mi>B</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mi>s</mi></msub><mo>→</mo><mi>⋯</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B :\equiv \lim (\cdots \to B_{s+1} \to B_s \to \cdots)</annotation></semantics></math> as “put together” from the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">A_s</annotation></semantics></math>‘s and from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>:</mo><mo>≡</mo><mo lspace="0em" rspace="thinmathspace">colim</mo><mo stretchy="false">(</mo><mi>⋯</mi><mo>→</mo><msub><mi>B</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mi>s</mi></msub><mo>→</mo><mi>⋯</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C :\equiv \colim (\cdots \to B_{s+1} \to B_s \to \cdots)</annotation></semantics></math>. In many cases, the sequence of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">A_s</annotation></semantics></math>’s will be eventually zero in one direction or the other, so that the sequence of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>B</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">B_s</annotation></semantics></math>’s will similarly be eventually constant. Eventual constancy as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>→</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex">s\to\infty</annotation></semantics></math> implies that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is the eventual value, while eventual constancy as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>→</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex">s\to-\infty</annotation></semantics></math> implies that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is that eventual value. In the latter case it simplifies things with no essential loss of generality to end with</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msub><mi>A</mi> <mn>1</mn></msub><mo>→</mo><msub><mi>B</mi> <mn>1</mn></msub><mo>→</mo><msub><mi>B</mi> <mn>0</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>B</mi> <mn>0</mn></msub><mo>→</mo><msub><mi>B</mi> <mn>0</mn></msub><mo>→</mo><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn><mo>→</mo><mn>0</mn><mo>→</mo><mn>0</mn></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  \vdots \\
  A_{1} \to B_{1} \to B_0\\
  B_0 \to B_{0} \to 0 \\
  0 \to 0 \to 0 \\
  \vdots
}
</annotation></semantics></math></div>
<p>so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C=0</annotation></semantics></math> and the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">A_s</annotation></semantics></math>‘s are the only “ingredients” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> (with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>0</mn></msub><mo>=</mo><msub><mi>B</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0 = B_0</annotation></semantics></math>). I’m going to focus mostly on the case where this holds and the sequence is also eventually constant in the other direction, so we have only finitely many extensions. In this case it’s easy to draw some of the same sorts of conclusions as in a single extension, e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B=0</annotation></semantics></math> if and only if all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>s</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A_s=0</annotation></semantics></math>, and so on; the general case is sometimes trickier but often works out, although “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>lim</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">\lim^1</annotation></semantics></math>” terms start to pop up.</p>

<p>It’s more common to describe iterated extensions in terms of <em>filtrations</em>. From any iterated extension as above, we have a sequence of subgroups</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>⊆</mo><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi><mo>⊆</mo><msub><mi>F</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>B</mi><mo>⊆</mo><mi>⋯</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex"> \cdots \subseteq F_s B \subseteq F_{s-1} B \subseteq \cdots \subseteq B </annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">F_s B</annotation></semantics></math> is the kernel of the projection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>→</mo><msub><mi>B</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">B \to B_s</annotation></semantics></math>. Since this projection is surjective, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>B</mi> <mi>s</mi></msub><mo>=</mo><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">B_s = B/F_s B</annotation></semantics></math>, and hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>s</mi></msub><mo>=</mo><msub><mi>F</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">A_s = F_{s-1} B/F_s B</annotation></semantics></math>. Thus, the whole iterated extension can be recovered from the filtration:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>B</mi><mo>→</mo><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>B</mi><mo>→</mo><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi></mtd></mtr> <mtr><mtd><msub><mi>F</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi><mo>→</mo><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi><mo>→</mo><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mi>B</mi></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  \vdots\\
  F_s B / F_{s+1} B \to B / F_{s+1}B \to B/F_s B\\
  F_{s-1} B / F_{s} B \to B / F_{s}B \to B/F_{s-1} B\\
  \vdots
}
</annotation></semantics></math></div>
<p>One problem with this point of view is that just having a filtration doesn’t ensure that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is the limit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>lim</mi> <mi>s</mi></msub><mi>B</mi><mo stretchy="false">/</mo><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\lim_s B/ F_s B</annotation></semantics></math>. When this is the case, one says that the filtration is <em>complete and Hausdorff</em>. (As you might guess, these words refer to a <a href="http://ncatlab.org/nlab/show/uniform+space">uniformity</a> induced on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> by the filtration.) The other condition we might want is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><mi>B</mi><mo stretchy="false">/</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">⋃</mo> <mi>s</mi></msub><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">C = B / \bigcup_s F_s B</annotation></semantics></math> is zero, i.e. that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">⋃</mo> <mi>s</mi></msub><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\bigcup_s F_s B = B</annotation></semantics></math>; a filtration with this property is called <em>exhaustive</em>. For <em>finite</em> iterated extensions, however, these conditions are all automatic.</p>

<p>A more serious problem with the filtration point of view is that it relies on the fact that the quotient of the kernel of a surjection is that same surjection — otherwise we couldn’t recover <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>B</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">B_s</annotation></semantics></math> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">F_s B</annotation></semantics></math>. This is no longer true when we replace abelian groups by pointed spaces and extensions by fibration sequences. Thus, in that case we <em>have</em> to consider instead an <em>iterated fibration sequence</em>, consisting of a sequence of fibration sequences:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  \vdots \\
  X_{s+1} \to Y_{s+1} \to Y_s\\
  X_s \to Y_s \to Y_{s-1}\\
  X_{s-1} \to Y_{s-1} \to Y_{s-2}\\
  \vdots
}
</annotation></semantics></math></div>
<p>As before, we view this as expressing the limit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>:</mo><mo>≡</mo><msub><mi>lim</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>⋯</mi><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo>→</mo><mi>⋯</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y :\equiv \lim_s (\cdots \to Y_{s+1}\to Y_s \to \cdots)</annotation></semantics></math> as put together out of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">X_s</annotation></semantics></math>‘s. It’s more common to describe this as a <em>tower of fibrations</em></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex"> \cdots \to Y_{s+1}\to Y_s \to Y_{s-1} \to \cdots </annotation></semantics></math></div>
<p>since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">X_s</annotation></semantics></math> is determined as the (homotopy) fiber of the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Y</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Y_s \to Y_{s-1}</annotation></semantics></math>. But by talking about iterated extensions instead of filtrations, and iterated fibration sequences instead of towers of fibrations, we can see the analogy much more easily.</p>

<p>(If we were working with spectra instead of spaces, then from an iterated fibration sequence we could define a “filtration” of the limit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mi>Y</mi></mrow><annotation encoding="application/x-tex">F_s Y</annotation></semantics></math> is the fiber of the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">Y\to Y_s</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Y</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">Y_s</annotation></semantics></math> <em>would</em> be the cofiber of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mi>Y</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">F_s Y \to Y</annotation></semantics></math>. However, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mi>Y</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">F_s Y \to Y</annotation></semantics></math> would not necessarily be “injective” in any sense.)</p>

<p>The goal now is to extract some algebraic relationship among the groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_s)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math> in an iterated fibration sequence, which relate to iterated extensions just as LES’s relate to extensions. Of course, the first thing we get is a sequence of LES’s:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  \vdots\\
  \cdots \to \pi_n(X_{s+1}) \to \pi_n(Y_{s+1}) \to \pi_n(Y_s) \to \pi_{n-1}(X_{s+1}) \to \cdots \\
  \cdots \to \pi_n(X_{s}) \to \pi_n(Y_{s}) \to \pi_n(Y_{s-1}) \to \pi_{n-1}(X_{s}) \to \cdots \\
  \vdots
}
</annotation></semantics></math></div>
<p>These sequences are related in that each group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s)</annotation></semantics></math> appears in <em>two</em> of them. This enables us to construct the following composite “connecting maps”</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex"> \pi_n(X_s) \to \pi_n(Y_s) \to \pi_{n-1}(X_{s+1}). </annotation></semantics></math></div>
<p>relating the homotopy groups of the fibers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">X_s</annotation></semantics></math>. For reasons that will become clear later, we’ll call these maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d^2</annotation></semantics></math> (note that this does <em>not</em> mean the square of a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math>; the superscript <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math> is just an index). The first interesting thing we notice about them is that they satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>2</mn></msup><mo>∘</mo><msup><mi>d</mi> <mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d^2 \circ d^2 = 0</annotation></semantics></math>, since in the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_n(X_s) \to \pi_n(Y_s) \to \pi_{n-1}(X_{s+1}) \to \pi_{n-1}(Y_{s+1}) \to \pi_{n-2}(X_{s+2}) </annotation></semantics></math></div>
<p>the middle two maps are adjacent in a LES, hence compose to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>. Thus, for every value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">n+s</annotation></semantics></math>, we have a <em>chain complex</em></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mover><mo>→</mo><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow></mover><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow></mover><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow></mover><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow></mover><mi>⋯</mi><mo>.</mo></mrow><annotation encoding="application/x-tex"> \cdots \xrightarrow{d^2} \pi_n(X_s) \xrightarrow{d^2} \pi_{n-1}(X_{s+1}) \xrightarrow{d^2} \pi_{n-2}(X_{s+2}) \xrightarrow{d^2} \cdots. </annotation></semantics></math></div>
<p>Of course, if we’re experienced homological-algebraists, the first thing that we want to do with a chain complex is take its homology, but let’s step back a second to make sure that that’s a sensible thing to do.</p>

<p>A <em>cycle</em> in this chain complex is an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in \pi_n(X_s)</annotation></semantics></math> that becomes zero in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{n-1}(X_{s+1})</annotation></semantics></math>. This means that when we map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s)</annotation></semantics></math>, it lands in the kernel of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s) \to \pi_{n-1}(X_{s+1})</annotation></semantics></math>. But since the sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex"> \cdots \to \pi_n(X_{s+1}) \to \pi_n(Y_{s+1}) \to \pi_n(Y_s) \to \pi_{n-1}(X_{s+1}) \to \cdots </annotation></semantics></math></div>
<p>is exact, that means exactly that the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s)</annotation></semantics></math> lies in the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_{s+1})</annotation></semantics></math>. In other words, an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in \pi_n(X_s)</annotation></semantics></math> automatically gives us an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s)</annotation></semantics></math>, while <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d^2(x)</annotation></semantics></math> is precisely the “obstruction” to lifting that to an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_{s+1})</annotation></semantics></math>. This naturally seems like the “first step” towards lifting it to an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math>, which is what we’re really interested in.</p>

<p>Similarly, a <em>boundary</em> in this chain complex is an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_s)</annotation></semantics></math> that’s in the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{n+1}(X_{s-1})</annotation></semantics></math>, and hence in particular in the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{n+1}(Y_{s-1})</annotation></semantics></math>. But since the sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex">  \cdots \to \pi_{n+1}(Y_{s-1}) \to \pi_n(X_{s}) \to \pi_n(Y_{s}) \to \pi_n(Y_{s-1}) \to \cdots </annotation></semantics></math></div>
<p>is exact, any such element must map to zero in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_{s})</annotation></semantics></math>, and hence also lift to zero in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_{s+1})</annotation></semantics></math>. So the homology at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_s)</annotation></semantics></math> (the group of cycles modulo the group of boundaries) is indeed a reasonable “second approximation” to “what we can learn about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_s)</annotation></semantics></math>”.</p>

<p>For a “third approximation”, we can more or less repeat the process. Given something in this homology “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>H</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>π</mi> <mo>*</mo></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mo>*</mo></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_{n,s}(\pi_\ast(X_\ast))</annotation></semantics></math>”, we can lift it to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_{s+1})</annotation></semantics></math>, then map it into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{n-1}(X_{s+2})</annotation></semantics></math>. The result is not well-defined because the lift is not well-defined, but its indeterminacy is precisely that of the lift, which by exactness is just an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_{s+1})</annotation></semantics></math>. Thus, we do have a well-defined element of the quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{n-1}(X_{s+2})</annotation></semantics></math> by the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d^2</annotation></semantics></math>, which happens to also lie in the kernel of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d^2</annotation></semantics></math>, and hence a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>3</mn></msup><mo>:</mo><msub><mi>H</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>π</mi> <mo>*</mo></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mo>*</mo></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><msub><mi>H</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>π</mi> <mo>*</mo></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mo>*</mo></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d^3 : H_{n,s}(\pi_\ast(X_\ast)) \to H_{n-1,s+2}(\pi_\ast(X_\ast))</annotation></semantics></math>. I’ll leave it to you to check that these maps make <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>H</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>π</mi> <mo>*</mo></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mo>*</mo></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H_{n,s}(\pi_\ast(X_\ast))</annotation></semantics></math> into another chain complex, and that elements of its homology can be lifted to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_{s+2})</annotation></semantics></math>.</p>

<p>In order to describe these higher approximations uniformly, let’s introduce a bit more terminology. Recall that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> is an abelian group, then a <em><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>-graded abelian group</em> is just a family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>g</mi></msub><msub><mo stretchy="false">)</mo> <mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(A_g)_{g\in G}</annotation></semantics></math> of abelian groups indexed by the underlying set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>-graded abelian groups and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">h\in G</annotation></semantics></math>, then a <em>degree-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math> map</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math> consists of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mi>g</mi></msub><mo>:</mo><msub><mi>A</mi> <mi>g</mi></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>g</mi><mo>+</mo><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_g : A_g \to B_{g+h}</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>. The composite of a degree-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>h</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_1</annotation></semantics></math> map with a degree-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>h</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_2</annotation></semantics></math> map is a degree-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>h</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>h</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(h_1+h_2)</annotation></semantics></math> map. For example, an unbounded chain complex may be defined as a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math>-graded abelian group equipped with a degree-1 (or degree-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1)</annotation></semantics></math>) endomap <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>∘</mo><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d \circ d = 0</annotation></semantics></math> (an equality of maps of degree 2 or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-2)</annotation></semantics></math>).</p>

<p>Now, the groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_s)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s)</annotation></semantics></math> can be assembled into a pair of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>ℤ</mi><mo>×</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbb{Z}\times \mathbb{Z})</annotation></semantics></math>-graded abelian groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>, and three maps between them <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>. The obvious grading is by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math>, but for historical reasons, I’m going to choose a different basis of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi><mo>×</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}\times \mathbb{Z}</annotation></semantics></math>, and write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p,q)</annotation></semantics></math> for the indexing elements.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>E</mi> <mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow></msub><mo>:</mo><mo>≡</mo><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>q</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> E_{p,q} :\equiv \pi_{p+q}(X_q) </annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>D</mi> <mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow></msub><mo>:</mo><mo>≡</mo><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>q</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> D_{p,q} :\equiv \pi_{p+q}(Y_q) </annotation></semantics></math></div>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>+</mo><mi>q</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p+q\lt 0</annotation></semantics></math>, then by convention we set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_{p+q}=0</annotation></semantics></math> (unless we are working with spectra, in which case no special convention is needed). Now each long exact sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex"> \cdots \to \pi_n(X_{s}) \to \pi_n(Y_{s}) \to \pi_n(Y_{s-1}) \to \pi_{n-1}(X_{s}) \to \cdots </annotation></semantics></math></div>
<p>can be rewritten as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msub><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow></msub><mover><mo>→</mo><mrow><msub><mi>k</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow></mover><msub><mi>D</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow></msub><mover><mo>→</mo><mrow><msub><mi>i</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow></msub></mrow></mover><msub><mi>D</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mover><mo>→</mo><mrow><msub><mi>j</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mover><msub><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>−</mo><mn>1</mn><mo>,</mo><mi>s</mi></mrow></msub><mo>→</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex"> \cdots \to E_{n-s,s} \xrightarrow{k_{n-s,s}} D_{n-s,s} \xrightarrow{i_{n-s,s}} D_{n-s+1,s-1} \xrightarrow{j_{n-s+1,s-1}} E_{n-s-1,s} \to \cdots </annotation></semantics></math></div>
<p>Together, the maps in these LES’s assemble into three graded maps</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>D</mi></mtd> <mtd></mtd> <mtd><mover><mo>→</mo><mi>i</mi></mover></mtd> <mtd></mtd> <mtd><mi>D</mi></mtd></mtr> <mtr><mtd></mtd> <mtd><msub><mo></mo><mi>k</mi></msub><mo>↖</mo></mtd> <mtd></mtd> <mtd><msub><mo>↙</mo> <mi>j</mi></msub></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mi>E</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  D &amp; &amp; \xrightarrow{i} &amp; &amp; D\\
  &amp; _{k}\nwarrow &amp; &amp; \swarrow_j\\
  &amp;&amp; E
}
</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> have degrees <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,-1)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-2,1)</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math> respectively. Moreover, the exactness of the LES’s implies that this triangle is exact at each vertex. This structure (two graded groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> and maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">i:D\to D</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">j:D\to E</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">k:E\to D</annotation></semantics></math> of some degrees such that the above triangle is exact at each vertex) is called an <em>exact couple</em>.</p>

<p>Now we can formalize the above process of successive approximation through passage to homology as follows. Given any exact couple <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>,</mo><mi>E</mi><mo>,</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D,E,i,j,k)</annotation></semantics></math>, we construct a new <em>derived</em> exact couple as follows.</p>

<ul>
<li>The composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>:</mo><mo>≡</mo><mi>j</mi><mi>k</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">d :\equiv j k : E \to E</annotation></semantics></math> satisfies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mi>d</mi><mo>=</mo><mi>j</mi><mi>k</mi><mi>j</mi><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d d = j k j k = 0</annotation></semantics></math>, so we can define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>′</mo><mo>:</mo><mo>≡</mo><mi>ker</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>im</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E' :\equiv ker(d)/im(d)</annotation></semantics></math> to be its homology.</li>

<li>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>′</mo><mo>=</mo><mi>im</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">D' = im(i) \subseteq D</annotation></semantics></math>. (Of course, both of these should be interpreted “degreewise”, remembering that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math> may have nonzero degrees.)</li>

<li>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>′</mo><mo>:</mo><mi>D</mi><mo>′</mo><mo>→</mo><mi>D</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">i':D'\to D'</annotation></semantics></math> be the restriction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">D'</annotation></semantics></math> (which obviously lands inside <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">D'</annotation></semantics></math>).</li>

<li>Define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>′</mo><mo>:</mo><mi>D</mi><mo>′</mo><mo>→</mo><mi>E</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">j':D'\to E'</annotation></semantics></math> as follows. Given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>D</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">x\in D'</annotation></semantics></math>, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>=</mo><mi>i</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x = i(y)</annotation></semantics></math> for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">y\in D</annotation></semantics></math>; let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>′</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j'(x)</annotation></semantics></math> be the homology class determined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j(y)</annotation></semantics></math> (which is a cycle since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k j = 0</annotation></semantics></math>). This is well-defined since if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>=</mo><mi>i</mi><mo stretchy="false">(</mo><mi>y</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x = i(y')</annotation></semantics></math> as well, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mi>y</mi><mo>′</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i(y-y') = 0</annotation></semantics></math>, hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>−</mo><mi>y</mi><mo>′</mo><mo>=</mo><mi>k</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y-y' = k(z)</annotation></semantics></math> for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">z\in E</annotation></semantics></math>, and thus <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>j</mi><mo stretchy="false">(</mo><mi>y</mi><mo>′</mo><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j(y) - j(y') = d(z)</annotation></semantics></math> is a boundary.</li>

<li>Define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>′</mo><mo>:</mo><mi>E</mi><mo>′</mo><mo>→</mo><mi>D</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">k':E'\to D'</annotation></semantics></math> by restricting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ker</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ker(d)</annotation></semantics></math> (which lands inside <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">D'</annotation></semantics></math> since if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>j</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d(x) = j(k(x)) = 0</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k(x)</annotation></semantics></math> lies in the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> by exactness) and then passing to the quotient (which is well-defined since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k j = 0</annotation></semantics></math>).</li>

<li>I’ll leave it as an exercise to check the exactness of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">i'</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">j'</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">k'</annotation></semantics></math>. Note that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>deg</mi><mo stretchy="false">(</mo><mi>i</mi><mo>′</mo><mo stretchy="false">)</mo><mo>=</mo><mi>deg</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">deg(i') = deg(i)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>deg</mi><mo stretchy="false">(</mo><mi>k</mi><mo>′</mo><mo stretchy="false">)</mo><mo>=</mo><mi>deg</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">deg(k')=deg(k)</annotation></semantics></math>, but <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>deg</mi><mo stretchy="false">(</mo><mi>j</mi><mo>′</mo><mo stretchy="false">)</mo><mo>=</mo><mi>deg</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>deg</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">deg(j')=deg(j) - deg(i)</annotation></semantics></math>.</li>
</ul>

<p>We can thus iterate this process. We write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>D</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>E</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>i</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>j</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>k</mi> <mi>r</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D^r,E^r,i^r,j^r,k^r)</annotation></semantics></math> for the exact couple obtained by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">r-2</annotation></semantics></math> iterations. In particular, we have graded abelian groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>r</mi></msup></mrow><annotation encoding="application/x-tex">E^r</annotation></semantics></math>, each of which is equipped with a differential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mi>r</mi></msup><mo>:</mo><msup><mi>E</mi> <mi>r</mi></msup><mo>→</mo><msup><mi>E</mi> <mi>r</mi></msup></mrow><annotation encoding="application/x-tex">d^r : E^r \to E^r</annotation></semantics></math> of degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>deg</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mi>deg</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>⋅</mo><mi>deg</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">deg(j) + deg(k) - (r-2)\cdot deg(i)</annotation></semantics></math> satisfying <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>∘</mo><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d\circ d = 0</annotation></semantics></math>, and such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">E^{r+1}</annotation></semantics></math> is the homology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>E</mi> <mi>r</mi></msup><mo>,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(E^r,d)</annotation></semantics></math>. This structure is called a <em>spectral sequence</em>.</p>

<p>Note that I’ve chosen the indexing so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> is the graded group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> we started with. Like the change from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,s)</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p,q)</annotation></semantics></math>, this is to match the convention used in the literature. (And that, in turn, is because some other ways of constructing spectral sequences begin with an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">E^1</annotation></semantics></math> whose homology is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math>. And that, I guess, is because someone a long time ago thought that the natural numbers started with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>, since I’ve never heard of an “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>0</mn></msup></mrow><annotation encoding="application/x-tex">E^0</annotation></semantics></math>”. Although no doubt someone in the comments will point out a spectral sequence that starts with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>0</mn></msup></mrow><annotation encoding="application/x-tex">E^0</annotation></semantics></math>.)</p>

<p>When the groups in a spectral sequence are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>ℤ</mi><mo>×</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbb{Z}\times\mathbb{Z})</annotation></semantics></math>-graded, as in our example and in most cases, it is usual to draw them in a lattice on the plane, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math> the horizontal coordinate and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math> the vertical one. For instance, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> can be drawn like this:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><msubsup><mi>E</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo>,</mo><mn>2</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>0</mn><mo>,</mo><mn>2</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><msubsup><mi>E</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo>,</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><msubsup><mi>E</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo>,</mo><mn>0</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>2</mn><mo>,</mo><mn>0</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><msubsup><mi>E</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><msubsup><mi>E</mi> <mrow><mn>2</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \\
  \cdots &amp; E_{-1,2}^2 &amp; E_{0,2}^2 &amp; E_{1,2}^2 &amp; E_{2,2}^2 &amp; \cdots\\
  \cdots &amp; E_{-1,1}^2 &amp; E_{0,1}^2 &amp; E_{1,1}^2 &amp; E_{2,1}^2 &amp; \cdots\\
  \cdots &amp; E_{-1,0}^2 &amp; E_{0,0}^2 &amp; E_{1,0}^2 &amp; E_{2,0}^2 &amp; \cdots\\
  \cdots &amp; E_{-1,-1}^2 &amp; E_{0,-1}^2 &amp; E_{1,-1}^2 &amp; E_{2,-1}^2 &amp; \cdots\\
  &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp;
}
</annotation></semantics></math></div>
<p>We call this the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> <em>page</em> of the spectral sequence. When the degrees of the differentials are as they are in our example (which is, again, the most common situation), we can draw the differential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d^2</annotation></semantics></math> on this lattice as moving two steps left and one step up. The best picture I’ve been able to find of this online is <a href="http://mathworld.wolfram.com/SpectralSequence.html">here</a>, although it’s of the dual “cohomologically indexed” case where the arrows go down and right instead of up and left.</p>

<p>Just to keep ourselves a bit more grounded, here’s what the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> page looks like in the case of an iterated fibration sequence of spaces:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>3</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>4</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><msub><mi>π</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>3</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>π</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd><mi>⋮</mi></mtd> <mtd></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \\
  \cdots &amp; \pi_1(X_2) &amp; \pi_2(X_2) &amp; \pi_3(X_2) &amp; \pi_4(X_2) &amp; \cdots\\
  \cdots &amp; \pi_0(X_1) &amp; \pi_1(X_1) &amp; \pi_2(X_1) &amp; \pi_3(X_1) &amp; \cdots\\
  \cdots &amp; 0 &amp; \pi_0(X_0) &amp; \pi_1(X_0) &amp; \pi_2(X_0) &amp; \cdots\\
  \cdots &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots\\
  &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp;
}
</annotation></semantics></math></div>
<p>With spectra, the zero groups above would be replaced by negative homotopy groups such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{-1}(X_0)</annotation></semantics></math>, etc.</p>

<p>We then obtain the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>3</mn></msup></mrow><annotation encoding="application/x-tex">E^3</annotation></semantics></math> page by replacing each entry <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">E^2_{p q}</annotation></semantics></math> of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> page by the homology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d^2</annotation></semantics></math> at that spot, i.e. the kernel of the outgoing differential modulo the image of the incoming one. The <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>3</mn></msup></mrow><annotation encoding="application/x-tex">E^3</annotation></semantics></math> page then has its own differential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>d</mi> <mn>3</mn></msup></mrow><annotation encoding="application/x-tex">d^3</annotation></semantics></math> which goes <em>three</em> steps left and <em>two</em> steps up, and we repeat. We then “take the limit” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>r</mi></msup></mrow><annotation encoding="application/x-tex">E^r</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>→</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex">r\to\infty</annotation></semantics></math>, and hope that the resulting “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>∞</mn></msup></mrow><annotation encoding="application/x-tex">E^\infty</annotation></semantics></math>” terms are useful — in our example, we hope they tell us something about the groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math>.</p>

<p>First of all, we have to address the question of what it means to “take the limit”, since in general <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">E^{r+1}</annotation></semantics></math> is neither a subobject nor a quotient object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>r</mi></msup></mrow><annotation encoding="application/x-tex">E^r</annotation></semantics></math>, but a <em>subquotient</em> (a quotient of a subobject, or equivalently a subobject of a quotient). One can make sense of this in general, but in many (perhaps most) applications of spectral sequences, there’s a much simpler answer. Namely, it often happens that for each grading <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p,q)</annotation></semantics></math>, the groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">E^r_{p q}</annotation></semantics></math> eventually stabilize as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>→</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex">r\to\infty</annotation></semantics></math>, so that we can define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mn>∞</mn></msubsup></mrow><annotation encoding="application/x-tex">E^\infty_{p q}</annotation></semantics></math> to be their eventual value. (The <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math> at which this happens generally depends on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p,q)</annotation></semantics></math>, so that interesting things are still happening <em>somewhere</em> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>r</mi></msup></mrow><annotation encoding="application/x-tex">E^r</annotation></semantics></math> for arbitrarily large values of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math>.)</p>

<p>Of course, having <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">E^{r+1}_{p q} = E^r_{p q}</annotation></semantics></math> means that the differentials coming into and out of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">E^r_{p q}</annotation></semantics></math> are zero, and a good reason for this is if their domain and codomain are respectively the zero group. Note that when the differentials have the usual degrees, they always move from one diagonal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>+</mo><mi>q</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p+q=n</annotation></semantics></math> to the next lower one <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>+</mo><mi>q</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p+q=n-1</annotation></semantics></math>. Thus, if each diagonal in the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> page (hence also in every other page) contains only finitely many nonzero groups, then the groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">E^r_{p q}</annotation></semantics></math> will eventually stabilize for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p,q)</annotation></semantics></math>.</p>

<p>In particular, this is the case in the example arising from a <em>finite</em> iterated fibration sequence, where the nonzero part of the spectral sequence lives entirely in a finite strip <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">0\le q\le Q</annotation></semantics></math>. It’s also the case for a bounded <em>above</em> fibration sequence (which stabilizes above some point <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">s=T</annotation></semantics></math> but extends infinitely downwards) as long as for every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, there is a point below which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_n(X_s) = \pi_n(Y_s)=0</annotation></semantics></math>, such as if the truncatedness of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Y</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">Y_s</annotation></semantics></math> decreases, or their connectedness increases, as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>→</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex">s\to-\infty</annotation></semantics></math>. In this case, we have the following.</p>

<p><strong>Convergence Theorem:</strong> Suppose given a bounded-above iterated fibration sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>X</mi> <mi>T</mi></msub><mo>→</mo><msub><mi>Y</mi> <mi>T</mi></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>T</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  X_{T} \to Y_{T} \to Y_{T-1}\\
  \vdots \\
  X_s \to Y_s \to Y_{s-1}\\
  X_{s-1} \to Y_{s-1} \to Y_{s-2}\\
  \vdots
}
</annotation></semantics></math></div>
<p>such that for every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, there is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_n(X_s) =\pi_n(Y_s)=0</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>≤</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">s\le R</annotation></semantics></math>, and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>=</mo><msub><mi>lim</mi> <mi>s</mi></msub><msub><mi>Y</mi> <mi>s</mi></msub><mo>=</mo><msub><mi>Y</mi> <mi>T</mi></msub></mrow><annotation encoding="application/x-tex">Y = \lim_s Y_s = Y_T</annotation></semantics></math>. Then for every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, there is a finite iterated extension:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>T</mi><mo>,</mo><mi>T</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>T</mi></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>T</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>R</mi><mo>,</mo><mi>R</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>R</mi></mrow></msub><mo>→</mo><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  E^\infty_{n-T,T} \to B_{n,T} \to B_{n,T-1}\\
  \vdots \\
  E^\infty_{n-s,s} \to B_{n,s} \to B_{n,s-1}\\
  E^\infty_{n-s+1,s-1} \to B_{n,s-1} \to B_{n,s-2}\\
  \vdots\\
  E^\infty_{n-R,R} \to B_{n,R} \to 0
}

</annotation></semantics></math></div>
<p>such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>B</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>lim</mi> <mi>s</mi></msub><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>T</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_n = \lim_s B_{n,s}= B_{n,T}</annotation></semantics></math> is equal to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math>.</p>

<p>This theorem makes our second analogy also into a functor between suitable categories of iterated fibration sequences and iterated extensions.</p>

<p>Note that the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>∞</mn></msup></mrow><annotation encoding="application/x-tex">E^\infty</annotation></semantics></math> groups appearing in the iterated extension for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math> are those on the diagonal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>+</mo><mi>q</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p+q=n</annotation></semantics></math>. Thus, the theorem says that when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is put together out of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">X_s</annotation></semantics></math>‘s, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math> is put together out of the groups on this diagonal, which are computed from the homotopy groups of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>s</mi></msub></mrow><annotation encoding="application/x-tex">X_s</annotation></semantics></math>’s in some way (encoded by the spectral sequence). It’s traditional to write this sort of “convergence” as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow> <mn>2</mn></msubsup><mo>=</mo><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>q</mi></msub><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>⇒</mo><mspace width="thickmathspace"></mspace><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> E^2_{p,q} = \pi_{p+q}(X_q) \;\Rightarrow\; \pi_{p+q}(Y) </annotation></semantics></math></div>
<p>to indicate which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>∞</mn></msup></mrow><annotation encoding="application/x-tex">E^\infty</annotation></semantics></math> groups are the “ingredients” of which group in the target.</p>

<p>At this point I should remind you that we’re either assuming all spaces are simply connected, or working with spectra instead of spaces. The notion of “convergence” is a lot trickier when you have to deal with nonabelianness of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math> and nongroupness of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math>. There are also fancier convergence theorems that allow more infinite behavior, such as when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">E^r_{p q}</annotation></semantics></math> doesn’t stabilize but still has a “limit”. Finally, with an unbounded-above iterated fibration sequence we would also have to deal with the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>lim</mi> <mi>s</mi></msub><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(\lim_s Y_s)</annotation></semantics></math> may not equal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>lim</mi> <mi>s</mi></msub><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lim_s \pi_n(Y_s)</annotation></semantics></math>.</p>

<p><strong>Proof of convergence theorem:</strong> For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p,q)</annotation></semantics></math>, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>≥</mo><mi>max</mi><mo stretchy="false">(</mo><mi>T</mi><mo>−</mo><mi>q</mi><mo>+</mo><mn>3</mn><mo>,</mo><mi>q</mi><mo>−</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \ge max(T-q+3,q-R+1)</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">E^r_{p q}</annotation></semantics></math> has stabilized, so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mn>∞</mn></msubsup><mo>=</mo><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">E^\infty_{p q} = E^r_{p q}</annotation></semantics></math>. For such an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>D</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">D^r_{p q}</annotation></semantics></math> is the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r-2)</annotation></semantics></math>-fold image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><msup><mi>D</mi> <mn>2</mn></msup><mo>→</mo><msup><mi>D</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">i:D^2\to D^2</annotation></semantics></math>, i.e. those elements in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>D</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">D^2</annotation></semantics></math> of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">(</mo><mi>⋯</mi><mi>i</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>⋯</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(i(\cdots i(x)\cdots ))</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r-2)</annotation></semantics></math> copies of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> consists of the maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s) \to \pi_n(Y_{s-1})</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s) = \pi_n(Y)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>≥</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">s\ge T</annotation></semantics></math>, this means <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>D</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">D^r_{p q}</annotation></semantics></math> is the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{p+q}(Y)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>q</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{p+q}(Y_q)</annotation></semantics></math> (and in particular is independent of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math> sufficiently large). Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>=</mo><msubsup><mi>D</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex">B_{n,s}= D^r_{n-s,s}</annotation></semantics></math> for any such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math>, i.e. the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(Y_s)</annotation></semantics></math>.</p>

<p>It remains to construct the extensions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">E^\infty_{n-s,s} \to B_{n,s} \to B_{n,s-1}</annotation></semantics></math> displayed above. However, just as we put together the exact couple <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>D</mi> <mn>2</mn></msup><mo>,</mo><msup><mi>E</mi> <mn>2</mn></msup><mo>,</mo><msup><mi>i</mi> <mn>2</mn></msup><mo>,</mo><msup><mi>j</mi> <mn>2</mn></msup><mo>,</mo><msup><mi>k</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D^2,E^2,i^2,j^2,k^2)</annotation></semantics></math> from long exact sequences, from the exact couple <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>D</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>E</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>i</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>j</mi> <mi>r</mi></msup><mo>,</mo><msup><mi>k</mi> <mi>r</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(D^{r},E^{r},i^{r},j^{r},k^{r})</annotation></semantics></math> we can extract some other long exact sequences. Note that by iterating the above formulas for degrees in a derived exact couple, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>deg</mi><mo stretchy="false">(</mo><msup><mi>i</mi> <mi>r</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">deg(i^{r}) = (1,-1)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>deg</mi><mo stretchy="false">(</mo><msup><mi>k</mi> <mi>r</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">deg(k^{r}) = 0</annotation></semantics></math>, but <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>deg</mi><mo stretchy="false">(</mo><msup><mi>j</mi> <mi>r</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>r</mi><mo>,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">deg(j^{r}) = (-r,r-1)</annotation></semantics></math>. Thus, we have LES’s</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msubsup><mi>D</mi> <mrow><mi>p</mi><mo>+</mo><mi>r</mi><mo>,</mo><mi>q</mi><mo>−</mo><mi>r</mi><mo>+</mo><mn>1</mn></mrow> <mi>r</mi></msubsup><mover><mo>→</mo><mi>j</mi></mover><msubsup><mi>E</mi> <mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow> <mi>r</mi></msubsup><mover><mo>→</mo><mi>k</mi></mover><msubsup><mi>D</mi> <mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow> <mi>r</mi></msubsup><mover><mo>→</mo><mi>i</mi></mover><msubsup><mi>D</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>−</mo><mn>1</mn></mrow> <mi>r</mi></msubsup><mover><mo>→</mo><mi>j</mi></mover><msubsup><mi>E</mi> <mrow><mi>p</mi><mo>−</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>+</mo><mi>r</mi><mo>−</mo><mn>2</mn></mrow> <mi>r</mi></msubsup><mo>→</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex"> \cdots \to D^{r}_{p+r,q-r+1} \xrightarrow{j} E^{r}_{p,q} \xrightarrow{k} D^{r}_{p,q} \xrightarrow{i} D^{r}_{p+1,q-1} \xrightarrow{j} E^{r}_{p-r+1,q+r-2} \to\cdots </annotation></semantics></math></div>
<p>If we choose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>≥</mo><mi>max</mi><mo stretchy="false">(</mo><mi>T</mi><mo>−</mo><mi>s</mi><mo>+</mo><mn>4</mn><mo>,</mo><mi>s</mi><mo>−</mo><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \ge max(T-s+4,s-R+1)</annotation></semantics></math>, then all three terms in the middle have stabilized, while the two on the ends are zero. Thus, inside this LES we have a short exact sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>→</mo><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \to E^\infty_{n-s,s} \to B_{n,s} \to B_{n,s-1} \to 0 </annotation></semantics></math></div>
<p>which is the extension that we wanted. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>This is all very abstract, so let’s look at a couple of degenerate cases. First, in the case of a finite iterated fibration sequence with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T=1</annotation></semantics></math>, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>X</mi> <mn>1</mn></msub><mo>→</mo><mi>Y</mi><mo>→</mo><msub><mi>X</mi> <mn>0</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mn>0</mn></msub><mo>→</mo><msub><mi>X</mi> <mn>0</mn></msub><mo>→</mo><mo>*</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  X_1 \to Y \to X_0\\
  X_0 \to X_0 \to \ast
}
</annotation></semantics></math></div>
<p>hence essentially just a single fibration sequence. The spectral sequence is confined to the strip <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>q</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">q\in \{0,1\}</annotation></semantics></math>, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> page looking like:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋯</mi></mtd> <mtd><msub><mi>π</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>3</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>π</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
\cdots &amp; \pi_0(X_1) &amp; \pi_1(X_1) &amp; \pi_2(X_1) &amp; \pi_3(X_1) &amp; \cdots \\
\cdots &amp; 0 &amp; \pi_0(X_0) &amp; \pi_1(X_0) &amp; \pi_2(X_0) &amp; \cdots
}
</annotation></semantics></math></div>
<p>The differentials on this page go, as always, left two and up one, hence from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_0) \to \pi_{n-1}(X_1)</annotation></semantics></math>; these are exactly the “connecting maps” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>δ</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\delta_n</annotation></semantics></math> in the ordinary LES of the fibration. Since the differentials entering <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_0)</annotation></semantics></math> come from zero, and those leaving <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_1)</annotation></semantics></math> go to zero, on passage to homology we get the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>3</mn></msup></mrow><annotation encoding="application/x-tex">E^3</annotation></semantics></math> page</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋯</mi></mtd> <mtd><mi>im</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>im</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>im</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mn>3</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>im</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mn>4</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd><mi>⋯</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  \cdots &amp; im(\delta_1) &amp; im(\delta_2) &amp; im(\delta_3) &amp; im(\delta_4) &amp; \cdots \\
  \cdots &amp; 0 &amp; ker(\delta_0) &amp; ker(\delta_1) &amp; ker(\delta_2) &amp; \cdots
}
</annotation></semantics></math></div>
<p>We have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>3</mn></msup><mo>=</mo><msup><mi>E</mi> <mn>∞</mn></msup></mrow><annotation encoding="application/x-tex">E^3 = E^\infty</annotation></semantics></math> since all the remaining differentials hit zero on one side or the other, so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mo>,</mo><mn>0</mn></mrow> <mn>∞</mn></msubsup><mo>=</mo><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E^\infty_{p,0} = ker(\delta_p)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mo>,</mo><mn>1</mn></mrow> <mn>∞</mn></msubsup><mo>=</mo><mi>im</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mrow><mi>p</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E^\infty_{p,1} = im(\delta_{p+2})</annotation></semantics></math>. The theorem then gives an iterated extension</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>im</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>ker</mi><mo stretchy="false">(</mo><msub><mi>δ</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> \array{
  im(\delta_{n+1}) \to \pi_n(Y) \to ker(\delta_n)\\
  ker(\delta_n) \to ker(\delta_n) \to 0
  }
</annotation></semantics></math></div>
<p>which is just the ordinary extension we observed above as coming from an LES.</p>

<p>Another degenerate case is when the iterated fibration sequence is the <em>Postnikov tower</em> of a space (or spectrum) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>. Suppose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_n(Y)=0</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\gt m</annotation></semantics></math>. Then for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\le m</annotation></semantics></math> we have an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{\Vert Y\Vert}_n</annotation></semantics></math>, with fibration sequences</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub><mo>→</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mi>n</mi></msub><mo>→</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> X_n \to {\Vert Y\Vert}_n \to {\Vert Y\Vert}_{n-1} </annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub><mo>=</mo><mi>K</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_n = K(\pi_n(Y),n)</annotation></semantics></math> is an Eilenberg-Mac Lane space, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_n) = \pi_n(Y)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\pi_i(X_n) = 0</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>≠</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i\neq n</annotation></semantics></math>. Together these form an iterated fibration sequence with limit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>. When <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type space, it is a finite sequence; when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type spectrum it is bounded above and satisfies the condition on downward homotopy groups; thus the convergence theorem applies. Since each fiber <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_n</annotation></semantics></math> is an Eilenberg-Mac Lane space of dimension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math> page of the spectral sequence is concentrated on the line <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p=0</annotation></semantics></math>, looking like this:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msub><mi>π</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  \vdots \\
  \pi_2(Y)\\
  \pi_1(Y) \\
  \pi_0(Y)\\
  \vdots
}
</annotation></semantics></math></div>
<p>There is no room for any nontrivial differentials, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>2</mn></msup><mo>=</mo><msup><mi>E</mi> <mn>∞</mn></msup></mrow><annotation encoding="application/x-tex">E^2=E^\infty</annotation></semantics></math>, and for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> we obtain the trivial iterated extension</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mn>0</mn><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><mn>0</mn><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn><mo>→</mo><mn>0</mn><mo>→</mo><mn>0</mn></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><mn>0</mn><mo>→</mo><mn>0</mn><mo>→</mo><mn>0</mn><mo>.</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  0 \to \pi_n(Y) \to \pi_n(Y) \\
  \vdots\\
  0 \to \pi_n(Y) \to \pi_n(Y) \\
  \pi_n(Y) \to \pi_n(Y) \to 0 \\
  0 \to 0 \to 0 \\
  \vdots\\
  0 \to 0 \to 0.
}
</annotation></semantics></math></div>
<p>Of course, the <em>interesting</em> applications of spectral sequences are less trivial, but this post is already quite long enough. In the companion post on the HoTT blog, I’ll talk about how to use this spectral sequence (with spectra) to extract versions of the Atiyah-Hirzebruch and Serre spectral sequences, and see what they can do for us.</p>

<p>One final teaser: note that while the groups in the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">E^{r+1}</annotation></semantics></math> page of a spectral sequence are determined by the groups and the differentials in the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>r</mi></msup></mrow><annotation encoding="application/x-tex">E^r</annotation></semantics></math> page, the differential in the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">E^{r+1}</annotation></semantics></math> page is not so determined. To figure out what it is, we need to know about the rest of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>r</mi> <mi mathvariant="normal">th</mi></msup></mrow><annotation encoding="application/x-tex">r^{\mathrm{th}}</annotation></semantics></math> exact couple, which can be tedious to work out. In many applications it suffices to know that such a differential <em>exists</em>, without knowing anything about it; but sometimes the values of the differential do matter. However, if we had a fully <em>constructive</em> definition of the whole exact couple and spectral sequence, as we would obtain by implementing the definition in a hypothetical fully constructive version of homotopy type theory, then the definition would be a program, and we could simply ask the computer to evaluate it on any input we cared about. This suggests to me a vague possibility of a way that homotopy type theory might conceivably one day be useful even to the “working algebraic topologist”.</p>

<h2 id="spectral_sequences_in_hott">Spectral Sequences in HoTT</h2>

<p>Now we want to construct the cohomological Serre spectral sequence of a fibration (i.e. a type family). First recall that a <strong>spectrum</strong> is a family of pointed types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><msub><mstyle mathvariant="sans-serif"><mi>Type</mi></mstyle> <mo>*</mo></msub></mrow><annotation encoding="application/x-tex"> Y : \mathbb{N} \to \mathsf{Type}_\ast</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Y</mi> <mi>n</mi></msub><mo>=</mo><mi>Ω</mi><msub><mi>Y</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> Y_n = \Omega Y_{n+1}</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. Last time I defined the <strong>cohomology</strong> of a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in a spectrum <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> to be</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>:</mo><mo>≡</mo><mo stretchy="false">‖</mo><mi>X</mi><mo>→</mo><msup><mi>Ω</mi> <mrow><mi>k</mi><mo>−</mo><mi>n</mi></mrow></msup><msub><mi>Y</mi> <mi>k</mi></msub><msub><mo stretchy="false">‖</mo> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex"> H^n(X;Y) :\equiv \Vert X \to \Omega^{k-n} Y_k \Vert_0</annotation></semantics></math></div>
<p>for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> sufficiently large that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>−</mo><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> k-n \ge 0</annotation></semantics></math>. An equivalent way to define this is as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>:</mo><mo>≡</mo><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^n(X;Y) :\equiv \pi_{-n} (\mathsf{SpMap}(X,Y))</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathsf{SpMap}(X,Y)</annotation></semantics></math> is the <em>mapping spectrum</em> defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub><mo>:</mo><mo>≡</mo><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><msub><mi>Y</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathsf{SpMap}(X,Y)_n :\equiv (X\to Y_n)</annotation></semantics></math>, and the homotopy groups of a spectrum <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> are defined by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>:</mo><mo>≡</mo><msub><mi>π</mi> <mrow><mi>k</mi><mo>+</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>Z</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_n (Z) :\equiv \pi_{k+n}( Z_k)</annotation></semantics></math></div>
<p>for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>∈</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex"> n \in \mathbb{Z}</annotation></semantics></math> and any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> sufficiently large that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mi>k</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> n+k\ge 0</annotation></semantics></math>. Again, the definition of a spectrum makes this independent of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>. In general, we can “do homotopy theory” with spectra just as we can with types. A map of spectra is, of course, a fiberwise pointed map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mo stretchy="false">(</mo><mi>n</mi><mo>:</mo><mi>ℕ</mi><mo stretchy="false">)</mo></mrow></msub><msub><mi>Y</mi> <mi>n</mi></msub><mo>→</mo><msub><mi>Z</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> f : \prod_{(n:\mathbb{N})} Y_n \to Z_n</annotation></semantics></math> such that the evident squares commute relating it to the equivalences <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Y</mi> <mi>n</mi></msub><mo>=</mo><mi>Ω</mi><msub><mi>Y</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> Y_n = \Omega Y_{n+1}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Z</mi> <mi>n</mi></msub><mo>=</mo><mi>Ω</mi><msub><mi>Z</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> Z_n = \Omega Z_{n+1}</annotation></semantics></math>. Similarly, the <em>fiber</em> of such a map is defined levelwise, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>fib</mi></mstyle><mo stretchy="false">(</mo><mi>f</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub><mo>:</mo><mo>≡</mo><mstyle mathvariant="sans-serif"><mi>fib</mi></mstyle><mo stretchy="false">(</mo><msub><mi>f</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathsf{fib}(f)_n :\equiv \mathsf{fib}(f_n)</annotation></semantics></math>. It’s easy to see that this inherits a spectrum structure. Moreover, the long exact sequences of homotopy groups for the fiber sequences <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>fib</mi></mstyle><mo stretchy="false">(</mo><msub><mi>f</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>Y</mi> <mi>n</mi></msub><mo>→</mo><msub><mi>Z</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> \mathsf{fib}(f_n) \to Y_n \to Z_n</annotation></semantics></math> splice together into a long exact sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>fib</mi></mstyle><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>→</mo><mi>⋯</mi></mrow><annotation encoding="application/x-tex"> \cdots \to \pi_n(\mathsf{fib}(f)) \to \pi_n(Y) \to \pi_n(Z) \to \cdots </annotation></semantics></math></div>
<p>which is infinite in <em>both</em> directions, with all entries being abelian groups.</p>

<p>Now in part one above, I explained how from an iterated fibration sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mi>s</mi></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>X</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>Y</mi> <mrow><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> \array{\vdots \\
     X_{s+1} \to Y_{s+1} \to Y_s\\
     X_s \to Y_s \to Y_{s-1}\\
     X_{s-1} \to Y_{s-1} \to Y_{s-2}\\
     \vdots}

</annotation></semantics></math></div>
<p>we obtain a spectral sequence with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mn>2</mn></msubsup><mo>=</mo><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>q</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> E^2_{p q} = \pi_{p+q}(X_q)</annotation></semantics></math>. Moreover, if the iterated fibration sequence stabilizes as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>→</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex"> s\to \infty</annotation></semantics></math> (i.e. for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>&gt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex"> s\gt T</annotation></semantics></math> it becomes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo>→</mo><mi>Y</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex"> \mathbf{1} \to Y \to Y</annotation></semantics></math>) and eventually becomes zero at each homotopy group separately as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>→</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex"> s \to -\infty</annotation></semantics></math>, then this spectral sequence “converges” to the homotopy groups of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, in the sense that for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> we have a finite iterated extension</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>T</mi><mo>,</mo><mi>T</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>T</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>,</mo><mi>s</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>s</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow> <mn>∞</mn></msubsup><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>,</mo><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr> <mtr><mtd><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>R</mi><mo>,</mo><mi>R</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><msubsup><mi>E</mi> <mrow><mi>n</mi><mo>−</mo><mi>R</mi><mo>,</mo><mi>R</mi></mrow> <mn>∞</mn></msubsup><mo>→</mo><mn>0</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  E^\infty_{n-T,T} \to \pi_n(Y) \to B_{n,T-1}\\
  \vdots\\
  E^\infty_{n-s,s} \to B_{n,s} \to B_{n,s-1}\\
  E^\infty_{n-s+1,s-1} \to B_{n,s-1} \to B_{n,s-2} \\
  \vdots\\
  E^\infty_{n-R,R} \to E^\infty_{n-R,R} \to 0
}

</annotation></semantics></math></div>
<p>in which the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>∞</mn></msup></mrow><annotation encoding="application/x-tex"> E^\infty</annotation></semantics></math> terms occurring are precisely the nonzero ones on the diagonal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>+</mo><mi>q</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex"> p+q=n</annotation></semantics></math> of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mn>∞</mn></msup></mrow><annotation encoding="application/x-tex"> E^\infty</annotation></semantics></math> page. (There are fancier sorts of convergence that apply to more general situations, but I don’t want to get into that right now.) One writes this as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow> <mn>2</mn></msubsup><mo>=</mo><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>q</mi></msub><mo stretchy="false">)</mo><mo>⇒</mo><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> E^2_{p,q} = \pi_{p+q}(X_q) \Rightarrow \pi_{p+q}(Y) </annotation></semantics></math></div>
<p>The only homotopical input required was the long exact sequences of homotopy groups associated to the iterated fibration sequence, which as we’ve seen applies just as well to spectra as to types. After that, it was only homological algebra of abelian groups, which was fully constructive, and hence formalizable using sets in homotopy type theory, with higher inductive types for quotients and images.</p>

<p>Part one was kind of light on examples, though. I mentioned the obvious example of an iterated fibration sequence, namely the Postnikov tower of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>K</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mi>s</mi></msub><mo>→</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>K</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mrow><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
  K(\pi_s(Y),s) \to {\Vert Y\Vert}_s \to {\Vert Y\Vert}_{s-1}\\
  K(\pi_{s-1}(Y),s-1) \to {\Vert Y\Vert}_{s-1} \to {\Vert Y\Vert}_{s-2}\\
  \vdots
}

</annotation></semantics></math></div>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>&lt;</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex"> m\lt \infty</annotation></semantics></math>, then this satisfies our simple hypotheses for convergence. A spectrum also has a Postnikov tower, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">‖</mo><mi>Y</mi><msub><mo stretchy="false">‖</mo> <mi>s</mi></msub><msub><mo stretchy="false">)</mo> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> (\Vert Y \Vert_s)_n</annotation></semantics></math> defined to be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">‖</mo><msub><mi>Y</mi> <mi>n</mi></msub><msub><mo stretchy="false">‖</mo> <mrow><mi>n</mi><mo>+</mo><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex"> \Vert Y_n\Vert_{n+s}</annotation></semantics></math>. This makes sense for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex"> s \in \mathbb{Z}</annotation></semantics></math>, as long as we make the convention that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">‖</mo><mi>X</mi><msub><mo stretchy="false">‖</mo> <mi>m</mi></msub><mo>=</mo><mstyle mathvariant="bold"><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex"> \Vert X\Vert_{m} = \mathbf{1}</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>&lt;</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> m \lt  -1</annotation></semantics></math>. If we define an <strong><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type spectrum</strong> to be one for which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Y</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> Y_n</annotation></semantics></math> is an ordinary <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (n+m)</annotation></semantics></math>-type for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>m</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex"> n \ge -m-2</annotation></semantics></math>, then the Postnikov tower of such a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> also satisfies our simple hypotheses for convergence despite potentially being infinite downwards (an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type spectrum can have nontrivial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> \pi_n</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>∞</mn><mo>&lt;</mo><mi>n</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex"> -\infty \lt  n \le m</annotation></semantics></math>).</p>

<p>The Postnikov tower of a space or spectrum doesn’t give rise to an interesting or useful spectral sequence. However, mapping out of a type preserves fibration sequences, so for any type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and spectrum <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> we have an induced iterated fibration sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>K</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mi>s</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>K</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>s</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mrow><mi>s</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>→</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><msub><mrow><mo stretchy="false">‖</mo><mi>Y</mi><mo stretchy="false">‖</mo></mrow> <mrow><mi>s</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>⋮</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
\mathsf{SpMap}(X,K(\pi_s(Y),s)) \to \mathsf{SpMap}(X,{\Vert Y\Vert}_s) \to \mathsf{SpMap}(X,{\Vert Y\Vert}_{s-1}) \\
\mathsf{SpMap}(X,K(\pi_{s-1}(Y),s-1)) \to \mathsf{SpMap}(X,{\Vert Y\Vert}_{s-1}) \to \mathsf{SpMap}(X,{\Vert Y\Vert}_{s-2}) \\
\vdots
}

</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> K(A,s)</annotation></semantics></math> denotes the spectrum whose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi mathvariant="normal">th</mi></msup></mrow><annotation encoding="application/x-tex"> n^{\mathrm{th}}</annotation></semantics></math> space is the usual Eilenberg-Mac Lane space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>s</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> K(A,s+n)</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>+</mo><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> s+n\ge 0</annotation></semantics></math>, and contractible otherwise. Note that the spectrum <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> K(A,0)</annotation></semantics></math> is the Eilenberg-Mac Lane spectrum that we denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mi>A</mi></mrow><annotation encoding="application/x-tex"> H A</annotation></semantics></math> last time.</p>

<p>Hence, we have a spectral sequence with</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" columnalign="right left right left right left right left right left" columnspacing="0em"><mtr><mtd><msubsup><mi>E</mi> <mrow><mi>p</mi><mi>q</mi></mrow> <mn>2</mn></msubsup></mtd> <mtd><mo>=</mo><msub><mi>π</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>K</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mi>q</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo><msub><mi>π</mi> <mi>p</mi></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>H</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mi>q</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo><msup><mi>H</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>p</mi></mrow></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><msub><mi>π</mi> <mi>q</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{aligned}
    E^2_{p q} &amp;= \pi_{p+q}(\mathsf{SpMap}(X,K(\pi_q(Y),q)))\\
             &amp;= \pi_p(\mathsf{SpMap}(X,H(\pi_q(y)))\\
             &amp;= H^{-p}(X;\pi_q(Y))
  \end{aligned}
</annotation></semantics></math></div>
<p>the “ordinary” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>p</mi><msup><mo stretchy="false">)</mo> <mi mathvariant="normal">th</mi></msup></mrow><annotation encoding="application/x-tex"> (-p)^{\mathrm{th}}</annotation></semantics></math> cohomology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in the abelian group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>q</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_q(Y)</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type spectrum for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>, then this spectral sequence converges in the above sense to the homotopy groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_n( \mathsf{SpMap}(X,Y))</annotation></semantics></math>, which as remarked above are the cohomology <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^{-n}(X;Y)</annotation></semantics></math>.</p>

<p>This is called the <em>Atiyah-Hirzebruch spectral sequence</em>. It says that for any (sufficiently nice) spectrum <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, the cohomology of any type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> (what algebraic topologists call “generalized cohomology”) can be put together out of the “ordinary” cohomology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in the homotopy groups of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>. One usually flips the sign of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math> in “cohomological” spectral sequences of this sort, simultaneously switching the subscripts and superscripts; thus we write instead</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mn>2</mn> <mrow><mi>p</mi><mi>q</mi></mrow></msubsup><mo>=</mo><msup><mi>H</mi> <mi>p</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><msup><mi>H</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> E_2^{p q} = H^p(X;\pi_{-q}(Y)) \Rightarrow H^{p+q}(X;Y)</annotation></semantics></math></div>
<p>Graphically, this corresponds to rotating all the “pages” of the spectral sequence by 180 degrees about the origin. This causes the differentials to go down and right rather than left and up. (Note also that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>H</mi> <mi>q</mi></msup><mo stretchy="false">(</mo><mstyle mathvariant="bold"><mn>1</mn></mstyle><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_{-q}(Y) = H^q(\mathbf{1};Y)</annotation></semantics></math> is also the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>q</mi> <mi mathvariant="normal">th</mi></msup></mrow><annotation encoding="application/x-tex"> q^{\mathrm{th}}</annotation></semantics></math> cohomology of a point with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>.)</p>

<p>Of course, this may not seem very interesting unless you have some spectra up your sleeve other than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mi>A</mi></mrow><annotation encoding="application/x-tex"> H A</annotation></semantics></math> whose cohomology you care about. However, we can also use it to construct the Serre spectral sequence, which is interesting even as a statement only about ordinary cohomology.</p>

<p>First we have to generalize our notion of cohomology a bit. In the language of classical algebraic topology, we’re going to define <em>parametrized</em> cohomology theories, including as a special case <em>cohomology with local coefficients</em>. However, in type-theoretic language, what’s going on is extremely simple and natural: replacing function types with <em>dependent</em> function types.</p>

<p>Thus, suppose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is a type and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>X</mi><mo>→</mo><mstyle mathvariant="sans-serif"><mi>Spectrum</mi></mstyle></mrow><annotation encoding="application/x-tex"> Y : X \to \mathsf{Spectrum}</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family of spectra. We define the cohomology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> to be</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>:</mo><mo>≡</mo><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpSect</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^n(X;Y) :\equiv \pi_{-n} (\mathsf{SpSect}(X,Y))</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpSect</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathsf{SpSect}(X,Y)</annotation></semantics></math> is the “spectrum of sections of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>” defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpSect</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub><mo>:</mo><mo>≡</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><mi>x</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \mathsf{SpSect}(X,Y)_n :\equiv \prod_{(x:X)} Y(x)_n)</annotation></semantics></math>. As usual with dependent function types, when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is a constant family this reduces to the previously defined notion of cohomology.</p>

<p>Where do families of spectra come from? One place they come from is families of abelian groups. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>→</mo><mstyle mathvariant="sans-serif"><mi>AbGp</mi></mstyle></mrow><annotation encoding="application/x-tex"> A : X \to \mathsf{AbGp}</annotation></semantics></math> is such, then composing it with the “Eilenberg-Mac Lane spectrum” function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo>:</mo><mstyle mathvariant="sans-serif"><mi>ApGp</mi></mstyle><mo>→</mo><mstyle mathvariant="sans-serif"><mi>Spectrum</mi></mstyle></mrow><annotation encoding="application/x-tex"> H : \mathsf{ApGp}\to \mathsf{Spectrum}</annotation></semantics></math> we obtain an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family of spectra, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mi>A</mi></mrow><annotation encoding="application/x-tex"> H A</annotation></semantics></math>. Note that since abelian groups are sets, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>AbGp</mi></mstyle></mrow><annotation encoding="application/x-tex"> \mathsf{AbGp}</annotation></semantics></math> is a 1-type, and hence any such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> factors through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">‖</mo><mi>X</mi><msub><mo stretchy="false">‖</mo> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex"> \Vert X \Vert_1</annotation></semantics></math>, the “fundamental groupoid” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. This is the homotopy-type-theory version of what classical algebraic topologists would call a <em>local system</em> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is pointed and connected, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">‖</mo><mi>X</mi><msub><mo stretchy="false">‖</mo> <mn>1</mn></msub><mo>=</mo><mi>K</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \Vert X \Vert_1 = K(\pi_1(X),1)</annotation></semantics></math>, and so (using the univalence axiom) we can further reduce a local system to a single abelian group with an action by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_1(X)</annotation></semantics></math>, the most classical notion. The cohomology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mi>A</mi></mrow><annotation encoding="application/x-tex"> H A</annotation></semantics></math> is called <em>cohomology with local coefficients</em>.</p>

<p>Where do local systems come from? One place they come from is homotopy groups of families of types (or spectra). We can compose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo>:</mo><msub><mstyle mathvariant="sans-serif"><mi>Type</mi></mstyle> <mo>*</mo></msub><mo>→</mo><mstyle mathvariant="sans-serif"><mi>AbGp</mi></mstyle></mrow><annotation encoding="application/x-tex"> \pi_n : \mathsf{Type}_\ast \to \mathsf{AbGp}</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo>:</mo><mstyle mathvariant="sans-serif"><mi>Spectrum</mi></mstyle><mo>→</mo><mstyle mathvariant="sans-serif"><mi>AbGp</mi></mstyle></mrow><annotation encoding="application/x-tex"> \pi_n : \mathsf{Spectrum} \to \mathsf{AbGp}</annotation></semantics></math> with any family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>X</mi><mo>→</mo><msub><mstyle mathvariant="sans-serif"><mi>Type</mi></mstyle> <mo>*</mo></msub></mrow><annotation encoding="application/x-tex"> Y : X \to \mathsf{Type}_\ast</annotation></semantics></math> of pointed types or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>X</mi><mo>→</mo><mstyle mathvariant="sans-serif"><mi>Spectrum</mi></mstyle></mrow><annotation encoding="application/x-tex"> Y : X \to \mathsf{Spectrum}</annotation></semantics></math> of spectra to obtain a local system. I think the ease with which we can pass back and forth between local systems and families of spectra is a good example of the value of the type-theoretic framework.</p>

<p>In the same way, we can construct the “fiberwise” Postnikov tower of a family of spectra <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>:</mo><mi>X</mi><mo>→</mo><mstyle mathvariant="sans-serif"><mi>Spectrum</mi></mstyle></mrow><annotation encoding="application/x-tex"> Y : X \to \mathsf{Spectrum}</annotation></semantics></math>, obtaining an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family of iterated fibration sequences. The fibers of these fibration sequences are loopings or deloopings of “parametrized Eilenberg-Mac Lane spectra” associated to the local systems <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>q</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>X</mi><mo>→</mo><mstyle mathvariant="sans-serif"><mi>AbGp</mi></mstyle></mrow><annotation encoding="application/x-tex"> \pi_q(Y) : X \to \mathsf{AbGp}</annotation></semantics></math>. Sinc <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpSect</mi></mstyle></mrow><annotation encoding="application/x-tex"> \mathsf{SpSect}</annotation></semantics></math>, like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle></mrow><annotation encoding="application/x-tex"> \mathsf{SpMap}</annotation></semantics></math>, preserves fibration sequences, we get a more general Atiyah-Hirzebruch spectral sequence with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mn>2</mn> <mrow><mi>p</mi><mi>q</mi></mrow></msubsup><mo>=</mo><msup><mi>H</mi> <mi>p</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> E^{p q}_2 = H^{p}(X;\pi_{-q}(Y))</annotation></semantics></math> (meaning the cohomology with local coefficients in the local system <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_{-q}(Y)</annotation></semantics></math>), which converges to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^{p+q}(X;Y)</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is a family of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type spectra.</p>

<p>Now we’re ready to deduce the Serre spectral sequence. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> be an ordinary spectrum, such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">H A</annotation></semantics></math>, and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>X</mi><mo>→</mo><mstyle mathvariant="sans-serif"><mi>Type</mi></mstyle></mrow><annotation encoding="application/x-tex"> F : X \to \mathsf{Type}</annotation></semantics></math> be a type family. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>↦</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> x\mapsto \mathsf{SpMap}(F_x,Y)</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family of spectra, which are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-type spectra if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is. Thus, we have the above “parametrized” Atiyah-Hirzebruch spectral sequence:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>p</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>λ</mi><mi>x</mi><mo>.</mo><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><msup><mi>H</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex"> H^p(X;\lambda x.\pi_{-q}(\mathsf{SpMap}(F_x,Y))) \Rightarrow H^{p+q}(X;\lambda x.\mathsf{SpMap}(F_x,Y)).</annotation></semantics></math></div>
<p>On the left, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>q</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>H</mi> <mi>q</mi></msup><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \pi_{-q}(\mathsf{SpMap}(F_x,Y)) = H^q(F_x;Y)</annotation></semantics></math> by definition. And as for the right side, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" columnalign="right left right left right left right left right left" columnspacing="0em"><mtr><mtd><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpSect</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></munder><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></munder><msub><mi>F</mi> <mi>x</mi></msub><mo>;</mo><mi>F</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\begin{aligned}
  H^n(X;\lambda x.\mathsf{SpMap}(F_x,Y)) &amp;= \pi_{-n}(\mathsf{SpSect}(X,\lambda x.\mathsf{SpMap}(F_x,Y)))\\
  &amp;= \pi_{-n}(\mathsf{SpMap}(\sum_{(x:X)} F_x, Y))\\
  &amp;= H^n(\sum_{(x:X)}F_x;F)
\end{aligned}

</annotation></semantics></math></div>
<p>the cohomology of the total space of the fibration <em>F</em> with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>. (The second step is a spectral version of the ordinary universal mapping property of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex"> \Sigma</annotation></semantics></math>-types, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>;</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></msub><msub><mi>F</mi> <mi>x</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>→</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> ((\sum_{(x;X)} F_x) \to Z) = \prod_{(x:X)} (F_x \to Z)</annotation></semantics></math>.) Thus, our spectral sequence becomes</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>p</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mi>λ</mi><mi>x</mi><mo>.</mo><msup><mi>H</mi> <mi>q</mi></msup><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><msup><mi>H</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msup><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></munder><msub><mi>F</mi> <mi>x</mi></msub><mo>;</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^p(X;\lambda x. H^q(F_x;Y)) \Rightarrow H^{p+q}(\sum_{(x:X)} F_x;Y)</annotation></semantics></math></div>
<p>which is the usual cohomological Serre spectral sequence, relating the cohomology of the base, with local coefficients in the cohomology of the fiber, to the cohomology of the total space. Note that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is pointed and simply connected, so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">‖</mo><mi>X</mi><msub><mo stretchy="false">‖</mo> <mn>1</mn></msub><mo>=</mo><mstyle mathvariant="bold"><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex"> \Vert X \Vert_1 = \mathbf{1}</annotation></semantics></math>, then any local system on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is constant, and so the cohomology with local coefficients in the domain reduces simply to the ordinary cohomology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in the cohomology of the fiber over the basepoint.</p>

<p>After all of this theory, I ought to give you at least one application to justify it all. Here’s a fairly easy one. Suppose we have a fibration of spheres, i.e. a fiber sequence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>S</mi> <mi>a</mi></msup><mo>→</mo><msup><mi>S</mi> <mi>b</mi></msup><mo>→</mo><msup><mi>S</mi> <mi>c</mi></msup></mrow><annotation encoding="application/x-tex"> S^a \to S^b \to S^c</annotation></semantics></math> in which all three types are spheres of some dimension, and suppose that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> c\gt1</annotation></semantics></math> so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>S</mi> <mi>c</mi></msup></mrow><annotation encoding="application/x-tex"> S^c</annotation></semantics></math> is simply connected and that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> a\gt0</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> b\gt0</annotation></semantics></math> for nontriviality. Then we have a Serre spectral sequence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>p</mi></msup><mo stretchy="false">(</mo><msup><mi>S</mi> <mi>c</mi></msup><mo>;</mo><msup><mi>H</mi> <mi>q</mi></msup><mo stretchy="false">(</mo><msup><mi>S</mi> <mi>a</mi></msup><mo>;</mo><mi>ℤ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><msup><mi>H</mi> <mrow><mi>p</mi><mo>+</mo><mi>q</mi></mrow></msup><mo stretchy="false">(</mo><msup><mi>S</mi> <mi>b</mi></msup><mo>;</mo><mi>ℤ</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex"> H^p(S^c; H^q(S^a;\mathbb{Z})) \Rightarrow H^{p+q}(S^b;\mathbb{Z}).</annotation></semantics></math></div>
<p>The Eilenberg-Steenrod axioms for ordinary cohomology (i.e. with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mi>ℤ</mi></mrow><annotation encoding="application/x-tex"> H \mathbb{Z}</annotation></semantics></math>) easily imply that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><msup><mi>S</mi> <mi>m</mi></msup><mo>;</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^n(S^m;\mathbb{Z})</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi></mrow><annotation encoding="application/x-tex"> \mathbb{Z}</annotation></semantics></math> when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex"> n=0</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex"> n=m</annotation></semantics></math>, and zero otherwise. Thus, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>E</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> E_2</annotation></semantics></math> page of this spectral sequence is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi></mrow><annotation encoding="application/x-tex"> \mathbb{Z}</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (0,0), (c,0), (0,a), (c,a)</annotation></semantics></math>, and zero everywhere else. The only possible nontrivial differential would be a map from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mn>0</mn><mo>,</mo><mi>a</mi></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex"> E^r_{0,a}</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mi>c</mi><mo>,</mo><mn>0</mn></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex"> E^r_{c,0}</annotation></semantics></math>, and this is only possible if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> c = a+1</annotation></semantics></math>. If there is <em>no</em> such differential, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>E</mi> <mn>∞</mn></msub><mo>=</mo><msub><mi>E</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> E_\infty = E_2</annotation></semantics></math>, and so the target <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><msup><mi>S</mi> <mi>b</mi></msup><mo>;</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^n(S^b;\mathbb{Z})</annotation></semantics></math> will be built out of nontrivial groups for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex"> n = 0,a,c,a+c</annotation></semantics></math>. However, we know that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><msup><mi>S</mi> <mi>b</mi></msup><mo>;</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H^n(S^b;\mathbb{Z})</annotation></semantics></math> is zero unless <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex"> n = 0,b</annotation></semantics></math>, so this is impossible. Therefore, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> c = a+1</annotation></semantics></math>, the differential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>E</mi> <mrow><mn>0</mn><mo>,</mo><mi>a</mi></mrow> <mi>r</mi></msubsup><mo>→</mo><msubsup><mi>E</mi> <mrow><mi>c</mi><mo>,</mo><mn>0</mn></mrow> <mi>r</mi></msubsup></mrow><annotation encoding="application/x-tex"> E^r_{0,a} \to E^r_{c,0}</annotation></semantics></math> is an isomorphism and “kills” both of these groups, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>2</mn><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> b = a+c = 2a+1</annotation></semantics></math>. (This argument by contradiction is valid constructively, since natural numbers have decidable equality.)</p>

<p>In conclusion, <em>the only possible fibrations of spheres are of the form</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>S</mi> <mi>a</mi></msup><mo>→</mo><msup><mi>S</mi> <mrow><mn>2</mn><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>→</mo><msup><mi>S</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex"> S^a \to S^{2a+1}\to S^{a+1}</annotation></semantics></math>. When <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> a=1</annotation></semantics></math> we do have such a fibration, namely the Hopf fibration. (Classically, there are also such fibrations for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mn>3</mn><mo>,</mo><mn>7</mn></mrow><annotation encoding="application/x-tex"> a=3,7</annotation></semantics></math> and no other positive values of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> — the latter is a famous theorem called the “Hopf invariant one problem”.)</p>

<p>There are lots of other applications of spectral sequences; it’ll be fun to see how many of them we can reproduce. Many of them require homology in addition to cohomology, though, which would be a whole other post.</p>

<p>One last comment deserves to be made. I claimed that this “is” the Serre spectral sequence, but actually I haven’t proven that. It has the same groups in its <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>E</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> E_2</annotation></semantics></math> page, and converges to the same thing, but that doesn’t imply that the whole spectral sequence is the same (although it strongly suggests it). And I haven’t seen this construction of the Serre SS anywhere in the classical algebraic topology literature (although I’d be surprised if it were new) — most constructions use instead a CW decomposition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, which is unavailable to us. So does this “Serre spectral sequence” agree with the classical one when interpreted in the simplicial model? I’m not sure how to go about trying to prove that. <em>(Edit: See <a href="#Maunder">below</a>!)</em></p>

<h2 id="on_indexing_choices">On indexing choices</h2>

<p>The “natural” indexing of the spectral sequence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X_s)</annotation></semantics></math> constructed above is by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math>, and in this indexing the initial differential has degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1,1)</annotation></semantics></math>. We chose to reindex it by writing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n = p+q</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">s=q</annotation></semantics></math>, in which case the initial differential has <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p,q)</annotation></semantics></math> degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-2,1)</annotation></semantics></math>, thereby matching the indexing and degrees for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>E</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math> page of some known spectral sequences (such as the Serre and Atiyah-Hirzebruch SS).</p>

<p>However, there are other ways to do the reindexing. For instance, if we instead set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mi>t</mi><mo>−</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">n = t-s</annotation></semantics></math>, then the initial differential will have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s,t)</annotation></semantics></math> degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,0)</annotation></semantics></math>, which looks more like the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>E</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math> page of a spectral sequence. For instance, the Adams spectral sequence can be obtained in this way from a suitably chosen tower of fibrations (although usually in that case one talk about cofibers rather than fibers, which in the world of spectra are the same up to a furtherh degree shift). Thanks to <a class="existingWikiWord" href="/nlab/show/Urs+Schreiber">Urs Schreiber</a> for pointing this out.</p>

<h2 id="notes">Notes</h2>

<p>Some notes not in the original blog posts:</p>

<ul>
<li>
<p>In the section on Spectral Sequences on HoTT it is ambiguous whether <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{SpMap}(X,Y)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpSect</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{SpSect}(X,Y)</annotation></semantics></math> consists of pointed or unpointed maps. Most steps taken are true both when they are interpreted as pointed or as unpointed maps. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{SpMap}(X,Y)</annotation></semantics></math> is unpointed then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is unpointed and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{-n} (\mathsf{SpMap}(X,Y))</annotation></semantics></math> is the unreduced cohomology of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> (with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>). If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{SpMap}(X,Y)</annotation></semantics></math> is pointed then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is interpreted as a pointed type and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{-n} (\mathsf{SpMap}(X,Y))</annotation></semantics></math> is the reduced cohomology. Everything in the proof of the Atiyah-Hirzebruch spectral sequence holds for both cases, so the Atiyah-Hirzebruch spectral sequence exists for both reduced and unreduced cohomology. However, the Serre Spectral sequence is only valid for unreduced cohomology, since the equivalence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="sans-serif"><mi>SpSect</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mstyle mathvariant="sans-serif"><mi>SpMap</mi></mstyle><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></munder><msub><mi>F</mi> <mi>x</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathsf{SpSect}(X,\lambda x.\mathsf{SpMap}(F_x,Y)) = \mathsf{SpMap}(\sum_{(x:X)} F_x, Y)</annotation></semantics></math></div>
<p>used in the proof is only true for unpointed maps.</p>
</li>

<li id="Maunder">
<p><a class="existingWikiWord" href="/nlab/show/Urs+Schreiber">Urs Schreiber</a> has <a href="https://homotopytypetheory.org/2013/08/08/spectral-sequences/#comment-100544">pointed out</a> that this construction of the AHSS appears in <a href="Atiyah&#x2013;Hirzebruch+spectral+sequence#Maunder63">C. R. F. Maunder (1963)</a>, who also shows that it agrees with the standard construction by constructing an isomorphism of <a class="existingWikiWord" href="/nlab/show/exact+couples">exact couples</a>. It seems likely that a similar method would work for the Serre SS.</p>
</li>
</ul>

<h2 id="References">References</h2>

<ul>
<li id="Shulman13">
<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>, <em>Spectral sequences</em> (2013) &lbrack;<a href="https://golem.ph.utexas.edu/category/2013/08/what_is_a_spectral_sequence.html">part I</a>, <a href="http://homotopytypetheory.org/2013/08/08/spectral-sequences/">part II</a>&rbrack;</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Floris+van+Doorn">Floris van Doorn</a>, §5 in: <em>On the Formalization of Higher Inductive Types and Synthetic Homotopy Theory</em> (2018) &lbrack;<a href="https://arxiv.org/abs/1808.10690">arXiv:1808.10690</a>&rbrack;</p>
</li>
</ul>

<p>Formalization in <a class="existingWikiWord" href="/nlab/show/Lean">Lean</a>:</p>

<ul>
<li id="vanDoornSpectral"><a class="existingWikiWord" href="/nlab/show/Floris+van+Doorn">Floris van Doorn</a>, <a class="existingWikiWord" href="/nlab/show/Egbert+Rijke">Egbert Rijke</a>, <a class="existingWikiWord" href="/nlab/show/Ulrik+Buchholtz">Ulrik Buchholtz</a>, <a class="existingWikiWord" href="/nlab/show/Favonia">Favonia</a>, <a class="existingWikiWord" href="/nlab/show/Steve+Awodey">Steve Awodey</a>, <a class="existingWikiWord" href="/nlab/show/Jeremy+Avigad">Jeremy Avigad</a>, <a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>, <a class="existingWikiWord" href="/nlab/show/Jonas+Frey">Jonas Frey</a>, <em>Spectral</em> &lbrack;<a href="https://github.com/cmu-phil/Spectral">github.com/cmu-phil/Spectral</a>&rbrack;</li>
</ul>
<div class="property">category: <a class="category_link" href="/nlab/all_pages/homotopy+theory">homotopy theory</a></div></body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on January  1, 2024 at 13:48:47.
    See the <a href="/nlab/history/spectral+sequences+in+homotopy+type+theory" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/spectral+sequences+in+homotopy+type+theory" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/14549/#Item_3">Discuss</a><span class="backintime"><a href="/nlab/revision/spectral+sequences+in+homotopy+type+theory/3" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/spectral+sequences+in+homotopy+type+theory" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/spectral+sequences+in+homotopy+type+theory" accesskey="S" class="navlink" id="history" rel="nofollow">History (3 revisions)</a>
  <a href="/nlab/show/spectral+sequences+in+homotopy+type+theory/cite" style="color: black">Cite</a>
  <a href="/nlab/print/spectral+sequences+in+homotopy+type+theory" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/spectral+sequences+in+homotopy+type+theory" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
