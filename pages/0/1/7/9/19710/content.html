
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      bidirectional typechecking in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      bidirectional typechecking
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/9030/#Item_46" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Bidirectional typechecking</title></head>
<body>
<h1 id="bidirectional_typechecking">Bidirectional typechecking</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#references'>References</a></li>
<ul>
<li><a href='#general'>General</a></li>
<li><a href='#for_dependent_types'>For dependent types</a></li>
<li><a href='#other_type_theories'>Other type theories</a></li>
</ul>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p><em>Bidirectional typechecking</em> is both a style of mathematical presentation of a <a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a> and a kind of <a class="existingWikiWord" href="/nlab/show/algorithm">algorithm</a> for implementing one. The idea is that the basic <a class="existingWikiWord" href="/nlab/show/judgment">judgment</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t:A</annotation></semantics></math> that a <a class="existingWikiWord" href="/nlab/show/term">term</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> belongs to a <a class="existingWikiWord" href="/nlab/show/type">type</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is split into two judgments:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇐</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t \Leftarrow A</annotation></semantics></math>: the term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> can be <em>checked</em> to have the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t \Rightarrow A</annotation></semantics></math>: from the term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> we can <em>infer</em>, or <em>synthesize</em>, the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> that it has.</li>
</ul>

<p>The difference is that in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇐</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\Leftarrow A</annotation></semantics></math> we regard both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> as “given” or “inputs”, whereas in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\Rightarrow A</annotation></semantics></math> we regard only <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> as an “input” and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> as an “output” that is “computed” from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>. When presented as a pure <a class="existingWikiWord" href="/nlab/show/deductive+system">deductive system</a>, these “input/output modes” do not mean anything, but when implemented as an algorithm they mean that we have two mutually recursive functions:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>check</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">check(t,A)</annotation></semantics></math> which simply succeeds or fails.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>infer</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">infer(t)</annotation></semantics></math> which either returns a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> or fails.</li>
</ul>

<p>See <a class="existingWikiWord" href="/nlab/show/logic+programming">logic programming</a>.</p>

<p>For example, from an un-annotated <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction such as the identity function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lambda x.x</annotation></semantics></math> we cannot infer its type: the variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, and hence the result, could have any type. But we can <em>check</em> that it has any given endomorphism type: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⇐</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda x.x) \Leftarrow (A\to A)</annotation></semantics></math> for any type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. On the other hand, if we can infer a type for the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⇒</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f\Rightarrow (A\to B)</annotation></semantics></math> (for instance, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> could be a variable, since variables are declared with their types), and we can check that an argument <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> has type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> (that is, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⇐</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a\Leftarrow A</annotation></semantics></math>), then we can also infer that the application <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math> has type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, that is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f(a) \Rightarrow B</annotation></semantics></math>. These observations correspond to bidirectional refinements of the usual typing rules for abstractions and applications:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>M</mi><mo>⇐</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>M</mi><mo stretchy="false">)</mo><mo>⇐</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>⇒</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⇐</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>B</mi></mrow></mfrac><mo>.</mo></mrow><annotation encoding="application/x-tex"> \frac{\Gamma,x:A \vdash M \Leftarrow B}{\Gamma\vdash (\lambda x.M) \Leftarrow (A\to B)} \qquad \frac{\Gamma\vdash f \Rightarrow (A\to B) \qquad \Gamma\vdash a \Leftarrow A }{\Gamma \vdash f(a) \Rightarrow B}.</annotation></semantics></math></div>
<p>Bidirectional typechecking is closely related to “canonical forms only” presentations of type theories (such as <a class="existingWikiWord" href="/nlab/show/logical+frameworks">logical frameworks</a>) that involve <span class="newWikiWord">hereditary substitution<a href="/nlab/new/hereditary+substitution">?</a></span>. For instance, because we infer a type for an application <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math> by inferring a type for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>, but we can only <em>check</em> the type of an un-annotated abstraction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda x.M</annotation></semantics></math>, an un-augmented bidirectional theory cannot typecheck a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-redex (see <a class="existingWikiWord" href="/nlab/show/beta-reduction">beta-reduction</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>M</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda x.M)(a)</annotation></semantics></math>. Thus it is a natural system in which to describe a type theory in which only canonical forms (no redexes) exist. But it is also easy to augment a bidirectional system with <span class="newWikiWord">type ascription<a href="/nlab/new/type+ascription">?</a></span>, which mediates between the two modes and allows typechecking redexes: if we can check <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇐</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\Leftarrow A</annotation></semantics></math>, then we can <em>infer</em> the same type of the <em>ascribed</em> term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">(t:A)\Rightarrow A</annotation></semantics></math>, allowing a redex to be written as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>M</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda x.M : A\to B)(a)</annotation></semantics></math>.</p>

<div class="un_remark">
<h6 id="remark">Remark</h6>

<p>There are many different notations used in the literature for the bidirectional typing judgments. Sometimes one finds <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇉</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\rightrightarrows A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇇</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\leftleftarrows A</annotation></semantics></math> in place of our <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\Rightarrow A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⇐</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\Leftarrow A</annotation></semantics></math>. Other times the order of the term and the type is reversed, for instance writing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t\in A</annotation></semantics></math> for inferring and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">A\ni t</annotation></semantics></math> for checking. Sometimes upwards and downwards-pointing arrows are used instead of leftwards and rightwards ones (e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo stretchy="false">↑</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t \uparrow A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo stretchy="false">↓</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t \downarrow A</annotation></semantics></math>, or maybe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><msup><mo>:</mo> <mo stretchy="false">↑</mo></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">t :^\uparrow A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><msup><mo>:</mo> <mo stretchy="false">↓</mo></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">t :^\downarrow A</annotation></semantics></math> or a dozen other variants) — but unfortunately there is no consensus on which judgment points up and which points down! It seems to be somewhat more common for checking to point up and inference to point down, as this matches the direction that “information flows through the derivation tree”, but the opposite convention is found in plenty of papers too. (It could be that there is a “modern” consensus that only older papers violate.)</p>
</div>

<h2 id="references">References</h2>

<h3 id="general">General</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Jana+Dunfield">Jana Dunfield</a>, <a class="existingWikiWord" href="/nlab/show/Neel+Krishnaswami">Neel Krishnaswami</a>, <em>Bidirectional Typing</em> (Survey), 2019, (<a href="https://www.cl.cam.ac.uk/~nk480/bidir-survey.pdf">pdf</a>)</p>
</li>

<li>
<p>Pierce, B. C., Turner, D. N.: <em>Local Type Inference</em>, ACM SIGPLAN–SIGACT Symposium on Principles of Programming Languages (POPL), San Diego, California, 1998, Full version in ACM Transactions on Programming Languages and Systems (TOPLAS), 22(1), January 2000, pp. 1–44, (<a href="http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf">pdf</a>). This is usually cited as the “original” paper on bidirectional typechecking.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Frank+Pfenning">Frank Pfenning</a>, <em>Lecture Notes on Bidirectional Type Checking</em>, <a href="https://www.cs.cmu.edu/~fp/courses/15312-f04/handouts/15-bidirectional.pdf">pdf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Conor+McBride">Conor McBride</a>, <em>Basics of bidirectionality</em>, <a href="https://pigworker.wordpress.com/2018/08/06/basics-of-bidirectionalism/">blog post</a></p>
</li>

<li>
<p>David Christiansen, <em>Bidirectional typing rules: a tutorial</em>, <a href="http://www.davidchristiansen.dk/tutorials/bidirectional.pdf">pdf</a></p>
</li>
</ul>

<h3 id="for_dependent_types">For dependent types</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Thierry+Coquand">Thierry Coquand</a>, <em>An algorithm for type-checking dependent types</em>, 1996, <a href="https://core.ac.uk/download/pdf/82345314.pdf">pdf</a></p>
</li>

<li>
<p>Thierry Coquand and Makoto Takeyama, <em>An Implementation of Type:Type</em>, 2002, <a href="https://link.springer.com/chapter/10.1007/3-540-45842-5_4">springerlink</a></p>
</li>

<li>
<p>Ulf Norell, <em>Towards a practical programming language based on dependent type theory</em>. PhD thesis, Chalmers University of Technology and Göteborg University, 2007. <a href="http://www.cse.chalmers.se/~ulfn/papers/thesis.html">web</a></p>
</li>

<li>
<p>Andreas Abel, Thierry Coquand, Peter Dybjer <em>Verifying a Semantic <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>β</mi><mi>η</mi></mrow><annotation encoding="application/x-tex">\beta\eta</annotation></semantics></math>-Conversion Test for Martin-Löf Type Theory (extended version)</em>, 2008 <a href="https://www.semanticscholar.org/paper/Verifying-a-Semantic-%CE%B2%CE%B7-Conversion-Test-for-Type-(-Abel-Coquand/ea73f57e4f1111b136cb9f0659c627dba25e53c8">semantic scholar (includes pdf)</a></p>
</li>

<li>
<p>Andreas Abel and <a class="existingWikiWord" href="/nlab/show/Thorsten+Altenkirch">Thorsten Altenkirch</a>, <em>A partial type checking algorithm for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type:Type</annotation></semantics></math></em>, 2008, <a href="http://www.cs.nott.ac.uk/~psztxa/publ/msfp08.pdf">pdf</a></p>
</li>

<li>
<p>Andres Löh, Conor McBride and Wouter Swierstra, <em>A Tutorial Implementation of a Dependently Typed Lambda Calculus</em>, 2009, <a href="https://www.andres-loeh.de/LambdaPi/">web</a> (includes Haskell code)</p>
</li>

<li>
<p>Andrea Asperti, Wilmer Ricciotti, Claudio Sacerdoti Coen, and Enrico Tassi. <em>A bi-directional refinement algorithm for the calculus of (co)inductive constructions</em>, 2012, <a href="https://arxiv.org/abs/1202.4905">arxiv</a></p>
</li>

<li>
<p>Kevin Watkins, Iliano Cervesato, Frank Pfenning, and David Walker. <em>A concurrent logical framework I: Judgments and properties</em>. Technical Report CMU-CS-02-101, Department of Computer Science, Carnegie Mellon University, 2002. Revised May 2003, <a href="http://www.cs.cmu.edu/~fp/papers/CMU-CS-02-101.pdf">pdf</a></p>
</li>
</ul>

<h3 id="other_type_theories">Other type theories</h3>

<ul>
<li>
<p>Rowan Davies and <a class="existingWikiWord" href="/nlab/show/Frank+Pfenning">Frank Pfenning</a>. <em>Intersection types and computational effects</em>. In P. Wadler, editor, Proceedings of the Fifth International Conference on Functional Programming (ICFP’00), pages 198-208, Montreal, Canada, September 2000. ACM Press. <a href="http://www.cs.cmu.edu/~fp/papers/icfp00.pdf">pdf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Jana+Dunfield">Jana Dunfield</a> and <a class="existingWikiWord" href="/nlab/show/Frank+Pfenning">Frank Pfenning</a>. <em>Tridirectional typechecking</em>. In X.Leroy, editor, Conference Record of the 31st Annual Symposium on Principles of Programming Languages (POPL’04), pages 281-292, Venice, Italy, January 2004. ACM Press. Extended version available as Technical Report CMU-CS-04-117, March 2004. <a href="http://www.cs.cmu.edu/~fp/papers/popl04.pdf">pdf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Jana+Dunfield">Jana Dunfield</a>, Neelakantan R. Krishnaswami, <em>Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism</em>, 2013, <a href="https://arxiv.org/abs/1306.6032">arxiv</a></p>
</li>

<li>
<p>Francisco Ferreira and Brigitte Pientka, <em>Bidirectional Elaboration of Dependently Typed Programs</em>, 2014, <a href="https://www.cs.mcgill.ca/~fferre8/papers/BidirectionalElaboration.pdf">pdf</a>. Despite the name, this paper is not about full <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a> but only has one level of dependency.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Jana+Dunfield">Jana Dunfield</a>, Neelakantan R. Krishnaswami, <em>Sound and Complete Bidirectional Typechecking for Higher-Rank Polymorphism with Existentials and Indexed Types</em>, 2016, <a href="https://arxiv.org/abs/1601.05106">arxiv</a></p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on June  4, 2021 at 10:21:20.
    See the <a href="/nlab/history/bidirectional+typechecking" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/bidirectional+typechecking" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/9030/#Item_46">Discuss</a><span class="backintime"><a href="/nlab/revision/bidirectional+typechecking/8" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/bidirectional+typechecking" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/bidirectional+typechecking" accesskey="S" class="navlink" id="history" rel="nofollow">History (8 revisions)</a>
  <a href="/nlab/show/bidirectional+typechecking/cite" style="color: black">Cite</a>
  <a href="/nlab/print/bidirectional+typechecking" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/bidirectional+typechecking" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
