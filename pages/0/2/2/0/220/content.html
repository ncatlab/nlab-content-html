
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      Trimble on ETCS II in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      Trimble on ETCS II
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/10490/#Item_1" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>ETCS : Internalizing the logic</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="foundations">Foundations</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundations">foundations</a></strong></p>

<h2 id="the_basis_of_it_all">The basis of it all</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/mathematical+logic">mathematical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/first-order+logic">first-order logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/universe">universe</a></p>
</li>
</ul>

<h2 id="set_theory"> Set theory</h2>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a></strong></p>

<ul>
<li>presentations of set theory
<ul>
<li><a class="existingWikiWord" href="/nlab/show/unsorted+set+theory">unsorted set theory</a></li>

<li><a class="existingWikiWord" href="/nlab/show/two-sorted+set+theory">two-sorted set theory</a></li>

<li><a class="existingWikiWord" href="/nlab/show/dependently+sorted+set+theory">dependently sorted set theory</a></li>

<li><a class="existingWikiWord" href="/nlab/show/structurally+presented+set+theory">structurally presented set theory</a></li>
</ul>
</li>

<li>structuralism in set theory
<ul>
<li><a class="existingWikiWord" href="/nlab/show/material+set+theory">material set theory</a>
<ul>
<li><a class="existingWikiWord" href="/nlab/show/ZFC">ZFC</a></li>

<li><a class="existingWikiWord" href="/nlab/show/ZFA">ZFA</a></li>

<li><a class="existingWikiWord" href="/nlab/show/New+Foundations">New Foundations</a></li>
</ul>
</li>

<li><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural set theory</a>
<ul>
<li><a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a>
<ul>
<li><a class="existingWikiWord" href="/nlab/show/fully+formal+ETCS">fully formal ETCS</a></li>

<li><a class="existingWikiWord" href="/nlab/show/ETCS+with+elements">ETCS with elements</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+I">Trimble on ETCS I</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+II">Trimble on ETCS II</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+III">Trimble on ETCS III</a></li>
</ul>
</li>

<li><a class="existingWikiWord" href="/nlab/show/SEAR">SEAR</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="foundational_axioms">Foundational axioms</h2>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundational+axiom">foundational axiom</a></strong></p>

<ul>
<li>
<p>basic constructions:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+cartesian+products">axiom of cartesian products</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+disjoint+unions">axiom of disjoint unions</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+the+empty+set">axiom of the empty set</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+fullness">axiom of fullness</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+function+sets">axiom of function sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+power+sets">axiom of power sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+quotient+sets">axiom of quotient sets</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/material+set+theory">material axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+extensionality">axiom of extensionality</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+foundation">axiom of foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+anti-foundation">axiom of anti-foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Mostowski%27s+axiom">Mostowski's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+pairing">axiom of pairing</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+transitive+closure">axiom of transitive closure</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+union">axiom of union</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+materialization">axiom of materialization</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theoretic axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+K">axiom K</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+UIP">axiom UIP</a></li>

<li><a class="existingWikiWord" href="/nlab/show/univalence+axiom">univalence axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Whitehead%27s+principle">Whitehead's principle</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/axioms+of+choice">axioms of choice</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+countable+choice">axiom of countable choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+dependent+choice">axiom of dependent choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+excluded+middle">axiom of excluded middle</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+existence">axiom of existence</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+multiple+choice">axiom of multiple choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Markov%27s+axiom">Markov's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/presentation+axiom">presentation axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/small+cardinality+selection+axiom">small cardinality selection axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+small+violations+of+choice">axiom of small violations of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+weakly+initial+sets+of+covers">axiom of weakly initial sets of covers</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/large+cardinal+axioms">large cardinal axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+infinity">axiom of infinity</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+universes">axiom of universes</a></li>

<li><a class="existingWikiWord" href="/nlab/show/regular+extension+axiom">regular extension axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/inaccessible+cardinal">inaccessible cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/measurable+cardinal">measurable cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/elementary+embedding">elementary embedding</a></li>

<li><a class="existingWikiWord" href="/nlab/show/supercompact+cardinal">supercompact cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Vop%C4%9Bnka%27s+principle">Vopěnka's principle</a></li>
</ul>
</li>

<li>
<p>strong axioms</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+separation">axiom of separation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+replacement">axiom of replacement</a></li>
</ul>
</li>

<li>
<p>further</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/reflection+principle">reflection principle</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="removing_axioms">Removing axioms</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a></li>

<li><a class="existingWikiWord" href="/nlab/show/predicative+mathematics">predicative mathematics</a></li>
</ul>
<div>
<p>
  <a href="/nlab/edit/foundations+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<p><em>This is Part II of an exposition by <a class="existingWikiWord" href="/nlab/show/Todd+Trimble">Todd Trimble</a> on <a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a></em>.</p>

<p>See also</p>

<ul>
<li>
<p>Part I, <a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+I">ZFC and ETCS</a></p>
</li>

<li>
<p>Part III, <a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+III">ETCS: Building joins and coproducts</a></p>
</li>
</ul>
<hr />
<h2 id="etcs__internalizing_the_logic">ETCS : Internalizing the logic</h2>

<p>This post is a continuation of the discussion of “the elementary theory of the category of sets” [ETCS] which we had begun last time, <a href="http://topologicalmusings.wordpress.com/2008/09/01/zfc-and-etcs-elementary-theory-of-the-category-of-sets/">here</a> and in the comments which followed. My thanks go to all who commented, for some useful feedback and thought-provoking questions.</p>

<p>Today I’ll describe some of the set-theoretic operations and “internal logic” of ETCS. I have a feeling that some people are going to love this, and some are going to hate it. My main worry is that it will leave some readers bewildered or exasperated, thinking that category theory has an amazing ability to make easy things difficult.</p>

<ul>
<li><strong>An aside:</strong> has anyone out there seen the book <em>Mathematics Made Difficult</em>? It’s probably out of print by now, but I recommend checking it out if you ever run into it — it’s a kind of extended in-joke which pokes fun at category theory and abstract methods generally. Some category theorists I know take a dim view of this book; I for my part found certain passages hilarious, in some cases making me laugh out loud for five minutes straight. There <em>are</em> category-theory-based books and articles out there which cry out for parody!</li>
</ul>

<p>In an attempt to nip my concerns in the bud, let me remind my readers that there are major differences between the way that standard set theories like ZFC treat membership and the way ETCS treats membership, and that differences at such a fundamental level are bound to propagate throughout the theoretical development, and impart a somewhat different character or feel between the theories. The differences may be summarized as follows:</p>

<ul>
<li>
<p>Membership in ZFC is a <em>global</em> relation between objects of the <em>same</em> type (sets).</p>
</li>

<li>
<p>Membership in ETCS is a <em>local</em> relation between objects of <em>different</em> types (“generalized” elements or functions, and sets).</p>
</li>
</ul>

<p>Part of what we meant by “local” is that an element <em>per se</em> is always considered relative to a particular set to which it belongs; strictly speaking, as per the discussion last time, the same element is never considered as belonging to two different sets. That is, in ETCS, an (ordinary) element of a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is defined to be a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x : 1 \to A</annotation></semantics></math>; since the codomain is fixed, the same morphism cannot be an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">1 \to B</annotation></semantics></math> of a different set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. This implies in particular that in ETCS, there is no meaningful global intersection operation on sets, which in ZFC is defined by:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"></mspace><mo>∧</mo><mspace width="mediummathspace"></mspace><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A \cap B = \{ x : (x \in A) \:\wedge\: (x \in B) \}</annotation></semantics></math></div>
<p>Instead, in ETCS, what we have is a <em>local</em> intersection operation on <em>subsets</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>↪</mo><mi>X</mi><mo>,</mo><mi>B</mi><mo>↪</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \hookrightarrow X, B \hookrightarrow X</annotation></semantics></math> of a set. But even the word “subset” requires care, because of how we are now treating membership. So let’s back up, and lay out some simple but fundamental definitions of terms as we are now using them.</p>

<p>Given two monomorphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>X</mi><mo>,</mo><mi>j</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">i : A \to X, j : B \to X</annotation></semantics></math>, we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>⊆</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \subseteq j</annotation></semantics></math> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \subseteq B</annotation></semantics></math> if the monos are understood, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><msub><mo>⊆</mo> <mi>X</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">A \subseteq_X B</annotation></semantics></math> if we wish to emphasize this is local to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>) if there is a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">k : A \to B</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">i = j k</annotation></semantics></math>. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math> is monic, there can be at most one such morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>; since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> is monic, such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> must be monic as well. We say <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i, j</annotation></semantics></math> <em>define the same subset</em> if this <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is an isomorphism. So: subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> are defined to be isomorphism classes of monomorphisms into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. As a simple exercise, one may show that monos <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i, j</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> define the same subset if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>⊆</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \subseteq j</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>⊆</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j \subseteq i</annotation></semantics></math>. The (reflexive, transitive) relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>⊆</mo> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\subseteq_X</annotation></semantics></math> on monomorphisms thus induces a reflexive, transitive, antisymmetric relation, <em>i.e.</em>, a partial order on subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>.</p>

<p>Taking some notational liberties, we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> to indicate a subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> (as isomorphism class of monos). If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x : U \to X</annotation></semantics></math> is a generalized element, let us say <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> <em>is in</em> a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> if it factors (evidently uniquely) through any representative mono <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">i : A \to X</annotation></semantics></math>, <em>i.e.</em>, if there exists <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>′</mo><mo>:</mo><mi>U</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x' : U \to A</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>=</mo><mi>i</mi><mi>x</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">x = i x'</annotation></semantics></math>. Now the <em>intersection</em> of two subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">B \subseteq X</annotation></semantics></math> is defined to be the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \cap B \subseteq X</annotation></semantics></math> defined by the pullback of any two representative monos <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>X</mi><mo>,</mo><mi>j</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">i : A \to X, j : B \to X</annotation></semantics></math>. Following the “Yoneda principle”, it may equivalently be defined up to isomorphism by specifying its generalized elements:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="mediummathspace"></mspace><mo>∩</mo><mspace width="mediummathspace"></mspace><mi>B</mi><msub><mo>≔</mo> <mi>i</mi></msub><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mo stretchy="false">(</mo><mi>x</mi><mspace width="mediummathspace"></mspace><mtext>is in</mtext><mspace width="mediummathspace"></mspace><mi>A</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"></mspace><mo>∧</mo><mspace width="mediummathspace"></mspace><mo stretchy="false">(</mo><mi>x</mi><mspace width="mediummathspace"></mspace><mtext>is in</mtext><mspace width="mediummathspace"></mspace><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">A \:\cap\: B {\coloneqq}_i \{ x \in X : (x \:\text{is in}\: A) \:\wedge\: (x \:\text{is in}\: B) \}.</annotation></semantics></math></div>
<p>Thus, intersection works essentially the same way as in ZFC, only it’s <em>local</em> to subsets of a given set.</p>

<p>While we’re at it, let’s reformulate the power set axiom in this language: it says simply that for each set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> there is a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B)</annotation></semantics></math> and a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mi>B</mi></msub><mo>⊆</mo><mi>B</mi><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\in_B \subseteq B \times P(B)</annotation></semantics></math>, such that for any relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>B</mi><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">R \subseteq B \times A</annotation></semantics></math>, there is a unique “classifying map” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_R : A \to P(B)</annotation></semantics></math> whereby, under <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mn>1</mn> <mi>B</mi></msub><mo>×</mo><msub><mi>χ</mi> <mi>R</mi></msub><mo>:</mo><mi>B</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1_B \times \chi_R : B \times A \to B \times P(B)</annotation></semantics></math>, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>B</mi></msub><mo>×</mo><msub><mi>χ</mi> <mi>R</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msub><mo>∈</mo> <mi>B</mi></msub><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">R = (1_B \times \chi_R)^{-1} (\in_B).</annotation></semantics></math></div>
<p>The equality is an equality between subsets, and the inverse image on the right is defined by a pullback. In categorical set theory notation,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">⟨</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false">⟩</mo><mo>∈</mo><mi>B</mi><mo>×</mo><mi>A</mi><mo>:</mo><mi>b</mi><msub><mo>∈</mo> <mi>B</mi></msub><msub><mi>χ</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">R = \{ \langle b, a \rangle \in B \times A : b \in_B \chi_R(a) \}.</annotation></semantics></math></div>
<p>Hence, there are natural bijections</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mfrac><mrow><mi>R</mi><mo>⊆</mo><mi>B</mi><mo>×</mo><mi>A</mi></mrow><mrow><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>R</mi><mo>⊆</mo><mi>B</mi><mo>×</mo><mi>A</mi></mrow><mrow><mi>B</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{R \subseteq B \times A}{A \to P(B)} \qquad \frac{R \subseteq B \times A}{B \to P(A)}</annotation></semantics></math></div>
<p>between subsets and classifying maps. The subset corresponding to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : A \to P(B)</annotation></semantics></math> is denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>ϕ</mi><mo>]</mo></mrow><mo>⊆</mo><mi>B</mi><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\left[\phi\right] \subseteq B \times A</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>ϕ</mi><mo>]</mo></mrow><mo>⊆</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\left[\phi\right] \subseteq A \times B</annotation></semantics></math>, and is called the <em>extension</em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math>.</p>

<p>The set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math> plays a particularly important role; it is called the “subset classifier” because subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> are in natural bijection with functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>χ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi : X \to P(1)</annotation></semantics></math>. [Cf. classifying spaces in the theory of fiber bundles.]</p>

<p>In ordinary set theory, the role of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math> is played by the 2-element set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>f</mi><mo>,</mo><mi>t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ f, t \}</annotation></semantics></math>. Here subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> are classified by their characteristic functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mo stretchy="false">{</mo><mi>f</mi><mo>,</mo><mi>t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\chi_A : X \to \{ f, t \}</annotation></semantics></math>, defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≔</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\chi_A(x) \coloneqq t</annotation></semantics></math> iff <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x \in A</annotation></semantics></math>. We thus have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><msubsup><mi>χ</mi> <mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = \chi_A^{-1}(t)</annotation></semantics></math>; the elementhood relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mn>1</mn></msub><mo>↪</mo><mn>1</mn><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\in_1 \hookrightarrow 1 \times P(1)</annotation></semantics></math> boils down to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t : 1 \to P(1)</annotation></semantics></math>. Something similar happens in ETCS set theory:</p>

<p><strong>Lemma 1.</strong> The domain of elementhood <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mn>1</mn></msub><mo>→</mo><mn>1</mn><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≅</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\in_1 \to 1 \times P(1) \cong P(1)</annotation></semantics></math> is terminal.</p>

<p><strong>Proof.</strong> A map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>→</mo><msub><mo>∈</mo> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X \to \in_1</annotation></semantics></math>, that is, a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>χ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi : X \to P(1)</annotation></semantics></math> which is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mn>1</mn></msub><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\in_1 \subseteq P(1)</annotation></semantics></math>, corresponds exactly to a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>χ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msub><mo>∈</mo> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\chi^{-1}(\in_1) \subseteq X</annotation></semantics></math> which contains all of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> (_i.e._, the subobject <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mn>1</mn> <mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">1_X : X \subseteq X</annotation></semantics></math>). Since the only such subset is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mn>1</mn> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">1_X</annotation></semantics></math>, there is exactly one map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>→</mo><msub><mo>∈</mo> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X \to \in_1</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>Hence elementhood <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mn>1</mn></msub><mo>⊆</mo><mn>1</mn><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\in_1 \subseteq 1 \times P(1)</annotation></semantics></math> is given by an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t : 1 \to P(1)</annotation></semantics></math>. The power set axiom says that a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> is retrieved from its classifying map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_A : X \to P(1)</annotation></semantics></math> as the pullback <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>χ</mi> <mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\chi^{-1}_A (t) \subseteq X</annotation></semantics></math>.</p>

<p>Part of the power of, well, power sets is in a certain dialectic between external operations on subsets and internal operations on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math>; one can do some rather amazing things with this. The intuitive (and pre-axiomatic) point is that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> has finite products, equalizers, and power objects, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math> is a <a href="http://topologicalmusings.wordpress.com/2008/07/12/basic-category-theory-iii-representability-adjoints-and-the-yoneda-lemma">representing object</a> for the functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">Sub : C^{op} \to Set</annotation></semantics></math></div>
<p>which maps an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> to the collection of subobjects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, and which maps a morphism (“function”) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> to the “inverse image” function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo>:</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{-1} : Sub(Y) \to Sub(X)</annotation></semantics></math>, that sends a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>:</mo><mi>B</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">j : B \subseteq Y</annotation></semantics></math> to the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f^{-1}(B) \subseteq X</annotation></semantics></math> given by the pullback of the arrows <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>:</mo><mi>B</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex"> j : B \subseteq Y</annotation></semantics></math>. By the <a href="http://topologicalmusings.wordpress.com/2008/07/12/basic-category-theory-iii-representability-adjoints-and-the-yoneda-lemma">Yoneda lemma</a>, this representability means that <em>external</em> natural operations on the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(X)</annotation></semantics></math> correspond to <em>internal</em> operations on the object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math>. As we will see, one can play off the external and internal points of view against each other to build up a considerable amount of logical structure, enough for just about any mathematical purpose.</p>

<ul>
<li><strong>Remark.</strong> A category satisfying just the first three axioms of ETCS, namely existence of finite products, equalizers, and power objects, is called an (elementary) <strong>topos</strong>. Most or perhaps all of this post will use just those axioms, so we are really doing some elementary topos theory. As I was just saying, we can build up a tremendous amount of logic internally within a topos, but there’s a catch: this logic will be in general intuitionistic. One gets classical logic (including law of the excluded middle) if one assumes strong extensionality [where we get the definition of a well-pointed topos]. Topos theory has a somewhat fearsome reputation, unfortunately; I’m hoping these notes will help alleviate some of the sting.</li>
</ul>

<p>To continue this train of thought: by the Yoneda lemma, the representing isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>θ</mi><mo>:</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover><mo>→</mo><mo>∼</mo></mover><mi>Sub</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \theta : \hom(-, P(1)) \stackrel{\sim}{\to} Sub(-)</annotation></semantics></math></div>
<p>is determined by a universal element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>θ</mi> <mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><msub><mn>1</mn> <mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta_{P(1)}(1_{P(1)})</annotation></semantics></math>, <em>i.e.</em>, a subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math>, namely the mono <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t : 1 \to P(1)</annotation></semantics></math>. In that sense, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t : 1 \to P(1)</annotation></semantics></math> plays the role of a <em>universal subset</em>. The Yoneda lemma implies that external natural operations on general posets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(X)</annotation></semantics></math> are completely determined by how they work on the universal subset.</p>

<h3 id="internal_meets">Internal Meets</h3>

<p>To illustrate these ideas, let us consider intersection. Externally, the intersection operation is a natural transformation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mo>∩</mo> <mi>X</mi></msub><mo>:</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>×</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">\cap_X : Sub(X) \times Sub(X) \to Sub(X).</annotation></semantics></math></div>
<p>This corresponds to a natural transformation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(X, P(1)) \times \hom(X, P(1)) \to \hom(X, P(1))</annotation></semantics></math></div>
<p>which (by Yoneda) is given by a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\wedge : P(1) \times P(1) \to P(1)</annotation></semantics></math>. Working through the details, this function is obtained by putting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X = P(1) \times P(1)</annotation></semantics></math> and chasing</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>π</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">⟩</mo><mo>∈</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\langle \pi_1, \pi_2 \rangle \in \hom(P(1) \times P(1), P(1)) \times \hom(P(1) \times P(1), P(1))</annotation></semantics></math></div>
<p>through the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover><mo>→</mo><mo>∼</mo></mover><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>×</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mo>∩</mo></mover><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mo>∼</mo></mover><mi>hom</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">\hom(X, P(1)) \times \hom(X, P(1)) \stackrel{\sim}{\to} Sub(X) \times Sub(X) \stackrel{\cap}{\to} Sub(X) \stackrel{\sim}{\to} \hom(X, P(1)).</annotation></semantics></math></div>
<p>Let’s analyze this bit by bit. The subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><msub><mi>π</mi> <mn>1</mn></msub><mo>]</mo></mrow><mo>=</mo><msubsup><mi>π</mi> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left[\pi_1\right] = \pi_{1}^{-1}(t) \subseteq P(1) \times P(1)</annotation></semantics></math> is given by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>×</mo><mi>id</mi><mo>:</mo><mn>1</mn><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">t \times id : 1 \times P(1) \to P(1) \times P(1),</annotation></semantics></math></div>
<p>and the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><msub><mi>π</mi> <mn>2</mn></msub><mo>]</mo></mrow><mo>=</mo><msubsup><mi>π</mi> <mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left[\pi_2\right] = \pi_{2}^{-1}(t) \subseteq P(1) \times P(1)</annotation></semantics></math> is given by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>id</mi><mo>×</mo><mi>t</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">id \times t : P(1) \times 1 \to P(1) \times P(1).</annotation></semantics></math></div>
<p>Hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><msub><mi>π</mi> <mn>1</mn></msub><mo>]</mo></mrow><mo>∩</mo><mrow><mo>[</mo><msub><mi>π</mi> <mn>2</mn></msub><mo>]</mo></mrow><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left[\pi_1\right] \cap \left[\pi_2\right] \subseteq P(1) \times P(1)</annotation></semantics></math> is given by the pullback of the functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>×</mo><mi>id</mi></mrow><annotation encoding="application/x-tex">t \times id</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>id</mi><mo>×</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">id \times t</annotation></semantics></math>, which is just</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>×</mo><mi>t</mi><mo>:</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">t \times t : 1 \times 1 \to P(1) \times P(1).</annotation></semantics></math></div>
<p>The map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\wedge : P(1) \times P(1) \to P(1)</annotation></semantics></math> is thus defined to be the classifying map of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>×</mo><mi>t</mi><mo>:</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \times t : 1 \times 1 \subseteq P(1) \times P(1)</annotation></semantics></math>.</p>

<p>To go from the internal meet <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\wedge : P(1) \times P(1) \to P(1)</annotation></semantics></math> back to the external intersection operation, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi><mo>,</mo><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X, B \subseteq X</annotation></semantics></math> be two subsets, with classifying maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>,</mo><msub><mi>χ</mi> <mi>B</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_A, \chi_B : X \to P(1)</annotation></semantics></math>. By the definition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>, we have that for all generalized elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"></mspace><mo>∧</mo><mspace width="mediummathspace"></mspace><msub><mi>χ</mi> <mi>B</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mspace width="thickmathspace"></mspace><mtext>if and only if</mtext><mspace width="thickmathspace"></mspace><mo stretchy="false">⟨</mo><msub><mi>χ</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>χ</mi> <mi>B</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo><mo>=</mo><mo stretchy="false">⟨</mo><mi>t</mi><mo>,</mo><mi>t</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\chi_A(x) \:\wedge\: \chi_B(x) = t \;\text{if and only if}\; \langle \chi_A(x), \chi_B(x) \rangle = \langle t, t \rangle</annotation></semantics></math></div>
<p>(where the equality signs are interpreted with the help of equalizers). This holds true iff <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is in the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> and is in the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">B \subseteq X</annotation></semantics></math>, <em>i.e.</em>, if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is in the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \cap B \subseteq X</annotation></semantics></math>. Thus <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>∧</mo><msub><mi>χ</mi> <mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\chi_A \wedge \chi_B</annotation></semantics></math> is indeed the classifying map of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \cap B \subseteq X</annotation></semantics></math>. In other words, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow></msub><mo>=</mo><msub><mi>χ</mi> <mi>A</mi></msub><mo>∧</mo><msub><mi>χ</mi> <mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\chi_{A \cap B} = \chi_A \wedge \chi_B</annotation></semantics></math>.</p>

<p>A by-product of the interplay between the internal and external is that the internal intersection operator</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∧</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\wedge : P(1) \times P(1) \to P(1)</annotation></semantics></math></div>
<p>is the meet operator of an internal <a href="http://topologicalmusings.wordpress.com/2008/04/02/toward-stone-duality-posets-and-meets">meet-semilattice</a> structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math>: it is commutative, associative, and idempotent (because that is true of external intersection). The identity element for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math> is the element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t : 1 \to P(1)</annotation></semantics></math>. In particular, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math> carries an internal poset structure: given generalized elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u, v : A \to P(1)</annotation></semantics></math>, we may define</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>u</mi><mo>≤</mo><mi>v</mi><mspace width="thickmathspace"></mspace><mtext>if and only if</mtext><mspace width="thickmathspace"></mspace><mi>u</mi><mo>=</mo><mi>u</mi><mo>∧</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \leq v \;\text{if and only if}\; u = u \wedge v</annotation></semantics></math></div>
<p>and this defines a reflexive, symmetric, antisymmetric relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mo>≤</mo><mo>]</mo></mrow><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left[\leq\right] \subseteq P(1) \times P(1)</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mo>≤</mo><mo>]</mo></mrow><msub><mo>≔</mo> <mi>i</mi></msub><mo stretchy="false">{</mo><mo stretchy="false">⟨</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false">⟩</mo><mo>∈</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>:</mo><mi>u</mi><mo>=</mo><mi>u</mi><mo>∧</mo><mi>v</mi><mo stretchy="false">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">\left[\leq\right] {\coloneqq}_i \{ \langle u, v \rangle \in P(1) \times P(1) : u = u \wedge v\},</annotation></semantics></math></div>
<p>equivalently described as the equalizer</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mo>≤</mo><mo>]</mo></mrow><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mover><mo>→</mo><mo>→</mo></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\left[\leq\right] \to P(1) \times P(1) \stackrel{\to}{\to} P(1)</annotation></semantics></math></div>
<p>of the maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1 : P(1) \times P(1) \to P(1)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\wedge : P(1) \times P(1) \to P(1)</annotation></semantics></math>. We have that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>u</mi><mo>≤</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \leq v</annotation></semantics></math> if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow><mo>⊆</mo><mrow><mo>[</mo><mi>v</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[u\right] \subseteq \left[v\right]</annotation></semantics></math>.</p>

<h3 id="internal_implication">Internal Implication</h3>

<p>Here we begin to see some of the amazing power of the interplay between internal and external logical operations. We will prove that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math> carries an internal Heyting algebra structure (ignoring joins for the time being).</p>

<p>Let’s recall the notion of <a href="http://topologicalmusings.wordpress.com/2008/04/08/distributivity-topology-and-heyting-algebras">Heyting algebra</a> in ordinary naive set-theoretic terms: it’s a lattice <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> that has a material implication operator “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math>” such that, for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">x, y, z \in P</annotation></semantics></math>,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∧</mo><mi>y</mi><mo>≤</mo><mi>z</mi><mspace width="thickmathspace"></mspace><mtext>if and only if</mtext><mspace width="thickmathspace"></mspace><mi>x</mi><mo>≤</mo><mi>y</mi><mo>⇒</mo><mi>z</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">x \wedge y \leq z \;\text{if and only if}\; x \leq y \Rightarrow z.</annotation></semantics></math></div>
<p>Now: by the universal property of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math>, a putative implication operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⇒</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Rightarrow : P(1) \times P(1) \to P(1)</annotation></semantics></math> is uniquely determined as the classifying map of its inverse image <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo>⇒</mo><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Rightarrow)^{-1}(t) \subseteq P(1) \times P(1)</annotation></semantics></math>, whose collection of generalized elements is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">⟨</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false">⟩</mo><mo>∈</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mi>u</mi><mo>⇒</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ \langle u, v \rangle \in P(1) \times P(1) : (u \Rightarrow v) = t\}</annotation></semantics></math></div>
<p>Given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy="false">⟩</mo><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\langle u, v \rangle : A \to P(1) \times P(1)</annotation></semantics></math>, the equality here is equivalent to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>≤</mo><mi>u</mi><mo>⇒</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">t \leq u \Rightarrow v</annotation></semantics></math></div>
<p>(because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t : 1 \to P(1)</annotation></semantics></math> is maximal), which in turn is equivalent to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∧</mo><mi>u</mi><mo>=</mo><mi>u</mi><mo>≤</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">t \wedge u = u \leq v</annotation></semantics></math></div>
<p>This means we should define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⇒</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Rightarrow : P(1) \times P(1) \to P(1)</annotation></semantics></math> to be the classifying map of the subset</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mo>≤</mo><mo>]</mo></mrow><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">\left[\leq\right] \subseteq P(1) \times P(1).</annotation></semantics></math></div>
<p><strong>Theorem 1.</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math> admits internal implication.</p>

<p><strong>Proof.</strong> We must check that for any three generalized elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u, v, w : A \to P(1)</annotation></semantics></math>, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo>≤</mo><mi>u</mi><mo>⇒</mo><mi>v</mi><mspace width="thickmathspace"></mspace><mtext>if and only if</mtext><mspace width="thickmathspace"></mspace><mi>w</mi><mo>∧</mo><mi>u</mi><mo>≤</mo><mi>v</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">w \leq u \Rightarrow v \;\text{if and only if}\; w \wedge u \leq v.</annotation></semantics></math></div>
<p>Passing to the external picture, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow><mo>,</mo><mrow><mo>[</mo><mi>v</mi><mo>]</mo></mrow><mo>,</mo><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[u\right], \left[v\right], \left[w\right]</annotation></semantics></math> be the corresponding subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. Now: according to how we defined <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⇒</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">\Rightarrow,</annotation></semantics></math> a generalized element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">e \in A</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>u</mi><mo>⇒</mo><mi>v</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[u \Rightarrow v\right]</annotation></semantics></math> if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>u</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>v</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u(e) \leq v(e)</annotation></semantics></math>. This applies in particular to any monomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>:</mo><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">e: \left[w\right] \to A</annotation></semantics></math> that represents the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex"> \left[w\right] \subseteq A</annotation></semantics></math>.</p>

<p><strong>Lemma 2.</strong> The composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>u</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mover><mo>→</mo><mi>e</mi></mover><mi>A</mi><mover><mo>→</mo><mi>u</mi></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle u(e) = (\left[w\right] \stackrel{e}{\to} A \stackrel{u}{\to} P(1))</annotation></semantics></math></div>
<p>is the classifying map of the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>∩</mo><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow><mo>⊆</mo><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[w\right] \cap \left[u\right] \subseteq \left[w\right]</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> As subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[w\right]</annotation></semantics></math>,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mi>e</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><msup><mi>u</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>∩</mo><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">(u e)^{-1}(t) = e^{-1} u^{-1}(t) = e^{-1}(\left[u\right]) = \left[w\right] \cap \left[u\right]</annotation></semantics></math></div>
<p>where the last equation holds because both sides are the subsets defined as the pullback of two representative monos <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>:</mo><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">e : \left[w\right] \to A</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">i : \left[u\right] \to A</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>Continuing the proof of Theorem 1, we see by Lemma 2 that the condition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>u</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>v</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u(e) \leq v(e)</annotation></semantics></math> corresponds externally to the condition</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>∩</mo><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow><mo>⊆</mo><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>∩</mo><mrow><mo>[</mo><mi>v</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[w\right] \cap \left[u\right] \subseteq \left[w\right] \cap \left[v\right]</annotation></semantics></math></div>
<p>and this condition is equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>w</mi><mo>]</mo></mrow><mo>∩</mo><mrow><mo>[</mo><mi>u</mi><mo>]</mo></mrow><mo>⊆</mo><mrow><mo>[</mo><mi>v</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[w\right] \cap \left[u\right] \subseteq \left[v\right]</annotation></semantics></math>.</p>

<p>Passing back to the internal picture, this is equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo>∧</mo><mi>u</mi><mo>≤</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">w \wedge u \leq v</annotation></semantics></math>, and the proof of Theorem 1 is complete. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<h3 id="cartesian_closed_structure">Cartesian Closed Structure</h3>

<p>Next we address a <a href="http://topologicalmusings.wordpress.com/2008/09/01/zfc-and-etcs-elementary-theory-of-the-category-of-sets/#comment-469">comment</a> made by “James”, that a category satisfying the ETCS axioms is <a href="http://topologicalmusings.wordpress.com/2008/06/29/basic-category-theory-ii">cartesian closed</a>. As everything else in this article, this uses only the fact that such a category is a topos: has finite products, equalizers, and “power sets”.</p>

<p><strong>Proposition 1.</strong> If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B</annotation></semantics></math> are “sets”, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A \times B)</annotation></semantics></math> represents an exponential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>.</mo></mrow><annotation encoding="application/x-tex">P(B)^A.</annotation></semantics></math></p>

<p><strong>Proof.</strong> By the power set axiom, there is a bijection between maps into the power set and relations:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mfrac><mrow><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{\phi : X \to P(A \times B)}{R \subseteq X \times (A \times B)}</annotation></semantics></math></div>
<p>which is natural in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. By the same token, there is a natural bijection</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mfrac><mrow><mi>R</mi><mo>⊆</mo><mo stretchy="false">(</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo stretchy="false">)</mo><mo>×</mo><mi>B</mi></mrow><mrow><mi>ϕ</mi><mo>′</mo><mo>:</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>.</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \frac{R \subseteq (X \times A) \times B}{\phi' : X \times A \to P(B)}.</annotation></semantics></math></div>
<p>Putting these together, we have a natural isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>×</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(-, P(A \times B)) \cong \hom(- \times A, P(B))</annotation></semantics></math></p>

<p>and this representability means precisely that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A \times B)</annotation></semantics></math> plays the role of an exponential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">P(B)^A</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Corollary 1.</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">P(A) \cong P(1)^A</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>The <a href="http://topologicalmusings.wordpress.com/2008/07/12/basic-category-theory-iii-representability-adjoints-and-the-yoneda-lemma/">universal element</a> of this representation is an evaluation map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \times P(A) \to P(1)</annotation></semantics></math>, which is just the classifying map of the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mi>A</mi></msub><mo>⊆</mo><mi>A</mi><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\in_A \subseteq A \times P(A)</annotation></semantics></math>.</p>

<p>Thus, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>≅</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B)^A \cong P(A \times B)</annotation></semantics></math> represents the set of all functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : A \to P(B)</annotation></semantics></math> (that is, relations from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex"> B</annotation></semantics></math>). This is all we need to continue the discussion of internal logic in this post, but let’s also sketch how we get full cartesian closure. [Warning: for those who are not comfortable with categorical reasoning, this sketch could be rough going in places.]</p>

<p>As per <a href="http://topologicalmusings.wordpress.com/2008/09/01/zfc-and-etcs-elementary-theory-of-the-category-of-sets/#comment-469">our</a> <a href="http://topologicalmusings.wordpress.com/2008/09/01/zfc-and-etcs-elementary-theory-of-the-category-of-sets/#comment-470">discussion</a>, we want to internalize the set of such relations which are graphs of functions, <em>i.e.</em>, maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> where each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\phi(a) \subseteq B</annotation></semantics></math> is a singleton, in other words which factor as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>A</mi><mo>→</mo><mi>B</mi><mover><mo>→</mo><mi>σ</mi></mover><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle A \to B \stackrel{\sigma}{\to} P(B)</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma : B \to P(B)</annotation></semantics></math> is the singleton mapping:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo>↦</mo><mo stretchy="false">{</mo><mi>b</mi><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mi>c</mi><mo>∈</mo><mi>B</mi><mo>:</mo><mi>b</mi><mo>=</mo><mi>c</mi><mo stretchy="false">}</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">b \mapsto \{ b \} = \{ c \in B: b = c \}.</annotation></semantics></math></div>
<p>We see from this set-theoretic description that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma : B \to P(B)</annotation></semantics></math> classifies the equality relation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">⟨</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">⟩</mo><mo>∈</mo><mi>B</mi><mo>×</mo><mi>B</mi><mo>:</mo><mi>b</mi><mo>=</mo><mi>c</mi><mo stretchy="false">}</mo><mo>⊆</mo><mi>B</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\{ \langle b, c \rangle \in B \times B: b = c \} \subseteq B \times B</annotation></semantics></math></div>
<p>which we can think of as either the equalizer of the pair of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>π</mi> <mn>2</mn></msub><mo>:</mo><mi>B</mi><mo>×</mo><mi>B</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\pi_1, \pi_2 : B \times B \to B</annotation></semantics></math> or, what is the same, the diagonal map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>δ</mi> <mi>B</mi></msub><mo>=</mo><mo stretchy="false">⟨</mo><msub><mn>1</mn> <mi>B</mi></msub><mo>,</mo><msub><mn>1</mn> <mi>B</mi></msub><mo stretchy="false">⟩</mo><mo>:</mo><mi>B</mi><mo>→</mo><mi>B</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\delta_B = \langle 1_B, 1_B \rangle : B \to B \times B</annotation></semantics></math>.</p>

<p>Thus, we put <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>=</mo><msub><mi>χ</mi> <mi>δ</mi></msub><mo>:</mo><mi>B</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma = \chi_{\delta} : B \to P(B)</annotation></semantics></math>, and it is not too hard to show that the singleton mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is a monomorphism. As usual, we get this monomorphism as the pullback <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>χ</mi> <mi>σ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_{\sigma}^{-1}(t)</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t : 1 \to P(1)</annotation></semantics></math> along <em>its</em> classifying map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>σ</mi></msub><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_{\sigma} : P(B) \to P(1)</annotation></semantics></math>.</p>

<p>Now: a right adjoint such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex"> (-)^A</annotation></semantics></math> preserves all limits, and in particular pullbacks, so we ought then to have a pullback</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msup><mi>B</mi> <mpadded width="0"><mi>A</mi></mpadded></msup></mtd> <mtd><mo>⟶</mo></mtd> <mtd><msup><mn>1</mn> <mpadded width="0"><mi>A</mi></mpadded></msup></mtd></mtr> <mtr><mtd><mpadded width="0" lspace="-100%width"><mstyle scriptlevel="1"><mrow><msup><mi>σ</mi> <mi>A</mi></msup></mrow></mstyle></mpadded><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><mpadded width="0"><mstyle scriptlevel="1"><mrow><msup><mi>t</mi> <mo lspace="0em" rspace="thinmathspace">A</mo></msup></mrow></mstyle></mpadded></mtd></mtr> <mtr><mtd><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><msup><mo stretchy="false">)</mo> <mpadded width="0"><mi>A</mi></mpadded></msup></mtd> <mtd><munder><mo>⟶</mo><mrow><msubsup><mi>χ</mi> <mi>σ</mi> <mi>A</mi></msubsup></mrow></munder></mtd> <mtd><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mpadded width="0"><mi>A</mi></mpadded></msup></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\begin{matrix}
  B^{\mathrlap{A}} &amp; \longrightarrow &amp; 1^{\mathrlap{A}} \\
  \mathllap{\scriptsize{\sigma^A}}\downarrow &amp; &amp; \downarrow\mathrlap{\scriptsize{t^\A}} \\
  P(B)^{\mathrlap{A}} &amp; \underset{\chi_\sigma^A}{\longrightarrow} &amp; P(1)^{\mathrlap{A}}
 \end{matrix}

</annotation></semantics></math></div>
<p>Of course, we don’t even have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>B</mi> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">B^A</annotation></semantics></math> yet, but this should give us an idea: <em>define</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>σ</mi> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">\sigma^A</annotation></semantics></math>, and in particular its domain <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>B</mi> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">B^A</annotation></semantics></math>, by taking the pullback of the right-hand map along the bottom map. In case there is doubt, the map on the bottom is defined Yoneda-wise, applying the isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>×</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(P(B)^A \times A, P(1)) \cong \hom(P(B)^A, P(1)^A)</annotation></semantics></math></div>
<p>to the element in the hom-set (on the left) given by the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>×</mo><mi>A</mi><mover><mo>→</mo><mi>ev</mi></mover><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msub><mi>χ</mi> <mi>σ</mi></msub></mrow></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle P(B)^A \times A \stackrel{ev}{\to} P(B) \stackrel{\chi_\sigma}{\to} P(1).</annotation></semantics></math></div>
<p>The map on the right of the pullback is defined similarly. That this recipe really gives a construction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>B</mi> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">B^A</annotation></semantics></math> will be left as an exercise for the reader.</p>

<h3 id="universal_quantification">Universal Quantification</h3>

<p>As further evidence of the power of the internal-external dialectic, we show how to internalize <a class="existingWikiWord" href="/nlab/show/universal+quantification">universal quantification</a>.</p>

<p>As we are dealing here now with <em>predicate</em> logic, let’s begin by defining some terms as to be used in ETCS and topos theory:</p>

<ul>
<li>
<p>An <em>ordinary predicate</em> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : A \to P(1)</annotation></semantics></math>. Alternatively, it is an ordinary element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>′</mo><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>≅</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi' : 1 \to P(1)^A \cong P(A)</annotation></semantics></math>. It corresponds (naturally and bijectively) to a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>ϕ</mi><mo>]</mo></mrow><mo>:</mo><mi>S</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\left[\phi\right]: S \subseteq A</annotation></semantics></math>.</p>
</li>

<li>
<p>A <em>generalized predicate</em> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>′</mo><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">\phi' : X \to P(A) \cong P(1)^A</annotation></semantics></math>. It may be identified with (corresponds naturally and bijectively to) a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : X \times A \to P(1)</annotation></semantics></math>, or to a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>ϕ</mi><mo>]</mo></mrow><mo>:</mo><mi>S</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\left[\phi\right] : S \subseteq X \times A</annotation></semantics></math>.</p>
</li>
</ul>

<p>We are trying to define an operator <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>A</mi></msub></mrow><annotation encoding="application/x-tex">\forall_A</annotation></semantics></math> which will take a predicate of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : X \times A \to P(1)</annotation></semantics></math> [conventionally written ] to a predicate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>A</mi></msub><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_A \phi : X \to P(1)</annotation></semantics></math> [conventionally written ]. Externally, this corresponds to a natural operation which takes subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \times A</annotation></semantics></math> to subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. <em>Internally</em>, it corresponds to an operation of the form:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>A</mi></msub><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">\forall_A : P(A) \cong P(1)^A \to P(1).</annotation></semantics></math></div>
<p>This function is determined by the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mo>∀</mo> <mi>A</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">(\forall_A)^{-1}(t) \subseteq P(1)^A</annotation></semantics></math>, defined elementwise by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>ϕ</mi><mo>∈</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>:</mo><msub><mo>∀</mo> <mi>A</mi></msub><mi>ϕ</mi><mo>=</mo><mi>t</mi><mo stretchy="false">}</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">\{ \phi \in P(1)^A : \forall_A \phi = t\}.</annotation></semantics></math></div>
<p>Now, in ordinary logic, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow></msub><mi>ϕ</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_{a \in A} \phi(a)</annotation></semantics></math> is true if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(a)</annotation></semantics></math> is true for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>, or, in slightly different words, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : A \to P(1)</annotation></semantics></math> is constantly true over all of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>ϕ</mi><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mover><mo>→</mo><mo>!</mo></mover><mn>1</mn><mover><mo>→</mo><mi>t</mi></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \phi = (A \stackrel{!}{\to} 1 \stackrel{t}{\to} P(1)).</annotation></semantics></math></div>
<p>The expression on the right (global truth over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>) corresponds to a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mi>A</mi></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">t_A : 1 \to P(1)^A</annotation></semantics></math>, indeed a monomorphism since any function with domain <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> is monic. Thus we are led to define the desired quantification operator <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>A</mi></msub><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_A : P(1)^A \to P(1)</annotation></semantics></math> as the classifying map of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mi>A</mi></msub><mo>:</mo><mn>1</mn><mo>⊆</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">t_A : 1 \subseteq P(1)^A</annotation></semantics></math>.</p>

<p>Let’s check how this works externally. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">\phi : X \to P(1)^A</annotation></semantics></math> be a generalized predicate of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. Then according to how <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>A</mi></msub></mrow><annotation encoding="application/x-tex">\forall_A</annotation></semantics></math> has just been defined, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>A</mi></msub><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_A \phi : X \to P(1)</annotation></semantics></math> classifies the subset</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>t</mi> <mi>A</mi></msub><mo>:</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo>⊆</mo><mi>X</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \{ x \in X: \phi(x, -) = t_A : A \to P(1)) \} \subseteq X</annotation></semantics></math></div>
<p>There is an interesting adjoint relationship between universal quantification and substitution (aka “pulling back”). By “substitution”, we mean that given any predicate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ψ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\psi : X \to P(1)</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, we can always pull back to a predicate on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \times A</annotation></semantics></math> (substituting in a dummy variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, forming <em>e.g.</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∧</mo><mrow><mo>[</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\psi(x) \wedge \left[a=a\right]</annotation></semantics></math>) by composing with the projection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\pi : X \times A \to X</annotation></semantics></math>. In terms of subsets, substitution along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is the natural external operation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mrow><mo>[</mo><mi>ψ</mi><mo>]</mo></mrow><mo>⊆</mo><mi>X</mi><mo stretchy="false">)</mo><mo>↦</mo><mo stretchy="false">(</mo><mrow><mo>[</mo><mi>ψ</mi><mo>]</mo></mrow><mo>×</mo><mi>A</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">(\left[\psi\right] \subseteq X) \mapsto (\left[\psi\right]\times A \subseteq X \times A).</annotation></semantics></math></div>
<p>Then, for any predicate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi : X \times A \to P(1)</annotation></semantics></math>, we have the adjoint relationship</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>ψ</mi><mo>]</mo></mrow><mo>×</mo><mi>A</mi><mo>⊆</mo><mi>ϕ</mi><mspace width="thickmathspace"></mspace><mtext>if and only if</mtext><mspace width="thickmathspace"></mspace><mrow><mo>[</mo><mi>ψ</mi><mo>]</mo></mrow><mo>⊆</mo><msub><mo>∀</mo> <mi>A</mi></msub><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\left[\psi\right] \times A \subseteq \phi \;\text{if and only if}\; \left[\psi\right] \subseteq \forall_A \phi</annotation></semantics></math></div>
<p>so that substitution along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is left adjoint to universal quantification along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. This is easy to check; I’ll leave that to the reader.</p>

<h3 id="internal_intersection_operators">Internal Intersection Operators</h3>

<p>Now we put all of the above together, to define an internal intersection operator</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mo>:</mo><mi>PPX</mi><mo>→</mo><mi>PX</mi></mrow><annotation encoding="application/x-tex">\bigcap : PPX \to PX</annotation></semantics></math></div>
<p>which intuitively takes an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>PPX</mi></mrow><annotation encoding="application/x-tex">1 \to PPX</annotation></semantics></math> (a family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> of subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>) to its intersection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>PX</mi></mrow><annotation encoding="application/x-tex">1 \to PX</annotation></semantics></math>, as a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mi>F</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\bigcap F \subseteq X</annotation></semantics></math>.</p>

<p>Let’s first write out a logical formula which expresses intersection:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mi>F</mi><mspace width="thickmathspace"></mspace><mtext>if and only if</mtext><mspace width="thickmathspace"></mspace><msub><mo>∀</mo> <mrow><mi>S</mi><mo>∈</mo><mi>PX</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo>∈</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">x \in \bigcap F \;\text{if and only if}\; \forall_{S \in PX} (S \in F) \Rightarrow (x \in S).</annotation></semantics></math></div>
<p>We have all the ingredients to deal with the logical formula on the right: we have an implication operator “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math>” as part of the internal Heyting algebra structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(1)</annotation></semantics></math>, and we have the quantification operator “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>PX</mi></msub></mrow><annotation encoding="application/x-tex">\forall_{PX}</annotation></semantics></math>”. The atomic expressions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mo>∈</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S \in F)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x \in S)</annotation></semantics></math> refer to internal elementhood: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x \in S)</annotation></semantics></math> means <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>x</mi><mo>,</mo><mi>S</mi><mo stretchy="false">⟩</mo><mo>∈</mo><mi>X</mi><mo>×</mo><mi>PX</mi></mrow><annotation encoding="application/x-tex">\langle x, S \rangle \in X \times PX</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mi>X</mi></msub><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>PX</mi></mrow><annotation encoding="application/x-tex">\in_{X} \subseteq X \times PX</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mo>∈</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S \in F)</annotation></semantics></math> means <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>S</mi><mo>,</mo><mi>F</mi><mo stretchy="false">⟩</mo><mo>∈</mo><mi>PX</mi><mo>×</mo><mi>PPX</mi></mrow><annotation encoding="application/x-tex">\langle S, F \rangle \in PX \times PPX</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∈</mo> <mi>PX</mi></msub><mo>⊆</mo><mi>PX</mi><mo>×</mo><mi>PPX</mi></mrow><annotation encoding="application/x-tex">\in_{PX} \subseteq PX \times PPX</annotation></semantics></math>.</p>

<p>There is a slight catch, in that the predicates “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><msub><mo>∈</mo> <mi>PX</mi></msub><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S \in_{PX} F)</annotation></semantics></math>” and “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x \in_X S)</annotation></semantics></math>” (as generalized predicates over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PX</mi></mrow><annotation encoding="application/x-tex">PX</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> lives) are taken over different domains. The first is of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mo>:</mo><mi>PPX</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup></mrow><annotation encoding="application/x-tex">\phi_1 : PPX \to P(1)^{PX}</annotation></semantics></math>, and the second is of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>2</mn></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup></mrow><annotation encoding="application/x-tex">\phi_2 : X \to P(1)^{PX}</annotation></semantics></math>. No matter: we just substitute in some dummy variables. That is, we just pull these maps back to a common domain <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PPX</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">PPX \times X</annotation></semantics></math>, forming the composites</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><msub><mi>ψ</mi> <mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>PPX</mi><mo>×</mo><mi>X</mi><mover><mo>→</mo><mrow><msub><mi>π</mi> <mn>1</mn></msub></mrow></mover><mi>PPX</mi><mover><mo>→</mo><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub></mrow></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \psi_1 = (PPX \times X \stackrel{\pi_1}{\to} PPX \stackrel{\phi_1}{\to} P(1)^{PX})</annotation></semantics></math></div>
<p>and</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><msub><mi>ψ</mi> <mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>PPX</mi><mo>×</mo><mi>X</mi><mover><mo>→</mo><mrow><msub><mi>π</mi> <mn>2</mn></msub></mrow></mover><mi>X</mi><mover><mo>→</mo><mrow><msub><mi>ϕ</mi> <mn>2</mn></msub></mrow></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup><mo stretchy="false">)</mo><mo>.</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \psi_2 = (PPX \times X \stackrel{\pi_2}{\to} X \stackrel{\phi_2}{\to} P(1)^{PX}).</annotation></semantics></math></div>
<p>Putting all this together, we form the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>PPX</mi><mo>×</mo><mi>X</mi><mover><mo>→</mo><mrow><mo stretchy="false">⟨</mo><msub><mi>ψ</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>ψ</mi> <mn>2</mn></msub><mo stretchy="false">⟩</mo></mrow></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle PPX \times X \stackrel{\langle \psi_1, \psi_2 \rangle}{\to} P(1)^{PX} \times P(1)^{PX}</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mo>≅</mo><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup><mover><mo>→</mo><mrow><mo stretchy="false">(</mo><mo>⇒</mo><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup></mrow></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>PX</mi></msup><mover><mo>→</mo><mrow><msub><mo>∀</mo> <mi>PX</mi></msub></mrow></mover><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \cong (P(1) \times P(1))^{PX} \stackrel{(\Rightarrow)^{PX}}{\to} P(1)^{PX} \stackrel{\forall_{PX}}{\to} P(1)</annotation></semantics></math></div>
<p>This composite directly expresses the definition of the internal predicate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x \in \bigcap F)</annotation></semantics></math> given above. By cartesian closure, this map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PPX</mi><mo>×</mo><mi>X</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PPX \times X \to P(1)</annotation></semantics></math> induces the desired internal intersection operator, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mo>:</mo><mi>PPX</mi><mo>→</mo><mi>PX</mi></mrow><annotation encoding="application/x-tex">\bigcap : PPX \to PX</annotation></semantics></math>.</p>

<p>This construction provides an important bridge to getting the rest of the internal logic of ETCS. Since we can can construct the intersection of arbitrary definable families of subsets, the power sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PX</mi></mrow><annotation encoding="application/x-tex">PX</annotation></semantics></math> are internal inf-lattices. But <a href="http://topologicalmusings.wordpress.com/2008/04/04/lattices-and-duality">inf-lattices are sup-lattices</a> as well; on this basis we will be able to construct the colimits ( <em>e.g.</em>, finite sums, coequalizers) that we need. Similarly, the intersection operators easily allow us to construct image factorizations: any function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> can be factored (in an essentially unique way) as an epi or surjection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">X \to I</annotation></semantics></math> to the image, followed by a mono or injection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">I \to Y</annotation></semantics></math>. The trick is to define the image as the smallest subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> through which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> factors, by taking the intersection of all such subsets. Image factorization leads in turn to the construction of <a class="existingWikiWord" href="/nlab/show/existential+quantification">existential quantification</a>.</p>

<p>As remarked above, the internal logic of a topos is generally intuitionistic (the law of excluded middle is not satisfied). But, if we add in the axiom of strong extensionality of ETCS, then we’re back to ordinary classical logic, where the law of excluded middle is satisfied, and where we just have the two truth values “true” and “false”. This means we will be able to reason in ETCS set theory just as we do in ordinary mathematics, taking just a bit of care with how we treat membership. The foregoing discussion gives indication that logical operations in categorical set theory work in ways familiar from naive set theory, and that basic set-theoretic constructions like intersection are well-grounded in ETCS.</p>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on November  2, 2019 at 19:55:14.
    See the <a href="/nlab/history/Trimble+on+ETCS+II" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/Trimble+on+ETCS+II" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/10490/#Item_1">Discuss</a><span class="backintime"><a href="/nlab/revision/Trimble+on+ETCS+II/14" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/Trimble+on+ETCS+II" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/Trimble+on+ETCS+II" accesskey="S" class="navlink" id="history" rel="nofollow">History (14 revisions)</a>
  <a href="/nlab/show/Trimble+on+ETCS+II/cite" style="color: black">Cite</a>
  <a href="/nlab/print/Trimble+on+ETCS+II" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/Trimble+on+ETCS+II" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
