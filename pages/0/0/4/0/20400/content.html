
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      CompLF in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      CompLF
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/9916/#Item_47" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="type_theory">Type theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></strong> <a class="existingWikiWord" href="/nlab/show/metalanguage">metalanguage</a>, <a class="existingWikiWord" href="/nlab/show/practical+foundations">practical foundations</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/judgement">judgement</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hypothetical+judgement">hypothetical judgement</a>, <a class="existingWikiWord" href="/nlab/show/sequent">sequent</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/antecedents">antecedents</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/consequent">consequent</a>, <a class="existingWikiWord" href="/nlab/show/succedents">succedents</a></li>
</ul>
</li>
</ul>

<ol>
<li><a class="existingWikiWord" href="/nlab/show/type+formation+rule">type formation rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+introduction+rule">term introduction rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+elimination+rule">term elimination rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/computation+rule">computation rule</a></li>
</ol>

<p><strong><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></strong> (<a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent</a>, <a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional</a>, <a class="existingWikiWord" href="/nlab/show/observational+type+theory">observational type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>)</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a></li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/syntax">syntax</a></strong> <a class="existingWikiWord" href="/nlab/show/object+language">object language</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/theory">theory</a>, <a class="existingWikiWord" href="/nlab/show/axiom">axiom</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>/<a class="existingWikiWord" href="/nlab/show/type">type</a> (<a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/definition">definition</a>/<a class="existingWikiWord" href="/nlab/show/proof">proof</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a> (<a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/theorem">theorem</a></p>
</li>
</ul>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></strong> = <br /> <strong><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/programs+as+proofs">programs as proofs</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation type theory/category theory</a></strong></p>

<table><thead><tr><th><a class="existingWikiWord" href="/nlab/show/logic">logic</a></th><th><a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a> (<a class="existingWikiWord" href="/nlab/show/internal+logic+of+set+theory">internal logic</a> of)</th><th><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></th><th><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></th></tr></thead><tbody><tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object">object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type">type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/predicate">predicate</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/family+of+sets">family of sets</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/display+morphism">display morphism</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+type">dependent type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof">proof</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/element">element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/term">term</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+rule">cut rule</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/composition">composition</a> of <a class="existingWikiWord" href="/nlab/show/classifying+morphisms">classifying morphisms</a> / <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of <a class="existingWikiWord" href="/nlab/show/display+maps">display maps</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/substitution">substitution</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+elimination">cut elimination</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/counit">counit</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/beta+reduction">beta reduction</a></td></tr>
<tr><td style="text-align: left;">introduction rule for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/unit">unit</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/eta+conversion">eta conversion</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/true">true</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/singleton">singleton</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-2%29-truncated+object">(-2)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+0">h-level 0</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/unit+type">unit type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/false">false</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+set">empty set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>, <a class="existingWikiWord" href="/nlab/show/truth+value">truth value</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subterminal+object">subterminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncated+object">(-1)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-proposition">h-proposition</a>, <a class="existingWikiWord" href="/nlab/show/mere+proposition">mere proposition</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+conjunction">logical conjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cartesian+product">cartesian product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product">product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product+type">product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjunction">disjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjoint+union">disjoint union</a> (<a class="existingWikiWord" href="/nlab/show/support">support</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/sum+type">sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+set">function set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/negation">negation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+set">function set</a> into <a class="existingWikiWord" href="/nlab/show/empty+set">empty set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a> into <a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a> into <a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universal+quantification">universal quantification</a></td><td style="text-align: left;">indexed <a class="existingWikiWord" href="/nlab/show/cartesian+product">cartesian product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product+type">dependent product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/existential+quantification">existential quantification</a></td><td style="text-align: left;">indexed <a class="existingWikiWord" href="/nlab/show/disjoint+union">disjoint union</a> (<a class="existingWikiWord" href="/nlab/show/support">support</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+equivalence">logical equivalence</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/bijection">bijection</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/isomorphism">isomorphism</a>/<a class="existingWikiWord" href="/nlab/show/adjoint+equivalence">adjoint equivalence</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+of+types">equivalence of types</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/support+set">support set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/support+object">support object</a>/<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/propositional+truncation">propositional truncation</a>/<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/n-image">n-image</a> of <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a> into <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/n-truncation">n-truncation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/n-truncation+modality">n-truncation modality</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equality">equality</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/diagonal+function">diagonal function</a>/<a class="existingWikiWord" href="/nlab/show/diagonal+subset">diagonal subset</a>/<a class="existingWikiWord" href="/nlab/show/diagonal+relation">diagonal relation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/path+space+object">path space object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/identity+type">identity type</a>/<a class="existingWikiWord" href="/nlab/show/path+type">path type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/completely+presented+set">completely presented set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/discrete+object">discrete object</a>/<a class="existingWikiWord" href="/nlab/show/0-truncated+object">0-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+2">h-level 2</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/set">set</a>/<a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a> with <a class="existingWikiWord" href="/nlab/show/equivalence+relation">equivalence relation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/groupoid+object+in+an+%28infinity%2C1%29-category">internal 0-groupoid</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>/<a class="existingWikiWord" href="/nlab/show/setoid">setoid</a> with its <a class="existingWikiWord" href="/nlab/show/pseudo-equivalence+relation">pseudo-equivalence relation</a> an actual <a class="existingWikiWord" href="/nlab/show/equivalence+relation">equivalence relation</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+class">equivalence class</a>/<a class="existingWikiWord" href="/nlab/show/quotient+set">quotient set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient">quotient</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+type">quotient type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/W-type">W-type</a>, <a class="existingWikiWord" href="/nlab/show/M-type">M-type</a></td></tr>
<tr><td style="text-align: left;">higher <a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></td></tr>
<tr><td style="text-align: left;">-</td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/0-truncated">0-truncated</a> <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+inductive+type">quotient inductive type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinduction">coinduction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/limit">limit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinductive+type">coinductive type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/preset">preset</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type">type</a> without <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a> of <a class="existingWikiWord" href="/nlab/show/truth+values">truth values</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+of+propositions">type of propositions</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+of+discourse">domain of discourse</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universe">universe</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+universe">type universe</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modality">modality</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/closure+operator">closure operator</a>, (<a class="existingWikiWord" href="/nlab/show/idempotent+monad">idempotent</a>) <a class="existingWikiWord" href="/nlab/show/monad">monad</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modal+type+theory">modal type theory</a>, <a class="existingWikiWord" href="/nlab/show/monad+%28in+computer+science%29">monad (in computer science)</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+logic">linear logic</a></td><td style="text-align: left;"></td><td style="text-align: left;">(<a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric</a>, <a class="existingWikiWord" href="/nlab/show/closed+monoidal+category">closed</a>) <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal category</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+type+theory">linear type theory</a>/<a class="existingWikiWord" href="/nlab/show/quantum+computation">quantum computation</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof+net">proof net</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/string+diagram">string diagram</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quantum+circuit">quantum circuit</a></td></tr>
<tr><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/contraction+rule">contraction rule</a></td><td style="text-align: left;"></td><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/diagonal">diagonal</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/no-cloning+theorem">no-cloning theorem</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/synthetic+mathematics">synthetic mathematics</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+specific+embedded+programming+language">domain specific embedded programming language</a></td></tr>
</tbody></table>

</div>
<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+levels">homotopy levels</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-type+theory">2-type theory</a>, <a class="existingWikiWord" href="/michaelshulman/show/2-categorical+logic">2-categorical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory+-+contents">homotopy type theory - contents</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/univalence">univalence</a>, <a class="existingWikiWord" href="/nlab/show/function+extensionality">function extensionality</a>, <a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+type+theory">cohesive homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/directed+homotopy+type+theory">directed homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/HoTT+methods+for+homotopy+theorists">HoTT methods for homotopy theorists</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/semantics">semantics</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>, <a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/display+map">display map</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+a+topos">internal logic of a topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Mitchell-Benabou+language">Mitchell-Benabou language</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kripke-Joyal+semantics">Kripke-Joyal semantics</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type-theoretic+model+category">type-theoretic model category</a></li>
</ul>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/type+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>

<h4 id="constructivism_realizability_computability">Constructivism, Realizability, Computability</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a></strong>, <strong><a class="existingWikiWord" href="/nlab/show/realizability">realizability</a></strong>, <strong><a class="existingWikiWord" href="/nlab/show/computability">computability</a></strong></p>

<p><a class="existingWikiWord" href="/nlab/show/intuitionistic+mathematics">intuitionistic mathematics</a></p>

<p><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>, <a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>, <a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></p>

<h3 id="constructive_mathematics">Constructive mathematics</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/topos">topos</a>, <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-topos">homotopy topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+form">canonical form</a>, <a class="existingWikiWord" href="/nlab/show/univalence">univalence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>, <a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/decidable+equality">decidable equality</a>, <a class="existingWikiWord" href="/nlab/show/decidable+subset">decidable subset</a>, <a class="existingWikiWord" href="/nlab/show/inhabited+set">inhabited set</a>, <a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a></p>
</li>
</ul>

<h3 id="realizability">Realizability</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+topos">realizability topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+model">realizability model</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+interpretation">realizability interpretation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/effective+topos">effective topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kleene%27s+first+algebra">Kleene's first algebra</a>, <a class="existingWikiWord" href="/nlab/show/Kleene%27s+second+algebra">Kleene's second algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/function+realizability">function realizability</a></p>
</li>
</ul>

<h3 id="computability">Computability</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/computability">computability</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computation">computation</a>, <a class="existingWikiWord" href="/nlab/show/computational+type+theory">computational type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+function">computable function</a>, <a class="existingWikiWord" href="/nlab/show/partial+recursive+function">partial recursive function</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+analysis">computable analysis</a>, <a class="existingWikiWord" href="/nlab/show/constructive+analysis">constructive analysis</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Type+Two+Theory+of+Effectivity">Type Two Theory of Effectivity</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+function+%28analysis%29">computable function (analysis)</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/exact+real+computer+arithmetic">exact real computer arithmetic</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+set">computable set</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/persistent+homology">persistent homology</a>, <a class="existingWikiWord" href="/nlab/show/effective+homology">effective homology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+physics">computable physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Church-Turing+thesis">Church-Turing thesis</a></p>
</li>
</ul>
</div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<ul>
<li><a href='#motive'>Motive</a></li>
<li><a href='#method'>Method</a></li>
<ul>
<li><a href='#type_checking_proof_terms'>Type checking Proof terms</a></li>
<li><a href='#proof_terms_as_the_basis_of_tactics'>Proof terms as the Basis of Tactics</a></li>
</ul>
<li><a href='#intended_style'>Intended Style</a></li>
<li><a href='#clf_as_a_metalogic'>CLF as a Metalogic</a></li>
</ul>
<li><a href='#syntax'>Syntax</a></li>
<ul>
<li><a href='#term_grammar'>Term grammar</a></li>
<li><a href='#judgment_forms'>Judgment forms</a></li>
<li><a href='#abbreviations'>Abbreviations</a></li>
<ul>
<li><a href='#SemJudg'>Semantic Judgment Forms</a></li>
<li><a href='#computations'>Computations</a></li>
<li><a href='#type_constructors'>Type constructors</a></li>
</ul>
</ul>
<li><a href='#Rules'>Rules</a></li>
<ul>
<li><a href='#type_formation'>Type Formation</a></li>
<li><a href='#miscellaneous'>Miscellaneous</a></li>
<li><a href='#equality'>Equality</a></li>
<li><a href='#functions'>Functions</a></li>
<li><a href='#intersection'>Intersection</a></li>
<li><a href='#computation_formation'>Computation Formation</a></li>
<li><a href='#subset'>Subset</a></li>
<li><a href='#per'>PER</a></li>
<li><a href='#booleans'>Booleans</a></li>
</ul>
<li><a href='#admissible_rules'>Admissible rules</a></li>
<ul>
<li><a href='#StructRules'>Structural rules</a></li>
<li><a href='#sanity_and_inversion'>Sanity and Inversion</a></li>
<li><a href='#AdmissSem'>Admissible Rules vs PER Semantics</a></li>
<li><a href='#loose_ends'>Loose ends</a></li>
<ul>
<li><a href='#equality_uses_respect_which_uses_equality'>Equality uses respect which uses equality</a></li>
<li><a href='#UsuPiIn'>Usual Pi-intro rule</a></li>
<li><a href='#congruence_rules'>Congruence rules</a></li>
</ul>
</ul>
<li><a href='#semantic_judgmental_reflection'>Semantic Judgmental Reflection</a></li>
<ul>
<li><a href='#equality_reflection'>Equality reflection</a></li>
<li><a href='#OpenEq'>Equality of Open terms</a></li>
<li><a href='#other_semantic_judgments'>Other semantic judgments</a></li>
</ul>
<li><a href='#constructive_propositions'>Constructive Propositions</a></li>
<li><a href='#ShortCirc'>Short-Circuiting connectives</a></li>
<li><a href='#more_admissiblederived_rules'>More admissible/derived rules</a></li>
<ul>
<li><a href='#bool_eliminations'>Bool eliminations</a></li>
<li><a href='#fun_with_subsets'>Fun with subsets</a></li>
<li><a href='#subtyping'>Subtyping</a></li>
</ul>
<li><a href='#PERtheory'>PER theory</a></li>
<li><a href='#CLFasLF'>CLF and Logical Frameworks</a></li>
<ul>
<li><a href='#martinlfs_logical_framework'>Martin-Löf’s Logical Framework</a></li>
<li><a href='#LFEq'>LF=</a></li>
<li><a href='#lf_signatures_as_inductiveinductive_families'>LF Signatures as Inductive-Inductive Families</a></li>
<li><a href='#QIIF'>Quotient-Inductive-Inductive Families as Refinements</a></li>
</ul>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>Prototype CompLF is a work-in-progress <a class="existingWikiWord" href="/nlab/show/proof+assistant">proof assistant</a> design combining ideas from <a class="existingWikiWord" href="/nlab/show/Nuprl">Nuprl</a>, <a class="existingWikiWord" href="/nlab/show/LF">LF</a>, and <a class="existingWikiWord" href="/nlab/show/decidability">undecidable type checking</a>. In this article, “CLF” and “CompLF” both abbreviate “Computational Logical Framework”. Elsewhere, “CLF” is used to abbreviate “Concurrent Logical Framework”, which is mostly unrelated. So far, CompLF is just Matt Oliveri’s unpublished formal system and a formalized metatheory for it.</p>

<h3 id="motive">Motive</h3>

<p>The motivation for CLF is to try and combine the convenience of <a class="existingWikiWord" href="/nlab/show/type+theory">type systems</a> with the flexibility of <a class="existingWikiWord" href="/nlab/show/certified+programming">program verification</a>, and make the resulting style of correct program construction applicable to mathematics in a general way.</p>

<p>In most typed computational languages—even those with rather strong type systems, like the <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type systems</a> of <a class="existingWikiWord" href="/nlab/show/Coq">Coq</a> and <a class="existingWikiWord" href="/nlab/show/Agda">Agda</a>—there is a distinction between types and program specifications. A specification should</p>

<ul>
<li>constrain the computational behavior of conforming <a class="existingWikiWord" href="/nlab/show/terms">terms</a>, and</li>

<li>not constrain the way this behavior is implemented.</li>
</ul>

<p><a class="existingWikiWord" href="/nlab/show/type">Types</a> typically constrain both behavior and implementation. Intuitively, this is because types are typically implemented using elaborate <a class="existingWikiWord" href="/nlab/show/syntax">syntax</a> checks, so they constrain behavior <em>by</em> constraining implementation.</p>

<p>A <em>program logic</em> provides predicates and proof rules about programs, and this provides an adequate approach to specification and verification of computational behavior. The requirement to satisfy a predicate doesn’t constrain the way a program is implemented because the syntax rules for forming a program don’t take into account any predicates the programmer may hope the program to satisfy. This is the sense in which program verification is more flexible than syntactic typing.</p>

<p>Using <a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>, many dependent type systems support specifications, in addition to types. But with the restriction to syntactic type checking, types and specifications remain distinct notions in practice.</p>

<p>(Many proof assistants have a feature called “program extraction” that converts term definitions into an <em>external</em> program. Using program extraction, syntactic dependent typing of terms can match the flexibility of specifications for external programs. This doesn’t provide any additional flexibility for terms themselves, though. (The realizer extraction mechanism described below is analogous to program extraction, but with terms as the <em>output</em> of realizer extraction, not the input.))</p>

<p>By taking types to denote (certain) <a class="existingWikiWord" href="/nlab/show/PER">PER</a>s on terms, Nuprl provides an <a class="existingWikiWord" href="/nlab/show/intrinsic+and+extrinsic+views+of+typing">extrinsic</a> notion of type that subsumes program specifications. So Nuprl has a type system, and its types provide the flexibility of program verification; but it seems that Nuprl doesn’t provide the convenience of a type system with a type checking algorithm.</p>

<p>From a naive perspective, it can’t be done. Type checking Nuprl would be undecidable, but more importantly, it would require automatically coming up with proofs of true mathematical statements, and there’s no good way to do that.</p>

<p>But that just means there needs to be additional machinery for formal proofs and practical proof checking. The question is then whether the formal proof machinery is as convenient, for developing correct programs, as type checking. The answer, for Nuprl’s proof system, is supposedly “no”. CLF will try to do better, by checking proof terms in a manner similar to dependent type checking.</p>

<h3 id="method">Method</h3>

<p>CLF is planned to combine a semantics similar to that of Nuprl with a language of proof terms similar to that of <a href="https://cedille.github.io/">Cedille</a>. (Cedille is actually the latest in a series of dependent type systems (co)designed by Aaron Stump in which the meaning of equality pertains to realizers, not proof terms.)</p>

<h4 id="type_checking_proof_terms">Type checking Proof terms</h4>

<p>The terms that the CLF type system is about are called “<a class="existingWikiWord" href="/nlab/show/realizers">realizers</a>”. (Since its Nuprl-inspired PER semantics is a term realizability model.) The proof terms would be an <em>additional</em> class of terms. Proof checking in CLF means type checking the proof terms. In the case of “obviously-well-typed” programs, the tree structures of the realizers and proof terms should be nearly isomorphic, so the system will resemble a typical syntactic type checker. In general, proof terms have additional information not present in realizers. This is the information that is needed for proof/type checking, but is not part of the computational content of the witness/element.</p>

<p>CLF types only depend on realizers, never proof terms. So to handle proof checking rules analogous to certain rules of dependent type systems, a realizer needs to be extracted from a proof on the fly. (Nuprl works around such rules, since it doesn’t extract realizers on the fly.) This solution is used in RedPRL, and is discussed in <a href="#SterlingHarperRefinement">Algebraic Foundations of Proof Refinement</a>, under the terminology “dependent proof refinement”. An analogue of on-the-fly realizer extraction is used by Cedille too, and is called “erasure”. This kind of proof checking algorithm seems to be an example of an elaboration algorithm: the input expressions (in this case, proof terms) are different from the internal terms (in this case, realizers).</p>

<p>The only information from derivations that’s missing from proof terms is derivations of definitional equality, which is <a class="existingWikiWord" href="/nlab/show/beta+conversion">beta conversion</a>. This is enough to make proof checking undecidable, since beta convertibility of untyped realizers is undecidable. CLF will boldly attempt to automate beta conversion by comparing <a class="existingWikiWord" href="/nlab/show/normal+form">normal forms</a> nonetheless.</p>

<p>Before normalizing terms, to compare them for definitional equality, they are first compared for <a class="existingWikiWord" href="/nlab/show/alpha-equivalence">alpha-equivalence</a>. This allows the user to safely “hand-crank” an equality proof about terms without normal forms. So CLF proof checking will not be total, but it should still be sound and complete with respect to formal derivability.</p>

<h4 id="proof_terms_as_the_basis_of_tactics">Proof terms as the Basis of Tactics</h4>

<p>LCF-style proof engines check proofs by executing some kind “proof script”, which runs “tactics” to reduce proof goals. Tactics fail when they attempt to use an invalid rule instance. The proof is complete when all goals are reduced to nothing.</p>

<p>A proof term can be thought of as a restricted form of proof script. The primitive proof term formers correspond to primitive derivation rules. Open proof term schemas correspond to derived rules. Operations on closed proof terms correspond to admissible rules. Tactics are arguably somewhere between derived rules and admissible rules: they tend to intensionally analyze the goal, but not entire proofs. Intuitively, tactic engines are a kind of macro expansion system to automate the production of proof terms.</p>

<p>When proofs are “generated” by tactics, proof terms should not actually need to be generated in memory; only realizers. This makes CLF’s proof checking like that of Nuprl and <a class="existingWikiWord" href="/nlab/show/Isabelle">Isabelle</a>, and unlike that of Coq. In Coq, the proof terms need to be generated in order to perform termination checking on them. (So Coq’s trusted kernel is not LCF-style; it’s “Automath-style”: proof checking is type checking.) Nuprl-style systems don’t benefit from termination checking because it’s possible to <em>prove</em> that an untyped realizer implements an element of the intended type, which entails any necessary totality properties. (And Isabelle/HOL doesn’t benefit from termination checking because it uses a <a class="existingWikiWord" href="/nlab/show/global+choice+operator">global choice operator</a>.)</p>

<p>It’s good for performance that the (relatively complex) proof terms never need to be dealt with, aside from a single compositional pass to check them. Instead, most of the detail work of proof checking deals with realizers.</p>

<p>While proof terms seem too complex to be the terms you want to deal with, it may turn out that CLF realizers are too simple. The concern is that the realizers may not have enough annotations for useful forms of proof automation. But if this does turn out to be a problem in practice, it still seems better to add annotations to the realizers as necessary, rather than to give up and collapse the distinction between proof terms and realizers.</p>

<h3 id="intended_style">Intended Style</h3>

<p>The primitives of CLF will probably be pretty low-level, and will rely on some “bootstrapping” up to the usual principles of type theory. (Some of this can be seen already, in the discussion of the rules below.) This bootstrapping will rely in crucial ways on the realizers being fundamentally untyped.</p>

<p>However, once the bootstrapping is taken care of, the intent is that the main way of using CLF will be a lot like other dependently-typed proof assistants: Constructions will be thought of as elements of types, and the type system will guide the details of constructing elements.</p>

<p>Given the goal of a system that feels typed, it may seem weird to explicitly base it on untyped realizers. The reason goes back to the flexibility of specifications, compared to purely syntactic typing. It should <em>always</em> be possible to construct elements in such a way that the computational content is well-implemented. But it seems that syntactic dependent typing requires ever more tricks to be added to the language in order to express elements using terms that are efficient.</p>

<p>Rather than having to change the language, CLF provides the option of reasoning about assignment of types to untyped realizers to <em>prove</em> the missing type theoretic principles. Of course, reasoning about type assignment can also be used, to taste, even when not strictly necessary. In general, there’s a spectrum of styles for using an extrinsic type theory, based on how much of the well-typedness of a construction is true by construction, versus proven afterward. Correctness by construction makes the development feel more intrinsic, but this difference in style is not a commitment: the extrinsic perspective applies to everything.</p>

<h3 id="clf_as_a_metalogic">CLF as a Metalogic</h3>

<p>The above considerations motivate a whole class of type system implementations that combine Nuprl-style semantics with a Cedille-like proof term checker. But what about <a class="existingWikiWord" href="/nlab/show/category">categories</a>?</p>

<p>To justify the proof rules, systems like Nuprl, Cedille, and CLF are based on term realizability models. But it’s not currently clear to what extent this approach is compatible with the <a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">categorical semantics of type theory</a>.</p>

<p>The specifics of CLF are motivated by the insight (of Matt Oliveri, but strongly inspired by <a href="#Andromeda">Andromeda</a>) that <a class="existingWikiWord" href="/nlab/show/extensional+type+theory">extensional type theories</a> (with equality reflection) promise to make great logical frameworks. Although categorical semantics for “structural” fragments of Nuprl-style systems may be feasible and useful, CLF sidesteps the whole issue by being a metalogic for reasoning about formal systems.</p>

<p>The idea is that by regarding CLF as a metalogic, its possible lack of categorical semantics is irrelevant because the object logic can be chosen so as to reason about the desired semantics. CLF as a metalogic is a way to try to make the (hypothesized) technical advantages of a Nuprl-Cedille-like approach applicable to any type theory.</p>

<p>Some discussion is needed to explain what makes extensional type theory good for logical frameworks, what that has to do with metalogics, and what makes CLF a good metalogic. <a href="#CLFasLF">Later</a>.</p>

<p>First, what follows is a draft version of the formal system that will be used in prototype CLF. These rules are non-algorithmic rules pertaining only to types and realizers; the details of the proof system are not designed yet. (And they won’t be until some issues are addressed in the semantics and rule set.) Some sketchy thoughts about the design of the proof system are at the beginning of the <a href="#Rules">Rules</a> section.</p>

<h2 id="syntax">Syntax</h2>

<h3 id="term_grammar">Term grammar</h3>

<p>The main <a class="existingWikiWord" href="/nlab/show/syntax">syntactic</a> class is <a class="existingWikiWord" href="/nlab/show/terms">terms</a>. <a class="existingWikiWord" href="/nlab/show/type">Type</a> expressions are terms. There are also <a class="existingWikiWord" href="/nlab/show/variables">variables</a> and <a class="existingWikiWord" href="/nlab/show/contexts">contexts</a>.</p>

<p>variables (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math>, …)<code> ::= </code>(Written as usual. Complain if you can’t tell them apart from metavariables.)</p>

<p>terms (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>, …)<code> ::=</code></p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">x \qquad</annotation></semantics></math> (variable reference)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">\lambda x.b \qquad</annotation></semantics></math> (lambda abstraction)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mspace width="thinmathspace"></mspace><mi>a</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">f\,a \qquad</annotation></semantics></math> (application)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>∈</mo><mi>C</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">a = b \in C \qquad</annotation></semantics></math> (equality type)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">\Pi x:A.B \qquad</annotation></semantics></math> (dependent function type)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">\cap x:A.B \qquad</annotation></semantics></math> (family intersection type)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">Comp \qquad</annotation></semantics></math> (type of computations (<a class="existingWikiWord" href="/nlab/show/realizers">realizers</a>))</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">\{x:A | B\} \qquad</annotation></semantics></math> (subset/separation type)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">\{x = y | R\} \qquad</annotation></semantics></math> (<a class="existingWikiWord" href="/nlab/show/PER">PER</a> comprehension type)</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">Bool \qquad</annotation></semantics></math> (type of “booleans”) (two-element type)</p>
</li>
</ul>

<p>To be added: an infinite type.</p>

<p>contexts (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>, …)<code> ::= </code><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math><code> | </code><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma,x:T</annotation></semantics></math></p>

<p>As usual, the rules may make liberal use of informal list operations to work with contexts.</p>

<h3 id="judgment_forms">Judgment forms</h3>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><msub><mo>≡</mo> <mi>β</mi></msub><mi>b</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">a \equiv_\beta b \qquad</annotation></semantics></math> (beta conversion)</p>

<p>The only <a class="existingWikiWord" href="/nlab/show/beta+reduction">beta reduction</a> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>a</mi><msub><mo>⟶</mo> <mi>β</mi></msub><mi>b</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\lambda x.b)\,a \longrightarrow_\beta b[a/x]</annotation></semantics></math>. Conversion is the congruence closure.</p>

<p>The other <a class="existingWikiWord" href="/nlab/show/judgment">judgment</a> forms will be defined <a class="existingWikiWord" href="/nlab/show/induction">inductively</a> by the rules below. They are:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">\Gamma \vdash T\,type \qquad</annotation></semantics></math> (type validity)</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi><mspace width="2em"></mspace></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Vdash T \qquad</annotation></semantics></math> (element in a type) (realizer of a type)</p>

<p>Note that in <a class="existingWikiWord" href="/nlab/show/Nuprl">Nuprl</a>, the (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Vdash T</annotation></semantics></math>) form is written (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>T</mi><mspace width="thickmathspace"></mspace><mo stretchy="false">⌊</mo><mi>ext</mi><mi>t</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\Gamma \vdash T\;\lfloor ext t \rfloor</annotation></semantics></math>). The “extract” part is computed from a derivation, so the user thinks of the judgment as stating that the type is <a class="existingWikiWord" href="/nlab/show/inhabited+type">inhabited</a>.</p>

<p>In the rules below, however, no attention is paid to what can be metatheoretically computed with terms or derivations. That is (important) future work.</p>

<p>(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Vdash T</annotation></semantics></math>) is used instead of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mspace width="thinmathspace"></mspace><mo>:</mo><mspace width="thinmathspace"></mspace><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t\,:\,T</annotation></semantics></math>) in order to avoid the misinterpretation of this judgment form as <a class="existingWikiWord" href="/nlab/show/intrinsic+and+extrinsic+views+of+typing">intrinsic typing</a> of terms. Note the contrast with variables, which <em>are</em> intrinsically typed.</p>

<p>The (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mspace width="thinmathspace"></mspace><mo>:</mo><mspace width="thinmathspace"></mspace><mi>T</mi></mrow><annotation encoding="application/x-tex">t\,:\,T</annotation></semantics></math>) form can be translated to this system as either (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \Vdash T</annotation></semantics></math>) or (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>?</mo><mo>⊩</mo><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">? \Vdash t \in T</annotation></semantics></math>). The latter uses the abbreviation “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math>” defined below, and the abuse of meta-notation that we don’t care what goes in the “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>?</mo></mrow><annotation encoding="application/x-tex">?</annotation></semantics></math>”. With (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \Vdash T</annotation></semantics></math>), we think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> as resulting from the proof of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. With (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>?</mo><mo>⊩</mo><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">? \Vdash t \in T</annotation></semantics></math>), we think of the “<em>semantic judgment</em>” (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \in T</annotation></semantics></math>) as a goal to prove internally. The rules ensure that these two ways of expressing an element of a type are interderivable. From this point on, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mo>?</mo><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash ? \Vdash T</annotation></semantics></math>) will be written as just (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash T</annotation></semantics></math>), although it remains informal.</p>

<h3 id="abbreviations">Abbreviations</h3>

<h4 id="SemJudg">Semantic Judgment Forms</h4>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>a</mi><mo>=</mo><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A\;\coloneqq\;a = a \in A</annotation></semantics></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>Π</mi><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B\;\coloneqq\;\Pi \underline{\;}:A.B</annotation></semantics></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A \wedge B\;\coloneqq\;\{\underline{\;}:A | B\}</annotation></semantics></math></p>

<p>“<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> equality is respected in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.”:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≺</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mi>Π</mi><mi>t</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \prec B\;\coloneqq\;\Pi t:Comp.\Pi t':Comp.
(t \in B)\to(t = t' \in A)\to(t = t' \in B)</annotation></semantics></math></p>

<p>“<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> members are included in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.”:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \subseteq B\;\coloneqq\;\Pi t:Comp.(t \in A)\to(t \in B)</annotation></semantics></math></p>

<p>“<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a subtype of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.”:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B\;\coloneqq\;(\lambda x.x) \in (A \to B)</annotation></semantics></math></p>

<p>Note: (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) ought to be logically equivalent to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>∧</mo><mi>A</mi><mo>≺</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \subseteq B \wedge A \prec B</annotation></semantics></math>), using the rules. And also to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mi>Π</mi><mi>t</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.\Pi t':Comp.(t = t' \in A)\to(t = t' \in B)</annotation></semantics></math>). So thinking of types as PERs, subtypes are subrelations.</p>

<p>“<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a refinement/<a class="existingWikiWord" href="/nlab/show/subquotient">subquotient</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.”:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊑</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>∧</mo><mi>B</mi><mo>≺</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \sqsubseteq B\;\coloneqq\;A \subseteq B \wedge B \prec A</annotation></semantics></math></p>

<p>Note the reversal of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math>, compared to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo></mrow><annotation encoding="application/x-tex">\lt\!\!:</annotation></semantics></math>. As relations on types, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo></mrow><annotation encoding="application/x-tex">\lt\!\!:</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math> ought to be <a class="existingWikiWord" href="/nlab/show/preorders">preorders</a>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math> is not transitive.</p>

<h4 id="computations">Computations</h4>

<p>The Church booleans:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>λ</mi><mi>t</mi><mo>.</mo><mi>λ</mi><mi>f</mi><mo>.</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">tru\;\coloneqq\;\lambda t.\lambda f.t</annotation></semantics></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fls</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>λ</mi><mi>t</mi><mo>.</mo><mi>λ</mi><mi>f</mi><mo>.</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">fls\;\coloneqq\;\lambda t.\lambda f.f</annotation></semantics></math></p>

<h4 id="type_constructors">Type constructors</h4>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>tru</mi><mo>=</mo><mi>tru</mi><mo>∈</mo><mi>Bool</mi></mrow><annotation encoding="application/x-tex">\top\;\coloneqq\;tru = tru \in Bool</annotation></semantics></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊥</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>tru</mi><mo>=</mo><mi>fls</mi><mo>∈</mo><mi>Bool</mi></mrow><annotation encoding="application/x-tex">\bot\;\coloneqq\;tru = fls \in Bool</annotation></semantics></math></p>

<p>“Squash” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>A</mi><mo stretchy="false">⌋</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mo>⊤</mo><mo stretchy="false">|</mo><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\lfloor A \rfloor\;\coloneqq\;\{\underline{\;}:\top | A\}</annotation></semantics></math></p>

<h2 id="Rules">Rules</h2>

<p>These rules are not the final rules that are planned to be implemented in proto CLF. The major differences planned for the final rules from those here are:</p>

<ul>
<li>Use roughly Nuprl-style hidden assumptions, but with unhiding handled automatically.</li>

<li>Have an additional judgment form for goals whose realizer is ignored/arbitrary, which interacts with unhiding.</li>

<li>Add formal proof terms.</li>
</ul>

<p>The expectation and hope is that the result will look fairly similar to algorithmic elaboration-style type checking rules. These rules will be the primitive tactics, and type checking will thus be a special case of running tactic trees.</p>

<h3 id="type_formation">Type Formation</h3>

<p>We have a strong equality formation rule, inspired by the medium-strength rule from <a href="#AnandRahliITP14">Anand &amp; Rahli</a>, which is also stronger than the usual one. Here is respect-based equality formation:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>A</mi><mo>≺</mo><mi>C</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>q</mi><mo>⊩</mo><mi>B</mi><mo>≺</mo><mi>C</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>∈</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma \vdash p \Vdash A \prec C \qquad
\Gamma \vdash q \Vdash B \prec C \qquad
\Gamma \vdash a \Vdash A \qquad \Gamma \vdash b \Vdash B}
{\Gamma \vdash a = b \in C\,type} \\
\\
\frac{\Gamma \vdash A\,type \qquad \Gamma,x:A \vdash B\,type}
{\Gamma \vdash \Pi x:A.B\,type} \\
\\
\frac{\Gamma \vdash A\,type \qquad \Gamma,x:A \vdash B\,type}
{\Gamma \vdash \cap x:A.B\,type}
\end{gathered}
</annotation></semantics></math></div>
<p>The <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> type, which is called <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Base</mi></mrow><annotation encoding="application/x-tex">Base</annotation></semantics></math> in Nuprl:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>Comp</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{}{\Gamma \vdash Comp\,type} \\
\\
\frac{\Gamma \vdash A\,type \qquad \Gamma,x:A \vdash B\,type}
{\Gamma \vdash \{x:A | B\}\,type}
\end{gathered}
</annotation></semantics></math></div>
<p>A PER comprehension type was originally conceived by Stuart Allen, and then forgotten and subsequently <a href="#PERTypes14">reintroduced</a>. However, I think Nuprl had already had <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Base</mi></mrow><annotation encoding="application/x-tex">Base</annotation></semantics></math>, subsets, and quotients, which make it definable. The real innovation is how PER comprehension and the strengthened equality formation rule interact to allow internal, logical-relations-style type definitions. We only allow forming a PER type from a pseudo-PER, rather than implicitly taking the symmetric transitive closure of any family:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>,</mo><mi>x</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>x</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>R</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>y</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>s</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo>→</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>y</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>3</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo>→</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo>→</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>Bool</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\begin{array}{l}\Gamma,x1:Comp,x2:Comp \vdash R\,type \\
\Gamma,y1:Comp,y2:Comp \vdash s \Vdash R[y1,y2/x1,x2] \to R[y2,y1/x1,x2] \\
\Gamma,y1:Comp,y2:Comp,y3:Comp \vdash t \Vdash R[y1,y2/x1,x2] \to R[y2,y3/x1,x2] \to R[y1,y3/x1,x2]\end{array}}
{\Gamma \vdash \{x1 = x2 | R\}\,type} \\
\\
\frac{}{\Gamma \vdash Bool\,type}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="miscellaneous">Miscellaneous</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>x</mi><mo>:</mo><mi>T</mi><mo>∈</mo><mi>Γ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>x</mi><mo>⊩</mo><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x:T \in \Gamma}{\Gamma \vdash x \Vdash T}</annotation></semantics></math></div>
<p>The untyped beta conversion rules have the same role as Nuprl’s direct computation rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>A</mi><msub><mo>≡</mo> <mi>β</mi></msub><mi>B</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>B</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>t</mi><msub><mo>≡</mo> <mi>β</mi></msub><mi>t</mi><mo>′</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>′</mo><mo>⊩</mo><mi>T</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{A \equiv_\beta B \qquad \Gamma \vdash B\,type \qquad
\Gamma \vdash t \Vdash A}
{\Gamma \vdash t \Vdash B} \\
\\
\frac{t \equiv_\beta t' \qquad \Gamma \vdash t \Vdash T}
{\Gamma \vdash t' \Vdash T}
\end{gathered}
</annotation></semantics></math></div>
<p>Every type respects itself, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. (Yes, you can use any term you like as the proof.):</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>A</mi><mo>≺</mo><mi>A</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>Comp</mi><mo>≺</mo><mi>A</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma \vdash A\,type}{\Gamma \vdash p \Vdash A \prec A} \\
\\
\frac{\Gamma \vdash A\,type}{\Gamma \vdash p \Vdash Comp \prec A}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="equality">Equality</h3>

<p>A reflexivity rule, but any term can be the proof:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>∈</mo><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash t \Vdash T}{\Gamma \vdash p \Vdash t = t \in T}</annotation></semantics></math></div>
<p>Terms participating in equality are elements. Normally this would only be admissible, but in CLF, it comes in handy to make it into “selectivity” rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mi>T</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mn>1</mn><mo>⊩</mo><mi>T</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mi>T</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mn>2</mn><mo>⊩</mo><mi>T</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma \vdash p \Vdash t1 = t2 \in T}{\Gamma \vdash t1 \Vdash T} \\
\\
\frac{\Gamma \vdash p \Vdash t1 = t2 \in T}{\Gamma \vdash t2 \Vdash T}
\end{gathered}
</annotation></semantics></math></div>
<p>Note that the above equality rules make (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Vdash T</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \in T</annotation></semantics></math>) interderivable, as promised.</p>

<p>We use a “subsumptive” rewrite rule as equality elimination. “Subsumptive” refers to the property that the realizer of the type we rewrite in is unaffected. The terminology “subsumptive” for this is new to CLF, although this is effectively the same equality elimination rule as in Nuprl. The terminology comes from “subsumptive” vs “coercive” implementations of subtyping. Note that formally, CLF has no typed judgmental equality. Semantically, it’s an <a class="existingWikiWord" href="/nlab/show/extensional+type+theory">extensional type theory</a>, but the semantic equality judgment is implemented as the equality type, like in Nuprl. This is sound due to equality reflection. So this rule is semantically a consequence of equality reflection, equality substitution, and (typed) conversion. As with equality reflection, the proof of equality is irrelevant:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>a</mi><mn>1</mn><mo>=</mo><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma,x:A \vdash B\,type \qquad
\Gamma \vdash p \Vdash a1 = a2 \in A \qquad
\Gamma \vdash b \Vdash B[a1/x]}
{\Gamma \vdash b \Vdash B[a2/x]}
</annotation></semantics></math></div>
<p>Any two terms are equal as the (consequently unique) proof of a true equality:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>q</mi><mo>⊩</mo><mi>p</mi><mn>1</mn><mo>=</mo><mi>p</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>∈</mo><mi>T</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash t \Vdash T}
{\Gamma \vdash q \Vdash p1 = p2 \in (t = t \in T)}
</annotation></semantics></math></div>
<p>That means <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math> too, which is thus the maximum PER, ordered by subtyping. (Well, just as soon as we make <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi></mrow><annotation encoding="application/x-tex">tru</annotation></semantics></math> an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math>.)</p>

<h3 id="functions">Functions</h3>

<p>We have the standard application rule, and a variant of function extensionality:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>a</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>=</mo><mi>f</mi><mo>′</mo><mspace width="thinmathspace"></mspace><mi>x</mi><mo>∈</mo><mi>B</mi><mspace width="2em"></mspace><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>f</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>q</mi><mo>⊩</mo><mi>f</mi><mo>=</mo><mi>f</mi><mo>′</mo><mo>∈</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma \vdash f \Vdash \Pi x:A.B \qquad
\Gamma \vdash a \Vdash A}
{\Gamma \vdash f\,a \Vdash B[a/x]} \\
\\
\frac{\Gamma \vdash A\,type \qquad
\Gamma,x:A \vdash p \Vdash f\,x = f'\,x \in B \qquad
x \notin FV(f,f')}
{\Gamma \vdash q \Vdash f = f' \in \Pi x:A.B}
\end{gathered}
</annotation></semantics></math></div>
<p>Unconventionally, we consider function extensionality to be the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> intro rule, and derive the fact that lambdas implement functions.</p>

<h3 id="intersection">Intersection</h3>

<p>Elements of a family intersection are like elements of a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> type, except you don’t have to apply them. An intersection element is <em>already</em> an element of all instances of the family. So the rules for family intersection are analogous to the rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mspace width="2em"></mspace><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>q</mi><mo>⊩</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma \vdash b \Vdash \cap x:A.B \qquad
\Gamma \vdash a \Vdash A}
{\Gamma \vdash b \Vdash B[a/x]} \\
\\
\frac{\Gamma \vdash A\,type \qquad
\Gamma,x:A \vdash p \Vdash b = b' \in B \qquad
x \notin FV(b,b')}
{\Gamma \vdash q \Vdash b = b' \in \cap x:A.B}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="computation_formation">Computation Formation</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>Comp</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo>⊩</mo><mi>Comp</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>⊩</mo><mi>Comp</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>Comp</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>a</mi><mo>⊩</mo><mi>Comp</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma,x:Comp \vdash b \Vdash Comp}{\Gamma \vdash \lambda x.b \Vdash Comp} \\
\\
\frac{\Gamma \vdash f \Vdash Comp \qquad \Gamma \vdash a \Vdash Comp}
{\Gamma \vdash f\,a \Vdash Comp}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="subset">Subset</h3>

<p>The subset type resembles an existential quantifier. In the elimination rule, the proof part must be computationally irrelevant, since an element of a subset does not include the proof. Nuprl handles this with a hidden assumption, which is the practical way to do it. But it’s also sound to just stick in a free variable side condition.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>z</mi><mo>:</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">/</mo><mi>z</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>y</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>z</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma,x:A \vdash B\,type \qquad
\Gamma \vdash a \Vdash A \qquad \Gamma \vdash b \Vdash B[a/x]}
{\Gamma \vdash a \Vdash \{x:A | B\}} \\
\\
\frac{\Gamma,z:\{x:A | B\} \vdash C\,type \qquad
\Gamma,x:A,y:B \vdash c \Vdash C[x/z] \qquad y \notin FV(c) \qquad
\Gamma \vdash a \Vdash \{x:A | B\}}
{\Gamma \vdash c[a/x] \Vdash C[a/z]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="per">PER</h3>

<p>The rules for PER comprehension are made simpler by the fact that we required <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> to be a pseudo-PER in the formation rule. The idea is that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mspace width="thickmathspace"></mspace><mi>x</mi><mn>1</mn><mspace width="thickmathspace"></mspace><mi>x</mi><mn>2</mn><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>↔</mo><mo stretchy="false">⌊</mo><mi>R</mi><mspace width="thickmathspace"></mspace><mi>t</mi><mn>1</mn><mspace width="thickmathspace"></mspace><mi>t</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">(t1 = t2 \in \{x1 = x2 | R\;x1\;x2\}) \leftrightarrow \lfloor R\;t1\;t2 \rfloor</annotation></semantics></math>), using the squash type constructor defined above. So comprehension and equality are almost inverse; you just lose the computational content of the equivalence proof.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mn>2</mn><mo>⊩</mo><mi>Comp</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>t</mi><mn>1</mn><mo>,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>q</mi><mo>⊩</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>R</mi><mo stretchy="false">[</mo><mi>t</mi><mn>1</mn><mo>,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>z</mi><mo>:</mo><mi>R</mi><mo stretchy="false">[</mo><mi>t</mi><mn>1</mn><mo>,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mspace width="2em"></mspace><mi>z</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma \vdash \{x1 = x2 | R\}\,type \qquad
\Gamma \vdash t2 \Vdash Comp \qquad
\Gamma \vdash p \Vdash R[t1,t2/x1,x2]}
{\Gamma \vdash q \Vdash t1 = t2 \in \{x1 = x2 | R\}} \\
\\
\frac{\begin{array}{l}
\Gamma \vdash C\,type \qquad
\Gamma \vdash R[t1,t2/x1,x2]\,type \\
\Gamma \vdash p \Vdash t1 = t2 \in \{x1 = x2 | R\} \\
\Gamma,z:R[t1,t2/x1,x2] \vdash c \Vdash C \qquad z \notin FV(c)
\end{array}}
{\Gamma \vdash c \Vdash C}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="booleans">Booleans</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>tru</mi><mo>⊩</mo><mi>Bool</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>fls</mi><mo>⊩</mo><mi>Bool</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{}{\Gamma \vdash tru \Vdash Bool} \qquad
\frac{}{\Gamma \vdash fls \Vdash Bool}
</annotation></semantics></math></div>
<p>Exercise: Does the following rule express (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi><mo>⊆</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Bool \subseteq Comp</annotation></semantics></math>), (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Bool \lt\!\!:\;Comp</annotation></semantics></math>), or (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi><mo>⊑</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Bool \sqsubseteq Comp</annotation></semantics></math>)?</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>Bool</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>Comp</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash b \Vdash Bool}{\Gamma \vdash b \Vdash Comp}</annotation></semantics></math></div>
<p>Our elimination rule is intuitively characterizing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> as the least type containing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi></mrow><annotation encoding="application/x-tex">tru</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fls</mi></mrow><annotation encoding="application/x-tex">fls</annotation></semantics></math>. The usual elimination rule is derived; it’s derivable because Church booleans actually work.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Bool</mi><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>tru</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>fls</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>Bool</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma,x:Bool \vdash C\,type \qquad
\Gamma \vdash c \Vdash C[tru/x] \qquad
\Gamma \vdash c \Vdash C[fls/x] \qquad
\Gamma \vdash b \Vdash Bool}
{\Gamma \vdash c \Vdash C[b/x]}
</annotation></semantics></math></div>
<p>An <a class="existingWikiWord" href="/nlab/show/ex+falso+quodlibet">ex falso quodlibet</a> rule, which is technically about booleans, because of how we defined <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊥</mo></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math>. Note that this makes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊥</mo></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math> the minimum PER, ordered by inclusion, subtyping, or refinement.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mo>⊥</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash T\,type \qquad
\Gamma \vdash p \Vdash \bot}
{\Gamma \vdash t \Vdash T}
</annotation></semantics></math></div>
<h2 id="admissible_rules">Admissible rules</h2>

<h3 id="StructRules">Structural rules</h3>

<p>The structural rules of weakening and substitution are admissible. “Strengthening” is not. Strengthening says that a variable that’s not free in the conclusion can be removed from the context:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><msub><mi>Γ</mi> <mn>1</mn></msub><mo>,</mo><mi>x</mi><mo>:</mo><mi>T</mi><mo>,</mo><msub><mi>Γ</mi> <mn>2</mn></msub><mo>⊢</mo><mi>𝒥</mi><mspace width="2em"></mspace><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><msub><mi>Γ</mi> <mn>2</mn></msub><mo>,</mo><mi>𝒥</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>Γ</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>Γ</mi> <mn>2</mn></msub><mo>⊢</mo><mi>𝒥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma_1,x:T,\Gamma_2 \vdash \mathcal{J} \qquad
x \notin FV(\Gamma_2,\mathcal{J})}
{\Gamma_1,\Gamma_2 \vdash \mathcal{J}}
</annotation></semantics></math></div>
<p>So nonadmissibility of strengthening means that a derivation can be using a hypothesis without it being obvious from the conclusion derived. This is typical of extensional type theory. Typically it’s considered all the fault of equality reflection, which may be technically true for some systems. But Nuprl benefits more from the lack of strengthening: subsets, intersections, quotients, and other “refinement-style” type constructors provide flexible control over which proofs make it into the computational content, and which are merely establishing external facts. (<a class="existingWikiWord" href="/nlab/show/quotient">Quotients</a> don’t have to be refinement-style, but in Nuprl and CLF, they are. See <a href="#PERtheory">below</a>.) Computational irrelevance is implemented by literally omitting the irrelevant proofs from terms. This leads to the lack of strengthening, and to undecidable type checking. The restriction imposed by equality reflection is that equality proofs never have computational content.</p>

<p>CLF follows Nuprl in trying to give the user maximum control over the terms used to represent elements. The hope is that with care, this can allow significantly greater convenience and performance than with decidable dependent type systems, which are committed to retaining enough annotations to effectively reject ill-typed terms. Once proof terms are added to the formal judgments, you probably do get strengthening. (But not decidability.)</p>

<h3 id="sanity_and_inversion">Sanity and Inversion</h3>

<p>You’d think a statement should make sense before you try to prove it. And likewise, that a type should be valid before you try to construct an element. But in practice, it also works to consider a typed construction as providing evidence that the type makes sense. Specifically, the only way to derive (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Vdash T</annotation></semantics></math>) is if you could also derive (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash T\,type</annotation></semantics></math>). That’s a “sanity check” admissible rule. It’s <em>probably</em> admissible for the judgments defined by the rules above.</p>

<p>Also, since the only way to derive type validity in this system (not using the sanity admissible rule) is to use a type former, a derivation of type validity implies that there are derivations of validity for the subexpressions of the type expression. These are “inversion” admissible rules.</p>

<h3 id="AdmissSem">Admissible Rules vs PER Semantics</h3>

<p>For full Nuprl, it seems practically impossible to prove admissibility of sanity or inversion, if they’re not just included among the primitive rules. But they <em>can</em> be included among the primitive rules, because they’re true in the semantics. Due to the way hypothetical judgments are defined, making the inversion rules true requires making type equality intensional.</p>

<p>The above rules are the result of an experiment to reason about formal derivability in a Nuprl-style system. In the PER semantics that the above rules were based on, type equality is extensional. So the basic rules directly satisfied were more complicated, since they needed extra premises that inversion would’ve made redundant. The above rules are actually admissible rules relative to those basic rules. Sanity and inversion are “probably” admissible for the above rules because what’s actually known is that they’re admissible for the basic rules; they were in fact used to prove the above rules.</p>

<p>So the experiment was partially successful, but I (Matt Oliveri) don’t recommend the approach. It cannot be easily adapted to handle universes, and some of the rules above still have type validity premises that a fully semantic approach could avoid.</p>

<p>It may seem weird that Nuprl is based on a particular PER semantics, if you think of it as a mathematical model. But if you think of it as a proof theoretic technique that reasons about realizability instead of formal derivability, perhaps it’s more palatable.</p>

<p>Thinking that way, all the consequences of the PER semantics are like admissible rules, and can be added to the formal system if they’re useful. But it still seems like a good idea to try and find a stable formal system with enough rules that incompleteness is not a problem in practice.</p>

<p>This raises questions though: If the formal rules of a Nuprl-style system are considered admissible, what defines the system? What are the mathematical models of Nuprl-style systems? If they’re considered unnatural, should Nuprl-style systems be modified?</p>

<p>In my (Matt Oliveri’s) opinion, Nuprl-style systems are potentially relevant and useful to mathematics, but it’s not currently clear exactly how that might work.</p>

<h3 id="loose_ends">Loose ends</h3>

<p>Now that we’ve covered the issue that the distinction between derivable and admissible doesn’t really matter for this system, we can get to explaining particular aspects that may seem to be in particular need of an explanation.</p>

<h4 id="equality_uses_respect_which_uses_equality">Equality uses respect which uses equality</h4>

<p>The equality formation rule refers to the respect (“<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math>”) relation. The latter is not primitive, it’s defined in terms of equality. Is that OK? Yes: Because of the rule that all types respect <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>, we get enough instances of equality formation to prove:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>≺</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type \qquad \Gamma \vdash B\,type}
{\Gamma \vdash A \prec B\;type}
</annotation></semantics></math></div>
<p>If it still seems suspiciously circular, rest assured that in the semantics, respecting computational equivalence is more basic than anything in the type system. The rule about respecting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> just exposes the fact internally.</p>

<p>Because every type respects itself, we get all the instances of equality formation from <a class="existingWikiWord" href="/nlab/show/Martin-L%C3%B6f+type+theory">Martin-Löf type theory</a>. Equality types beyond that are for reasoning about membership.</p>

<h4 id="UsuPiIn">Usual Pi-intro rule</h4>

<p>Taking function extensionality to be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> intro seems odd. Not only is it not about lambdas, it’s not apparently about elements at all; just equality. That’s (one place) where the selectivity rules are handy. The function extensionality rule is strong enough to combine with selectivity (and reflexivity) to derive elements of function type. A term is a function when you can apply it to an argument to get a result:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mspace width="2em"></mspace><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type \qquad
\Gamma,x:A \vdash f\,x \Vdash B \qquad x \notin FV(f)}
{\Gamma \vdash f \Vdash \Pi x:A.B}
</annotation></semantics></math></div>
<p>Proving that lambdas are functions additionally uses beta conversion. Lambdas are functions, not by fiat, but because they produce results when applied.</p>

<p>Note that not all functions are denoted by lambdas. At the very least, the empty function is denoted by any term you like. That is, a function type with empty domain has the same PER as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math>. However, any function is equal to a lambda, when considered only as a function. Formally, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>f</mi><mo>:</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo>⊢</mo><mi>f</mi><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Gamma,f:\Pi x:A.B \vdash f = (\lambda x.f\,x) \in \Pi x:A.B</annotation></semantics></math></div>
<p>as well as (the weaker)</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>f</mi><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>Hf</mi><mo>:</mo><mi>f</mi><mo>∈</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo>⊢</mo><mi>f</mi><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Gamma,f:Comp,Hf:f \in \Pi x:A.B \vdash f = (\lambda x.f\,x) \in \Pi x:A.B</annotation></semantics></math></div>
<p>but not</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>f</mi><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>Hf</mi><mo>:</mo><mi>f</mi><mo>∈</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo>⊢</mo><mi>f</mi><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">\Gamma,f:Comp,Hf:f \in \Pi x:A.B \vdash f = (\lambda x.f\,x) \in Comp</annotation></semantics></math></div>
<p>.</p>

<h4 id="congruence_rules">Congruence rules</h4>

<p>With such a small set of type constructors, it may be hard to tell, but congruence rules are rarely needed as primitives. Beta conversion was already defined as an untyped congruence closure, and for typed equality, the subsumptive rewrite rule does most of the work of congruence rules. The extensionality rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math> are needed to help with binders and (our ersatz) hidden assumptions. That may turn out to handle everything, with this judgmental setup.</p>

<h2 id="semantic_judgmental_reflection">Semantic Judgmental Reflection</h2>

<h3 id="equality_reflection">Equality reflection</h3>

<p>With many type theories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, it’s cumbersome but straightforward to define collections of the formal derivations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> as type families in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. This provides a form of <em>syntactic</em> reflection of a system’s judgments within itself. <a class="existingWikiWord" href="/nlab/show/provability+logic">There</a> <a class="existingWikiWord" href="/nlab/show/modal+type+theory">are</a> <a class="existingWikiWord" href="/nlab/show/higher-order+abstract+syntax">ways</a> of making syntactic reflection more convenient and/or powerful.</p>

<p>But Nuprl-style systems provide a quite different kind of judgmental reflection that we’ll call “<em>semantic</em> judgmental reflection”, or just “judgmental reflection” for short. The original example of judgmental reflection, and the basis of the name, is the equality reflection rule of extensional type theory (ETT), which makes the “identity” type family a reflection of the meaning of the element equality judgment of the same system. In a sense, this is still the only judgmental reflection principle in Nuprl-style systems. (But the type family is called “equality”.) The difference is in the interpretation of the equality judgment.</p>

<p>There are two styles of interpretation for ETT: <a class="existingWikiWord" href="/nlab/show/intrinsic+and+extrinsic+views+of+typing">intrinsic and extrinsic</a>. Extrinsic is the original, since an example is Martin-Löf’s <a class="existingWikiWord" href="/nlab/show/meaning+explanation">meaning explanation</a>, which was the original justification for equality reflection. Intrinsic seems to have become the default one. It’s the style considered in <a href="#HofmannThesis">Martin Hofmann’s thesis</a>, for example. But Nuprl and CLF commit to the extrinsic style.</p>

<p>An irony is that by considering terms extrinsically typed, you consider them intrinsically meaningful. In Nuprl and CLF, following Martin-Löf, terms have an intrinsic computational meaning. The role of the Nuprl-style type system is to reason about that. (Remember: this can all be considered a <a href="#AdmissSem">substitute for admissible rules</a>! …Probably.)</p>

<p>There is actually no interpretation necessary, for terms in general. The type system can be layered over the terms as they are, making use of an operational model of their computational meaning. (A denotational semantics would probably work too.) The details need not concern us here, but some things are important:</p>

<ul>
<li>Computational meaning pertains principally to closed terms, because free variables don’t compute; they’re just placeholders.</li>

<li>Some closed terms are designated as types, and denote PERs on closed terms.</li>

<li>For closed terms and types, the equality judgment form (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t = t' \in T</annotation></semantics></math>) just accesses the PER of the type.</li>

<li>For closed terms and types, the judgment of being an element of a type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \in T</annotation></semantics></math>) is a special case of equality.</li>

<li>It’s the judgments about closed terms that are reflected as closed types; judgments about open terms are not involved.</li>
</ul>

<p>All of these points are important to the design of a Nuprl-style system. But the one that seems to distinguish the approach from intrinsic typing is that being an element is a special case of equality. In the intrinsic approach, equality is only meaningful when applied to two terms known to have the same type. So being an element must be somehow prior to equality. But with the judgment of being an element as a special case of equality, it’s simultaneous.</p>

<p>A lot of the power of judgmental reflection is that it <em>can</em> be understood as reasoning about the computational content of the language as it actually is. But since it’s probably not <em>necessary</em> to interpret Nuprl-style systems as being about their own syntax, we should speak of “computations”, not “closed terms”. In CLF, however they’re interpreted, computations are axiomatized as the elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. (And actually, it may be that types need not be computations.) Types are PERs on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>, and are accessed by the equality judgment form, which is reflected by the equality type constructor. So you use equality types to reason about equality in types, and also membership of computations in types.</p>

<h3 id="OpenEq">Equality of Open terms</h3>

<p>So then what’s with all this respect (“<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math>”) stuff in the equality formation rule? If terms have an intrinsic computational meaning, and equality reasons about it, shouldn’t the rule be just:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash T\,type}{\Gamma \vdash t1 = t2 \in T\,type}</annotation></semantics></math></div>
<p>?</p>

<p>No, that doesn’t work. The extra complexity has to do with making the axiomatization work for open terms. Consider the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo stretchy="false">|</mo><mi>x</mi><mo>∈</mo><mi>Bool</mi><mo>∧</mo><mi>y</mi><mo>∈</mo><mi>Bool</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">I\;\coloneqq\;\{x = y | x \in Bool \wedge y \in Bool\}</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi><mo>=</mo><mi>fls</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">tru = fls \in I</annotation></semantics></math>. But then consider (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>I</mi><mo>⊢</mo><mi>tru</mi><mo>=</mo><mi>x</mi><mo>∈</mo><mi>Bool</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">x:I \vdash tru = x \in Bool\,type</annotation></semantics></math>). The simple formation rule would derive it, but it doesn’t make sense, because (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi><mo>=</mo><mi>tru</mi><mo>∈</mo><mi>Bool</mi></mrow><annotation encoding="application/x-tex">tru = tru \in Bool</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi><mo>=</mo><mi>fls</mi><mo>∈</mo><mi>Bool</mi></mrow><annotation encoding="application/x-tex">tru = fls \in Bool</annotation></semantics></math>) are different types, although <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi></mrow><annotation encoding="application/x-tex">tru</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fls</mi></mrow><annotation encoding="application/x-tex">fls</annotation></semantics></math> are the same <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math>. The problem is that equality of types and elements is generally different from equality of computations, and we want well-typed open terms to respect equality of elements. The respect-based equality formation rule doesn’t derive the bad type family because you’d need to find some type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> such that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>I</mi><mo>⊢</mo><mi>x</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">x:I \vdash x \Vdash T</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>≺</mo><mi>Bool</mi></mrow><annotation encoding="application/x-tex">T \prec Bool</annotation></semantics></math>). But if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>I</mi><mo>⊢</mo><mi>x</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">x:I \vdash x \Vdash T</annotation></semantics></math>), then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> considers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tru</mi></mrow><annotation encoding="application/x-tex">tru</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fls</mi></mrow><annotation encoding="application/x-tex">fls</annotation></semantics></math> equal, while if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>≺</mo><mi>Bool</mi></mrow><annotation encoding="application/x-tex">T \prec Bool</annotation></semantics></math>), then it doesn’t.</p>

<p>That variables and other open terms cannot generally be treated as computations is the sense in which variables are intrinsically typed: although elements are all realized by computations, an arbitrary element generally cannot be used as a computation, so reasoning about membership is constrained.</p>

<h3 id="other_semantic_judgments">Other semantic judgments</h3>

<p>Based on the ability to reason about membership, in addition to equality, other types can be defined that seem like semantic judgments. For example, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo></mrow><annotation encoding="application/x-tex">\lt\!\!:</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math> were <a href="#SemJudg">defined above</a>. But what kinds of things are these semantic judgments in general?</p>

<p>A lenient answer is that semantic judgments are type (families) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> such that any two elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> are equal (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> is a subsingleton), and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>J</mi><mo stretchy="false">⌋</mo><mo>→</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">\lfloor J \rfloor \to J</annotation></semantics></math>) is inhabited. That is, the squash-stable subsingletons. All such types are isomorphic to equality types, and are the <a class="existingWikiWord" href="/nlab/show/regular+subobjects">regular subobjects</a>, if you consider a Nuprl-style system as a category. (In a <a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory#DependentTypeTheory">manner analogous to ETT</a>, using inhabitedness of equality types to determine equality of morphisms.)</p>

<p>A stricter definition of semantic judgments is that they are type (families) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> such that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>J</mi><mo stretchy="false">⌋</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>J</mi></mrow><annotation encoding="application/x-tex">\lfloor J \rfloor \lt\!\!:\;J</annotation></semantics></math>). Types formed with equality, squash itself, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo></mrow><annotation encoding="application/x-tex">\lt\!\!:</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math> are always judgments in this strict sense. These types are extensionally equal to equality types (for example, this one: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">(\lambda x.x) \in J</annotation></semantics></math>) in the following sense:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≈</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo>∧</mo><mi>B</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>A</mi></mrow><annotation encoding="application/x-tex">A \approx B\;\coloneqq\;A \lt\!\!:\;B \wedge B \lt\!\!:\;A</annotation></semantics></math></p>

<p>This definition of extensional equality is motivated by the “subsumption” (derived) rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash t \Vdash A \qquad
\Gamma \vdash A \lt\!\!:\;B}
{\Gamma \vdash t \Vdash B}
</annotation></semantics></math></div>
<p>So <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math> gives us subsumptions in both directions. Extensionally equal types denote the same PER.</p>

<p>Thus, the semantic judgments in the strict sense are regular subobjects defined in a convenient way so that they’re inhabited if and only if they’re basically <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math> is itself a semantic judgment. Also:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>≈</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≈</mo><mo stretchy="false">(</mo><mi>A</mi><mo>⊑</mo><mi>B</mi><mo>∧</mo><mi>B</mi><mo>⊑</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \approx B) \approx (A \sqsubseteq B \wedge B \sqsubseteq A)</annotation></semantics></math></p>

<p>However, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>∧</mo><mi>B</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \subseteq B \wedge B \subseteq A</annotation></semantics></math>) is generally weaker. For example, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> have the same members (computations) but are not extensionally equal, or even isomorphic.</p>

<h2 id="constructive_propositions">Constructive Propositions</h2>

<p>We define <a class="existingWikiWord" href="/nlab/show/propositional+truncation">propositional truncation</a> as quotienting a type down to a subsingleton:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo><mo>≔</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo stretchy="false">|</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo>∧</mo><mi>y</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil \coloneqq \{x = y | x \in A \wedge y \in A\}</annotation></semantics></math></p>

<p>Unlike the squash of a type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>A</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor A \rfloor</annotation></semantics></math>), <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil</annotation></semantics></math> has the same set of computations as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. So from a computational perspective, a member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil</annotation></semantics></math> is just as useful as a member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. But well-typed computations using a member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil</annotation></semantics></math> are not allowed to depend on the identity of the member. So for example, a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\lceil A \rceil \to B</annotation></semantics></math> is a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mspace width="thinmathspace"></mspace><mo>:</mo><mspace width="thinmathspace"></mspace><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f\,:\,A \to B</annotation></semantics></math> such that for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>,</mo><mi>a</mi><mo>′</mo><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a,a':A</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mi>a</mi><mo>=</mo><mi>f</mi><mi>a</mi><mo>′</mo><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f a = f a' \in B</annotation></semantics></math>. So a map out of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil</annotation></semantics></math> is constant, but that’s still more permissive than a map out of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>A</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor A \rfloor</annotation></semantics></math>, which doesn’t have access to a member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>

<p>Let</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mi>A</mi><mo>≔</mo><mi>A</mi><mo>→</mo><mo>⊥</mo></mrow><annotation encoding="application/x-tex">\not A \coloneqq A \to \bot</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>dec</mi><mi>A</mi><mo>≔</mo><mo stretchy="false">{</mo><mi>b</mi><mo>:</mo><mi>Bool</mi><mo stretchy="false">|</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>b</mi><mo>=</mo><mi>tru</mi><mo>∈</mo><mi>Bool</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>b</mi><mo>=</mo><mi>fls</mi><mo>∈</mo><mi>Bool</mi><mo stretchy="false">)</mo><mo>→</mo><mo>¬</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">dec A \coloneqq \{b:Bool | ((b = tru \in Bool) \to A) \wedge ((b = fls \in Bool) \to \not A)\}</annotation></semantics></math></li>
</ul>

<p>By non-contradiction, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>dec</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dec A</annotation></semantics></math> is a subsingleton, so <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>dec</mi><mi>A</mi><mo stretchy="false">⌉</mo><mo>≈</mo><mi>dec</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">\lceil dec A \rceil \approx dec A</annotation></semantics></math>. The member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>dec</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dec A</annotation></semantics></math>, if you can get ahold of it, tells you whether <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is inhabited. On the other hand, a member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>dec</mi><mi>A</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor dec A\rfloor</annotation></semantics></math> tells you nothing: its existence means that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is either inhabited or not, but you still don’t know which. A member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mo>¬</mo><mo stretchy="false">(</mo><mi>dec</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\not \not (dec A)</annotation></semantics></math> also tells you nothing, and even its existence is uninformative: you can prove <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mo>¬</mo><mo stretchy="false">(</mo><mi>dec</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\not \not (dec A)</annotation></semantics></math> yourself, without knowing anything about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>

<p>There are implications <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo><mo>→</mo><mo stretchy="false">⌊</mo><mi>A</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil \to \lfloor A \rfloor</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>A</mi><mo stretchy="false">⌋</mo><mo>→</mo><mo>¬</mo><mo>¬</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\lfloor A \rfloor \to \not \not A</annotation></semantics></math>, going from more useful subsingletons to less useful subsingletons. There generally aren’t implications going in the other direction. You can sort of think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>A</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor A \rfloor</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mo>¬</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\not \not A</annotation></semantics></math> as truncating down to <a class="existingWikiWord" href="/nlab/show/proof+relevance">constructive</a>, <a class="existingWikiWord" href="/nlab/show/constructive+mathematics">intuitionistic</a>, and <a class="existingWikiWord" href="/nlab/show/classical+logic">classical</a> propositions, respectively. Here, the distinction between “constructive” and “intuitionistic” is that constructive logic is explicitly computational, whereas intuitionistic logic merely declines to assume anti-computational principles, like <a class="existingWikiWord" href="/nlab/show/excluded+middle">excluded middle</a>. (So for example, <a class="existingWikiWord" href="/nlab/show/constructive+set+theory">constructive set theory</a> is merely intuitionistic by this terminology, though it has constructive models.) (None of this has to do with <a class="existingWikiWord" href="/nlab/show/intuitionism">intuitionism</a>.)</p>

<p>It should be consistent to add the rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mo stretchy="false">(</mo><mo>¬</mo><mo>¬</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">⌊</mo><mi>A</mi><mo stretchy="false">⌋</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type}{\Gamma \vdash p \Vdash (\not \not A) \to \lfloor A \rfloor}</annotation></semantics></math></div>
<p>This makes the semantic judgments classical, rather than intuitionistic. Constructive propositions remain constructive, and <a class="existingWikiWord" href="/nlab/show/canonicity">canonicity</a> is not affected.</p>

<p>In contrast, having <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mo>¬</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\not \not A</annotation></semantics></math> imply <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌈</mo><mi>A</mi><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil A \rceil</annotation></semantics></math> is not known to be consistent, and it ruins canonicity. (It’s quite possible that it’s consistent with the current rules, but this is pure luck. In full Nuprl, the same implication is probably false, due to “partial” types.)</p>

<h2 id="ShortCirc">Short-Circuiting connectives</h2>

<p>Due to the <a href="#StructRules">lack of strengthening</a>, a funny thing happens when we consider the non-dependent special case of dependent connectives. Consider conjunction (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>), which we defined as a special case of subset:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi><mo>≔</mo><mo stretchy="false">{</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A \wedge B \coloneqq \{\underline{\;}:A | B\}</annotation></semantics></math></p>

<p>From the formation rule for subset, we derive the following formation rule for conjunction:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type \qquad \Gamma,\underline{\;}:A \vdash B\,type}
{\Gamma \vdash A \wedge B\,type}
</annotation></semantics></math></div>
<p>That is:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mo>∧</mo><mi>intro</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type \qquad
\Gamma,x:A \vdash B\,type \qquad x \notin FV(B)}
{\Gamma \vdash A \wedge B\,type}\;(\wedge intro1)
</annotation></semantics></math></div>
<p>With strengthening, this would be basically the same as:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mo>∧</mo><mi>intro</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type \qquad \Gamma \vdash B\,type}
{\Gamma \vdash A \wedge B\,type}\;(\wedge intro2)
</annotation></semantics></math></div>
<p>But without being able to strengthen the premises of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo>∧</mo><mi>intro</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\wedge intro1)</annotation></semantics></math> to those of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo>∧</mo><mi>intro</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\wedge intro2)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo>∧</mo><mi>intro</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\wedge intro1)</annotation></semantics></math> itself is generally <em>stronger</em> than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo>∧</mo><mi>intro</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\wedge intro2)</annotation></semantics></math>. Specifically, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> only needs to be a type if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is inhabited. So <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math> is a <em>short-circuiting</em> conjunction, kind of like the <code>&amp;&amp;</code> boolean operator from many programming languages, where the right conjunct need only be able to return a boolean when the left conjunct is true. (Because that’s the only case in which it’s evaluated.)</p>

<p>Implication is similarly short-circuiting, like a conditional expression from a programming language:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>→</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type \qquad \Gamma,\underline{\;}:A \vdash B\,type}
{\Gamma \vdash A \to B\,type}
</annotation></semantics></math></div>
<p>Short-circuiting disjunction doesn’t seem natural for types; what is a dependent <a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a>? But if the left disjunct is a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math>, there’s always (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>=</mo><mi>fls</mi><mo>∈</mo><mi>Bool</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">(a = fls \in Bool) \to B</annotation></semantics></math>). <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> only needs to be a type if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fls</mi></mrow><annotation encoding="application/x-tex">fls</annotation></semantics></math>. Given an element of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>=</mo><mi>fls</mi><mo>∈</mo><mi>Bool</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">(a = fls \in Bool) \to B</annotation></semantics></math>), by branching on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math>, we get either (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>tru</mi><mo>∈</mo><mi>Bool</mi></mrow><annotation encoding="application/x-tex">a = tru \in Bool</annotation></semantics></math>) or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>

<h2 id="more_admissiblederived_rules">More admissible/derived rules</h2>

<h3 id="bool_eliminations">Bool eliminations</h3>

<p>Combining (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo lspace="0em" rspace="thinmathspace">Comp</mo></mrow><annotation encoding="application/x-tex">Bool \lt\!\!:\;\Comp</annotation></semantics></math>) with the primitive elimination rule for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math>, you get this alternative elimination rule, where the motive is a family on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>tru</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>fls</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>Bool</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma,x:Comp \vdash C\,type \qquad
\Gamma \vdash c \Vdash C[tru/x] \qquad
\Gamma \vdash c \Vdash C[fls/x] \qquad
\Gamma \vdash b \Vdash Bool}
{\Gamma \vdash c \Vdash C[b/x]}
</annotation></semantics></math></div>
<p>Curiously, you can go in the other direction too, and get both of the original rules from this one.</p>

<p>To get the usual elimination rule, prove that Church booleans are self-eliminating functions:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Bool</mi><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>Bool</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>tru</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>→</mo><mi>C</mi><mo stretchy="false">[</mo><mi>fls</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>→</mo><mi>C</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma,x:Bool \vdash C\,type \qquad
\Gamma \vdash b \Vdash Bool}
{\Gamma \vdash b \Vdash C[tru/x] \to C[fls/x] \to C[b/x]}
</annotation></semantics></math></div>
<p>This is reasoning about membership, so we really do want to know that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math>s are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>s. The usual elimination rule then just applies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math> at that function type.</p>

<p>In Nuprl, it’s often possible to get induction rules without a premise showing that the motive is a valid family. The idea is that for sufficiently concrete types, validity of the motive can be proven pointwise, and moreover the cases of this proof are actually implied by the cases of the main induction.</p>

<p>In the current CLF rules though, it doesn’t seem possible to derive such rules. Also, including such strengthened induction rules as primitive doesn’t seem compatible with the <a href="#AdmissSem">current hybrid approach</a> based on admissible formal rules: the sanity check would require an unusual type validity rule, which would ruin the inversion lemma. Basically the Nuprl-style justification for omitting the motive premise is “too semantic” for the current hybrid approach.</p>

<h3 id="fun_with_subsets">Fun with subsets</h3>

<h3 id="subtyping">Subtyping</h3>

<p>Subtyping variance rules should be derivable for the type constructors. Here are some for the primitive type constructors:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>′</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>⊢</mo><mi>B</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo>′</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>.</mo><mi>B</mi><mo>′</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
\Gamma \vdash A\,type \qquad \Gamma,x:A \vdash B\,type \\
\Gamma \vdash A' \lt\!\!:\;A \qquad
\Gamma,x:A' \vdash B \lt\!\!:\;B'
\end{array}}
{\Gamma \vdash (\Pi x:A.B) \lt\!\!:\;(\Pi x:A'.B')}
</annotation></semantics></math></div>
<p>Yes, contravariance for function domains. A difference from subsetting in <a class="existingWikiWord" href="/nlab/show/material+set+theory">material set theory</a>. Family intersections are completely analogous:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>′</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>⊢</mo><mi>B</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo>′</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>.</mo><mi>B</mi><mo>′</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
\Gamma \vdash A\,type \qquad \Gamma,x:A \vdash B\,type \\
\Gamma \vdash A' \lt\!\!:\;A \qquad
\Gamma,x:A' \vdash B \lt\!\!:\;B'
\end{array}}
{\Gamma \vdash (\cap x:A.B) \lt\!\!:\;(\cap x:A'.B')}
</annotation></semantics></math></div>
<p>Subset is covariant in both positions:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>⊢</mo><mi>B</mi><mo>′</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mo>′</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo>′</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo stretchy="false">|</mo><mi>B</mi><mo>′</mo><mo stretchy="false">}</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
\Gamma,x:A' \vdash B'\,type \\
\Gamma \vdash A \lt\!\!:\;A' \qquad
\Gamma,x:A \vdash B \lt\!\!:\;B'
\end{array}}
{\Gamma \vdash \{x:A | B\} \lt\!\!:\;\{x:A' | B'\}}
</annotation></semantics></math></div>
<p>This rule can be strengthened, since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is proof irrelevant:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>⊢</mo><mi>B</mi><mo>′</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mo>′</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>m</mi><mo>⊩</mo><mi>B</mi><mo>→</mo><mi>B</mi><mo>′</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">}</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo stretchy="false">|</mo><mi>B</mi><mo>′</mo><mo stretchy="false">}</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
\Gamma,x:A' \vdash B'\,type \\
\Gamma \vdash A \lt\!\!:\;A' \qquad
\Gamma,x:A \vdash m \Vdash B \to B'
\end{array}}
{\Gamma \vdash \{x:A | B\} \lt\!\!:\;\{x:A' | B'\}}
</annotation></semantics></math></div>
<p>The intersection rule can be strengthened too, since the “argument” is irrelevant, but it’s not as pretty, because the type dependency is <em>not</em> irrelevant:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>m</mi><mo>⊩</mo><mi>A</mi><mo>′</mo><mo>→</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>m</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo>′</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>.</mo><mi>B</mi><mo>′</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
\Gamma \vdash A\,type \qquad \Gamma,x:A \vdash B\,type \\
\Gamma \vdash m \Vdash A' \to A \qquad
\Gamma,x:A' \vdash B[m\,x/x] \lt\!\!:\;B'
\end{array}}
{\Gamma \vdash (\cap x:A.B) \lt\!\!:\;(\cap x:A'.B')}
</annotation></semantics></math></div>
<h2 id="PERtheory">PER theory</h2>

<p>We have <a href="#UsuPiIn">seen</a> that in CLF (as in Nuprl) whether two terms are equal depends on what type we compare them at, and that we <a href="#OpenEq">need to care</a> about whether one type respects (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math>) another’s equality. This gives rise to three different (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math>) basic (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo></mrow><annotation encoding="application/x-tex">\lt\!\!:</annotation></semantics></math>) preorders (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊑</mo></mrow><annotation encoding="application/x-tex">\sqsubseteq</annotation></semantics></math>) on types, whereas <a class="existingWikiWord" href="/nlab/show/material+set+theory">material set theory</a> has just one. What does all this extra complexity buy us?</p>

<p>Very roughly, it buys us the ability to reason directly using realizers, rather than some other system of terms that denote mathematical objects that are realizable. Intuitively, the realizers are elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>, and are fairly intensional compared to most types of mathematical object. But the terms are still written as realizers, no matter the type.</p>

<p>More specifically, it’s an aspect of how quotients work that seems to be the root cause of the difference between set theory and “PER theory”. PER semantics provides <em>refinement-style quotients</em>: there are no operations needed for mapping into or out of quotients. Quotienting has zero overhead in terms, since terms are realizers, and computationally, quotients don’t change anything. It’s up to the semantics of the type system to make quotient types work correctly anyway.</p>

<p>Eventually, general subquotients should be definable in CLF as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mo>≔</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo stretchy="false">|</mo><mi>x</mi><mo>∈</mo><mi>T</mi><mo>∧</mo><mi>y</mi><mo>∈</mo><mi>T</mi><mo>∧</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x = y:T | R\} \coloneqq \{x = y | x \in T \wedge y \in T \wedge R\}</annotation></semantics></math></p>

<p>(Of course, this definition can already be written, but it doesn’t currently seem to have all the desired properties, due to missing rules.)</p>

<p>This is using the <a href="#ShortCirc">short-circuiting</a> behavior of conjunction to allow deriving a formation rule something like:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mn>1</mn><mo>:</mo><mi>T</mi><mo>,</mo><mi>x</mi><mn>2</mn><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>R</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>y</mi><mn>1</mn><mo>:</mo><mi>T</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>s</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo>→</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>y</mi><mn>1</mn><mo>:</mo><mi>T</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>T</mi><mo>,</mo><mi>y</mi><mn>3</mn><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo>→</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo>→</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}\Gamma \vdash T\,type \qquad \Gamma,x1:T,x2:T \vdash R\,type \\
\Gamma,y1:T,y2:T \vdash s \Vdash R[y1,y2/x1,x2] \to R[y2,y1/x1,x2] \\
\Gamma,y1:T,y2:T,y3:T \vdash t \Vdash R[y1,y2/x1,x2] \to R[y2,y3/x1,x2] \to R[y1,y3/x1,x2]\end{array}}
{\Gamma \vdash \{x1 = x2:T | R\}\,type}
</annotation></semantics></math></div>
<p>So we expect <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> be a family on a pair of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>s, which means that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> equality is respected in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>, and therefore in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x = y:T | R\}</annotation></semantics></math>. And by definition, a member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x = y:T | R\}</annotation></semantics></math> is a member of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. That is, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>≺</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T \prec \{x = y:T | R\}</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mo>⊆</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\{x = y:T | R\} \subseteq T</annotation></semantics></math>), so therefore (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mo>⊑</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\{x = y:T | R\} \sqsubseteq T</annotation></semantics></math>).</p>

<p>In case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is also reflexive for members of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>: (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo>⊢</mo><mi>r</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mo>,</mo><mi>y</mi><mo stretchy="false">/</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Gamma,y:T \vdash r \Vdash R[y,y/x1,x2]</annotation></semantics></math>), then we also have (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>⊆</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T \subseteq \{x = y:T | R\}</annotation></semantics></math>). Combining with respect, we get (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T \lt\!\!:\;\{x = y:T | R\}</annotation></semantics></math>). In this case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x = y:T | R\}</annotation></semantics></math> is a (full) quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lambda x.x</annotation></semantics></math>) realizes the quotient <em>projection</em> mapping from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x = y:T | R\}</annotation></semantics></math>.</p>

<p>Taking stock, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/regular+and+exact+completions#TheExLexCompletion">pseudo-equivalence relation</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, we have:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mo>⊆</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\{x = y:T | R\} \subseteq T</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>⊆</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T \subseteq \{x = y:T | R\}</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>≺</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T \prec \{x = y:T | R\}</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo><mo>⊑</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\{x = y:T | R\} \sqsubseteq T</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>T</mi><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T \lt\!\!:\;\{x = y:T | R\}</annotation></semantics></math></li>
</ul>

<p>Since we have member inclusion in both directions, according to set theory, this “quotient” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is not actually any different from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. But to PER theory, it’s the same set of realizers, but with a possibly coarser equality. We can see the difference with our old friend, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi><mo>≡</mo><mo stretchy="false">⌈</mo><mi>Bool</mi><mo stretchy="false">⌉</mo><mo>≈</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>:</mo><mi>Bool</mi><mo stretchy="false">|</mo><mo>⊤</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">I \equiv \lceil Bool \rceil \approx \{x = y:Bool | \top\}</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> is a singleton, but <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> is not.</p>

<p>In set theory, the intuition behind quotients is that a quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> is a set of equivalence classes of members of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>. So <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> and its quotient generally have different members. The effect on equality is a consequence of <a class="existingWikiWord" href="/nlab/show/axiom+of+extensionality">set extensionality</a>. With PERs, this intuition is superficially contradicted by the semantic judgments, so it should be used with care, or not at all.</p>

<p>In programming, programmers informally use quotients, probably mostly without realizing it. For example, when using hash tables to implement finite maps, the representation has extra implementation details like the number of buckets, and the assignment of keys to buckets. Any meaningful results given to the user should not depend on this information. That doesn’t mean that the computation of the results should not depend on it, but that the results should not vary due to changes in implementation details. Programmers know that, so they effectively treat hash tables as quotient types where implementation details have been modded out. And no operations on equivalence classes of hash tables will be found in the program; programming languages provide no such thing. So the programmer’s quotient is not the set theoretic quotient construction, it’s the refinement-style quotient codified by PER theory.</p>

<p>(What seems to be missing from the current rules is a way to prove that you can map out of a quotient by mapping out of the base type in a way that respects the equivalence relation. For example, to allow using a hash table correctly by proving that only implementation details of the result vary with implementation details of the hash table.)</p>

<p>However, for many purposes, it may be a net improvement to give up on refinement-style quotients in order to get the simplicity of set theory. Refinement-style quotients seem particularly <a href="#QIIF">well suited</a> to CLF’s use as a metalogic, though.</p>

<h2 id="CLFasLF">CLF and Logical Frameworks</h2>

<p><a class="existingWikiWord" href="/nlab/show/logical+framework">Logical frameworks</a> provide a formal notation for languages. (Especially languages that support logical deduction.) The kind of logical framework CLF aims to provide is one that represents dependent type systems using HOAS signatures.</p>

<p>The logical framework “<a class="existingWikiWord" href="/nlab/show/LF">LF</a>” uses HOAS, and can already represent seemingly any language, including dependent type systems. But the issue is not only whether a language can be represented at all, but how “deep” the encoding is. With a <em>shallow</em> encoding, the framework representation of encoded expressions of the language is close to a custom representation tailored to that language. With a <em>deep</em> encoding, a lot of overhead is introduced by the encoding, making the framework representation much less convenient than a custom one.</p>

<p>LF’s use of HOAS makes the encoding of many languages shallower, but only works for languages that can be expressed using <a class="existingWikiWord" href="/nlab/show/natural+deduction">natural-deduction</a>-style rules. (That includes the degenerate case of languages with no binding forms. That is, <a class="existingWikiWord" href="/nlab/show/combinatory+logic">combinator</a> languages.) So to encode <a class="existingWikiWord" href="/nlab/show/substructural+logic">substructural</a> languages, for example, evidence of substructural variable use needs to be handled explicitly, unlike with a custom representation.</p>

<p>There are two styles of HOAS-based encoding associated with LF, called “synthetic” and “analytic”. (See the <a class="existingWikiWord" href="/nlab/show/logical+framework">logical framework</a> page.) Synthetic is a deeper style of encoding than analytic, but analytic only works for languages where type equality is just <a class="existingWikiWord" href="/nlab/show/alpha+equivalence">alpha equivalence</a>.</p>

<p>The formal description of a language in LF and similar logical frameworks is called a “signature”, since it’s similar to a <a class="existingWikiWord" href="/nlab/show/signature+%28in+logic%29">signature</a> for some fixed logic.</p>

<h3 id="martinlfs_logical_framework">Martin-Löf’s Logical Framework</h3>

<p>To see how equality reflection is useful for a logical framework, we will propose an extension of LF, called “LF=” (LF with equality), that combines the shallowness of LF’s analytic encoding with more of the flexibility of LF’s synthetic encoding. (But in LF=, the encoding is generally not analytic, in the sense of algorithmic judgments. That’s the catch.) But first, it’s instructive to cover analytic encoding in Martin-Löf’s logical framework (“MLLF”).</p>

<p>Unlike LF, MLLF doesn’t have a fixed judgmental equality. Term formers are specified in roughly the same intrinsically typed way as with the analytic encoding for LF. But meanwhile, judgmental equality rules for the object language are added by adding corresponding judgmental equality rules to the framework. Thus, MLLF can shallowly encode many type systems with analytic judgments, not just the ones where type equality is very simple, like with LF. MLLF is particularly well suited to specifying variants of Martin-Löf type theory.</p>

<p>MLLF is defined and discussed in Martin-Löf’s <a href="#AnaSynJudg">Analytic and Synthetic Judgements in Type Theory</a> and in part III of <a href="#ProgMLTT">Programming in Martin-Löf’s Type Theory</a>. The former reference also discusses the notions of analytic and synthetic judgment, while the latter makes it perhaps clearer how the “theory of types” is intended to be used as a logical framework. Martin-Löf’s main theory of mathematical collections is the “theory of sets”, which is specified using the logical framework.</p>

<p>There are tools that provide a style of language specification very similar to MLLF. <a href="https://deducteam.github.io/">Dedukti</a> implements a logical framework similar to LF, but signatures can also include typed rewrite rules that extend judgmental equality. There’s an <a href="#AgdaJudgRewr16">Agda feature</a> that allows proven or hypothesized equations to be declared as rewrites that extend judgmental equality. This can presumably be combined with axioms to imitate Dedukti signatures, and quite possibly more.</p>

<p>These tools are designed under the assumption that, while open-ended, judgmental equality remains analytic. That is, it’s something that you can sanely just check automatically. (Or so the story goes.) Trying to add extensional type theory’s equality reflection rule to a rewrite engine is not going to work. It generally won’t have a good way to solve the premise that proves the equation. (Either the system will give up, or do something useless.)</p>

<p>The equality reflection rule is enough to make the judgments synthetic. That is, something you generally have to prove. To handle type systems with synthetic judgments, you either need to use a synthetic encoding (for example, in LF or Isabelle), or use a tool designed to handle synthetic judgments, like Nuprl, <a href="http://metaprl.org/">MetaPRL</a>, <a href="#Andromeda">Andromeda</a>, or (eventually, hopefully) CLF.</p>

<h3 id="LFEq">LF=</h3>

<p>Like LF, and unlike MLLF, LF= has a fixed judgmental equality. Unlike either LF or MLLF, this judgmental equality is synthetic, because LF= has equality reflection. (LF=’s typing judgment form is synthetic as well, for the usual reason that it makes use of judgmental equality.)</p>

<p>LF= is LF plus a reflective equality type constructor. (Combined with LF’s eta equality for function types, this gets function extensionality.) But still no equality kinds. LF is often formulated such that only canonical forms (beta normal, eta long) are well typed. This probably does not work for LF=; use your favorite way of formulating extensional type theory. (The details don’t matter here, since I’m going to propose CLF as a generalization of LF=.)</p>

<p>To encode an intrinsically typed language in LF=, you can declare intrinsically typed constants/axioms in LF=, much like LF’s analytic encoding:</p>

<pre><code>tp : Type
el : tp -&gt; Type

Pi : {A:tp} (el A -&gt; tp) -&gt; tp
lam : {A:tp} {B:el A-&gt;tp} ({a:el A} el (B a)) -&gt; el (Pi A B)
app : {A:tp} {B:el A-&gt;tp} el (Pi A B) -&gt; {a:el A} el (B a)</code></pre>

<p>Like in MLLF, the object language’s judgmental equality is identified with the framework’s judgmental equality. This means you don’t need to encode congruence rules. Interesting equality rules are encoded by assuming an equation:</p>

<pre><code>pi_beta : {A:tp} {B:el A-&gt;tp} {b:{a:el A} el (B a)} {a:el A} app A B (lam A B b) a = b a
pi_eta : {A:tp} {B:el A-&gt;tp} {f:el (Pi A B)} f = lam A B ([a] app A B f a)</code></pre>

<p>Unlike MLLF, these axioms are just additional constants; there is no restriction other than that they be well typed declarations in LF=. Although these equations are just constants, by using equality reflection to use them, no coercions appear in the terms. If using LF= equations added a coercion to the term, LF= equality would not be an adequate representation of judgmental equality. (The adequacy of reflective equality is inspired by <a href="#Andromeda">Andromeda</a>.)</p>

<p>For an example of why using equality reflection in the framework doesn’t automatically make the object language extensional, we will cover the non-derivability of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>nat</mi><mo>,</mo><mi>m</mi><mo>:</mo><mi>nat</mi><mo>⊢</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>≡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mspace width="thickmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>nat</mi></mrow><annotation encoding="application/x-tex">n:nat,m:nat \vdash n + m \equiv m + n\;:\;nat</annotation></semantics></math>) in intensional type theory. So we add natural numbers:</p>

<pre><code>nat : tp

zro : el nat
suc : el nat -&gt; el nat

natrec : ...

natrec_zro : ...
natrec_suc : ...</code></pre>

<p><code>natrec</code> should be the dependent elimination form for the inductive type of natural numbers. <code>natrec_zro</code> and <code>natrec_suc</code> are its defining equations.</p>

<p>We can then define—in the metalanguage—a derived form</p>

<pre><code>plus : el nat -&gt; el nat -&gt; el nat</code></pre>

<p>using <code>natrec</code>. We will write (<code>plus n m</code>) as (<code>n + m</code>).</p>

<p>The judgment (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>nat</mi><mo>,</mo><mi>m</mi><mo>:</mo><mi>nat</mi><mo>⊢</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>≡</mo><mi>m</mi><mo>+</mo><mi>n</mi><mspace width="thickmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>nat</mi></mrow><annotation encoding="application/x-tex">n:nat,m:nat \vdash n + m \equiv m + n\;:\;nat</annotation></semantics></math>) is represented as (<code>{n:el nat} {m:el nat} n + m = m + n</code>). There is “obviously” no LF= term of that type, since there’s no induction principle for the LF= type <code>el nat</code>, and the only interesting equations about <code>el nat</code> don’t apply for a general element. The object language has <code>natrec</code> as an induction principle, but that only works for proving object language types, not LF= equality.</p>

<p>Of course, if we add reflective equality to the <em>object language</em>, then we should be able to combine <code>natrec</code> and the object language’s equality reflection to prove the LF= equation. Here is a reflective equality type constructor:</p>

<pre><code>eq : {T:tp} el T -&gt; el T -&gt; tp
eqI : {T:tp} {t:el T} el (eq T t t)
eqE : {T:tp} {t1 t2:el T} el (eq T t1 t2) -&gt; t1 = t2
eqK : {T:tp} {t:el T} {p:el (eq T t t)} p = eqI T t</code></pre>

<p><code>eqE</code> is the equality reflection rule for the object language. Note that there’s no trouble declaring this constant. It’s just another judgmental equality rule for the object language. LF= was prepared all along for equality requiring proof. On the other hand, that means that it requires <em>boring</em> proof in the common case that it’s obvious. So an implementation of LF= would have a practical need for proof automation, to effect type checking of the object language.</p>

<p>Part of the rationale behind CLF—and seemingly many other type system implementations based on synthetic judgments—is that there’s no <em>implementation</em> reason to distinguish type checking from other forms of proof automation. That type checking really is just automatic “proving” of judgments.</p>

<p>On the other hand, if you insist upon decidable type checking, that would be a reason to distinguish type checking from general proof automation. Implementers of synthetic type systems seem united in not considering decidability an important property of type checking.</p>

<h3 id="lf_signatures_as_inductiveinductive_families">LF Signatures as Inductive-Inductive Families</h3>

<p>LF, MLLF, and LF= are all specialized, weak languages, wherein the object language is specified as a list of assumptions. CLF is not. Although it’s still fairly weak, it’s supposed to be strong enough to actually prove stuff. In CLF, the object language is defined as some number of mutually <a class="existingWikiWord" href="/nlab/show/inductive-inductive+type">inductive-inductive families</a>.</p>

<p>Declared LF type families correspond to CLF inductive type family definitions. The declared element formers for declared LF families correspond to the constructors of the CLF inductive families. Since multiple families can be declared in LF prior to declaring elements, the CLF inductive families are mutually defined, in general. And since there can also be type dependencies between the families, induction-induction is generally necessary.</p>

<p>LF signatures are not ordinary inductive-inductive families. Although the constructors can take functions as arguments, this does not denote an infinitary constructor, as found in <a class="existingWikiWord" href="/nlab/show/W-types">W-types</a>. Instead, a constructor applied to a function argument denotes an expression with a <a class="existingWikiWord" href="/nlab/show/bound+variable">binding</a> subexpression. This is the HOAS interpretation of function types: applying a function just substitutes into an open expression. Since binding and substitution are rather tame notions from formal syntax, there are no restrictions on recurrences in the inductive definition. For example, a recurrence is allowed in the domain of a function type, unlike with infinitary <a class="existingWikiWord" href="/nlab/show/inductive+types">inductive types</a>.</p>

<p>HOAS should be used in CLF too. But unlike LF, this doesn’t involve function types, since CLF’s maps out of an inductive definition allow case analysis, which would not be an adequate representation of binding subexpressions. Instead, lambdas from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> can be used as the representation of binding subexpressions. In the family definitions, free variables will presumably be kept track of explicitly, as usual for an inductive definition of a formal system. It should be possible to develop some generic definition of the families, for some broad type of signature codes. (It should include at least all LF= signatures. See below.)</p>

<p>In other words, in CLF, the HOAS interpretation of signatures should be definable; it’s not just part of the metatheory. This should allow CLF to serve as both a logical framework, and a metalanguage for reasoning about derivability. With sufficient proof automation, reasoning about derivability allows the convenient use of object languages. The shallowness of the encoding avoids much of the notational inconvenience and computational overhead usually present when reasoning via a metalanguage definition.</p>

<h3 id="QIIF">Quotient-Inductive-Inductive Families as Refinements</h3>

<p>The addition of reflective equality types to LF= has the consequence that LF= signatures correspond to quotient inductive-inductive families, not just plain inductive-inductive families. The declarations concluding with an equality type correspond to equality constructors.</p>

<p>In CLF, quotienting is actually needed just to define inductive-inductive families, since lambdas in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> don’t already satisfy the eta conversion rule of LF’s function type. So in principle, supporting quotient inductive-inductive families should be a straightforward modification to the construction. Due to the use of <a href="#PERtheory">refinement-style quotients</a>, quotienting the inductive-inductive families doesn’t make the encoding any deeper.</p>

<h2 id="references">References</h2>

<ul>
<li id="AnandRahliITP14">
<p>Abhishek Anand, Vincent Rahli, <em>Towards a Formally Verified Proof Assistant</em>, Interactive Theorem Proving (ITP) 2014 (<a href="http://www.nuprl.org/html/Nuprl2Coq/">project web</a>, <a href="http://www.nuprl.org/KB/show.php?ID=726">paper web</a>, <a href="http://www.nuprl.org/documents/Anand/TowardsAFormallyVerifiedProofAssistant.pdf">pdf</a>)</p>
</li>

<li id="PERTypes14">
<p>Abhishek Anand, Mark Bickford, <a class="existingWikiWord" href="/nlab/show/Robert+Constable">Robert L. Constable</a>, Vincent Rahli, <em>A Type Theory with Partial Equivalence Relations as Types</em>, Types for Proofs and Programs (TYPES) 2014 (<a href="https://vrahli.github.io/articles/slides-per-types.pdf">slides</a>, <a href="http://www.nuprl.org/KB/show.php?ID=722">web</a>, <a href="http://www.nuprl.org/documents/Anand/ATypeTheoryWithPartialEquivalenceRelationsAsTypes.pdf">pdf</a>)</p>
</li>

<li id="HofmannThesis">
<p><a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, <em>Extensional concepts in intensional type theory</em>, Ph.D. dissertation, University of Edinburgh (1995). (<a href="http://www.lfcs.inf.ed.ac.uk/reports/95/ECS-LFCS-95-327/">link</a>)</p>
</li>

<li id="SterlingHarperRefinement">
<p><a class="existingWikiWord" href="/nlab/show/Jonathan+Sterling">Jonathan Sterling</a>, <a class="existingWikiWord" href="/nlab/show/Robert+Harper">Robert Harper</a>, <em>Algebraic Foundations of Proof Refinement</em>, 2017 (<a href="https://arxiv.org/abs/1703.05215">arXiv</a>)</p>
</li>

<li id="Andromeda">
<p><a class="existingWikiWord" href="/nlab/show/Andrej+Bauer">Andrej Bauer</a>, Gaëtan Gilbert, Philipp G. Haselwarter, <a class="existingWikiWord" href="/nlab/show/Matija+Pretnar">Matija Pretnar</a>, Christopher A. Stone, <em>Design and Implementation of the Andromeda Proof Assistant</em>, 2018 (<a href="https://arxiv.org/abs/1802.06217v1">arXiv</a>, <a href="http://www.andromeda-prover.org/">project web</a>)</p>
</li>

<li id="AnaSynJudg">
<p><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a>, <em>Analytic and Synthetic Judgments in Type Theory</em>, 1994 (<a href="http://archive-pml.github.io/martin-lof/pdfs/Martin-Lof-Analytic-and-Synthetic-Judgements-in-Type-Theory.pdf">pdf</a>)</p>
</li>

<li id="ProgMLTT">
<p>Bengt Nordström, Kent Petersson, Jan M. Smith, <em>Programming in Martin-Löf’s Type Theory</em>, Oxford University Press (1990) (<a href="http://www.cse.chalmers.se/research/group/logic/book/">web</a>)</p>
</li>

<li id="AgdaJudgRewr16">
<p>Jesper Cockx, Andreas Abel, <em>Sprinkles of extensionality for your vanilla type theory</em>, Types for Proofs and Programs (TYPES) 2016 (<a href="http://www.cse.chalmers.se/~abela/types16-cockx.pdf">pdf</a>)</p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on July 11, 2020 at 22:13:36.
    See the <a href="/nlab/history/CompLF" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/CompLF" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/9916/#Item_47">Discuss</a><span class="backintime"><a href="/nlab/revision/CompLF/62" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/CompLF" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/CompLF" accesskey="S" class="navlink" id="history" rel="nofollow">History (62 revisions)</a>
  <a href="/nlab/show/CompLF/cite" style="color: black">Cite</a>
  <a href="/nlab/print/CompLF" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/CompLF" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
