
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      CompLF/HOAS in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      CompLF/HOAS
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/11554/#Item_4" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#secondorder_formulation_of_rules'>Second-order formulation of rules</a></li>
<ul>
<li><a href='#miscellaneous'>Miscellaneous</a></li>
<li><a href='#equality'>Equality</a></li>
<li><a href='#identity'>Identity</a></li>
<li><a href='#functions'>Functions</a></li>
<li><a href='#intersection'>Intersection</a></li>
<li><a href='#subset'>Subset</a></li>
<li><a href='#computations'>Computations</a></li>
<li><a href='#booleans'>Booleans</a></li>
<li><a href='#per'>PER</a></li>
</ul>
<li><a href='#JudgReason'>Judgment-level reasoning</a></li>
<ul>
<li><a href='#vs_reasoning_about_reflected_judgments'>Vs reasoning about Reflected Judgments</a></li>
<ul>
<li><a href='#open_vs_closed_terms'>Open vs “Closed Terms”</a></li>
<li><a href='#presuppositions'>Presuppositions</a></li>
<li><a href='#DiffPresup'>Type Expressions differing only in their Presuppositions</a></li>
<li><a href='#related_pairs_of_computations'>Related Pairs of Computations</a></li>
<li><a href='#lessons'>Lessons</a></li>
</ul>
<li><a href='#NonNegate'>“Non-negatable” Types</a></li>
<ul>
<li><a href='#membership_in_a_type_formerly'>Membership in a Type (Formerly)</a></li>
<li><a href='#TpOK'>Type Validity</a></li>
<li><a href='#membership_in_a_type_sometimes'>Membership in a Type (Sometimes)</a></li>
</ul>
<li><a href='#CombTruth'>Combined Truth</a></li>
<ul>
<li><a href='#CombElim'>Elimination into Combined Truth</a></li>
</ul>
<li><a href='#IdType'>Identity</a></li>
</ul>
<li><a href='#CheckingMode'>Checking Mode</a></li>
<ul>
<li><a href='#basics'>Basics</a></li>
<li><a href='#functions_2'>Functions</a></li>
<li><a href='#caveat'>Caveat</a></li>
</ul>
<li><a href='#StrTpV'>Strengthening Type Validity</a></li>
<ul>
<li><a href='#TpV'>Type Validity</a></li>
<li><a href='#custom_presuppositions'>Custom Presuppositions</a></li>
</ul>
<li><a href='#PartLogic'>Partial Logic</a></li>
<ul>
<li><a href='#frege_structures'>Frege Structures</a></li>
<li><a href='#FSLogic'>Fitch-Scott Partial Logic</a></li>
<ul>
<li><a href='#paradox_and_partiality'>Paradox and Partiality</a></li>
<li><a href='#squadge'>Squadge</a></li>
<li><a href='#partial_sequent_calculus'>Partial Sequent Calculus</a></li>
<li><a href='#recursive_classes'>Recursive Classes</a></li>
<li><a href='#dependent_types'>Dependent Types</a></li>
<li><a href='#what_about_kripke'>What about Kripke?</a></li>
</ul>
<li><a href='#free_logic'>Free Logic</a></li>
<ul>
<li><a href='#negative_positive_neutral'>Negative, Positive, Neutral</a></li>
<li><a href='#outer_domain'>Outer Domain</a></li>
<li><a href='#quantification_over_outer_domain'>Quantification over Outer Domain</a></li>
</ul>
</ul>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>The <a class="existingWikiWord" href="/nlab/show/CompLF+v1">rules of CompLF</a> have been designed so that <a class="existingWikiWord" href="/nlab/show/structural+rules">structural rules</a> (e.g. weakening and substitution) are admissible, and the remaining rules can be expressed as higher-order abstract syntax (HOAS) axioms in <a class="existingWikiWord" href="/nlab/show/logical+frameworks">logical frameworks</a> like <a class="existingWikiWord" href="/nlab/show/LF">LF</a> or <a class="existingWikiWord" href="/nlab/show/Isabelle">Isabelle</a>/Pure. (Except the variable rule, which isn’t needed in HOAS form.) This is a significant (but superficial) difference from Nuprl. Two major interesting things happen with this HOAS formulation of CompLF.</p>

<p>First, the HOAS formulation highlights a connection between dependent type systems and partial logic. The connection is there for all dependent type systems formulated as deductive systems with judgments on raw terms (untyped <span class="newWikiWord">abstract syntax<a href="/nlab/new/abstract+syntax">?</a></span> trees), but Nuprl-like systems make more use of the connection than most.</p>

<p>Second, although the rules are not algorithmic, there is implicit propagation of type validity facts in the semantics, which is analogous to the type propagation of a dependent type checker. The primitive typing judgment form (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) outputs validity of the type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>). But using the inversion rules, it’s possible to derive rules for a defined typing judgment form that inputs type validity. This will hopefully be useful for verifying a bidirectional proof checker for CompLF and similar systems.</p>

<h2 id="secondorder_formulation_of_rules">Second-order formulation of rules</h2>

<p>This section repeats some of the rules of v1 in HOAS style, since variables and substitution (of terms) are technically expressed differently. For convenience, here is the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Nat</mi></mrow><annotation encoding="application/x-tex">Nat</annotation></semantics></math> elimination rule from <a class="existingWikiWord" href="/nlab/show/CompLF+v1">v1</a>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>n</mi><mo>⊩</mo><mi>Nat</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>zro</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>,</mo><mi>h</mi><mo>:</mo><mi>C</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>suc</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
\Gamma \vdash n \Vdash Nat \qquad
\Gamma,x:Nat \vdash C\,type \\
\Gamma \vdash c \Vdash C[zro/x] \\
\Gamma,x:Nat,h:C \vdash c \Vdash C[suc(x)/x]
\end{array}}
{\Gamma \vdash c \Vdash C[n/x]}
</annotation></semantics></math></div>
<p>And here it is in a traditional HOAS form:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>natElim</mi><mspace width="thinmathspace"></mspace><mo>:</mo><mspace width="thinmathspace"></mspace><mo>∀</mo><mi>n</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>C</mi><mo>.</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⊩</mo><mi>Nat</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⊩</mo><mi>Nat</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo></mrow><annotation encoding="application/x-tex">natElim\,:\,\forall n,c,C.(n \Vdash Nat) \Rightarrow
(\forall x.(x \Vdash Nat) \Rightarrow (C(x)\,type)) \Rightarrow</annotation></semantics></math><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>zro</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>,</mo><mi>h</mi><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⊩</mo><mi>Nat</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>h</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>suc</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\qquad (c \Vdash C(zro)) \Rightarrow
(\forall x,h.(x \Vdash Nat) \Rightarrow (h \Vdash C(x)) \Rightarrow (c \Vdash C(suc(x)))) \Rightarrow</annotation></semantics></math><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\qquad (c \Vdash C(n))</annotation></semantics></math></p>

<p>So in the HOAS formulation of rules, the judgment forms are atomic relation symbols in a predicate logic, and the rules are axioms. Note that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in this example rule is a <em>function</em> in the HOAS formulation. But it’s a function of the logical framework, not of the object language. When rules quantify over functions, that’s second-order quantification.</p>

<p>Translating ordinary rules into HOAS lands in a second-order fragment. There’s a somewhat standard notation for rules of this fragment, which leaves the quantifiers implicit, and more resembles ordinary rules. (Meta)variables “declared” to the left of a turnstile in a “premise” are quantified just in that premise; the rest are quantified at the outside of the rule. Note that all the premise-local quantifiers only quantify over terms, which is first-order. Here is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>natElim</mi></mrow><annotation encoding="application/x-tex">natElim</annotation></semantics></math> in this “second-order” notation:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>n</mi><mo>⊩</mo><mi>Nat</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>zro</mi><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>,</mo><mi>h</mi><mo>:</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>suc</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
n \Vdash Nat \qquad
x:Nat \vdash C[x]\,type \\
c \Vdash C[zro] \\
x:Nat,h:C[x] \vdash c \Vdash C[suc(x)]
\end{array}}
{c \Vdash C[n]}
</annotation></semantics></math></div>
<p>Much nicer, right? Note that the variable declarations effect both a quantifier and a typing hypothesis. So the special status of typing judgments working like context entries is built into the notation.</p>

<p>The rest of the rules we repeat in HOAS form will be given now in this second-order notation. Many rules will not be repeated because there’s no guesswork in translating them.</p>

<h3 id="miscellaneous">Miscellaneous</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{a \Vdash A}{A\,type}</annotation></semantics></math></div>
<h3 id="equality">Equality</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>p</mi><mn>1</mn><mo>=</mo><mi>p</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">(</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo>′</mo><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{a \Vdash A}{q \Vdash p1 = p2 \in (a = a \in A)} \\
\\
\frac{p \Vdash a = a' \in A}{a \Vdash A} \\
\\
\frac{p \Vdash a = a' \in A \qquad
x:A \vdash C[x]\,type \qquad
c \Vdash C[a]}
{c \Vdash C[a']}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="identity">Identity</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>t</mi><mo>≡</mo><mi>t</mi><mo>′</mo><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>t</mi><mo>′</mo><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{p \Vdash t \equiv t' \qquad c \Vdash C[t]}{c \Vdash C[t']}</annotation></semantics></math></div>
<h3 id="functions">Functions</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>f</mi><mspace width="thinmathspace"></mspace><mi>a</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>=</mo><mi>f</mi><mo>′</mo><mspace width="thinmathspace"></mspace><mi>x</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>f</mi><mo>=</mo><mi>f</mi><mo>′</mo><mo>∈</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{A\,type \qquad x:A \vdash B[x]\,type}{\Pi x:A.B[x]\,type} \\
\\
\frac{\Pi x:A.B[x]\,type}{A\,type} \\
\\
\frac{\Pi x:A.B[x]\,type \qquad a \Vdash A}{B[a]\,type} \\
\\
\\
\frac{f \Vdash \Pi x:A.B[x] \qquad a \Vdash A}{f\,a \Vdash B[a]} \\
\\
\frac{A\,type \qquad
x:A \vdash p[x] \Vdash f\,x = f'\,x \in B[x]}
{q \Vdash f = f' \in \Pi x:A.B[x]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="intersection">Intersection</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>b</mi><mo>⊩</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{b \Vdash \cap x:A.B[x] \qquad a \Vdash A}{b \Vdash B[a]} \\
\\
\frac{A\,type \qquad
x:A \vdash p[x] \Vdash b = b' \in B[x]}
{q \Vdash b = b' \in \cap x:A.B[x]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="subset">Subset</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><mrow><mi>a</mi><mo>⊩</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>a</mi><mo>⊩</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊢</mo><mi>c</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{x:A \vdash B[x]\,type \qquad
a \Vdash A \qquad b \Vdash B[a]}
{a \Vdash \{x:A | B[x]\}} \\
\\
\frac{a \Vdash \{x:A | B[x]\} \qquad
x:A,y:B[x] \vdash c[x] \Vdash C[x]}
{c[a] \Vdash C[a]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="computations">Computations</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>x</mi><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>Comp</mi></mrow><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>Comp</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>y</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>x</mi><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>h</mi><mo>:</mo><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⊢</mo><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo>,</mo><mi>h</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>c</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo>′</mo><mo stretchy="false">[</mo><mi>x</mi><mo>′</mo><mo stretchy="false">]</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>q</mi><mo>⊩</mo><mi>c</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo>′</mo><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{x:Comp \vdash b[x] \Vdash Comp}{\lambda x.b[x] \Vdash Comp} \\
\\
\frac{\begin{array}{l}
a \Vdash A \qquad
y:A \vdash C[y]\,type \\
x:Comp,x':Comp,h:(x = x' \in A) \vdash
p[x,x',h] \Vdash c[x] = c'[x'] \in C[x]
\end{array}}
{q \Vdash c[a] = c'[a] \in C[a]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="booleans">Booleans</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>b</mi><mo>⊩</mo><mi>Bool</mi><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>tru</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>fls</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{b \Vdash Bool \qquad
c \Vdash C[tru] \qquad
c \Vdash C[fls]}
{c \Vdash C[b]}
</annotation></semantics></math></div>
<h3 id="per">PER</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>x</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>x</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>R</mi><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>y</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>s</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊃</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>1</mn><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>y</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>3</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>t</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">]</mo><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊃</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">]</mo><mo>⊃</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>p</mi><mo>⊩</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mtd></mtr> <mtr><mtd><mi>R</mi><mo stretchy="false">[</mo><mi>t</mi><mn>1</mn><mo>,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>h</mi><mo>:</mo><mi>R</mi><mo stretchy="false">[</mo><mi>t</mi><mn>1</mn><mo>,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi></mtd></mtr></mtable><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\begin{array}{l}
x1:Comp,x2:Comp \vdash R[x1,x2]\,type \\
y1:Comp,y2:Comp \vdash s[y1,y2] \Vdash R[y1,y2] \supset R[y2,y1] \\
y1:Comp,y2:Comp,y3:Comp \vdash t[y1,y2,y3] \Vdash R[y1,y2] \supset R[y2,y3] \supset R[y1,y3]
\end{array}}
{\{x1 = x2 | R[x1,x2]\}\,type} \\
\\
\frac{\begin{array}{l}
p \Vdash t1 = t2 \in \{x1 = x2 | R[x1,x2]\} \\
R[t1,t2]\,type \\
h:R[t1,t2] \vdash c \Vdash C
\end{array}}
{c \Vdash C}
\end{gathered}
</annotation></semantics></math></div>
<h2 id="JudgReason">Judgment-level reasoning</h2>

<p>Reasoning at the judgment level using this logical framework is not as convenient as having a type checker for terms, or even as convenient as having a Nuprl-like proof refiner that extracts the realizers. But it’s very straightforward and expressive. It can be used to prove derived rules, and other facts about derivability that aren’t of the form to be rules. For example, you can show that adding a certain new rule would allow deriving a contradiction.</p>

<p>Many unusual phenomena of Nuprl-like systems become clearer when analyzed in terms of judgment-level reasoning.</p>

<h3 id="vs_reasoning_about_reflected_judgments">Vs reasoning about Reflected Judgments</h3>

<p>In Nuprl-like systems, the semantic judgments are reflected internally as squashed types, and can be reasoned about using propositions-as-types. The logical framework gives us a way to reason about formal judgments. Aside from the ability to reason about “large” judgment forms like type validity, is this judgment-level reasoning actually different from internal reasoning? It turns out it is.</p>

<p>For example, consider the framework formula:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math></div>
<p>The puzzle is to find, assuming (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">B\,type</annotation></semantics></math>), a type that’s provably inhabited if and only if that formula is derivable. In more detail, we want some framework function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> such that:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>.</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mo>∃</mo><mi>p</mi><mo>.</mo><mi>p</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall A,B.(A\,type) \Rightarrow (B\,type) \Rightarrow
((\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)) \Leftrightarrow (\exists p.p \Vdash R(A,B)))
</annotation></semantics></math></div>
<p>A couple of perhaps-plausible-looking solutions for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A,B)</annotation></semantics></math> are (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.(t \in A) \to (t \in B)</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mo>⊤</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:\top.(t \in A) \to (t \in B)</annotation></semantics></math>). But both of these are wrong. The first is too weak (you get left-to-right only) and the second is not even a type (which makes existence of an element too strong).</p>

<p>The framework formula we’re trying to represent turns out to be asserting that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a subtype of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, since it can be read as a special case of the subsumption rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>t</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>t</mi><mo>⊩</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{t \Vdash A}{t \Vdash B}</annotation></semantics></math></div>
<p>So we can take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A,B)</annotation></semantics></math> to be (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>). In fact, the first wrong answer is what we called “inclusion” (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math>).</p>

<h4 id="open_vs_closed_terms">Open vs “Closed Terms”</h4>

<p>So how come (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.(t \in A) \to (t \in B)</annotation></semantics></math>) don’t correspond? I mean, the intuitive reason is that subtyping is not just member inclusion, it must also preserve equations. But what is the formal reason? We have the fact that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>p</mi><mo>.</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>p</mi><mo>⊩</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p.(a \Vdash A) \Leftrightarrow (p \Vdash a \in A)</annotation></semantics></math></div>
<p>so the difference between (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊩</mo></mrow><annotation encoding="application/x-tex">\Vdash</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math>) is not the mismatch. The mismatch turns out to be the quantifiers used.</p>

<p>It turns out (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.(t \in A) \to (t \in B)</annotation></semantics></math>) is inhabited if and only if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>Comp</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash Comp) \Rightarrow (t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>). So there’s an extra (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t \Vdash Comp</annotation></semantics></math>) requirement making inclusion weaker than subtyping.</p>

<p>If you think about how adequacy of a HOAS representation works, the logical framework quantifiers over terms are quantifying over <em>open</em> terms, specifically. Meanwhile the object language quantifiers range over the elements of a type, and in the PER semantics, elements of types are represented by <em>closed</em> terms. The open terms behave differently because PER semantics also enforces respect for typed equality, and in the formal system, this requirement is implicit.</p>

<p>But equality at the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> type is just computational equivalence, which is respected by all the semantic judgments. So when dealing with computations, the implicit respect requirements are vacuous, and the framework reasoning about arbitrary open terms closely resembles semantic reasoning about arbitrary closed terms. This might be part of the reason why <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> is sometimes glossed as the type of all closed terms, although this technically doesn’t make sense. (Semantically, many types contain all the closed terms, while syntactically, no type can rule out variables.)</p>

<p>Another reason for the intuition that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> is the type of closed terms is that there’s an admissible rule saying that any closed term has type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. (This rule cannot be represented in HOAS style without some modal trick. The proof is by structural induction on the term, and uses the appropriate computation formation rule in each case. The motive needs to be generalized in order to handle binding forms.)</p>

<p>Returning to the issue of subtyping vs inclusion, one could think of inclusion as the closed special case of subtyping. It’s only because of the restriction to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> that the (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t \in A) \to (t \in B)</annotation></semantics></math>) part corresponds to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>), as explained in the next section.</p>

<h4 id="presuppositions">Presuppositions</h4>

<p>So if quantifying over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> adds an undesired (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t \Vdash Comp</annotation></semantics></math>) requirement, quantifying over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math> seems closer, since the requirement (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mo>⊤</mo></mrow><annotation encoding="application/x-tex">t \Vdash \top</annotation></semantics></math>) is trivial. But in general, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>D</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:D.(t \in A) \to (t \in B)</annotation></semantics></math>) corresponds to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>D</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash D) \Rightarrow ((t \in A)\,type \wedge ((t \Vdash A) \Rightarrow (t \Vdash B)))</annotation></semantics></math>). With (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t \Vdash Comp</annotation></semantics></math>), (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">(t \in A)\,type</annotation></semantics></math>) is derivable, but in general, its derivability depends on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>

<p>So since (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mo>⊤</mo></mrow><annotation encoding="application/x-tex">t \Vdash \top</annotation></semantics></math>) is trivial, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mo>⊤</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:\top.(t \in A) \to (t \in B)</annotation></semantics></math>) corresponds to just (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \in A)\,type \wedge ((t \Vdash A) \Rightarrow (t \Vdash B))</annotation></semantics></math>), but the (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\forall t.(t \in A)\,type</annotation></semantics></math>) part is too strong. Due to relaxed equality, it’s saying that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> is basically the same as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math>, which is usually not so.</p>

<p>The root of the problem is that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) is not interderivable with (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x:A \vdash f\,x \Vdash B[x]</annotation></semantics></math>) in general, but rather (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A\,type) \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>). From the perspective of <a class="existingWikiWord" href="/nlab/show/intrinsic+and+extrinsic+views+of+typing">intrinsic typing</a>, it doesn’t make sense to regard (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) as part of the <em>truth</em> of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>). Instead, it’s a “presupposition”: something that has to be true for (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) to even <em>make sense</em>.</p>

<p>The full presupposition of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) is (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type</annotation></semantics></math>). That (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) is interderivable with (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A\,type) \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>), and not (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>), (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type \Rightarrow (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>), or something even weirder, is due to the “presupposition policy” the judgment forms are using. (Is there a better term for this?) (Technically, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>) is also interderivable, but it redundantly checks (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">x:A \vdash B[x]\,type</annotation></semantics></math>).)</p>

<p>As a practical matter, presuppositions don’t validate themselves, so a proof assistant needs some policy on when/how they get validated. In Nuprl-like systems, the presuppositions are all instances of the type validity judgment. Although they generally cannot be checked automatically, as mentioned in the <a href="#idea">idea section</a>, propagation of type validity resembles type propagation in a type checker.</p>

<p>Validity/definedness of type expressions is propagated differently than elements of the types are. Various formation and inversion rules for type constructors, combined with various typing judgment forms, yield various styles of type (validity) propagation, and provide a policy for handling presuppositions. This is a running theme of this page.</p>

<p>A related approach to presupposition policy comes from <em>partial logics</em>: logics in which formulas may not be meaningful propositions, in the sense that they fail to denote a truth value. The case in type theory is the possibility of type expressions that are not valid, in that they don’t denote a semantic type. But classical partial logics provide a different perspective on non-denoting formulas, which avoids having any primitive validity judgment. This is discussed in <a href="#PartLogic">later sections</a>.</p>

<p>If the presuppositions can be checked automatically (as in most dependent type checkers), the presupposition policy is not so visible to the user, but it’s still there. When trying to represent judgment-level assertions as types though, the details of the presupposition policy become important.</p>

<p>Getting back to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mo>⊤</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:\top.(t \in A) \to (t \in B)</annotation></semantics></math>) failing to correspond to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>), the problem is that the forms of implication generally don’t correspond, due to the implicit requirement to check that the type-level implication is a valid type. Assuming a <em>type</em> incurs an obligation to show that the expression is in fact a type, while assuming a <em>judgment</em> has no implicit obligation.</p>

<h4 id="DiffPresup">Type Expressions differing only in their Presuppositions</h4>

<p>It looks like the type-level assumption (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">(t \in A) \to ...</annotation></semantics></math>) is not going to work. Let’s take a closer look at what the solution (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) is doing instead. Subtyping was defined as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B\;\coloneqq\;(\lambda x.x) \in (A \to B)</annotation></semantics></math></p>

<p>Using the computation formation rules, we have (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">\lambda x.x \Vdash Comp</annotation></semantics></math>). By assumption, we have (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">B\,type</annotation></semantics></math>), so by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> formation, we have (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">(A \to B)\,type</annotation></semantics></math>). Finally, equality formation gives us (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda x.x) \in (A \to B)</annotation></semantics></math>).</p>

<p>That this sort of representation is a type at all is actually the clever part. Using the representation of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \Vdash T</annotation></semantics></math>) as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \in T</annotation></semantics></math>), and the rules for functions, it’s now straightforward that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) represents (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>).</p>

<p>But it seems like there’s a less tricky solution: (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>). Both (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) and this assume <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> itself, rather than (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t \in A</annotation></semantics></math>). And that <em>is</em> the way you’re supposed to do it in type theory, after all. The standard wisdom is that typing judgments are not something you can assume. We have just covered in detail <em>why</em> that is still the case with Nuprl-like extensions.</p>

<p>(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>) does technically solve the problem: if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">B\,type</annotation></semantics></math>), then</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>p</mi><mo>.</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>p</mi><mo>⊩</mo><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p.(\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)) \Leftrightarrow (p \Vdash \Pi a:A.a \in B)</annotation></semantics></math></p>

<p>This implies that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>) is inhabited when it should be, and is squashed, moreover. There’s something disappointing about this solution though: while (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) is a type whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> are, validity of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>) entails that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a:A \vdash a \Vdash Relax(B)</annotation></semantics></math>). In other words, that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> equality is respected in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. This should only be a <em>consequence</em> of subtyping, not a <em>presupposition</em> of it.</p>

<p>Specifically,</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>⇔</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \lt\!\!:\;B)\,type \Leftrightarrow (A\,type \wedge (\underline{\;}:A \vdash B\,type))</annotation></semantics></math> and</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>⇔</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi a:A.a \in B)\,type \Leftrightarrow (A\,type \wedge (a:A \vdash a \Vdash Relax(B)))</annotation></semantics></math>.</li>
</ul>

<p>So these semantic judgments are true at the same time, but have different presuppositions. For the problem of representing semantic judgments as types, it seems that the moral of the story is to close off a term as much as possible before reasoning about membership, if you want to avoid presuppositions.</p>

<h4 id="related_pairs_of_computations">Related Pairs of Computations</h4>

<p>There is actually another solution though: the big-hammer approach of reasoning about pairs of computations: (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mi>Π</mi><mi>t</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.\Pi t':Comp.(t = t' \in A) \to (t = t' \in B)</annotation></semantics></math>). This representation makes it explicit that subtyping implies respect for equality. Thanks in part to the let-comp rule, this type is completely equivalent to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>): the presuppositions are the same, and they have the same PER.</p>

<h4 id="lessons">Lessons</h4>

<p>The puzzle of representing the subtyping judgment as a type operation has been chosen because the discussion of solutions, plausible false solutions, and partial solutions touches upon many important issues of judgment-level reasoning. Here is a summary of important lessons we tried to convey:</p>

<ul>
<li>The judgment forms that have interesting presuppositions are the <em>semantic</em> judgment forms, which are implemented as <em>type</em> operations.</li>

<li>The presupposition(s) of a semantic judgment represented as a type are simply the things you need to show in order to show that the type is valid.</li>

<li>The formal judgment forms don’t have interesting presuppositions; only that the expressions involved are syntactically well-formed, which can be checked while parsing.</li>

<li>Type-level implication (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math>) and judgment-level implication (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⇒</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \Rightarrow Y</annotation></semantics></math>) are not the same, even when the types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> represent the corresponding judgments <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, because of presuppositions.</li>

<li>Two type expressions can have the same meaning in case they’re both meaningful, but differ in their presuppositions, the conditions under which they’re meaningful.</li>

<li>Respect for typed equality is automatically enforced by “open” reasoning about arbitrary elements, but can/must be done manually when doing “closed” reasoning about computations.</li>
</ul>

<p>All but the last point also apply—via propositions-as-types—to a style of partial logic that <a class="existingWikiWord" href="/nlab/show/Peter+Aczel">Peter Aczel</a> called “Frege structures”. Partial logic, Frege structures, and the connection to Nuprl-like systems are discussed <a href="#PartLogic">below</a>.</p>

<p>The last point—about respect for equality, except when dealing with elements of a particular type—seems very peculiar to PER semantics. You don’t need PER semantics to get those other “Frege phenomena”, and you don’t need PER semantics to get implicit respect for extensional equality, but the way they interact in PER semantics is quite extraordinary.</p>

<h3 id="NonNegate">“Non-negatable” Types</h3>

<p>We have <a href="#DiffPresup">seen</a> that just because a judgment form is representable as a type operation doesn’t mean that that type operation gets you a valid type in all the situations you might want. In the most extreme case of this, the type is only meaningful when it’s true. In other words, the type presupposes itself. Karl Crary <a href="#KCThesis">called</a> these types “non-negatable”, since they’re intuitively either true or nonsense, never false. Assuming a non-negatable type with a type-level implication is guaranteed to be useless, since you must prove it in order to safely assume it.</p>

<h4 id="membership_in_a_type_formerly">Membership in a Type (Formerly)</h4>

<p>Crary’s main example of a non-negatable type was membership (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>). Membership is not non-negatable in Nuprl anymore, since Nuprl switched to a more liberal equality. It’s also not non-negatable in CompLF, which uses relaxed equality. Membership is still “harder to negate” than one might like, as we saw.</p>

<p>But in Martin-Löf type theory, and earlier versions of Nuprl, the equality semantic judgment/type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mn>1</mn><mo>=</mo><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a1 = a2 \in A</annotation></semantics></math>) presupposes (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mn>1</mn><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a1 \in A</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a2 \in A</annotation></semantics></math>). Since the membership <em>type</em> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) is an abbreviation for equality (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a = a \in A</annotation></semantics></math>), it presupposed itself. (With membership non-negatable, Crary added subtyping as a primitive type constructor, or else it would’ve been non-negatable as well.)</p>

<h4 id="TpOK">Type Validity</h4>

<p>There is another semantic judgment which is still non-negatable: type validity. It’s kind of a weird trick that this judgment is representable as a type. (Coincidentally, Crary noticed the trick, and used it, arguing that it was more convenient than membership in an arbitrary universe.) It sounds like there’d be a size paradox, right? Well that’s why there’s probably nothing that can be done about the non-negatability.</p>

<p>So what’s the big trick? Basically, to use almost any trivially true proposition that mentions the type. We’ll use:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mo>⊃</mo><mo>⊤</mo></mrow><annotation encoding="application/x-tex">TpOK(A)\;\coloneqq\;A \supset \top</annotation></semantics></math></p>

<p>The trick is that it’s only “trivially true” when it’s a valid type, which requires that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a valid type. So it’s either true or nonsense; it’s non-negatable. We have:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>p</mi><mo>.</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>p</mi><mo>⊩</mo><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p.(A\,type) \Leftrightarrow (p \Vdash TpOK(A))</annotation></semantics></math></p>

<p>The right-to-left direction crucially relies on the sanity rule (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \Vdash A) \Rightarrow (A\,type)</annotation></semantics></math>) and an inversion rule.</p>

<h4 id="membership_in_a_type_sometimes">Membership in a Type (Sometimes)</h4>

<p>Although membership is not <em>always</em> non-negatable anymore, because (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) presupposes (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \Vdash Relax(A)</annotation></semantics></math>), it’s still non-negatable whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> are the same. This is precisely when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. (And in that case, Nuprl’s (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">A \cup Comp</annotation></semantics></math>) would be the same as well, so Nuprl’s membership would also be non-negatable.)</p>

<h3 id="CombTruth">Combined Truth</h3>

<p>Hopefully, the <a href="#TpOK">representability of type validity</a> shows better what’s “really” going on with representability of judgment forms. When truth of a squashed type is used at the judgment level, it’s not just the intuitive truth—which <em>presupposes</em> validity—that’s being used; it’s some “combined truth”, which <em>implies</em> validity, via the sanity rule.</p>

<p>When assuming the truth of a type using type-level implication, you assume the usual truth, and presuppositions are accumulated. But when assuming the truth of a type using judgment-level implication, you assume combined truth. Keep in mind that the derivation rules themselves are all assertions of judgment-level implications, and are thus working with combined truth.</p>

<p>So technically, combined truth comes from the (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) formal judgment form, when we only really care about whether <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is inhabited. In general, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> is an element of it. Meanwhile the type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) intuitively says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> is an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, <em>presupposing</em> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \Vdash Relax(A)</annotation></semantics></math>). Since the latter <em>implies</em> that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math>—and therefore <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>—are types, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) indirectly presupposes that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type. Combined truth of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) combines its intuitive truth with its presuppositions, and thus ends up the same as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>).</p>

<p>As for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpOK(A)</annotation></semantics></math>, the intuitive truth is vacuous, and the presupposition is basically just that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type, so the combined truth of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpOK(A)</annotation></semantics></math> says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type.</p>

<h4 id="CombElim">Elimination into Combined Truth</h4>

<p>Some of the elimination rules do not have a premise requiring that the elimination motive be a valid type family. The substitution instance of the motive appearing in the conclusion still must be a valid type, due to combined truth. But the validity of that substitution instance follows from the validity of substitution instances obtained from the premises.</p>

<p>This is the case for identity elimination (rewrite), subset elimination, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> elimination, and PER comprehension elimination. Although they’re ostensibly not eliminating anything, the direct computation rules are similar in that they can be used to rewrite with beta conversion in any typing goal.</p>

<p>Because combined truth allows many semantic judgment forms—even <a href="#TpOK">type validity</a>—to be represented as typing judgments, these “combined elimination” principles are stronger than they may look.</p>

<p>A common problem with the representation of judgment forms as type operations is the reliance on combined truth, which means that presuppositions are carrying some or all of the weight, but they don’t get propagated in the same way as ordinary truth.</p>

<p>If an elimination rule requires a premise showing that the motive is a valid type family, the presupposition part of combined truth effectively has to be shown prior to the application of the rule. In other words, such ordinary elimination rules help to conclude ordinary truth only. But with a combined elimination rule, there is no motive validity premise, so the rule helps to conclude the combined truth of the motive.</p>

<p>Here are some consequences of combined elimination on represented judgments:</p>

<ul>
<li>You can beta convert in the subject of a typing judgment, not just the type.</li>

<li>You can beta convert in a type validity judgment.</li>

<li>Same goes for rewriting with an identity.</li>

<li>You can branch on a boolean in a valid type.</li>
</ul>

<p>That last one—type-level branching—is provided by the following derived rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>b</mi><mo>⊩</mo><mi>Bool</mi><mspace width="2em"></mspace><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>F</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mo stretchy="false">(</mo><mi>b</mi><mspace width="thinmathspace"></mspace><mi>T</mi><mspace width="thinmathspace"></mspace><mi>F</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{b \Vdash Bool \qquad T\,type \qquad F\,type}{(b\,T\,F)\,type}</annotation></semantics></math></div>
<p>This is shown by eliminating <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math> with the motive (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>≔</mo><mi>TpOK</mi><mo stretchy="false">(</mo><mi>x</mi><mspace width="thinmathspace"></mspace><mi>T</mi><mspace width="thinmathspace"></mspace><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C[x] \coloneqq TpOK(x\,T\,F)</annotation></semantics></math>). Since type validity is non-negatable, we would not be able to show this motive to be valid except by proving each case. But proving each case is exactly why we want to use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> elimination in the first place! So without the combined elimination, we’d be in an infinite regress. As for proving each case, it goes by beta reducing the applied Church boolean, yielding one of the premises.</p>

<h3 id="IdType">Identity</h3>

<p>(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t1 = t2 \in Comp</annotation></semantics></math>) intuitively says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computationally equivalent. But it presupposes that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computations, so the combined truth is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are the same computation.</p>

<p>The identity type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>≡</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t1 \equiv t2</annotation></semantics></math>) also says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computationally equivalent, but the presupposition has been weakened, so that combined truth does <em>not</em> imply that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computations.</p>

<p>Because computational equivalence does not respect typed equality, except for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> type (and its subtypes), (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>≡</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t1 \equiv t2</annotation></semantics></math>) is not generally a type unless <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computations. That is, it’s only a type family over a pair of computations. But surprisingly, some instances of identity are valid types although <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are not computations. In particular, if the terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computationally equivalent, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>≡</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t1 \equiv t2</annotation></semantics></math>) is (combined) true.</p>

<p>That identity is often not known to be a type doesn’t get in the way of assuming it with <em>judgment-level</em> implication. For example, you can prove derived rules showing that identity is symmetric and transitive. Indeed, identity is in some sense the “real” equality of judgment-level reasoning: it’s intuitively a relation on <em>terms</em>, not elements of a type; it’s an equivalence relation; and it rewrites in any open type expression, not just valid type families.</p>

<p>(TODO: Explain how many presuppositions arise from intensional type equality, and that equality of identity types is extensional, making them valid when they’re pointwise true. Maybe on another page.)</p>

<h2 id="CheckingMode">Checking Mode</h2>

<p>The sanity rule says that the usual formal typing judgment (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) implies type validity (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>). This is analogous to the <em>admissible</em> sanity rule of unidirectional typing rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mspace width="thinmathspace"></mspace><mi>ctx</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mspace width="thinmathspace"></mspace><mo>:</mo><mspace width="thinmathspace"></mspace><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma\,ctx \qquad \Gamma \vdash a\,:\,A}{\Gamma \vdash A\,type}</annotation></semantics></math></div>
<p>In a unidirectional type checker, type validity being a conclusion of sanity goes well with the type expression itself being an output of the type checker. In a <a class="existingWikiWord" href="/nlab/show/bidirectional+typechecking">bidirectional type checker</a>, there are two modes: “synthesizing mode” inputs a term and (if it succeeds) outputs a type it has, and “checking mode” inputs a term and a type, and checks the term against the type.</p>

<p>Although CompLF’s primitive rules are not algorithmic, we can think of the typing judgment (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) as corresponding to the synthesizing mode of bidirectional typing, due to the sanity rule. This section defines another formal judgment form (logical framework predicate) to correspond to the checking mode, and derives rules that propagate type validity bidirectionally.</p>

<h3 id="basics">Basics</h3>

<p>Here is the defined judgment:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \ni a\;\coloneqq\;(A\,type) \Rightarrow (a \Vdash A)</annotation></semantics></math></p>

<p>The intuition is that a derivation of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) includes a derivation of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>), which is accessed using the sanity rule. So any rule that concludes with a judgment of form (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) is effectively outputting a derivation of type validity as well as typing.</p>

<p>By defining (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \ni a</annotation></semantics></math>) as an implication assuming type validity, a rule that concludes with a judgment of that form will be implicitly taking the type validity judgment as an extra premise, and inputting a derivation of it. (Intuitively, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \ni a</annotation></semantics></math>) inputs <em>and</em> outputs type validity, but it doesn’t matter because (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⇒</mo><mo stretchy="false">(</mo><mi>X</mi><mo>∧</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \Rightarrow (X \wedge Y)</annotation></semantics></math>) is equivalent to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⇒</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \Rightarrow Y</annotation></semantics></math>).)</p>

<p>So synthesizing mode (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) outputs type validity, while checking mode (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \ni a</annotation></semantics></math>) inputs it. We can immediately derive the rules that change direction:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{a \Vdash A}{A \ni a} \qquad
\frac{A\,type \qquad A \ni a}{a \Vdash A}
</annotation></semantics></math></div>
<p>The rule on the left has type validity coming in from both directions. For algorithmic rules, the types themselves would be coming in, and they would need to be compared. The rule here would just mean to check that they’re syntactically equal, and an algorithm for dependent type checking would usually do something much smarter. But since these rules are not algorithmic, we just do the stupid thing for illustration purposes.</p>

<p>The rule on the right explicitly takes type validity, and propagates it out in both directions. In algorithmic rules, the type itself would need to be given to the rule via a type annotation on the term in the conclusion.</p>

<p>Here’s a more interesting direction change rule using subsumption:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>t</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo>∋</mo><mi>p</mi></mrow><mrow><mi>B</mi><mo>∋</mo><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{t \Vdash A \qquad A \lt\!\!:\;B \ni p}{B \ni t}</annotation></semantics></math></div>
<p>Deriving this rule, we receive the validity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> from the first premise, and the validity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> from the conclusion, form the validity of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) in order to use the second premise, which lets us change <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> from an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> to a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>

<h3 id="functions_2">Functions</h3>

<p>With a unidirectional type checker (that does not use nonlocal inference), lambdas need a type annotation for the function domain. This corresponds to the type validity premise in the (derived) lambda rule of CompLF:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{A\,type \qquad x:A \vdash b[x] \Vdash B[x]}{\lambda x.b[x] \Vdash \Pi x:A.B[x]}</annotation></semantics></math></div>
<p>As with bidirectional type checking, we can avoid this by making the rule checking mode:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∋</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∋</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x:A \vdash B[x] \ni b[x]}{\Pi x:A.B[x] \ni \lambda x.b[x]}</annotation></semantics></math></div>
<p>Note that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∋</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x:A \vdash B[x] \ni b[x]</annotation></semantics></math>) is notation for (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>x</mi><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∋</mo><mi>b</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall x.(x \Vdash A) \Rightarrow (B(x) \ni b(x))</annotation></semantics></math>). That is, context entries are always synthesizing mode in our notation.</p>

<p>The unidirectional rule for function application receives two candidates for the domain of the function: one from the function itself, one from the argument. So it needs to compare them. The bidirectional rule eliminates (or at least postpones) this check by using checking mode on the argument. We can derive an analogous rule for CompLF:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><mrow><mi>f</mi><mspace width="thinmathspace"></mspace><mi>a</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{f \Vdash \Pi x:A.B[x] \qquad A \ni a}{f\,a \Vdash B[a]}</annotation></semantics></math></div>
<p>(TODO: Put up more rules)</p>

<h3 id="caveat">Caveat</h3>

<p>When reasoning at the judgment level, the bidirectional rules don’t actually seem to make most things easier, and they make many things less convenient. There are now two judgment forms for typing, making rules incompatible without manually switching directions. Avoiding type validity premises is <em>usually</em> not that helpful because those premises are usually easy, so it’s easier to just follow your nose through them than cleverly avoid them. Since a main point of judgment-level reasoning is to derive new rules, sticking to a bidirectional style tends to multiply the number of derived rules you want, creating extra work.</p>

<p>It seems like a better idea to postpone a serious attempt at a bidirectional rule set until you have an actual algorithm in mind. At that point, the defined checking mode judgment might make it much easier to prove sound those bidirectional rules you will actually use.</p>

<p>Sometimes though, even for judgment-level reasoning, bidirectional rules can avoid a large number of very silly subgoals, like when introducing an element of a deeply nested type. In this case, the unidirectional rules would make you prove many copies of the same type validity goals, and bidirectional rules are the perfect plumbing.</p>

<h2 id="StrTpV">Strengthening Type Validity</h2>

<p>Most of the primitive type constructors have inversions for their formation rules. When deriving rules for a new “type constructor” defined using PER comprehension, an extra trick or two are needed to get the inversion rules you want.</p>

<p>The reason why inversion rules are usually desirable when deriving a type constructor is that the elimination rules typically need to know that the subexpressions of the type being eliminated are well-typed. (Type subexpressions are valid; element subexpressions have the appropriate type.) These facts are proven when forming the type, so it’s only fair to be able to get back what you’ve paid for. Otherwise they would need to be proven again whenever applying an elimination rule. (This is assuming the derived rules are for the primitive typing judgment, where the introduction rules establish type validity. For <a href="#CheckingMode">checking mode</a> rules you would expect introduction rules to avoid that, but this also requires inversion rules.)</p>

<p>The PER comprehension type constructor itself does not have any formation inversion rules. Partially this is because a later version of CompLF may strengthen the introduction rules in a way that’s incompatible with the obvious inversion rule. But mostly it’s because the inversion rule wouldn’t really help. It’s easier and more flexible to add your own type validity conditions than to take whatever falls out of the PER comprehension.</p>

<p>For example, suppose we’re deriving <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> types. We should start with the PER for a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> type:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><mi>p</mi><mo>=</mo><mi>p</mi><mo>′</mo><mo stretchy="false">|</mo><mo>∃</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo>′</mo><mo>,</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>.</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo>∧</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>∧</mo><mi>p</mi><mo>≡</mo><mo stretchy="false">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">⟩</mo><mo>∧</mo><mi>p</mi><mo>′</mo><mo>≡</mo><mo stretchy="false">⟨</mo><mi>a</mi><mo>′</mo><mo>,</mo><mi>b</mi><mo>′</mo><mo stretchy="false">⟩</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma' x:A.B[x]\;\coloneqq\;\{p = p' | \exists a,a',b,b':Comp.a = a' \in A \wedge b = b' \in B[a] \wedge p \equiv \lang a,b \rang \wedge p' \equiv \lang a',b' \rang\}</annotation></semantics></math></p>

<p>Where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∃</mo></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math> is defined as a squashed subset, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\lang a,b \rang</annotation></semantics></math> is some encoding of ordered pairs, suppose.</p>

<p>We could try to derive the inversion rules</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Sigma' x:A.B[x]\,type}{A\,type} \qquad
\frac{\Sigma' x:A.B[x]\,type \qquad a \Vdash A}{B[a]\,type}
</annotation></semantics></math></div>
<p>for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Sigma'</annotation></semantics></math> somehow by pulling things out of that (relatively) complicated PER comprehension. But it’s easier to just define another type operation (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma x:A.B[x]</annotation></semantics></math>) to be just like (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma' x:A.B[x]</annotation></semantics></math>), but only a valid type if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi x:A.B[x]</annotation></semantics></math>) is. (The choice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> over the other type constructors with the same validity conditions is arbitrary.)</p>

<h3 id="TpV">Type Validity</h3>

<p>We can define a utility type constructor to add a type validity condition to another type, while leaving its PER unmodified:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⊃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">TpV(A | B)\;\coloneqq\;TpOK(B) \supset A</annotation></semantics></math></p>

<p>Intuitively, we want some kind of validity-level conjunction, so it’s unintuitive that this definition uses implication (non-dependent intersection). But for validity, type-level implication <em>is</em> actually a conjunction. (That’s another way to see why type-level implications mess up reasoning about combined truth.)</p>

<p>If we used</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>wrong</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpV(A | B)\;\coloneqq\;\{\underline{\;}:A | TpOK(B)\} \qquad (wrong)</annotation></semantics></math></p>

<p>it would only add the validity condition (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\underline{\;}:A \vdash B\,type</annotation></semantics></math>). And if we used</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∧</mo><mi>A</mi><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>wrong</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpV(A | B)\;\coloneqq\;TpOK(B) \wedge A \qquad (wrong)</annotation></semantics></math></p>

<p>it would squash <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, so the PER would generally not be the same. (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⊃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">TpOK(B) \supset A</annotation></semantics></math>) is not the only way to do it, but it seems like a good way to do it.</p>

<p>Here are the derived rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{A\,type \qquad B\,type}{TpV(A | B)\,type} \\
\\
\frac{TpV(A | B)\,type}{A\,type} \qquad
\frac{TpV(A | B)\,type}{B\,type} \\
\\
\\
\frac{B\,type \qquad a \Vdash A}{a \Vdash TpV(A | B)} \\
\\
\frac{a \Vdash TpV(A | B)}{a \Vdash A}
\end{gathered}
</annotation></semantics></math></div>
<p>With <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math>, we can complete the definition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> types as suggested above:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpV</mi><mo stretchy="false">(</mo><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">|</mo><mspace width="thickmathspace"></mspace><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma x:A.B[x]\;\coloneqq\;TpV(\Sigma' x:A.B[x]\;|\;\Pi x:A.B[x])</annotation></semantics></math></p>

<p>Combining the inversion rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>, we get the desired inversion rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>. Inversion rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Sigma'</annotation></semantics></math> are not needed at all. In general, there seems to be no use for inversion rules for PER comprehension.</p>

<h3 id="custom_presuppositions">Custom Presuppositions</h3>

<p>It would not be dependent type theory if types depended only on types. In the primitive type constructors, aside from the trick of <a href="#CombElim">type-level branching</a>, the only dependency comes from the equality types. But for the equality type to be valid, the terms only need to be elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> for the appropriate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. When types depend on elements, we might want type validity to require well-typedness of the terms. And who knows, we might also want all sorts of other requirements for validity of a derived type constructor. What kinds of requirements can be added to type validity?</p>

<p>Because type validity is a judgment form without any term witness, the most we could hope to pack into type validity is mere inhabitedness of a type. And it turns out we can indeed do that. We would like to add inhabitedness of a type as a condition to type validity in the same way that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math> added a type validity condition. It suffices to define a type constructor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)</annotation></semantics></math> whose validity coincides with combined truth of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>, and then add that to an existing type with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math>.</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)</annotation></semantics></math> is a non-negatable version of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>P</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor P \rfloor</annotation></semantics></math>. It should validate the following rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>P</mi></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>p</mi><mo>⊩</mo><mo stretchy="false">⌊</mo><mi>P</mi><mo stretchy="false">⌋</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{p \Vdash P}{q \Vdash PreSup(P)} \\
\\
\frac{PreSup(P)\,type}{p \Vdash \lfloor P \rfloor}
\end{gathered}
</annotation></semantics></math></div>
<p>It would be pretty straightforward to just add a primitive type constructor to do this. And it’s really just a lucky break that we don’t have to.</p>

<p><a href="#DiffPresup">Recall</a> that there’s a “bad” definition of subtyping as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>). Well actually we’ll use (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∩</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\cap a:A.a \in B</annotation></semantics></math>), which is just as bad. It’s bad as a definition of subtyping because it has the excessively strong presupposition that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≺</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \prec B</annotation></semantics></math>). Due to the inversion rules and the rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math>, we can actually <em>use</em> this presupposition if we know the bad subtyping is a valid type. This seems to be the most interesting fact we can get out of the primitive inversion rules, so we should encode inhabitedness of a type in terms of respect for equality.</p>

<p>We can define a type constructor for “Diaconescu booleans” that quotients <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> down to a singleton if and only if some type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> is inhabited. In the <a class="existingWikiWord" href="/nlab/show/Diaconescu-Goodman-Myhill+theorem">Diaconescu-Goodman-Myhill theorem</a>, these conditionally quotiented booleans are used to encode a proposition as an equation.</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpV</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>b</mi><mn>1</mn><mo>=</mo><mi>b</mi><mn>2</mn><mo stretchy="false">|</mo><mi>b</mi><mn>1</mn><mo>=</mo><mi>b</mi><mn>2</mn><mo>∈</mo><mi>Bool</mi><mo>∨</mo><mo stretchy="false">(</mo><mi>P</mi><mo>∧</mo><mi>b</mi><mn>1</mn><mo>∈</mo><mi>Bool</mi><mo>∧</mo><mi>b</mi><mn>2</mn><mo>∈</mo><mi>Bool</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo stretchy="false">|</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">DiaBool(P)\;\coloneqq\;TpV(\{b1 = b2 | b1 = b2 \in Bool \vee (P \wedge b1 \in Bool \wedge b2 \in Bool)\} | P)</annotation></semantics></math></p>

<p>Our <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi></mrow><annotation encoding="application/x-tex">DiaBool</annotation></semantics></math>-ical trick is that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi><mo stretchy="false">(</mo><mo>⊤</mo><mo stretchy="false">)</mo><mo>≺</mo><mi>DiaBool</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">DiaBool(\top) \prec DiaBool(P)</annotation></semantics></math>) if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>P</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor P \rfloor</annotation></semantics></math>. So we define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi></mrow><annotation encoding="application/x-tex">PreSup</annotation></semantics></math> as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo>∩</mo><mi>b</mi><mo>:</mo><mi>DiaBool</mi><mo stretchy="false">(</mo><mo>⊤</mo><mo stretchy="false">)</mo><mo>.</mo><mi>b</mi><mo>∈</mo><mi>DiaBool</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)\;\coloneqq\;\cap b:DiaBool(\top).b \in DiaBool(P)</annotation></semantics></math></p>

<p>This definition was motivated by getting respect to mean the right thing, but as it turns out, subtyping and respect coincide for instances of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi></mrow><annotation encoding="application/x-tex">DiaBool</annotation></semantics></math>. (Since they all have the same computations, namely the booleans.) So <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)</annotation></semantics></math> is non-negatable, and satisfies the rules above.</p>

<p>As an (admittedly pretty boring) application of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi></mrow><annotation encoding="application/x-tex">PreSup</annotation></semantics></math>, we can define a “Martin-Löf” equality type constructor that’s like relaxed equality, but is only meaningful on elements of the indicated type:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mn>1</mn><msub><mo>=</mo> <mi>A</mi></msub><mi>a</mi><mn>2</mn><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpV</mi><mo stretchy="false">(</mo><mi>a</mi><mn>1</mn><mo>=</mo><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mo stretchy="false">|</mo><mspace width="thickmathspace"></mspace><mi>PreSup</mi><mo stretchy="false">(</mo><mi>a</mi><mn>1</mn><mo>∈</mo><mi>A</mi><mo>∧</mo><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a1 =_A a2\;\coloneqq\;TpV(a1 = a2 \in A\;|\;PreSup(a1 \in A \wedge a2 \in A))</annotation></semantics></math></p>

<h2 id="PartLogic">Partial Logic</h2>

<p>This section sketches the connection between dependent type theory and partial logic. The idea of the connection is that both styles of system handle presuppositions in essentially the same way.</p>

<h3 id="frege_structures">Frege Structures</h3>

<p>In <a href="#KahleFSU">a paper</a> about adding universes to Frege structures, Reinhard Kahle presents Frege structures formulated as “a truth theory over applicative theories”. That is, a logic for reasoning about <a class="existingWikiWord" href="/nlab/show/combinatory+logic">combinators</a>, plus a truth predicate. (Supposedly, Frege structures were not originally formulated that way.)</p>

<p>This formulation based on a truth predicate is a close analogue of the formulation of CompLF in a HOAS logical framework.</p>

<ul>
<li>
<p>The formulas of the applicative language for Frege structures correspond to the logical framework formulas for CompLF.</p>
</li>

<li>
<p>The terms of the applicative language correspond to the terms of CompLF. Additionally, both term languages present an untyped computation system.</p>
</li>

<li>
<p>Classical propositions represented as computations in Frege structures correspond to types represented as computations in CompLF.</p>
</li>

<li>
<p>The truth predicate (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>) of this “truth theory” formulation expresses what we called <a href="#CombTruth">combined truth</a>. It thus corresponds (modulo propositions-as-types) to the typing judgment form (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊩</mo></mrow><annotation encoding="application/x-tex">\Vdash</annotation></semantics></math>) of CompLF. Rather than have a primitive “is a proposition” predicate, the truth theory uses (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∨</mo><mi>T</mi><mo stretchy="false">(</mo><mover><mo>¬</mo><mo>˙</mo></mover><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)\;\coloneqq\;T(x) \vee T(\dot{\not} x)</annotation></semantics></math>), which works in part due to classical logic. This corresponds to the type validity judgment form.</p>
</li>
</ul>

<p>Kahle’s paper is very much about the representability of formulas as propositions in Frege structures, which corresponds to the representability of framework formulas as squashed types in CompLF <a href="#JudgReason">discussed above</a>. With Frege structures, there’s a strong metatheorem about representability. Kahle calls it “Proposition 5”. This allows representing any formula with only positive occurrences of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. By adding universes to Frege structures, Kahle allows for negative occurrences of restricted versions of combined truth.</p>

<p>(It seems that there’s nothing as strong as Proposition 5 available for CompLF. For example, there doesn’t seem to be a way to express disjunction of combined truth in CompLF. The disjunction available in CompLF is only a type when both disjuncts are. Frege structures have a “parallel or” that’s (combined) true when either disjunct is.)</p>

<p>Since proposition validity (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∨</mo><mi>T</mi><mo stretchy="false">(</mo><mover><mo>¬</mo><mo>˙</mo></mover><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)\;\coloneqq\;T(x) \vee T(\dot{\not} x)</annotation></semantics></math>) uses only positive occurrences of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, it’s representable. Namely, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mover><mo>¬</mo><mo>˙</mo></mover><mo stretchy="false">(</mo><mover><mo>¬</mo><mo>˙</mo></mover><mi>x</mi><mover><mo>∧</mo><mo>˙</mo></mover><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>↔</mo><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∨</mo><mi>T</mi><mo stretchy="false">(</mo><mover><mo>¬</mo><mo>˙</mo></mover><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(\dot{\not}(\dot{\not} x \dot{\wedge} x)) \leftrightarrow (T(x) \vee T(\dot{\not} x))</annotation></semantics></math>). So with appropriate definitions of disjunction and implication for classical logic, the representation could also be (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mover><mo>∨</mo><mo>˙</mo></mover><mover><mo>¬</mo><mo>˙</mo></mover><mi>x</mi></mrow><annotation encoding="application/x-tex">x \dot{\vee} \dot{\not} x</annotation></semantics></math>) or (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mover><mo>→</mo><mo>˙</mo></mover><mi>x</mi></mrow><annotation encoding="application/x-tex">x \dot{\to} x</annotation></semantics></math>). So the idea is essentially the same as representing <a href="#TpOK">type validity</a> as a type in CompLF: use some tautology that mentions the thing that should be valid. (Our particular definition, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊃</mo><mo>⊤</mo></mrow><annotation encoding="application/x-tex">A \supset \top</annotation></semantics></math>) could be imitated in Frege structures as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mover><mo>→</mo><mo>˙</mo></mover><mo stretchy="false">(</mo><mi>x</mi><mover><mo>=</mo><mo>˙</mo></mover><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \dot{\to} (x \dot{=} x)</annotation></semantics></math>), but this <em>doesn’t</em> work, because it’s always true, due to the parallel behavior of Frege structures connectives, rather than the short-circuiting behavior of CompLF type constructors. Clearly not <em>all</em> tautologies do the trick.)</p>

<p>In Frege structures, too, proposition validity is <a href="#NonNegate">non-negatable</a>. With the truth predicate, this can be expressed quite clearly as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mi>T</mi><mo stretchy="false">(</mo><mover><mo>¬</mo><mo>˙</mo></mover><mo stretchy="false">(</mo><mi>x</mi><mover><mo>→</mo><mo>˙</mo></mover><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\not T(\dot{\not}(x \dot{\to} x))</annotation></semantics></math>. In Frege structures terminology, this is saying that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mover><mo>→</mo><mo>˙</mo></mover><mi>x</mi></mrow><annotation encoding="application/x-tex">x \dot{\to} x</annotation></semantics></math>) is “not false”. It’s either “true” (combined true) or not a proposition.</p>

<p>So intuitively, the problem with representing negative occurrences of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> without stratification is that that would entail assuming proposition validity in a proposition. But you can’t, since proposition validity is non-negatable.</p>

<p>TODO: Relation to synthesis and checking modes?<br />tl;dw<br />Synthesis: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(x)</annotation></semantics></math><br />Checking: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mi>T</mi><mo stretchy="false">(</mo><mover><mo>¬</mo><mo>˙</mo></mover><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\not T(\dot{\not} x)</annotation></semantics></math></p>

<h3 id="FSLogic">Fitch-Scott Partial Logic</h3>

<p><a class="existingWikiWord" href="/nlab/show/Dana+Scott">Dana Scott</a> wrote <a href="#ScottComb">a note</a> in which he sketched a system very similar to Frege structures. This was prior to <a class="existingWikiWord" href="/nlab/show/Peter+Aczel">Peter Aczel</a>’s paper that coined “Frege structures”. Scott attributes key ideas of the system to Fitch, who worked on foundational logics based on combinators.</p>

<p>For anyone trying to learn about Frege structures on the internet, it seems like many of the papers about it are paywalled. Scott’s note and <a href="#KahleFSU">Kahle’s paper</a> are a couple of (currently, Aug 2020) open access sources. Kahle cited Aczel on Frege structures, and didn’t give much explanation of the basics. Hopefully that was done by Aczel, but that paper is paywalled.</p>

<p>Scott’s note seems like a good explanation of the main ideas of Frege structures, since his system is so similar. We covered Kahle’s version first because—if not for the above discussion of the approach using a formal truth predicate—Frege structures might seem quite distant from Nuprl-like systems, other than a basis on the untyped lambda calculus.</p>

<h4 id="paradox_and_partiality">Paradox and Partiality</h4>

<p>Scott explains how—due to the way the system combines untyped lambda calculus and logical operations—there <em>would</em> be an inconsistency due to the <a class="existingWikiWord" href="/nlab/show/liar+paradox">liar</a>/<a class="existingWikiWord" href="/nlab/show/Russell%27s+paradox">Russell</a> paradox, except that the formula which seems to contradict itself turns out to be neither true nor false. In the terminology of Frege structures, it’s not a proposition. (For CompLF, it can similarly be shown that something looking like a self-contradicting type is not a type. Formalizing this requires the logical framework, since <a href="#TpOK">type validity is non-negatable</a>.)</p>

<p>But Scott’s system doesn’t have the distinct notions of first-order formula vs proposition from Kahle’s truth theory formulation of Frege structures. In Scott’s terminology, the formulas are apparently just the terms that one is treating as formulas, by regarding them as possibly having a truth value. Because some formulas cannot have a truth value (“truth-value gaps”), the system is regarded as a partial logic: some formulas fail to denote a truth value.</p>

<p>Scott analyzes this partial logic as a three-valued logic, with an undefined “value” below the usual values true and false. The significance of ordering undefined below true and false (like in the flat domain of partial booleans) is that the connectives need to be monotone. (And quantifiers too, which work like infinitary connectives.)</p>

<p>Scott gives three-valued truth tables for the connectives. We have come a long way from type theory, with its typing and type validity judgments, but hopefully the connection is still in sight: the possibility of a formula being undefined corresponds to the possibility of raw type expressions for which type validity is not derivable. Truth tables for type constructors seems like too much to ask for, but truth tables for partial logic still shows the issue of presuppositions in a new light.</p>

<h4 id="squadge">Squadge</h4>

<p>There’s an unusual primitive connective in Scott’s system, which is not in Kahle’s formulation of Frege structures: a “squadge” connective, which “gives the common part of the <em>and</em> and the <em>or</em>.” That is, it has the same value as conjunction and disjunction, when they agree, and is otherwise undefined. In case that does not seem like an intuitive definition, it also has the same value as its inputs, when they agree, and is otherwise undefined. Squadge is supposedly necessary, in the purely propositional part of partial logic, for defining all the monotone connectives. It plays a role analogous to CompLF’s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi></mrow><annotation encoding="application/x-tex">PreSup</annotation></semantics></math>, allowing the user to <a href="#StrTpV">strategically make formulas undefined</a>. But with an undefined formula already available due to the liar/Russell paradox, squadge turns out to be redundant, at least semantically:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>λ</mi><mi>x</mi><mo>.</mo><mo>~</mo><mo stretchy="false">(</mo><mi>x</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r\;\coloneqq\;\lambda x.~(x\,x)</annotation></semantics></math><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>*</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>r</mi><mspace width="thinmathspace"></mspace><mi>r</mi></mrow><annotation encoding="application/x-tex">*\;\coloneqq\;r\,r</annotation></semantics></math><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>ϕ</mi><mo>∨</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">PreSup(\phi)\;\coloneqq\;\phi \vee *</annotation></semantics></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PropOK</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>ϕ</mi><mo>→</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">PropOK(\phi)\;\coloneqq\;\phi \to \phi</annotation></semantics></math><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PropV</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">|</mo><mi>ψ</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>PropOK</mi><mo stretchy="false">(</mo><mi>ψ</mi><mo stretchy="false">)</mo><mo>→</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mo>∧</mo><mi>PropOK</mi><mo stretchy="false">(</mo><mi>ψ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PropV(\phi | \psi)\;\coloneqq\;(PropOK(\psi) \to \phi) \wedge PropOK(\psi)</annotation></semantics></math></p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mspace width="thinmathspace"></mspace><mi>squadge</mi><mspace width="thinmathspace"></mspace><mi>ψ</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>PropV</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">|</mo><mi>PreSup</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo>↔</mo><mi>ψ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi\,squadge\,\psi\;\coloneqq\;PropV(\phi | PreSup(\phi \leftrightarrow \psi))</annotation></semantics></math></p>

<p>By defining squadge in terms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PropV</mi></mrow><annotation encoding="application/x-tex">PropV</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi></mrow><annotation encoding="application/x-tex">PreSup</annotation></semantics></math>, which work like (the classical special cases of) the CompLF counterparts, it’s clear that CompLF also has squadge. But CompLF doesn’t have the parallel versions of conjunction, disjunction, or the quantifiers, that Frege structures do! Meanwhile Frege structures <em>can</em> define (the classical special cases of) CompLF’s connectives. That is, short-circuiting conjunction and implication, and strict disjunction and quantifiers.</p>

<h4 id="partial_sequent_calculus">Partial Sequent Calculus</h4>

<p>Scott gives a proof system for his partial logic: a modified sequent calculus where each side of the turnstile is a set of <em>terms</em>. These terms are treated like formulas in that the derivation rules use connectives and quantifiers on them. So the situation is analogous to that of a deductive system for dependent type theory, based on raw terms: certain terms in the rules are treated like types. Just as dependent typing rules need to cope with types that are not valid though, the sequent calculus for partial logic needs to cope with truth-value gaps. The particulars of the rules for partial sequent calculus are quite different from dependent typing rules, though.</p>

<h4 id="recursive_classes">Recursive Classes</h4>

<p>Scott sketches a representability metatheorem similar to Kahle’s Proposition 5, but more exciting: by combining a <a class="existingWikiWord" href="/nlab/show/fixed-point+combinator">fixed-point combinator</a> with the quantifiers and connectives, the system can represent recursive first-order predicates in which the recurrences are positive. Implicitly, the predicate can also use combined truth positively, because this just means using some term as a formula.</p>

<p>The predicates obtained in this way are usually non-negatable. The fact that you can meaningfully prove them tends to rely on the non-strictness of connectives and quantifiers, to avoid infinite descent down a recursion that doesn’t terminate. (Branching on the argument would allow guiding the recursion to a base case, to get proofs. But this would not arise from a plain first-order definition. Also, the pure untyped lambda calculus doesn’t provide a way to branch on arbitrary objects. Moreover, even if the recursion terminates, this does not help if you can’t prove it, which would usually require induction, and Scott’s system has no such principle.)</p>

<p>Due to being non-negatable, these recursive predicates are more like defined judgment forms than types, in CompLF terminology. Or you could think of them as proper classes. But the properness is certainly not about cardinality.</p>

<p>The use of general recursion to define non-negatable semantic judgment forms seems like it should work in CompLF too, but as with Proposition 5, you don’t get as strong a result due to the lack of parallel connectives. But in the first place, it’s not clear that these non-negatable recursive definitions are actually good for much, since you can’t reason about them by induction. Any sort of useful interaction with other parts of the system would probably need to be arranged very cleverly.</p>

<h4 id="dependent_types">Dependent Types</h4>

<p>Scott encodes types as what Kahle called propositional functions: functions whose applications always have a truth value. These collect into a class, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, expressing that something is a propositional function. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> itself is not a type, but is closed under the construction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> types, which Scott defines with the now-usual logical predicates clauses (except using classical logic to write the usual implication as disjunction). He shows some good derived rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>.</p>

<p>Encoding dependent type systems into Frege structures and <a class="existingWikiWord" href="/nlab/show/explicit+mathematics">explicit mathematics</a> became a research topic later on. It doesn’t seem to have led to a nice <a class="existingWikiWord" href="/nlab/show/proof+assistant">proof assistant</a> for working with dependently typed constructions, though.</p>

<p>Finally, Scott sketches a sort of universe hierarchy, based on stratifying the classes of true/false objects. This is somewhat like the universes of Kahle, but sounds more like the “truth levels” of Cantini that Kahle cites.</p>

<h4 id="what_about_kripke">What about Kripke?</h4>

<p>At the same time as Scott’s note, <a href="#KripkeTruth">Kripke came out with</a> a “theory of truth” very much like Fitch’s idea to use partial logic to avoid paradox. Kripke followed the style of Tarski’s notion of truth predicate, rather than use combinators or lambda calculus. Formulas can be Gödel numbered in first-order arithmetic, and this numbering allows formulating Tarski’s T-schema, saying that any formula is logically equivalent to the truth predicate applied to the Gödel number of the formula.</p>

<p>Just as Fitch-Scott logic and Frege structures allow defining recursive formulas using the untyped lambda calculus/combinators, Kripke’s theory allows them by combining the truth predicate with <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quining</a>. You might say Frege structures provide <a class="existingWikiWord" href="/nlab/show/type+of+types#RussellStyle">Russell-style</a> recursive formulas while Kripke’s theory provides <a class="existingWikiWord" href="/nlab/show/type+of+types#TarskiStyle">Tarski-style</a> recursive formulas. Either way, you can formulate “This sentence is false.”, and the liar paradox is avoided by not assigning that formula a truth value.</p>

<p>Kripke’s theory provides the full T-schema in the setting of partial logic. There’s also a “closed off” version that totalizes the logic by mapping undefined to false at the end. This version resembles Kahle’s truth theory, and has a restricted T-schema.</p>

<h3 id="free_logic">Free Logic</h3>

<p>Free logic is logic in which terms need not denote elements of types (logical sorts). Free logics seem to be essentially the same idea as logics of partial terms. The term “free logic” is nice since it’s shorter than “logic of partial terms”. “Partial logic” would be nice, but that seems to be taken to mean logic of partial <em>formulas</em>, as discussed <a href="#FSLogic">above</a>.</p>

<p>There is a <a href="#SEPLogicFree">SEP article</a> about free logic. Its emphasis is on a free version of untyped classical first-order logic, so for us, that means it has one type, and the well-defined terms denote elements of that type. The article refers to the type as the quantification domain, and thinks of its elements (“members”) as the “existing things”. The article speaks of whether terms denote some existing thing, rather than whether they are well-defined. So the article’s “existence” predicate is often called a “definedness” predicate elsewhere. This may be a difference for philosophical purposes, but for mathematical and metatheoretical purposes, they seem the same.</p>

<p>In CompLF, the quantifiers (like family intersection and subset, but of course also <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>) have types as the quantification domains. Functions (elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> types) also have types as their domains. So the form of CompLF statement corresponding to existence/definedness of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> should be (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \in T</annotation></semantics></math>). Or is it (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \Vdash T</annotation></semantics></math>)? Or (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>∋</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">T \ni t</annotation></semantics></math>)? So you see, there are extra complications, due to having multiple types, the distinction between propositions and judgments, and the fact that type expressions themselves may be undefined. Also, with the HOAS logical framework, we also have the framework-level quantifiers, which do not involve types. We will see that all of these things are somewhat related to ideas in free logic.</p>

<h4 id="negative_positive_neutral">Negative, Positive, Neutral</h4>

<p>The SEP article identifies three “general approaches” to the semantics of free logic: In “negative” semantics, atomic formulas are necessarily false when applied to a non-denoting term. In “positive” semantics, the only requirement is that existence applied to a non-denoting term is false. (Of course, since existence is required to indicate which terms have a denotation.) In “neutral” semantics, atomic formulas, except for existence, necessarily lack a truth value when applied to a non-denoting term.</p>

<p>So technically, the positive approach is the most general, since all approaches require the same behavior of the existence predicate, and otherwise, the positive approach has no requirements. Meanwhile, assuming there’s at least one atomic predicate other than existence with at least one argument, the negative and neutral approaches are mutually exclusive. Actually, maybe the positive approach was intended to rule out truth value gaps. In that case it would not be more general than neutral. (And none of these approaches would explain CompLF.) But if we consider each argument of each atomic predicate individually, we can consider whether it’s behaving like the negative approach, neutral approach, or neither.</p>

<p>In the presence of truth value gaps, there are two interpretations of the negative approach to an argument: One is that if the argument is undefined, the predicate must be false. The other is that if the argument is undefined, the predicate must not be true. The first interpretation does not seem to show up anywhere in CompLF, but the second interpretation of the negative approach shows up in the equality predicate: If (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t = t' \in T</annotation></semantics></math>) is true, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">t'</annotation></semantics></math> must denote elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. (So if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">t'</annotation></semantics></math> fail to denote, the equation cannot be (combined) true.) So the negative approach in this interpretation corresponds to strictness principles for atomic predicates: a predicate is true only if an argument is defined.</p>

<p>The neutral approach <em>also</em> shows up in the equality predicate, provided we regard a term as having a truth value if and only if it denotes a type: If (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t = t' \in T</annotation></semantics></math>) is a type, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">t'</annotation></semantics></math> must denote elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(T)</annotation></semantics></math> (which entails also that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is a type). So if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">t'</annotation></semantics></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> fail to denote, the equation has no truth value. So the neutral approach corresponds to inversion principles for atomic type constructors.</p>

<p>The identity type constructor (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math>) has neither strictness nor inversion principles, so I suppose we could consider it to be following the positive approach.</p>

<h4 id="outer_domain">Outer Domain</h4>

<p>The positive approach to the semantics of free logic often makes use of an “outer domain”. This domain is not (necessarily) quantified over, but it’s used as the codomain of the term interpretation function. Atomic predicates are then interpreted simply as relations on the outer domain.</p>

<p>In the semantics of CompLF, the outer domain is the set of terms, considered up to computational equivalence. So the “interpretation” of terms is just a quotient projection. (Types are subquotients of this outer domain, not subsets, and the PER semantics that’s used to handle this causes phenomena that seem to have no analogue in free logic. For example, not everything is a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>, even though <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> is the internalization of the outer domain.)</p>

<p>Relations on the outer domain are used as the interpretations of judgment forms. So in general, they correspond to predicates in the positive approach. They can be made more negative using conjunction. Provided they’re representable as type operations, they can be made more neutral using <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi></mrow><annotation encoding="application/x-tex">PreSup</annotation></semantics></math>. (See <a href="#StrTpV">above</a>.)</p>

<h4 id="quantification_over_outer_domain">Quantification over Outer Domain</h4>

<p>TODO</p>

<p>TODO?: Kahle’s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> according to free logic.</p>

<h2 id="references">References</h2>

<ul>
<li id="ScottComb">
<p><a class="existingWikiWord" href="/nlab/show/Dana+Scott">Dana Scott</a>, <em>Combinators and Classes</em>, Lambda Calculus and Computer Science Theory (LCCST) 1975 (<a href="https://www.researchgate.net/publication/221200880_Combinators_and_classes">web</a>)</p>
</li>

<li id="KCThesis">
<p>Karl Crary, <em>Type-Theoretic Methodology for Practical Programming Languages</em>, 1998 PhD thesis (<a href="http://www.nuprl.org/KB/show.php?ShowPub=Cra98">web</a>, <a href="http://www.nuprl.org/documents/Crary/Thesis-TypeTheoretic.pdf">pdf</a>)</p>
</li>

<li id="KahleFSU">
<p>Reinhard Kahle, <em>Universes over Frege Structures</em>, Annals of Pure and Applied Logic (2003) (<a href="https://www.sciencedirect.com/science/article/pii/S0168007202000404">web</a>)</p>
</li>

<li id="SEPLogicFree">
<p>John Nolt, <em>Free Logic</em>, Stanford Encyclopedia of Philosophy (SEP) Fall 2018 (<a href="https://plato.stanford.edu/archives/fall2018/entries/logic-free/">web</a>)</p>
</li>

<li id="KripkeTruth">
<p>Saul Kripke, <em>Outline of a Theory of Truth</em>, Journal of Philosophy (1975)</p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on September 18, 2020 at 13:14:19.
    See the <a href="/nlab/history/CompLF%2FHOAS" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/CompLF%2FHOAS" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/11554/#Item_4">Discuss</a><span class="backintime"><a href="/nlab/revision/CompLF%2FHOAS/35" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/CompLF%2FHOAS" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/CompLF%2FHOAS" accesskey="S" class="navlink" id="history" rel="nofollow">History (35 revisions)</a>
  <a href="/nlab/show/CompLF%2FHOAS/cite" style="color: black">Cite</a>
  <a href="/nlab/print/CompLF%2FHOAS" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/CompLF%2FHOAS" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
