
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      type universe in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      type universe
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/3362/#Item_16" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="universes">Universes</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/universe">universe</a></strong></p>

<p>(in <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a>/<a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>/<a class="existingWikiWord" href="/nlab/show/computer+science">computer science</a>)</p>

<p><strong>of all <a class="existingWikiWord" href="/nlab/show/homotopy+types">homotopy types</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/type+of+types">type of types</a>, <a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a>,</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/univalence">univalence</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/codomain+fibration">codomain fibration</a></p>
</li>
</ul>

<p><strong>of <a class="existingWikiWord" href="/nlab/show/homotopy+n-types">homotopy n-types</a></strong></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type+of+n-types">type of n-types</a></li>
</ul>

<p><strong>of <a class="existingWikiWord" href="/nlab/show/0-truncated+object">0-truncated types</a>/<a class="existingWikiWord" href="/nlab/show/h-sets">h-sets</a></strong></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type+of+h-sets">type of h-sets</a>, <a class="existingWikiWord" href="/nlab/show/universe+in+a+topos">universe in a topos</a></li>
</ul>

<p><strong>of <a class="existingWikiWord" href="/nlab/show/%28-1%29-truncated+object">(-1)-truncated types</a>/<a class="existingWikiWord" href="/nlab/show/h-propositions">h-propositions</a></strong></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type+of+propositions">type of propositions</a>, <a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a></li>
</ul>

<h3 id="resizing">resizing</h3>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/universe+enlargement">universe enlargement</a></li>
</ul>
</div></div>

<h4 id="type_theory">Type theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></strong> <a class="existingWikiWord" href="/nlab/show/metalanguage">metalanguage</a>, <a class="existingWikiWord" href="/nlab/show/practical+foundations">practical foundations</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/judgement">judgement</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hypothetical+judgement">hypothetical judgement</a>, <a class="existingWikiWord" href="/nlab/show/sequent">sequent</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/antecedents">antecedents</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/consequent">consequent</a>, <a class="existingWikiWord" href="/nlab/show/succedents">succedents</a></li>
</ul>
</li>
</ul>

<ol>
<li><a class="existingWikiWord" href="/nlab/show/type+formation+rule">type formation rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+introduction+rule">term introduction rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+elimination+rule">term elimination rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/computation+rule">computation rule</a></li>
</ol>

<p><strong><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></strong> (<a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent</a>, <a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional</a>, <a class="existingWikiWord" href="/nlab/show/observational+type+theory">observational type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>)</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a></li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/syntax">syntax</a></strong> <a class="existingWikiWord" href="/nlab/show/object+language">object language</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/theory">theory</a>, <a class="existingWikiWord" href="/nlab/show/axiom">axiom</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>/<a class="existingWikiWord" href="/nlab/show/type">type</a> (<a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/definition">definition</a>/<a class="existingWikiWord" href="/nlab/show/proof">proof</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a> (<a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/theorem">theorem</a></p>
</li>
</ul>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></strong> = <br /> <strong><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/programs+as+proofs">programs as proofs</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation type theory/category theory</a></strong></p>

<table><thead><tr><th><a class="existingWikiWord" href="/nlab/show/logic">logic</a></th><th><a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a> (<a class="existingWikiWord" href="/nlab/show/internal+logic+of+set+theory">internal logic</a> of)</th><th><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></th><th><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></th></tr></thead><tbody><tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object">object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type">type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/predicate">predicate</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/family+of+sets">family of sets</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/display+morphism">display morphism</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+type">dependent type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof">proof</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/element">element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/term">term</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+rule">cut rule</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/composition">composition</a> of <a class="existingWikiWord" href="/nlab/show/classifying+morphisms">classifying morphisms</a> / <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of <a class="existingWikiWord" href="/nlab/show/display+maps">display maps</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/substitution">substitution</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/introduction+rule">introduction rule</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/counit">counit</a> for hom-tensor adjunction</td><td style="text-align: left;">lambda</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/elimination+rule">elimination rule</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/unit">unit</a> for hom-tensor adjunction</td><td style="text-align: left;">application</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+elimination">cut elimination</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;">one of the <a class="existingWikiWord" href="/nlab/show/zigzag+identities">zigzag identities</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/beta+reduction">beta reduction</a></td></tr>
<tr><td style="text-align: left;">identity elimination for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"></td><td style="text-align: left;">the other <a class="existingWikiWord" href="/nlab/show/zigzag+identity">zigzag identity</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/eta+conversion">eta conversion</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/true">true</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/singleton">singleton</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-2%29-truncated+object">(-2)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+0">h-level 0</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/unit+type">unit type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/false">false</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+set">empty set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>, <a class="existingWikiWord" href="/nlab/show/truth+value">truth value</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subterminal+object">subterminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncated+object">(-1)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-proposition">h-proposition</a>, <a class="existingWikiWord" href="/nlab/show/mere+proposition">mere proposition</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+conjunction">logical conjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cartesian+product">cartesian product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product">product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product+type">product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjunction">disjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjoint+union">disjoint union</a> (<a class="existingWikiWord" href="/nlab/show/support">support</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/sum+type">sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+set">function set</a> (into <a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a> (into <a class="existingWikiWord" href="/nlab/show/subterminal+object">subterminal object</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a> (into <a class="existingWikiWord" href="/nlab/show/h-proposition">h-proposition</a>)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/negation">negation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+set">function set</a> into <a class="existingWikiWord" href="/nlab/show/empty+set">empty set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a> into <a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a> into <a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universal+quantification">universal quantification</a></td><td style="text-align: left;">indexed <a class="existingWikiWord" href="/nlab/show/cartesian+product">cartesian product</a> (of family of <a class="existingWikiWord" href="/nlab/show/subsingletons">subsingletons</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a> (of family of <a class="existingWikiWord" href="/nlab/show/subterminal+objects">subterminal objects</a>)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product+type">dependent product type</a> (of family of <a class="existingWikiWord" href="/nlab/show/h-propositions">h-propositions</a>)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/existential+quantification">existential quantification</a></td><td style="text-align: left;">indexed <a class="existingWikiWord" href="/nlab/show/disjoint+union">disjoint union</a> (<a class="existingWikiWord" href="/nlab/show/support">support</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+equivalence">logical equivalence</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/bijection+set">bijection set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object+of+isomorphisms">object of isomorphisms</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+type">equivalence type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/support+set">support set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/support+object">support object</a>/<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/propositional+truncation">propositional truncation</a>/<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/n-image">n-image</a> of <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a> into <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/n-truncation">n-truncation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/n-truncation+modality">n-truncation modality</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equality">equality</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/diagonal+function">diagonal function</a>/<a class="existingWikiWord" href="/nlab/show/diagonal+subset">diagonal subset</a>/<a class="existingWikiWord" href="/nlab/show/diagonal+relation">diagonal relation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/path+space+object">path space object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/identity+type">identity type</a>/<a class="existingWikiWord" href="/nlab/show/path+type">path type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/completely+presented+set">completely presented set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/discrete+object">discrete object</a>/<a class="existingWikiWord" href="/nlab/show/0-truncated+object">0-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+2">h-level 2</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/set">set</a>/<a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a> with <a class="existingWikiWord" href="/nlab/show/equivalence+relation">equivalence relation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/groupoid+object+in+an+%28infinity%2C1%29-category">internal 0-groupoid</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>/<a class="existingWikiWord" href="/nlab/show/setoid">setoid</a> with its <a class="existingWikiWord" href="/nlab/show/pseudo-equivalence+relation">pseudo-equivalence relation</a> an actual <a class="existingWikiWord" href="/nlab/show/equivalence+relation">equivalence relation</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+class">equivalence class</a>/<a class="existingWikiWord" href="/nlab/show/quotient+set">quotient set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient">quotient</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+type">quotient type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/W-type">W-type</a>, <a class="existingWikiWord" href="/nlab/show/M-type">M-type</a></td></tr>
<tr><td style="text-align: left;">higher <a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></td></tr>
<tr><td style="text-align: left;">-</td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/0-truncated">0-truncated</a> <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+inductive+type">quotient inductive type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinduction">coinduction</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/limit">limit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinductive+type">coinductive type</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/preset">preset</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type">type</a> without <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a> of <a class="existingWikiWord" href="/nlab/show/truth+values">truth values</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+of+propositions">type of propositions</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+of+discourse">domain of discourse</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universe">universe</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+universe">type universe</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modality">modality</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/closure+operator">closure operator</a>, (<a class="existingWikiWord" href="/nlab/show/idempotent+monad">idempotent</a>) <a class="existingWikiWord" href="/nlab/show/monad">monad</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modal+type+theory">modal type theory</a>, <a class="existingWikiWord" href="/nlab/show/monad+%28in+computer+science%29">monad (in computer science)</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+logic">linear logic</a></td><td style="text-align: left;"></td><td style="text-align: left;">(<a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric</a>, <a class="existingWikiWord" href="/nlab/show/closed+monoidal+category">closed</a>) <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal category</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+type+theory">linear type theory</a>/<a class="existingWikiWord" href="/nlab/show/quantum+computation">quantum computation</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof+net">proof net</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/string+diagram">string diagram</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quantum+circuit">quantum circuit</a></td></tr>
<tr><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/contraction+rule">contraction rule</a></td><td style="text-align: left;"></td><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/diagonal">diagonal</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/no-cloning+theorem">no-cloning theorem</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/synthetic+mathematics">synthetic mathematics</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+specific+embedded+programming+language">domain specific embedded programming language</a></td></tr>
</tbody></table>

</div>
<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+levels">homotopy levels</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-type+theory">2-type theory</a>, <a class="existingWikiWord" href="/michaelshulman/show/2-categorical+logic">2-categorical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory+-+contents">homotopy type theory - contents</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/univalence">univalence</a>, <a class="existingWikiWord" href="/nlab/show/function+extensionality">function extensionality</a>, <a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+type+theory">cohesive homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/directed+homotopy+type+theory">directed homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/HoTT+methods+for+homotopy+theorists">HoTT methods for homotopy theorists</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/semantics">semantics</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>, <a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/display+map">display map</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+a+topos">internal logic of a topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Mitchell-Benabou+language">Mitchell-Benabou language</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kripke-Joyal+semantics">Kripke-Joyal semantics</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type-theoretic+model+category">type-theoretic model category</a></li>
</ul>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/type+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#formalizations'>Formalizations</a></li>
<ul>
<li><a href='#RussellStyle'>Russell universe</a></li>
<li><a href='#TarskiStyle'>Tarski universes</a></li>
</ul>
<li><a href='#properties'>Properties</a></li>
<ul>
<li><a href='#UniverseEnlargement'>Universe enlargement</a></li>
<li><a href='#extensionality_principle_of_type_universes'>Extensionality principle of type universes</a></li>
<li><a href='#cumulativity'>Cumulativity</a></li>
<li><a href='#CategoricalSemantics'>Categorical semantics</a></li>
</ul>
<li><a href='#other_types_of_types'>Other types of types</a></li>
<ul>
<li><a href='#as_a_strict_tarski_universe'>As a strict Tarski universe</a></li>
<li><a href='#as_a_weak_tarski_universe'>As a weak Tarski universe</a></li>
<li><a href='#as_a_russell_universe'>As a Russell universe</a></li>
</ul>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>In <a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, a <em>type universe</em> – usually written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math> – is a <a class="existingWikiWord" href="/nlab/show/type">type</a> whose <a class="existingWikiWord" href="/nlab/show/terms">terms</a> are either themselves <a class="existingWikiWord" href="/nlab/show/type">types</a> (<a class="existingWikiWord" href="/nlab/show/Russell+universes">Russell universes</a>), or representations of types in an internal model of the type theory (<a class="existingWikiWord" href="/nlab/show/Tarski+universes">Tarski universes</a>). Either way, it is a <a class="existingWikiWord" href="/nlab/show/universe">universe</a> of (small) <a class="existingWikiWord" href="/nlab/show/type">types</a>, a <em>universe in type theory</em>, and sometimes called a <em>type of types</em>.</p>

<p id="TypeUniverseAsReflection"> One also speaks of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math> as being a <em>reflection</em> of the type system in itself (e.g. <a href="#MartinLoef74">MartinLöf 74, p. 6</a>, <a href="#Palmgren">Palmgren, pp. 2-3</a>, <a href="#Rathjen">Rathjen, p. 1</a>, <a href="#Luo11">Luo 11, section 2.5</a>, <a href="#Luo12">Luo 12, p. 2</a>, <a href="#SEP">Stanf. Enc. Phil.</a>), following the <em><a class="existingWikiWord" href="/nlab/show/reflection+principle">reflection principle</a></em> in <a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a>.</p>

<p>In <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> a type of (small) types is what in <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+theory">higher</a> <a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a> is interpreted as a (small) <em><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></em>. Thus, the type of types is a refinement of the <a class="existingWikiWord" href="/nlab/show/type+of+propositions">type of propositions</a> which only contains the <a class="existingWikiWord" href="/nlab/show/%28-1%29-truncated">(-1)-truncated</a>/<a class="existingWikiWord" href="/nlab/show/h-level">h-level</a>-1 types (and is semantically a <a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a>).</p>

<p>In the presence of a type universe a <a class="existingWikiWord" href="/nlab/show/judgement">judgement</a> of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>⊢</mo><mi>A</mi><mo>:</mo><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">
  \vdash A : \mathcal{U}

</annotation></semantics></math></div>
<p>says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/term">term</a> of <a class="existingWikiWord" href="/nlab/show/type">type</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math>, hence is either a (small) <a class="existingWikiWord" href="/nlab/show/type">type</a> itself (for Russell universes), or a representation of types in an internal model of the type theory (for Tarski universes).</p>

<p>More generally, in Russell universes a <a class="existingWikiWord" href="/nlab/show/hypothetical+judgement">hypothetical judgement</a> of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>X</mi><mo>⊢</mo><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">
  x : X \vdash A(x) : \mathcal{U}

</annotation></semantics></math></div>
<p>says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/dependent+type">dependent type</a>.</p>

<p>In Tarski universes the corresponding hypothetical judgment would be of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>X</mi><mo>⊢</mo><mi>El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">
  x : X \vdash El(A)(x)\; type

</annotation></semantics></math></div>
<p>Type universes are important in <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a> for numerous reasons:</p>

<ol>
<li>
<p>In <a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a>, one could usually quantify over sets using the <a class="existingWikiWord" href="/nlab/show/universal+quantifier">universal quantifier</a> and the <a class="existingWikiWord" href="/nlab/show/existential+quantifier">existential quantifier</a>. However, in <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a>, one could only quantify over elements of types. Without type universes, types are not elements of type universes, but rather <a class="existingWikiWord" href="/nlab/show/judgment">judged</a> separately as a type, and thus it is impossible to quantify over types. Quantification over types is necessary for proving <a class="existingWikiWord" href="/nlab/show/universal+properties">universal properties</a> of various <a class="existingWikiWord" href="/nlab/show/mathematical+structures">mathematical structures</a>, such as that the <a class="existingWikiWord" href="/nlab/show/integers">integers</a> are the <a class="existingWikiWord" href="/nlab/show/initial+object">initial</a> <a class="existingWikiWord" href="/nlab/show/commutative+ring">commutative ring</a>.</p>
</li>

<li>
<p>Having type universes in the type theory avoids having to use long annotations everywhere. For example, without type universes, the <a class="existingWikiWord" href="/nlab/show/heterogeneous+identity+type">heterogeneous identity type</a> for the type family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x:A \vdash B(x)</annotation></semantics></math>, elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">b:A</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><msub><mi mathvariant="normal">Id</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p:\mathrm{Id}_A(a, b)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>:</mo><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y:B(a)</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi><mo>:</mo><mi>B</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z:B(b)</annotation></semantics></math> is represented by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">hId</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>p</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{hId}_{x:A.B(x)}(a, b, p, y, z)</annotation></semantics></math>, where the subscript <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x:A.B(x)</annotation></semantics></math> is a long annotation used to represent the type family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x:A \vdash B(x)</annotation></semantics></math>. With type universes, the type family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">x:A \vdash B(x):U</annotation></semantics></math> is represented by the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">B:A \to U</annotation></semantics></math>, and the same heterogeneous identity type is then represented by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">hId</mi> <mi>B</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>p</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{hId}_{B}(a, b, p, y, z)</annotation></semantics></math>, which is more concise when written out, and in addition, the subscript <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is now represents that the type depends upon the universe, rather than merely being an annotation, and could be written as the dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">hId</mi><mo stretchy="false">(</mo><mi>B</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>p</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{hId}(B, a, b, p, y, z)</annotation></semantics></math>.</p>
</li>

<li>
<p>In <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a> with <a class="existingWikiWord" href="/nlab/show/judgmental+equality">judgmental equality</a> and a hierarchy of <a class="existingWikiWord" href="/nlab/show/Russell+universes">Russell universes</a>, the <a class="existingWikiWord" href="/nlab/show/congruence+rules">congruence rules</a> for <a class="existingWikiWord" href="/nlab/show/substitution">substitution</a> implies the <a class="existingWikiWord" href="/nlab/show/congruence+rules">congruence rules</a> for every type in the type theory. However, without <a class="existingWikiWord" href="/nlab/show/type+universes">type universes</a>, one has to add to the theory a separate judgment for types, as well as <a class="existingWikiWord" href="/nlab/show/judgmental+equality">judgmental equality</a> of types, and the associated <a class="existingWikiWord" href="/nlab/show/structural+rules">structural rules</a> for strict judgmental equality of types. The <a class="existingWikiWord" href="/nlab/show/congruence+rules">congruence rules</a> for <a class="existingWikiWord" href="/nlab/show/substitution">substitution</a> no longer implies the <a class="existingWikiWord" href="/nlab/show/congruence+rules">congruence rules</a> for every type former in the type theory, because not all types are terms of universes. Thus, the <a class="existingWikiWord" href="/nlab/show/congruence+rules">congruence rules</a> for every type in the type theory have to be added separately.</p>
</li>

<li>
<p>In <a class="existingWikiWord" href="/nlab/show/objective+type+theory">objective type theory</a>, there is no separate <a class="existingWikiWord" href="/nlab/show/judgmental+equality">judgmental equality</a> in the theory. While this results in a simpler formal theory, since one doesn’t need all the structural and congruence rules for judgmental equality, there is the question of how one forms <a class="existingWikiWord" href="/nlab/show/definitions">definitions</a> of types in the theory without judgmental equality. With type universes, one could define a symbol <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> as a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">A:U</annotation></semantics></math> using the <a class="existingWikiWord" href="/nlab/show/propositional+equality">propositional equality</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><msub><mo>=</mo> <mi>U</mi></msub><mi>A</mi></mrow><annotation encoding="application/x-tex">B =_U A</annotation></semantics></math>. However, without type universes, types are not elements of type universes, but rather <a class="existingWikiWord" href="/nlab/show/judgment">judged</a> separately as a type, and thus one cannot compare them for equality. Instead, one would have to use <a class="existingWikiWord" href="/nlab/show/equivalences+of+types">equivalences of types</a>. However, equivalences are significantly more complex to define, since the symbol <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>≃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B \simeq A</annotation></semantics></math> usually representing the <a class="existingWikiWord" href="/nlab/show/equivalence+type">equivalence type</a> hasn’t been formally defined in the theory yet, and any definition of <a class="existingWikiWord" href="/nlab/show/equivalence+type">equivalence type</a> or <a class="existingWikiWord" href="/nlab/show/isEquiv">isEquiv</a> for functions is itself a very complex expression when only using <a class="existingWikiWord" href="/nlab/show/dependent+function+types">dependent function types</a>, <a class="existingWikiWord" href="/nlab/show/function+types">function types</a>, <a class="existingWikiWord" href="/nlab/show/dependent+pair+types">dependent pair types</a>, <a class="existingWikiWord" href="/nlab/show/pair+types">pair types</a>, and <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a> in the expression.</p>
</li>

<li>
<p>In the <a class="existingWikiWord" href="/nlab/show/split+context">split context</a> formalization of <a class="existingWikiWord" href="/nlab/show/spatial+type+theory">spatial type theory</a> and <a class="existingWikiWord" href="/nlab/show/cohesive+type+theory">cohesive type theory</a> with an additional judgment for crisp terms of types, with a hierarchy of <a class="existingWikiWord" href="/nlab/show/Russell+universes">Russell universes</a>, one could define crisp types by simply postulating the type to crisply be an element of a type universe. However, without <a class="existingWikiWord" href="/nlab/show/type+universes">type universes</a>, one has to add to the theory a separate judgment for crisp types, and all the requisite <a class="existingWikiWord" href="/nlab/show/inference+rules">inference rules</a>, <a class="existingWikiWord" href="/nlab/show/structural+rules">structural rules</a>, and <a class="existingWikiWord" href="/nlab/show/congruence+rules">congruence rules</a> for crisp type judgments.</p>
</li>
</ol>

<p>In <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> the type universe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math> is often assumed to satisfy the <a class="existingWikiWord" href="/nlab/show/univalence">univalence</a> <a class="existingWikiWord" href="/nlab/show/axiom">axiom</a>. This is a reflection of the fact that in its <a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a> as an <a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a> is part of an <a class="existingWikiWord" href="/nlab/show/internal+%28%E2%88%9E%2C1%29-category">internal (∞,1)-category</a> in the ambient <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-topos">(∞,1)-topos</a>: the one that as an <a class="existingWikiWord" href="/nlab/show/indexed+category">indexed category</a> is the small <a class="existingWikiWord" href="/nlab/show/codomain+fibration">codomain fibration</a>.</p>

<p><a class="existingWikiWord" href="/nlab/show/Per+Martin-Lof">Per Martin-Lof</a>‘s original type theory contained a Russell universe which contained <em>all</em> types, which therefore in particular contained itself, i.e. one had <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type : Type</annotation></semantics></math>. But it was pointed out by <a class="existingWikiWord" href="/nlab/show/Jean-Yves+Girard">Jean-Yves Girard</a> that this was inconsistent; see <a class="existingWikiWord" href="/nlab/show/Girard%27s+paradox">Girard's paradox</a>. Thus, modern type theories generally contain a hierarchy of types universes, with</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi><mo>⊢</mo><mi>𝒰</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>:</mo><mi>𝒰</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n:\mathbb{N} \vdash \mathcal{U}(n) : \mathcal{U}(n + 1)</annotation></semantics></math></div>
<p>for Russell universes, and</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi><mo>⊢</mo><mi>𝒰</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">n:\mathbb{N} \vdash \mathcal{U}(n)\; type</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi><mo>⊢</mo><msup><mi>𝒰</mi> <mo>′</mo></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>:</mo><mi>𝒰</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n:\mathbb{N} \vdash \mathcal{U}^{'}(n) : \mathcal{U}(n + 1)</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi><mo>⊢</mo><msub><mi>El</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msup><mi>𝒰</mi> <mo>′</mo></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≡</mo><mi>Type</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n:\mathbb{N} \vdash El_{n+1}(\mathcal{U}^{'}(n)) \equiv Type(n)</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi><mo>⊢</mo><msub><mi>El</mi> <mrow><mi>n</mi><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><mi>𝒰</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>→</mo><mi>𝒰</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n:\mathbb{N} \vdash El_{n,n+1}:\mathcal{U}(n) \to \mathcal{U}(n + 1)</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>is</mi><mn>1</mn><mi>Monic</mi><mo stretchy="false">(</mo><msub><mi>El</mi> <mrow><mi>n</mi><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n:\mathbb{N} \vdash p:is1Monic(El_{n,n+1})</annotation></semantics></math></div>
<p>for Tarski universes.</p>

<h2 id="formalizations">Formalizations</h2>

<h3 id="RussellStyle">Russell universe</h3>

<p>A <strong><a class="existingWikiWord" href="/nlab/show/Russell+universe">Russell universe</a></strong> or <strong>universe à la Russell</strong> is a <a class="existingWikiWord" href="/nlab/show/type">type</a> whose terms <em>are</em> types. In the presence of a separate <a class="existingWikiWord" href="/nlab/show/judgment">judgment</a> “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thickmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A \;type</annotation></semantics></math>”, this can be formulated as a <a class="existingWikiWord" href="/nlab/show/natural+deduction">deduction rule</a> of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>A</mi><mo>:</mo><mi>𝒰</mi></mrow><mrow><mi>A</mi><mspace width="thickmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{A:\mathcal{U}}{A \;type}</annotation></semantics></math></div>
<p>Thus, the <a href="natural+deduction#IntroductionAndElimination">type formers</a> have rules saying which universe they belong to, such as:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>A</mi><mo>:</mo><mi>𝒰</mi><mspace width="1em"></mspace><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>𝒰</mi></mrow><mrow><mi>Π</mi><mspace width="thinmathspace"></mspace><mi>A</mi><mspace width="thinmathspace"></mspace><mi>B</mi><mo>:</mo><mi>𝒰</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{A:\mathcal{U}\quad B:A\to \mathcal{U}}{\Pi\, A\, B : \mathcal{U}}</annotation></semantics></math></div>
<p>With Russell universes, we can also omit the judgment “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thickmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\; type</annotation></semantics></math>” and replace it everywhere by a judgment that A is a term of some universe. This is the approach taken in <a href="#UFP13">UFP13</a>.</p>

<h3 id="TarskiStyle">Tarski universes</h3>

<p>A <strong><a class="existingWikiWord" href="/nlab/show/Tarski+universe">Tarski universe</a></strong> or a <strong>universe à la Tarski</strong> (<a href="#Hofmann">Hofmann, section 2.1.6</a>, <a href="#Luo12">Luo 12</a>, <a href="#Gallozzi14">Gallozzi 14, p. 40</a>) is a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> together with an “interpretation” operation allowing us to regard its <a class="existingWikiWord" href="/nlab/show/terms">terms</a> as <em>codes</em> or <em>names</em> for actual types. Thus we have a rule such as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>A</mi><mo>:</mo><mi>𝒰</mi></mrow><mrow><mi>El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{A:\mathcal{U}}{El(A)\;type}</annotation></semantics></math></div>
<p>saying that for each term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> of the type universe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> there is an actual type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">El(A)</annotation></semantics></math>. This is the approach taken by <a class="existingWikiWord" href="/nlab/show/Egbert+Rijke">Egbert Rijke</a>‘s <a class="existingWikiWord" href="/nlab/show/Introduction+to+Homotopy+Type+Theory">Introduction to Homotopy Type Theory</a>.</p>

<p>Conversely, with notation as used at <em><a class="existingWikiWord" href="/nlab/show/object+classifier+in+an+%28infinity%2C1%29-topos">object classifier in an (infinity,1)-topos</a></em>, one might write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo>′</mo><mi>El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>′</mo></mrow><annotation encoding="application/x-tex">A = 'El(A)'</annotation></semantics></math> to indicate that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is the <em>name</em> of the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">El(A)</annotation></semantics></math> in the type universe.</p>

<p>We usually also have operations on the universe corresponding to (but not identical to) type formers, such as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>A</mi><mo>:</mo><mi>𝒰</mi><mspace width="1em"></mspace><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>𝒰</mi></mrow><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>:</mo><mi>𝒰</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{A:\mathcal{U}\quad B:A\to \mathcal{U}}{\pi(A, B) : \mathcal{U}}</annotation></semantics></math></div>
<p>with an <a class="existingWikiWord" href="/nlab/show/equality">equality</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>El</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>Π</mi><mspace width="thinmathspace"></mspace><mi>El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>El</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">El(\pi(A,B))=\Pi \, El(A)\, El(B)</annotation></semantics></math>. Usually this latter equality (and those for other type formers) is a <a class="existingWikiWord" href="/nlab/show/judgmental+equality">judgmental equality</a>. If it is only an <a class="existingWikiWord" href="/nlab/show/equivalence+in+homotopy+type+theory">equivalence</a> (i.e. we have a rule which gives us a canonical term of the equivalence type), we may speak of a <strong><a class="existingWikiWord" href="/nlab/show/weakly+Tarski+universe">weakly Tarski universe</a></strong> (<a href="#Gallozzi14">Gallozzi 14, p. 49-50</a>).</p>

<p>We can give a slightly different definition of weakly Tarski universe using <a class="existingWikiWord" href="/nlab/show/propositional+equality">propositional equality</a> and a larger universe. More precisely, we can consider two (or many) universes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}'</annotation></semantics></math> with the usual rules for the relative reflection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>el</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>:</mo><mi>𝒰</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">el(a):\mathcal{U}'</annotation></semantics></math> for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">a:U</annotation></semantics></math>, a choice of weakly or strongly Tarski <a class="existingWikiWord" href="/nlab/show/computation+rules">computation rules</a> for the reflections <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>El</mi></mrow><annotation encoding="application/x-tex">El</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>El</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">El'</annotation></semantics></math>, and a computation rule for the relative reflection el of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi></mrow><annotation encoding="application/x-tex">\mathcal{U}</annotation></semantics></math> inside <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒰</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\mathcal{U}'</annotation></semantics></math> based on propositional equality, which gives us canonical elements of the identity types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Id</mi> <mrow><mi>𝒰</mi><mo>′</mo></mrow></msub><mo stretchy="false">(</mo><mi>π</mi><mo>′</mo><mo stretchy="false">(</mo><mi>el</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>,</mo><mi>el</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>,</mo><mi>el</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Id_{\mathcal{U}'}(\pi'(el(a),el(b)),el(\pi(a,b)))</annotation></semantics></math> and similarly for the other type formers.</p>

<p>If the containing universe is univalent the two definitions turn out to coincide.</p>

<p>The three notions of Tarski universe can be ordered by generality: Every Tarski universe is weakly Tarski by equivalences, because both definitional equality of types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \equiv B</annotation></semantics></math> and the identity types between two types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A = B</annotation></semantics></math> imply that the two types of equivalent <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><msub><mo>≃</mo> <mi>𝒰</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">A \simeq_\mathcal{U} B</annotation></semantics></math>. Similarly, every strict Tarski universe is weakly Tarski by the identity type, because definitional equality of types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \equiv B</annotation></semantics></math> implies that two types are identified <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A = B</annotation></semantics></math>.</p>

<p>Since each type former is independent of each other, one could also have mixed versions of Tarski universes, where some of the type formers are strictly Tarski and some are weakly Tarski. This leads to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math> possible Tarski universes, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> is the number of type formers in a type theory, and the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math> type theories are only <a class="existingWikiWord" href="/nlab/show/partially+ordered">partially ordered</a> by generality. Internally in an ambient universe, that number becomes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mn>3</mn> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">3^n</annotation></semantics></math>.</p>

<p>Universes defined internally via <a class="existingWikiWord" href="/nlab/show/induction-recursion">induction-recursion</a> are stricty Tarski. Weakly Tarski universes are easier to obtain in <a class="existingWikiWord" href="/nlab/show/semantics">semantics</a> (see <a href="#CategoricalSemantics">below</a>): they are somewhat more annoying to use, but probably suffice for most purposes. In <a class="existingWikiWord" href="/nlab/show/objective+type+theory">objective type theory</a>, there is no <a class="existingWikiWord" href="/nlab/show/definitional+equality">definitional equality</a>, so every Tarski universe is weakly Tarski.</p>

<h2 id="properties">Properties</h2>

<h3 id="UniverseEnlargement">Universe enlargement</h3>

<p>Both <a class="existingWikiWord" href="/nlab/show/Coq">Coq</a> and <a class="existingWikiWord" href="/nlab/show/Agda">Agda</a> support <a class="existingWikiWord" href="/nlab/show/universe+polymorphism">universe polymorphism</a> to deal with the issue of universe enlargement. Moreover, Coq supports <a class="existingWikiWord" href="/nlab/show/typical+ambiguity">typical ambiguity</a>.</p>

<h3 id="extensionality_principle_of_type_universes">Extensionality principle of type universes</h3>

<p>The extensionality principle of type universes is given by the <a class="existingWikiWord" href="/nlab/show/univalence+axiom">univalence axiom</a>, which for <a class="existingWikiWord" href="/nlab/show/Tarski+universes">Tarski universes</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(U, T)</annotation></semantics></math> states that <a class="existingWikiWord" href="/nlab/show/transport">transport</a> across the universal type family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is an equivalence of types for all small types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">A:U</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">B:U</annotation></semantics></math>; and for <a class="existingWikiWord" href="/nlab/show/Russell+universes">Russell universes</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> states that the recursively defined function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">idToEquiv</mi></mrow><annotation encoding="application/x-tex">\mathrm{idToEquiv}</annotation></semantics></math>, which takes identifications between small types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">A:U</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">B:U</annotation></semantics></math> to equivalences between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, is an equivalence of types for all small types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">A:U</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">B:U</annotation></semantics></math>.</p>

<h3 id="cumulativity">Cumulativity</h3>

<p>A tower of universes is <strong>cumulative</strong> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><msub><mi>𝒰</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A:\mathcal{U}_i</annotation></semantics></math> implies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><msub><mi>𝒰</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A:\mathcal{U}_{i+1}</annotation></semantics></math> (rather than, say, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Lift</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi>𝒰</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Lift(A):\mathcal{U}_{i+1}</annotation></semantics></math>).</p>

<p>Cumulative Russell universes have some issues; see for instance <a href="#Luo12">Luo 12</a>.</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Coq">Coq</a> uses Russell style universes. For practical purposes, it also has cumulativity, although there is some question (perhaps mainly semantic) of whether this is true internally or whether it uses casts that are simply hidden from the user.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Agda">Agda</a> uses non-cumulative Russell style universes.</p>
</li>

<li>
<p><a href="#UFP13">UFP13</a> (first edition) uses cumulative Russell style universes.</p>
</li>
</ul>

<h3 id="CategoricalSemantics">Categorical semantics</h3>

<p><a class="existingWikiWord" href="/nlab/show/univalence">Univalent</a><a href="#RussellStyle">Russell universes</a> have been shown to be interpreted in <a class="existingWikiWord" href="/nlab/show/type-theoretic+model+categories">type-theoretic model categories</a> presenting the base <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-topos">(∞,1)-topos</a> <a class="existingWikiWord" href="/nlab/show/%E2%88%9EGrpd">∞Grpd</a></p>

<p>(<a href="#KapulkinLumsdaineVoevodsky12">Kapulkin-Lumsdaine-Voevodsky 12</a>) and more generally presenting <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-toposes">(∞,1)-toposes</a> of <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-presheaves">(∞,1)-presheaves</a> over <a class="existingWikiWord" href="/nlab/show/elegant+Reedy+categories">elegant Reedy categories</a> (<a href="#Shulman13">Shulman 13</a>).</p>

<p>Discussion for general <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-toposes">(∞,1)-toposes</a> (of <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-sheaves">(∞,1)-sheaves</a>) that should have implementation <a href="#TarskiStyle">weakly Tarski</a> (<a href="#Gallozzi14">Gallozzi 14, p. 49-50</a>) is in (<a href="#GepnerKock12">Gepner-Kock 12</a>).</p>

<p>For more on this see the respective sections at <em><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a></em>.</p>

<h2 id="other_types_of_types">Other types of types</h2>

<p>There is other notions of type of types. Suppose we have a Russell universe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> or a Tarski universe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(U, T)</annotation></semantics></math> and a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>:</mo><mi>U</mi><mo>→</mo><msub><mi mathvariant="normal">Prop</mi> <mi>U</mi></msub></mrow><annotation encoding="application/x-tex">P:U \to \mathrm{Prop}_U</annotation></semantics></math>. Then the type of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>-small types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> is given by the <a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>A</mi><mo>:</mo><mi>U</mi></mrow></msub><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{A:U} P(A)</annotation></semantics></math> for Russell universes and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>A</mi><mo>:</mo><mi>U</mi></mrow></msub><mi>T</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{A:U} T(P(A))</annotation></semantics></math> for Tarski universes.</p>

<p>Since universes are internal models of type theory, in a dependent type theory with a separate <a class="existingWikiWord" href="/nlab/show/type">type</a> <a class="existingWikiWord" href="/nlab/show/judgment">judgment</a>, one could generalize the above notion of “type of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>-small types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>” to the notion of “type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>”. Types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, previously elements of the universe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">A:U</annotation></semantics></math>, are now judged to be types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow><annotation encoding="application/x-tex">A \; \mathrm{type}</annotation></semantics></math>. The function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>:</mo><mi>U</mi><mo>→</mo><msub><mi mathvariant="normal">Prop</mi> <mi>U</mi></msub></mrow><annotation encoding="application/x-tex">P:U \to \mathrm{Prop}_U</annotation></semantics></math> which takes types to propositons is now an operator on types, which is defined using <a class="existingWikiWord" href="/nlab/show/inference+rules">inference rules</a>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac><mspace width="1em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">proptrunc</mi> <mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mo>:</mo><mi mathvariant="normal">isProp</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash P(A) \; \mathrm{type}} \quad \frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{proptrunc}_{P(A)}:\mathrm{isProp}(P(A)) \; \mathrm{type}}</annotation></semantics></math></div>
<p>as well as the typal congruence rules for forming <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi><mo>≃</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">congform</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type} \quad \Gamma \vdash e:A \simeq B}{\Gamma \vdash \mathrm{congform}_P(e):P(A) \simeq P(B) \; \mathrm{type}}</annotation></semantics></math></div>
<p>Examples of such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> definable from the existing type formers in <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a> include</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">isProp</mi></mrow><annotation encoding="application/x-tex">\mathrm{isProp}</annotation></semantics></math>, which results in the <a class="existingWikiWord" href="/nlab/show/type+of+all+propositions">type of all propositions</a>,</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">isFinite</mi></mrow><annotation encoding="application/x-tex">\mathrm{isFinite}</annotation></semantics></math>, which results in the <a class="existingWikiWord" href="/nlab/show/type+of+all+finite+types">type of all finite types</a>,</li>

<li>given a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>≃</mo><mi>T</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[(-) \simeq T]</annotation></semantics></math>, which results in the type of all types merely <a class="existingWikiWord" href="/nlab/show/equivalence+of+types">equivalent</a> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>.</li>

<li>given a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>↪</mo><mi>T</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[(-) \hookrightarrow T]</annotation></semantics></math>, which results in the <a class="existingWikiWord" href="/nlab/show/subobject+preorder">subtype preorder</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, the type of all types which merely <a class="existingWikiWord" href="/nlab/show/embedding+of+types">embed into</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>.</li>
</ul>

<p>The resulting <strong>type of types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></strong> is denoted by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Type}_P</annotation></semantics></math>.</p>

<p>Care must be taken for which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> one could use to define the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>. For example, given <a class="existingWikiWord" href="/nlab/show/unit+type">unit type</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝟙</mi></mrow><annotation encoding="application/x-tex">\mathbb{1}</annotation></semantics></math>, for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mo>→</mo><mi>𝟙</mi></mrow><annotation encoding="application/x-tex">P(A) \equiv A \to \mathbb{1}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≡</mo><mi mathvariant="normal">isSet</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A) \equiv \mathrm{isSet}(A)</annotation></semantics></math>, the resulting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Type}_P</annotation></semantics></math> always contains itself or its <a class="existingWikiWord" href="/nlab/show/set+truncation">set truncation</a> in addition to the <a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a>, resulting in <a class="existingWikiWord" href="/nlab/show/Girard%27s+paradox">Girard's paradox</a>; thus, one cannot form such types of types in the type theory. Similarly, for</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≡</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></munder><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>y</mi><mo>:</mo><mi>A</mi></mrow></munder><mo stretchy="false">(</mo><mi>x</mi><msub><mo>=</mo> <mi>A</mi></msub><mi>y</mi><mo stretchy="false">)</mo><mo>∨</mo><mo>¬</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mo>=</mo> <mi>A</mi></msub><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A) \equiv \prod_{x:A} \prod_{y:A} (x =_A y) \vee \neg (x =_A y)</annotation></semantics></math></div>
<p>the resulting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Type}_P</annotation></semantics></math> contains its set truncation in addition to the empty type if the <a class="existingWikiWord" href="/nlab/show/principle+of+excluded+middle">principle of excluded middle</a> holds for all propositions, resulting in <a class="existingWikiWord" href="/nlab/show/Girard%27s+paradox">Girard's paradox</a>; thus, one could only form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Type}_P</annotation></semantics></math> for</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≡</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></munder><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>y</mi><mo>:</mo><mi>A</mi></mrow></munder><mo stretchy="false">(</mo><mi>x</mi><msub><mo>=</mo> <mi>A</mi></msub><mi>y</mi><mo stretchy="false">)</mo><mo>∨</mo><mo>¬</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mo>=</mo> <mi>A</mi></msub><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A) \equiv \prod_{x:A} \prod_{y:A} (x =_A y) \vee \neg (x =_A y)</annotation></semantics></math></div>
<p>if one doesn’t have excluded middle in the type theory.</p>

<p>Now, supposing that the <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a> has the above rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Type}_P</annotation></semantics></math> could be presented either as a <a class="existingWikiWord" href="/nlab/show/Russell+universe">Russell universe</a> or a <a class="existingWikiWord" href="/nlab/show/Tarski+universe">Tarski universe</a> in a <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a>. The difference between the two is that in the former, every type which satisfies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> in the type theory is literally an element of the type of types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>, while in the latter, elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{Type}_P</annotation></semantics></math> are only indices of a type family <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">El</mi></mrow><annotation encoding="application/x-tex">\mathrm{El}</annotation></semantics></math>; every <a class="existingWikiWord" href="/nlab/show/finite+type">finite type</a> in the type theory is only <a class="existingWikiWord" href="/nlab/show/essentially+small+type">essentially <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml">
  <semantics>
    <mrow>
      <msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub>
    </mrow>
    <annotation encoding="application/x-tex">\mathrm{Type}_P</annotation>
  </semantics>
</math>-small</a> for <a class="existingWikiWord" href="/nlab/show/weak+Tarski+universes">weak Tarski universes</a> or <a class="existingWikiWord" href="/nlab/show/judgmentally+equal">judgmentally equal</a> to an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><annotation encoding="application/x-tex">A:\mathrm{Type}_P</annotation></semantics></math> for <a class="existingWikiWord" href="/nlab/show/strict+Tarski+universes">strict Tarski universes</a>.</p>

<h4 id="as_a_strict_tarski_universe">As a strict Tarski universe</h4>

<p>As a <a class="existingWikiWord" href="/nlab/show/strict+Tarski+universe">strict Tarski universe</a>, the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> is given by the following <a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a> <a class="existingWikiWord" href="/nlab/show/inference+rules">inference rules</a>:</p>

<p>Formation rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">ctx</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \; \mathrm{ctx}}{\Gamma \vdash \mathrm{Type}_P \; \mathrm{type}}</annotation></semantics></math></div>
<p>Introduction rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{toElem}_A:P(A) \to \mathrm{Type}_P}</annotation></semantics></math></div>
<p>Elimination rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \mathrm{El}(A) \; \mathrm{type}} \qquad \frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \mathrm{witn}_P(A):P(\mathrm{El}(A))}</annotation></semantics></math></div>
<p>Computation rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \mathrm{El}(\mathrm{toElem}_A(p)) \equiv A \; \mathrm{type}}</annotation></semantics></math></div>
<ul>
<li>Judgmental computation rules:</li>
</ul>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≡</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \mathrm{witn}_P(\mathrm{toElem}_A(p)) \equiv p:P(A)}</annotation></semantics></math></div>
<ul>
<li>Typal computation rules:</li>
</ul>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msubsup><mi>β</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow> <mrow><msub><mi mathvariant="normal">Witn</mi> <mi>P</mi></msub><mo>,</mo><mi>A</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mo>=</mo> <mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \beta_{\mathrm{Type}_P}^{\mathrm{Witn}_P,A}(p):\mathrm{witn}_P(\mathrm{toElem}_A(p)) =_{P(A)} p}</annotation></semantics></math></div>
<p>Uniqueness rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>

<ul>
<li>
<p>Judgmental computation rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">toElem</mi> <mrow><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \mathrm{toElem}_{\mathrm{El}(A)}(\mathrm{witn}_P(A)) \equiv A:\mathrm{Type}_P}</annotation></semantics></math></div></li>

<li>
<p>Typal computation rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>η</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi mathvariant="normal">toElem</mi> <mrow><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mo>=</mo> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \eta_{\mathrm{Type}_P}(A):\mathrm{toElem}_{\mathrm{El}(A)}(\mathrm{witn}_P(A)) =_{\mathrm{Type}_P} A}</annotation></semantics></math></div></li>
</ul>

<p><a class="existingWikiWord" href="/nlab/show/univalence+axiom">Extensionality principle</a> of the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">ext</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">isEquiv</mi><mo stretchy="false">(</mo><msup><mi mathvariant="normal">transport</mi> <mi mathvariant="normal">El</mi></msup><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P \quad \Gamma \vdash B:\mathrm{Type}_P} {\Gamma \vdash \mathrm{ext}_{\mathrm{Type}_P}(A, B):\mathrm{isEquiv}(\mathrm{transport}^\mathrm{El}(A, B))}</annotation></semantics></math></div>
<h4 id="as_a_weak_tarski_universe">As a weak Tarski universe</h4>

<p>As a <a class="existingWikiWord" href="/nlab/show/weak+Tarski+universe">weak Tarski universe</a>, the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> is given by the following <a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a> <a class="existingWikiWord" href="/nlab/show/inference+rules">inference rules</a>:</p>

<p>Formation rules for the type of all finite types:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">ctx</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \; \mathrm{ctx}}{\Gamma \vdash \mathrm{Type}_P \; \mathrm{type}}</annotation></semantics></math></div>
<p>Introduction rules for the type of all finite types:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{toElem}_A:P(A) \to \mathrm{Type}_P}</annotation></semantics></math></div>
<p>Elimination rules for the type of all finite types:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \mathrm{El}(A) \; \mathrm{type}} \qquad \frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \mathrm{witn}_P(A):P(\mathrm{El}(A))}</annotation></semantics></math></div>
<p>Computation rules for the type of all finite types:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msubsup><mi>β</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow> <mrow><mi mathvariant="normal">El</mi><mo>,</mo><mi>A</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≃</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \beta_{\mathrm{Type}_P}^{\mathrm{El}, A}(p):\mathrm{El}(\mathrm{toElem}_A(p)) \simeq A \; \mathrm{type}}</annotation></semantics></math></div>
<ul>
<li>Judgmental computation rules:</li>
</ul>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">congform</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msubsup><mi>β</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow> <mrow><mi mathvariant="normal">El</mi><mo>,</mo><mi>A</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≡</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \mathrm{congform}_P(\beta_{\mathrm{Type}_P}^{\mathrm{El}, A}(p))(\mathrm{witn}_P(\mathrm{toElem}_A(p))) \equiv p:P(A)}</annotation></semantics></math></div>
<ul>
<li>Typal computation rules:</li>
</ul>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msubsup><mi>β</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow> <mrow><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo>,</mo><mi>A</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi mathvariant="normal">congform</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msubsup><mi>β</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow> <mrow><mi mathvariant="normal">El</mi><mo>,</mo><mi>A</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mo>=</mo> <mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \beta_{\mathrm{Type}_P}^{\mathrm{witn}_P,A}(p):\mathrm{congform}_P(\beta_{\mathrm{Type}_P}^{\mathrm{El}, A}(p))(\mathrm{witn}_P(\mathrm{toElem}_A(p))) =_{P(A)} p}</annotation></semantics></math></div>
<p>where the equivalence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi mathvariant="normal">congform</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msubsup><mi>β</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow> <mrow><mi mathvariant="normal">El</mi><mo>,</mo><mi>A</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≃</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{congform}_P(\beta_{\mathrm{Type}_P}^{\mathrm{El}, A}(p)):P(\mathrm{El}(\mathrm{toElem}_A(p))) \simeq P(A)</annotation></semantics></math></div>
<p>is provided from the typal computation rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math>.</p>

<p>Uniqueness rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>

<ul>
<li>
<p>Judgmental computation rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>≡</mo><msub><mi mathvariant="normal">toElem</mi> <mrow><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash A \equiv \mathrm{toElem}_{\mathrm{El}(A)}(\mathrm{witn}_P(A)):\mathrm{Type}_P}</annotation></semantics></math></div></li>

<li>
<p>Typal computation rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>η</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><msub><mo>=</mo> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><msub><mi mathvariant="normal">toElem</mi> <mrow><mi mathvariant="normal">El</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \eta_{\mathrm{Type}_P}(A):A =_{\mathrm{Type}_P} \mathrm{toElem}_{\mathrm{El}(A)}(\mathrm{witn}_P(A))}</annotation></semantics></math></div></li>
</ul>

<p><a class="existingWikiWord" href="/nlab/show/univalence+axiom">Extensionality principle</a> of the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">ext</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">isEquiv</mi><mo stretchy="false">(</mo><msup><mi mathvariant="normal">transport</mi> <mi mathvariant="normal">El</mi></msup><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P \quad \Gamma \vdash B:\mathrm{Type}_P} {\Gamma \vdash \mathrm{ext}_{\mathrm{Type}_P}(A, B):\mathrm{isEquiv}(\mathrm{transport}^\mathrm{El}(A, B))}</annotation></semantics></math></div>
<h4 id="as_a_russell_universe">As a Russell universe</h4>

<p>As a <a class="existingWikiWord" href="/nlab/show/Russell+universe">Russell universe</a>, the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> is given by the following <a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a> <a class="existingWikiWord" href="/nlab/show/inference+rules">inference rules</a>:</p>

<p>Formation rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">ctx</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \; \mathrm{ctx}}{\Gamma \vdash \mathrm{Type}_P \; \mathrm{type}}</annotation></semantics></math></div>
<p>Introduction rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type}}{\Gamma \vdash \mathrm{toElem}_A:P(A) \to \mathrm{Type}_P}</annotation></semantics></math></div>
<p>Elimination rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash A \; \mathrm{type}} \qquad \frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \mathrm{witn}_P(A):P(A)}</annotation></semantics></math></div>
<p>Computation rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \mathrm{toElem}_A(p) \equiv A \; \mathrm{type}}</annotation></semantics></math></div>
<ul>
<li>Judgmental computation rules:</li>
</ul>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≡</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \mathrm{witn}_P(\mathrm{toElem}_A(p)) \equiv p:P(A)}</annotation></semantics></math></div>
<ul>
<li>Typal computation rules:</li>
</ul>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi mathvariant="normal">type</mi><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msubsup><mi>β</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow> <mrow><mi mathvariant="normal">finWitn</mi><mo>,</mo><mi>A</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mo>=</mo> <mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash p:P(A)}{\Gamma \vdash \beta_{\mathrm{Type}_P}^{\mathrm{finWitn},A}(p):\mathrm{witn}_P(\mathrm{toElem}_A(p)) =_{P(A)} p}</annotation></semantics></math></div>
<p>Uniqueness rules for the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>

<ul>
<li>
<p>Judgmental computation rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \mathrm{toElem}_{A}(\mathrm{witn}_P(A)) \equiv A:\mathrm{Type}_P}</annotation></semantics></math></div></li>

<li>
<p>Typal computation rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>η</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi mathvariant="normal">toElem</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="normal">witn</mi> <mi>P</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mo>=</mo> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P}{\Gamma \vdash \eta_{\mathrm{Type}_P}(A):\mathrm{toElem}_{A}(\mathrm{witn}_P(A)) =_{\mathrm{Type}_P} A}</annotation></semantics></math></div></li>
</ul>

<p><a class="existingWikiWord" href="/nlab/show/univalence+axiom">Extensionality principle</a> of the type of all types which satisfy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub><mspace width="1em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo>:</mo><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi mathvariant="normal">ext</mi> <mrow><msub><mi mathvariant="normal">Type</mi> <mi>P</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">isEquiv</mi><mo stretchy="false">(</mo><mi mathvariant="normal">idToEquiv</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A:\mathrm{Type}_P \quad \Gamma \vdash B:\mathrm{Type}_P} {\Gamma \vdash \mathrm{ext}_{\mathrm{Type}_P}(A, B):\mathrm{isEquiv}(\mathrm{idToEquiv}(A, B))}</annotation></semantics></math></div>
<h2 id="related_concepts">Related concepts</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/resizing+axiom">resizing axiom</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/universe+polymorphism">universe polymorphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/univalence">univalence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Prop">Prop</a>, the <a class="existingWikiWord" href="/nlab/show/type+of+propositions">type of propositions</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+of+classes">type of classes</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/parametric+polymorphism">parametric polymorphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Girard%27s+paradox">Girard's paradox</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Awodey%27s+conjecture">Awodey's conjecture</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/univalent+type+theory">univalent type theory</a></p>
</li>
</ul>

<h2 id="references">References</h2>

<p>Type universes in <a class="existingWikiWord" href="/nlab/show/Martin-L%C3%B6f+type+theory">Martin-Löf type theory</a> originate in un-stratified and hence inconsistent form with</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a>, §2.7.1 in: <em>A Theory of Types</em>, unpublished note (1971) &lbrack;<a href="https://raw.githubusercontent.com/michaelt/martin-lof/master/pdfs/martin-loef1971%20-%20A%20Theory%20of%20Types.pdf">pdf</a>, <a class="existingWikiWord" href="/nlab/files/MartinLoef1971-ATheoryOfTypes.pdf" title="pdf">pdf</a>&rbrack;</li>
</ul>

<p>and then in stratified and consistent form in</p>

<ul>
<li id="MartinLof75"><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a>, §1.10 in: <em>An intuitionistic theory of types: predicative part</em>, in: H. E. Rose, J. C. Shepherdson (eds.), <em>Logic Colloquium ‘73, Proceedings of the Logic Colloquium</em>, Studies in Logic and the Foundations of Mathematics <strong>80</strong>, Elsevier (1975) 73-118 &lbrack;<a href="https://doi.org/10.1016/S0049-237X(08)71945-1">doi:10.1016/S0049-237X(08)71945-1</a>, <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.926">CiteSeer</a>&rbrack;</li>
</ul>

<p>elaborated on in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a> (notes by <a class="existingWikiWord" href="/nlab/show/Giovanni+Sambin">Giovanni Sambin</a>): <em>Universes</em>, pp. 47 in: <em>Intuitionistic type theory</em>, Lecture notes Padua 1984, Bibliopolis, Napoli (1984) &lbrack;<a href="https://archive-pml.github.io/martin-lof/pdfs/Bibliopolis-Book-retypeset-1984.pdf">pdf</a>, <a class="existingWikiWord" href="/nlab/files/MartinLofIntuitionisticTypeTheory.pdf" title="pdf">pdf</a>&rbrack;</li>
</ul>

<p>which also introduces (p. 48) the distinction into notions of <em><a class="existingWikiWord" href="/nlab/show/Russell+universes">Russell universes</a></em> and <em><a class="existingWikiWord" href="/nlab/show/Tarski+universes">Tarski universes</a></em>.</p>

<p>Further discussion in</p>

<ul>
<li id="Hofmann95"><a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, <em>Universes</em>, section 2.3.5 in: <em>Syntax and semantics of dependent types</em>, Chapter 2 in: <em>Extensional concepts in intensional type theory</em>, Ph.D. thesis, University of Edinburgh (1995), Distinguished Dissertations, Springer (1997) &lbrack;<a href="http://www.lfcs.inf.ed.ac.uk/reports/95/ECS-LFCS-95-327/">ECS-LFCS-95-327</a>, <a class="existingWikiWord" href="/nlab/files/HofmannExtensionalIntensionalTypeTheory.pdf" title="pdf">pdf</a>, <a href="https://doi.org/10.1007/978-1-4471-0963-1">doi:10.1007/978-1-4471-0963-1</a>&rbrack;</li>
</ul>

<p>Review and further discussion:</p>

<ul>
<li id="Palmgren"><a class="existingWikiWord" href="/nlab/show/Erik+Palmgren">Erik Palmgren</a>, <em>On Universes in Type Theory</em>, in <em>Twenty-Five Years of Constructive Type Theory</em>, Oxford University Press (1998) 191–204 &lbrack;<a href="http://www2.math.uu.se/~palmgren/universe.pdf">pdf</a>, <a href="https://doi.org/10.1093/oso/9780198501275.003.0012">doi:10.1093/oso/9780198501275.003.0012</a>&rbrack;</li>
</ul>

<p>Introduction with an eye towards <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>:</p>

<ul>
<li id="UFP13"><a class="existingWikiWord" href="/nlab/show/Univalent+Foundations+Project">Univalent Foundations Project</a>, §1.3 in <em><a class="existingWikiWord" href="/nlab/show/Homotopy+Type+Theory+--+Univalent+Foundations+of+Mathematics">Homotopy Type Theory – Univalent Foundations of Mathematics</a></em> (2013) &lbrack;<a href="http://homotopytypetheory.org/book/">web</a>, <a href="http://hottheory.files.wordpress.com/2013/03/hott-online-323-g28e4374.pdf">pdf</a>&rbrack;</li>
</ul>

<p>Definition of weakly Tarski universes:</p>

<ul>
<li id="Hofmann">
<p><a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, section 2.1.6 of <em>Syntax and semantics of dependent types</em> (<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.8985">web</a>)</p>
</li>

<li id="Luo12">
<p><a class="existingWikiWord" href="/nlab/show/Zhaohui+Luo">Zhaohui Luo</a>, <em>Notes on Universes in Type Theory</em>, 2012 (<a href="http://www.cs.rhul.ac.uk/home/zhaohui/universes.pdf">pdf</a>)</p>
</li>

<li id="Gallozzi14">
<p><a class="existingWikiWord" href="/nlab/show/Cesare+Gallozzi">Cesare Gallozzi</a>, <em>Constructive Set Theory from a Weak Tarski Universe</em>, MSc thesis (2014) (<a href="http://xxx.tau.ac.il/abs/1411.5591">arXiv:1411.5591</a>)</p>
</li>
</ul>

<p>Detailed discussion of the type of types in <a class="existingWikiWord" href="/nlab/show/Coq">Coq</a> is in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Adam+Chlipala">Adam Chlipala</a>, <em><a href="http://adam.chlipala.net/cpdt/">Certified programming with dependent types</a></em> – <em><a href="http://adam.chlipala.net/cpdt/html/Universes.html">Library Universes</a></em></li>
</ul>

<p>See also around slide 8 of the survey</p>

<ul>
<li>Frade, <em>Calculus of inductive constructions</em> (2008/2009) (<a href="http://www3.di.uminho.pt/~mjf/pub/SFV-CIC-2up.pdf">pdf</a>)</li>
</ul>

<p>A <a class="existingWikiWord" href="/nlab/show/formal+proof">formal proof</a> in <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> that the type of <a class="existingWikiWord" href="/nlab/show/homotopy+n-types">homotopy n-types</a> is not itself a homotopy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-type (it is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math>-type) is in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Nicolai+Kraus">Nicolai Kraus</a>, <a class="existingWikiWord" href="/nlab/show/Christian+Sattler">Christian Sattler</a>, <em>The universe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒰</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{U}_n</annotation></semantics></math> is not an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-type</em> May 2013 (<a href="http://red.cs.nott.ac.uk/~ngk/universes.pdf">pdf</a>)</li>
</ul>

<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+theory">(∞,1)-Categorical</a> semantics for <a class="existingWikiWord" href="/nlab/show/univalence">univalent</a> type universes is discussed in</p>

<ul>
<li id="KapulkinLumsdaineVoevodsky12">
<p><a class="existingWikiWord" href="/nlab/show/Chris+Kapulkin">Chris Kapulkin</a>, <a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>, <a class="existingWikiWord" href="/nlab/show/Vladimir+Voevodsky">Vladimir Voevodsky</a>, <em>The Simplicial Model of Univalent Foundations</em> (<a href="http://arxiv.org/abs/1211.2851">arXiv:1211.2851</a>)</p>
</li>

<li id="Shulman13">
<p><a class="existingWikiWord" href="/nlab/show/Michael+Shulman">Michael Shulman</a>, <em>The univalence axiom for elegant Reedy presheaves</em> (<a href="http://arxiv.org/abs/1307.6248">arXiv:1307.6248</a>)</p>
</li>

<li id="GepnerKock12">
<p><a class="existingWikiWord" href="/nlab/show/David+Gepner">David Gepner</a>, <a class="existingWikiWord" href="/nlab/show/Joachim+Kock">Joachim Kock</a>, <em>Univalence in locally cartesian closed ∞-categories</em> (<a href="http://arxiv.org/abs/1208.1749">arXiv:1208.1749</a>)</p>
</li>
</ul>

<p>Relation to <a class="existingWikiWord" href="/nlab/show/injective+types">injective types</a>:</p>

<ul>
<li id="Escardo19"><a class="existingWikiWord" href="/nlab/show/Mart%C3%ADn+Escard%C3%B3">Martín Escardó</a>, <em>Injectives types in univalent mathematics</em> (<a href="https://arxiv.org/abs/1903.01211">arXiv:1903.01211</a>)</li>
</ul>

<p>See also</p>

<ul>
<li id="Rathjen">
<p><a class="existingWikiWord" href="/nlab/show/Michael+Rathjen">Michael Rathjen</a>, <em>The strength of Martin-Löf type theory with superuniverse. Part I</em> <a href="https://www1.maths.leeds.ac.uk/~rathjen/Super.pdf">pdf</a></p>
</li>

<li id="SEP">
<p>Stanford Encyclopedia of Philosophy, <em><a href="http://plato.stanford.edu/entries/type-theory/#6">Type theory – Extensions of type systems, Polymorphism, Paradoxes</a></em></p>
</li>

<li id="Luo11">
<p><a class="existingWikiWord" href="/nlab/show/Zhaohui+Luo">Zhaohui Luo</a>, <em>Contextual analysis of word meanings in type-theoretical semantics</em>, in Pogodalla, Prost (eds.) <em>Logical Aspects of Computational Linguistics</em>, 2011 (<a href="http://www.cs.rhul.ac.uk/home/zhaohui/LACL11.pdf">pdf</a>)</p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on November 24, 2023 at 19:25:16.
    See the <a href="/nlab/history/type+universe" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/type+universe" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/3362/#Item_16">Discuss</a><span class="backintime"><a href="/nlab/revision/type+universe/55" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/type+universe" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/type+universe" accesskey="S" class="navlink" id="history" rel="nofollow">History (55 revisions)</a>
  <a href="/nlab/show/type+universe/cite" style="color: black">Cite</a>
  <a href="/nlab/print/type+universe" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/type+universe" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
