
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      categorical model of dependent types in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1553353531" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1592003439" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="http://nlab-local/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="http://nlab-local/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span><br />
      categorical model of dependent types
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/3853/#Item_41" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Categorical models of dependent types</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="type_theory">Type theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></strong> <a class="existingWikiWord" href="/nlab/show/metalanguage">metalanguage</a>, <a class="existingWikiWord" href="/nlab/show/practical+foundations">practical foundations</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/judgement">judgement</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hypothetical+judgement">hypothetical judgement</a>, <a class="existingWikiWord" href="/nlab/show/sequent">sequent</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/antecedents">antecedents</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/consequent">consequent</a>, <a class="existingWikiWord" href="/nlab/show/succedents">succedents</a></li>
</ul>
</li>
</ul>

<ol>
<li><a class="existingWikiWord" href="/nlab/show/type+formation+rule">type formation rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+introduction+rule">term introduction rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+elimination+rule">term elimination rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/computation+rule">computation rule</a></li>
</ol>

<p><strong><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></strong> (<a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent</a>, <a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional</a>, <a class="existingWikiWord" href="/nlab/show/observational+type+theory">observational type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>)</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a></li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/syntax">syntax</a></strong> <a class="existingWikiWord" href="/nlab/show/object+language">object language</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/theory">theory</a>, <a class="existingWikiWord" href="/nlab/show/axiom">axiom</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>/<a class="existingWikiWord" href="/nlab/show/type">type</a> (<a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/definition">definition</a>/<a class="existingWikiWord" href="/nlab/show/proof">proof</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a> (<a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/theorem">theorem</a></p>
</li>
</ul>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></strong> = <br /> <strong><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/programs+as+proofs">programs as proofs</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation type theory/category theory</a></strong></p>

<table><thead><tr><th><a class="existingWikiWord" href="/nlab/show/logic">logic</a></th><th><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></th><th><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></th></tr></thead><tbody><tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/true">true</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-2%29-truncated+object">(-2)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+0">h-level 0</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/unit+type">unit type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/false">false</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28-1%29-truncated+object">(-1)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-proposition">h-proposition</a>, <a class="existingWikiWord" href="/nlab/show/mere+proposition">mere proposition</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof">proof</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/program">program</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+rule">cut rule</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/composition">composition</a> of <a class="existingWikiWord" href="/nlab/show/classifying+morphisms">classifying morphisms</a> / <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of <a class="existingWikiWord" href="/nlab/show/display+maps">display maps</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/substitution">substitution</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+elimination">cut elimination</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/counit">counit</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/beta+reduction">beta reduction</a></td></tr>
<tr><td style="text-align: left;">introduction rule for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/unit">unit</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/eta+conversion">eta conversion</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+conjunction">logical conjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product">product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product+type">product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjunction">disjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/sum+type">sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/negation">negation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a> into <a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a> into <a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universal+quantification">universal quantification</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product+type">dependent product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/existential+quantification">existential quantification</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence">equivalence</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/path+space+object">path space object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/identity+type">identity type</a>/<a class="existingWikiWord" href="/nlab/show/path+type">path type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+class">equivalence class</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient">quotient</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+type">quotient type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/W-type">W-type</a>, <a class="existingWikiWord" href="/nlab/show/M-type">M-type</a></td></tr>
<tr><td style="text-align: left;">higher <a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></td></tr>
<tr><td style="text-align: left;">-</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/0-truncated">0-truncated</a> <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+inductive+type">quotient inductive type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinduction">coinduction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/limit">limit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinductive+type">coinductive type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/completely+presented+set">completely presented set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/discrete+object">discrete object</a>/<a class="existingWikiWord" href="/nlab/show/0-truncated+object">0-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+2">h-level 2</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/preset">preset</a>/<a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/groupoid+object+in+an+%28infinity%2C1%29-category">internal 0-groupoid</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>/<a class="existingWikiWord" href="/nlab/show/setoid">setoid</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universe">universe</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+of+types">type of types</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modality">modality</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/closure+operator">closure operator</a>, (<a class="existingWikiWord" href="/nlab/show/idempotent+monad">idempotent</a>) <a class="existingWikiWord" href="/nlab/show/monad">monad</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modal+type+theory">modal type theory</a>, <a class="existingWikiWord" href="/nlab/show/monad+%28in+computer+science%29">monad (in computer science)</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+logic">linear logic</a></td><td style="text-align: left;">(<a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric</a>, <a class="existingWikiWord" href="/nlab/show/closed+monoidal+category">closed</a>) <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal category</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+type+theory">linear type theory</a>/<a class="existingWikiWord" href="/nlab/show/quantum+computation">quantum computation</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof+net">proof net</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/string+diagram">string diagram</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quantum+circuit">quantum circuit</a></td></tr>
<tr><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/contraction+rule">contraction rule</a></td><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/diagonal">diagonal</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/no-cloning+theorem">no-cloning theorem</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/synthetic+mathematics">synthetic mathematics</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+specific+embedded+programming+language">domain specific embedded programming language</a></td></tr>
</tbody></table>

</div>
<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+levels">homotopy levels</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-type+theory">2-type theory</a>, <a class="existingWikiWord" href="/michaelshulman/show/2-categorical+logic">2-categorical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory+-+contents">homotopy type theory - contents</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/univalence">univalence</a>, <a class="existingWikiWord" href="/nlab/show/function+extensionality">function extensionality</a>, <a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+type+theory">cohesive homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/directed+homotopy+type+theory">directed homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/HoTT+methods+for+homotopy+theorists">HoTT methods for homotopy theorists</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/semantics">semantics</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>, <a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/display+map">display map</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+a+topos">internal logic of a topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Mitchell-Benabou+language">Mitchell-Benabou language</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kripke-Joyal+semantics">Kripke-Joyal semantics</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type-theoretic+model+category">type-theoretic model category</a></li>
</ul>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/type+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>

<h4 id="category_theory">Category theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></strong></p>

<h2 id="concepts">Concepts</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category">category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/functor">functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Cat">Cat</a></p>
</li>
</ul>

<h2 id="universal_constructions">Universal constructions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/universal+construction">universal construction</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/representable+functor">representable functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+functor">adjoint functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/limit">limit</a>/<a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/end">end</a>/<a class="existingWikiWord" href="/nlab/show/coend">coend</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kan+extension">Kan extension</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="theorems">Theorems</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Isbell+duality">Isbell duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Grothendieck+construction">Grothendieck construction</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+functor+theorem">adjoint functor theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monadicity+theorem">monadicity theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+lifting+theorem">adjoint lifting theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Tannaka+duality">Tannaka duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Gabriel-Ulmer+duality">Gabriel-Ulmer duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Freyd-Mitchell+embedding+theorem">Freyd-Mitchell embedding theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a></p>
</li>
</ul>

<h2 id="extensions">Extensions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sheaf+and+topos+theory">sheaf and topos theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/enriched+category+theory">enriched category theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+category+theory">higher category theory</a></p>
</li>
</ul>

<h2 id="applications">Applications</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/applications+of+%28higher%29+category+theory">applications of (higher) category theory</a></li>
</ul>
<div>
<p>
  <a href="/nlab/edit/category+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="categorical_models_of_dependent_types">Categorical models of dependent types</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#definitions'>Definitions</a></li>
<ul>
<li><a href='#comprehension_categories'>Comprehension categories</a></li>
<li><a href='#display_map_categories'>Display map categories</a></li>
<li><a href='#categories_with_attributes'>Categories with attributes</a></li>
<li><a href='#categories_with_families'>Categories with families</a></li>
<li><a href='#natural_models'>Natural Models</a></li>
<li><a href='#contextual_categories_or_csystems'>Contextual categories, or C-systems</a></li>
</ul>
<li><a href='#examples'>Examples</a></li>
<ul>
<li><a href='#syntactic_categories'>Syntactic categories</a></li>
<li><a href='#splitting_fibrations'>Splitting fibrations</a></li>
<li><a href='#universes'>Universes</a></li>
<li><a href='#simple_fibrations'>Simple fibrations</a></li>
<li><a href='#the_big_model_of_locally_cartesian_closed_categories'>The big model of locally cartesian closed categories</a></li>
</ul>
<li><a href='#related_pages'>Related pages</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>In the <a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a>, <a class="existingWikiWord" href="/nlab/show/dependent+types">dependent types</a> are said to correspond to morphisms regarded as indexed families. That is, if a <a class="existingWikiWord" href="/nlab/show/type">type</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> corresponds to an <a class="existingWikiWord" href="/nlab/show/object">object</a> in some <a class="existingWikiWord" href="/nlab/show/category">category</a>, then a <a class="existingWikiWord" href="/nlab/show/dependent+type">dependent type</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>⊢</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (x:A) \;\vdash\; (B(x) \;type) </annotation></semantics></math></div>
<p>corresponds to a <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B\to A</annotation></semantics></math> in that category. We think of this morphism as a <a class="existingWikiWord" href="/nlab/show/bundle">bundle</a> or <a class="existingWikiWord" href="/nlab/show/fibration">fibration</a>, whose <a class="existingWikiWord" href="/nlab/show/fiber">fiber</a> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math> is the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(x)</annotation></semantics></math>. We can then say that <a class="existingWikiWord" href="/nlab/show/type+former">type forming operations</a> such as <a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a> and <a class="existingWikiWord" href="/nlab/show/dependent+product+type">dependent product type</a> correspond to category-theoretic operations of <a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> and <a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a>.</p>

<p>However, this correspondence is not quite precise; in the case of dependent types there are extra <a class="existingWikiWord" href="/nlab/show/coherence">coherence</a> issues. <a class="existingWikiWord" href="/nlab/show/substitution">Substitution</a> in <a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a> should correspond to <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> in <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a> (but see at <em><a href="substitution#CategoricalSemantics">substitution – Categorical semantics</a></em> for more); that is, given a term</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>C</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>⊢</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (y:C) \;\vdash\; (f(y) : A) </annotation></semantics></math></div>
<p>corresponding to a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f:C\to A</annotation></semantics></math>, the substituted dependent type</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>C</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>⊢</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (y:C) \;\vdash\; (B(f(y)) \;type) </annotation></semantics></math></div>
<p>should correspond to the pullback of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B\to A</annotation></semantics></math> along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>. However, substitution in type theory is strictly <a class="existingWikiWord" href="/nlab/show/associativity">associative</a>. That is, given also <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">g:D\to C</annotation></semantics></math>, the dependent type</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>z</mi><mo>:</mo><mi>D</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>⊢</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (z:D) \;\vdash\; (B(f(g(z))) \;type)</annotation></semantics></math></div>
<p>is <a class="existingWikiWord" href="/nlab/show/equality">syntactically the same</a> regardless of whether we obtain it by substituting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>≔</mo><mi>g</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \coloneqq g(z)</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(f(y))</annotation></semantics></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≔</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \coloneqq f(g(z))</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(x)</annotation></semantics></math>. In category theory, however, pullback is not generally strictly associative, so there is a mismatch. Similarly, every <a class="existingWikiWord" href="/nlab/show/type+formation+rule">type-forming operation</a> must also be strictly preserved by substitition/pullback.</p>

<p>The way this is generally dealt with is to introduce a category-theoretic structure which does have a “substitution” operation which is strictly associative, hence does correspond directly to type theory, and then show that any category can be “strictified” into such a stricter structure. Unfortunately, there are many different such structures which have been used, differing only slightly. On this page we define and compare them all.</p>

<p>One of these structures is called “contextual categories” (definition <a class="maruku-ref" href="#ContextualCategory"></a> below).</p>

<p id="StandInForSyntax"> This and other kinds of categories-with-extra-structure may hence be thought of as stand-ins for the <a class="existingWikiWord" href="/nlab/show/syntax">syntax</a> of a <a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>:</p>

<blockquote>
<p>Rather than constructing an interpretation of the syntax directly, we may work via the intermediary notion of contextual categories, a class of algebraic objects abstracting the key structure carried by the syntax. The plain definition of a contextual category corresponds to the structural core of the syntax; further syntactic rules (logical constructors, etc.) correspond to extra algebraic structure that contextual categories may carry. Essentially, contextual categories provide a completely equivalent alternative to the syntactic presentation of type theory.</p>

<p>Why is this duplication of notions desirable? The trouble with the syntax is that it is mathematically tricky to handle. Any full presentation must account for (among other things) variable binding, capture-free substitution, and the possibility of multiple derivations of a judgement; and so a direct interpretation must deal with all of these, at the same time as tackling the details of the particular model in question. By passing to contextual categories, one deals with these subtleties and bureaucracy once and for all, and obtains a clear framework for subsequently constructing models. Conversely, why not work only with contextual categories, dispensing with syntax entirely?</p>

<p>The trouble on this side is that working with higher-order logical structure in contextual categories quickly becomes unreadable. The reader preferring to take contextual categories as primary may regard the syntax as essentially a notation for working within them: a powerful, flexible, and intuitive notation, but one whose validity requires non-trivial work to establish. (The situation is comparable to that of string diagrams, as used in monoidal and more elaborately structured categories.)</p>

<p>(from <a href="#KapulkinLumsdaine12">Kapulkin-Lumsdaine 12</a>)</p>
</blockquote>

<h2 id="definitions">Definitions</h2>

<p>In all the definitions, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> will be a <a class="existingWikiWord" href="/nlab/show/category">category</a>. Generally, we will regard the objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> as <a class="existingWikiWord" href="/nlab/show/contexts">contexts</a> in a type theory.</p>

<p>So far, we do not assume anything about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> as a category. Usually, one at least wants <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> to have a <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>, representing the empty context, although this is not always included in the definitions. The additional structures we impose on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> below will imply in particular that certain <a class="existingWikiWord" href="/nlab/show/pullbacks">pullbacks</a> exist in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>Sometimes, we want to consider <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> as a <a class="existingWikiWord" href="/nlab/show/strict+category">strict category</a>, that is, we consider its objects up to <a class="existingWikiWord" href="/nlab/show/equality">equality</a> rather than <a class="existingWikiWord" href="/nlab/show/isomorphism">isomorphism</a>. However, for most of the definitions below (until we get to contextual categories), it is still sensible to treat <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in an ordinary category-theoretic way, with the strictness living in the additional structure.</p>

<p>All of this could be made more precise by assembling the structures considered below into <a class="existingWikiWord" href="/nlab/show/categories">categories</a>, <a class="existingWikiWord" href="/nlab/show/2-categories">2-categories</a>, and/or <a class="existingWikiWord" href="/nlab/show/strict+2-categories">strict 2-categories</a>.</p>

<h3 id="comprehension_categories">Comprehension categories</h3>

<div class="num_defn" id="ComprehensionCategory">
<h6 id="definition">Definition</h6>

<p>A <strong>comprehension category</strong> consists of a strictly <a class="existingWikiWord" href="/nlab/show/commuting+diagram">commutative triangle</a> of <a class="existingWikiWord" href="/nlab/show/functors">functors</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>E</mi></mtd> <mtd></mtd> <mtd><mo>→</mo></mtd> <mtd></mtd> <mtd><msup><mi>C</mi> <mi>I</mi></msup></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>↘</mo></mtd> <mtd></mtd> <mtd><mo>↙</mo><mstyle scriptlevel="1"><mi>cod</mi></mstyle></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mi>C</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> \array{ E &amp;&amp; \to &amp;&amp; C^I\\ &amp; \searrow &amp;&amp; \swarrow {\scriptsize cod} \\ &amp;&amp; C } </annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">C^I</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/arrow+category">arrow category</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cod</mi><mo lspace="verythinmathspace">:</mo><msup><mi>C</mi> <mi>I</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">cod \colon C^I \to C</annotation></semantics></math> denotes the codomain projection (which is a <a class="existingWikiWord" href="/nlab/show/codomain+fibration">fibration</a> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> has pullbacks), and such that</p>

<ol>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/Grothendieck+fibration">Grothendieck fibration</a>,</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> takes <a class="existingWikiWord" href="/nlab/show/cartesian+morphisms">cartesian morphisms</a> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> to cartesian morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">C^I</annotation></semantics></math> (i.e. to <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> squares in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>).</p>
</li>
</ol>
</div>

<div class="num_remark">
<h6 id="remark">Remark</h6>

<p>In def <a class="maruku-ref" href="#ComprehensionCategory"></a> we do not ask that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>I</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">C^I \to C</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/Grothendieck+fibration">fibration</a> (that would require <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> to have all <a class="existingWikiWord" href="/nlab/show/pullbacks">pullbacks</a>), only that the <em>particular</em> morphisms in the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> are cartesian.</p>
</div>

<div class="num_defn" id="FullAndSplitComprehensionCategory">
<h6 id="definition_2">Definition</h6>

<p>A comprehension category (def. <a class="maruku-ref" href="#ComprehensionCategory"></a>) is called</p>

<ul>
<li>
<p><strong>full</strong> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/fully+faithful+functor">fully faithful functor</a>.</p>
</li>

<li>
<p><strong>split</strong> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/split+fibration">split fibration</a>.</p>
</li>
</ul>

<p>In the latter case, we must consider <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> at least to be a <a class="existingWikiWord" href="/nlab/show/strict+category">strict category</a> (that is, we consider its objects up to equality rather than isomorphism) for the notion to make sense.</p>
</div>

<div class="num_remark" id="MeaningOfComprehensionCategory">
<h6 id="remark_2">Remark</h6>

<p>The interpretation of def. <a class="maruku-ref" href="#ComprehensionCategory"></a> is as follows:</p>

<p>In a comprehension category, we may regard the objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> as <a class="existingWikiWord" href="/nlab/show/contexts">contexts</a>, and the <a class="existingWikiWord" href="/nlab/show/fiber">fiber</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>Γ</mi></msup></mrow><annotation encoding="application/x-tex">E^\Gamma</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math> over an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> as the category of <a class="existingWikiWord" href="/nlab/show/dependent+types">dependent types</a> in context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>. If the comprehension category is split (def. <a class="maruku-ref" href="#FullAndSplitComprehensionCategory"></a>), then such dependent types have strictly <a class="existingWikiWord" href="/nlab/show/associativity">associative</a> <a class="existingWikiWord" href="/nlab/show/substitution">substitution</a>.</p>

<p>The functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> assigns to each “type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> in context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>” a new context which we think of as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> <em>extended</em> by a fresh <a class="existingWikiWord" href="/nlab/show/variable">variable</a> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, and write as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma.A</annotation></semantics></math>. This new context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma.A</annotation></semantics></math> comes with a projection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>A</mi><mo>→</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma.A\to \Gamma</annotation></semantics></math> (which forgets the fresh variable), and all substitutions in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> are realized as pullbacks in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
</div>

<h3 id="display_map_categories">Display map categories</h3>

<div class="num_defn" id="DisplayMapCategory">
<h6 id="definition_3">Definition</h6>

<p>A <strong><a class="existingWikiWord" href="/nlab/show/display+map+category">display map category</a></strong> consists of a <a class="existingWikiWord" href="/nlab/show/category">category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> together with a <a class="existingWikiWord" href="/nlab/show/class">class</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/morphisms">morphisms</a> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, called <em><a class="existingWikiWord" href="/nlab/show/display+maps">display maps</a></em>, such that all <a class="existingWikiWord" href="/nlab/show/pullbacks">pullbacks</a> of display maps exist and are themselves display maps.</p>
</div>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a display map category, then by defining <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> to be the <a class="existingWikiWord" href="/nlab/show/full+subcategory">full subcategory</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">C^I</annotation></semantics></math> whose objects are display maps, we obtain a full comprehension category (def. <a class="maruku-ref" href="#FullAndSplitComprehensionCategory"></a>). Thus, we have:</p>

<div class="num_lemma" id="DMCasCmpC">
<h6 id="lemma">Lemma</h6>

<p>Display map categories (def. <a class="maruku-ref" href="#DisplayMapCategory"></a>) may be identified with those comprehension categories, def. <a class="maruku-ref" href="#ComprehensionCategory"></a>, for which the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> is the inclusion of a <a class="existingWikiWord" href="/nlab/show/full+subcategory">full subcategory</a>.</p>
</div>

<div class="num_remark">
<h6 id="remark_3">Remark</h6>

<p>Working up to <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalence of categories</a>, as is usual in <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a>, it is natural to consider display map categories to also be equivalent to <em>full</em> comprehension categories, def. <a class="maruku-ref" href="#FullAndSplitComprehensionCategory"></a>, (those where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> is merely fully faithful).</p>

<p>However, this breaks down when we are interested in <em>split</em> comprehension categories, def. <a class="maruku-ref" href="#FullAndSplitComprehensionCategory"></a>, for modeling substitution with strict associativity, since then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> at least must be regarded as a <a class="existingWikiWord" href="/nlab/show/strict+category">strict category</a> and considered up to <a class="existingWikiWord" href="/nlab/show/isomorphism">isomorphism</a> rather than equivalence. Thus, display map categories may be said to be equivalent to non-split full comprehension categories, but “split display map categories” are not equivalent to split full comprehension categories. (In fact, split display map categories are not very useful; usually in order to make pullbacks strictly associative we have to introduce extra “names” for the same objects.)</p>
</div>

<h3 id="categories_with_attributes">Categories with attributes</h3>

<div class="num_defn" id="CategoryWithAttributes">
<h6 id="definition_4">Definition</h6>

<p>A <strong>category with attributes</strong> is a comprehension category, def. <a class="maruku-ref" href="#ComprehensionCategory"></a>, for which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/discrete+fibration">discrete fibration</a>.</p>
</div>

<div class="num_remark">
<h6 id="remark_4">Remark</h6>

<p>That is, in a category with attributes (def. <a class="maruku-ref" href="#CategoryWithAttributes"></a>) we demand only that each context comes with a <a class="existingWikiWord" href="/nlab/show/set">set</a> of <a class="existingWikiWord" href="/nlab/show/dependent+types">dependent types</a> in that context, rather than a category of such. The intent is that the morphisms between two types in context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> should be determined by the morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> between the extended contexts over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>.</p>

<p>Another way to convey this same intent with a comprehension category would be to ask that it be <em>full</em>, def. <a class="maruku-ref" href="#FullAndSplitComprehensionCategory"></a>, i.e. that the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> be fully faithful.</p>
</div>

<p>In fact, any category with attributes gives rise to a full comprehension category by factoring the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> into a <a class="existingWikiWord" href="/nlab/show/bijective+on+objects+functor">bijective on objects functor</a> followed by a <a class="existingWikiWord" href="/nlab/show/fully+faithful+functor">fully faithful functor</a>. In this way, we obtain:</p>

<div class="num_lemma" id="CWAasCmpC">
<h6 id="lemma_2">Lemma</h6>

<p>The category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>CwA</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{CwA}</annotation></semantics></math> of categories with attributes (def. <a class="maruku-ref" href="#CategoryWithAttributes"></a>) is equivalent to the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>CompCat</mi></mstyle> <mtext>full,split</mtext></msub></mrow><annotation encoding="application/x-tex">\mathbf{CompCat}_{\text{full,split}}</annotation></semantics></math> of full split comprehension categories (def. <a class="maruku-ref" href="#FullAndSplitComprehensionCategory"></a>).</p>

<p>(These are, however, quite different as subcategories of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>CompCat</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{CompCat}</annotation></semantics></math>.)</p>
</div>

<h3 id="categories_with_families">Categories with families</h3>

<p>A category with attributes specifies for each “context” only a set of “types” in that context. A comprehension category, by contrast, specifies a whole <em>category</em> of “types” in each context. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>∈</mo><msup><mi>E</mi> <mi>Γ</mi></msup></mrow><annotation encoding="application/x-tex">A,B\in E^\Gamma</annotation></semantics></math>, then we may think of a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f:A\to B</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>Γ</mi></msup></mrow><annotation encoding="application/x-tex">E^\Gamma</annotation></semantics></math> as a term</p>
<div class="maruku-equation" id="eq:cmpcterm"><span class="maruku-eq-number">(1)</span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mover><mi>x</mi><mo stretchy="false">→</mo></mover><mo>:</mo><mi>Γ</mi><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false">(</mo><mover><mi>x</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>⊢</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mover><mi>x</mi><mo stretchy="false">→</mo></mover><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi><mo stretchy="false">(</mo><mover><mi>x</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (\vec{x} : \Gamma), (a:A(\vec{x})) \;\vdash\; (f(\vec{x},a) : B(\vec{x}))  </annotation></semantics></math></div>
<p>in type theory.<br />A <em>category with families</em> specifies instead, for each context and each type in that context, a set of “terms belonging to that type”. These should be thought of as terms</p>
<div class="maruku-equation" id="eq:cwfterm"><span class="maruku-eq-number">(2)</span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mover><mi>x</mi><mo stretchy="false">→</mo></mover><mo>:</mo><mi>Γ</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>⊢</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mover><mi>x</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi><mo stretchy="false">(</mo><mover><mi>x</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (\vec{x} : \Gamma) \;\vdash\; (f(\vec{x}) : B(\vec{x}))  </annotation></semantics></math></div>
<p>in type theory.</p>

<div class="num_remark">
<h6 id="remark_5">Remark</h6>

<p>A <a class="existingWikiWord" href="/nlab/show/term">term</a> of the form <a class="maruku-eqref" href="#eq:cmpcterm">(1)</a> can equivalently be regarded as a term of the form <a class="maruku-eqref" href="#eq:cwfterm">(2)</a> by replacing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> by the extended context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma.A</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> by its substitution along the projection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>A</mi><mo>→</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma.A \to \Gamma</annotation></semantics></math>.</p>
</div>

<p>The additional insight in the following definition is that if we expect all of these terms to be determined by the morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, as in a category with attributes or a full comprehension category, then instead of specifying the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> and then asking either that it be fully faithful or that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> be discrete (removing the information about extra morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>), if we specify the terms of the form <a class="maruku-eqref" href="#eq:cwfterm">(2)</a>, then the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> is determined by a universal property.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Fam</mi></mrow><annotation encoding="application/x-tex">Fam</annotation></semantics></math> denote the category of families of sets. Its objects are set-indexed families <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>i</mi></msub><msub><mo stretchy="false">)</mo> <mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(A_i)_{i\in I}</annotation></semantics></math>, and its morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>i</mi></msub><msub><mo stretchy="false">)</mo> <mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mo>→</mo><mo stretchy="false">(</mo><msub><mi>B</mi> <mi>j</mi></msub><msub><mo stretchy="false">)</mo> <mrow><mi>j</mi><mo>∈</mo><mi>J</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(A_i)_{i\in I} \to (B_j)_{j\in J}</annotation></semantics></math> consist of a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>I</mi><mo>→</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">f\colon I\to J</annotation></semantics></math> and functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mi>i</mi></msub><mo lspace="verythinmathspace">:</mo><msub><mi>A</mi> <mi>i</mi></msub><mo>→</mo><msub><mi>B</mi> <mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">g_i \colon A_i \to B_{f(i)}</annotation></semantics></math>. We can equivalently, of course, regard this as the arrow category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Set</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">Set^I</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/Set">Set</a>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>B</mi> <mi>j</mi></msub><msub><mo stretchy="false">)</mo> <mrow><mi>j</mi><mo>∈</mo><mi>J</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(B_j)_{j\in J}</annotation></semantics></math> corresponds to the arrow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo><mi>B</mi><mo>→</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">\coprod B \to J</annotation></semantics></math>.</p>

<div class="num_defn" id="CategoryWithFamilies">
<h6 id="definition_5">Definition</h6>

<p>A <strong>category with families</strong> is a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> together with</p>

<ul>
<li>
<p>A functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Fam</mi></mrow><annotation encoding="application/x-tex">F:C^{op} \to Fam</annotation></semantics></math>, written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>Tm</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">)</mo> <mrow><mi>A</mi><mo>∈</mo><mi>Ty</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">F(\Gamma) = (Tm(A))_{A\in Ty(\Gamma)}</annotation></semantics></math>.</p>
</li>

<li>
<p>For each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma\in C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>Ty</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A\in Ty(\Gamma)</annotation></semantics></math>, a <a class="existingWikiWord" href="/nlab/show/representing+object">representing object</a> for the functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" columnalign="right left right left right left right left right left" columnspacing="0em"><mtr><mtd><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">/</mo><mi>Γ</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mtd> <mtd><mo>→</mo><mi>Set</mi></mtd></mtr> <mtr><mtd><mo stretchy="false">(</mo><mi>Δ</mi><mover><mo>→</mo><mi>f</mi></mover><mi>Γ</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>↦</mo><mi>Tm</mi><mo stretchy="false">(</mo><msup><mi>f</mi> <mo>*</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\begin{aligned}
  (C/\Gamma)^{op} &amp; \to Set\\
  (\Delta \xrightarrow{f} \Gamma) &amp; \mapsto Tm(f^*(A))
\end{aligned}

</annotation></semantics></math></div></li>
</ul>
</div>

<p>Intuitively, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(\Gamma)</annotation></semantics></math> is the set of terms in the context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> indexed by their type, and the representing object for the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">/</mo><mi>Γ</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">(C/\Gamma)^{op} \to Set</annotation></semantics></math> is the projection from context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>;</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma; A</annotation></semantics></math> to context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>.</p>

<p>We can then prove:</p>

<div class="num_lemma" id="CwAareCwF">
<h6 id="lemma_3">Lemma</h6>

<p>Categories with attributes, def. <a class="maruku-ref" href="#CategoryWithAttributes"></a> are equivalent to categories with families, def. <a class="maruku-ref" href="#CategoryWithFamilies"></a>.</p>
</div>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>Given a category with families, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math> be the <a class="existingWikiWord" href="/nlab/show/Grothendieck+construction">Grothendieck construction</a> of the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ty</mi><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">Ty:C^{op}\to Set</annotation></semantics></math>, and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> take each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>Ty</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A\in Ty(\Gamma)</annotation></semantics></math> to the above representing object. This is a category with attributes.</p>

<p>Conversely, given a category with attributes, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ty</mi><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">Ty:C^{op}\to Set</annotation></semantics></math> be the functor corresponding to the discrete fibration <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math>, and for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>Ty</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A\in Ty(\Gamma)</annotation></semantics></math> let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Tm(A)</annotation></semantics></math> be the set of <a class="existingWikiWord" href="/nlab/show/sections">sections</a> of the morphism in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> that is the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">C^I</annotation></semantics></math>. These constructions are inverses up to isomorphism.</p>
</div>

<h3 id="natural_models">Natural Models</h3>

<p><a class="existingWikiWord" href="/nlab/show/Steve+Awodey">Steve Awodey</a> (<a href="#Awodey2018">Awodey 2018</a>) presented the following “natural model” of type theory as an alternative to categories with families.</p>

<div class="num_theorem">
<h6 id="theorem">Theorem</h6>

<p>If we modify Def. <a class="maruku-ref" href="#CategoryWithFamilies"></a> by requiring only that the functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Δ</mi><mover><mo>→</mo><mi>f</mi></mover><mi>Γ</mi><mo stretchy="false">)</mo><mo>↦</mo><mi>Tm</mi><mo stretchy="false">(</mo><msup><mi>f</mi> <mo>*</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Delta \xrightarrow{f} \Gamma) \mapsto Tm(f^*(A))</annotation></semantics></math> be representable (rather than equipped with representing objects), then it is equivalent to giving</p>

<ol>
<li>a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, together with</li>

<li>a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi><mo>→</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Tm \to Ty</annotation></semantics></math> in the category of <a class="existingWikiWord" href="/nlab/show/presheaves">presheaves</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> which is a <a class="existingWikiWord" href="/nlab/show/representable+morphism">representable morphism</a>.</li>
</ol>
</div>

<p>The category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> models the category of contexts and substitutions, and the morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi><mo>→</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Tm \to Ty</annotation></semantics></math> models the bundle of (context-dependent) terms over (context-dependent) types. The representability models the extension of a context with a new typed variable.</p>

<p>The condition of being a representable morphism can be reformulated in terms of representable profunctors as follows. A natural model consists of</p>

<ol>
<li>a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>,</li>

<li>a presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ty</mi><mo>:</mo><mover><mi>C</mi><mo stretchy="false">^</mo></mover></mrow><annotation encoding="application/x-tex">Ty : \hat C</annotation></semantics></math> of types in context.</li>

<li>a presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi><mo>:</mo><mover><mrow><mo>∫</mo><mi>Ty</mi></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">Tm : \widehat {\int Ty}</annotation></semantics></math> of typed terms in context.</li>

<li>a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ext</mi><mo>:</mo><mover><mrow><mo>∫</mo><mi>Ty</mi></mrow><mo>^</mo></mover><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">ext : \widehat {\int Ty} \to C</annotation></semantics></math> of context extension with data that represents the profunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>∫</mo><mi>Ty</mi></mrow><mo stretchy="false">(</mo><mi>ty</mi><mo>−</mo><mo>,</mo><mo>=</mo><mo stretchy="false">)</mo><mo>⊙</mo><mi>C</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>ctx</mi><mo stretchy="false">(</mo><mi>ty</mi><mo stretchy="false">(</mo><mo>=</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>:</mo><mo>∫</mo><mi>Ty</mi><mi>⇸</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">{\int Ty}(ty-,=) \odot C(-,ctx(ty(=))) : \int Ty &amp;#8696; C</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ty</mi><mo>:</mo><mo>∫</mo><mi>Tm</mi><mo>→</mo><mo>∫</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">ty : \int Tm \to \int Ty</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ctx</mi><mo>:</mo><mo>∫</mo><mi>Ty</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">ctx : \int Ty \to C</annotation></semantics></math> are the projections of the <a class="existingWikiWord" href="/nlab/show/Grothendieck+construction">Grothendieck construction</a>.</li>
</ol>

<p>Writing the profunctor as P, it is equivalent to the following definition:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>Δ</mi><mo>,</mo><mo stretchy="false">(</mo><mi>Γ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>γ</mi><mo>:</mo><mi>Δ</mi><mo>→</mo><mi>Γ</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>a</mi><mo>:</mo><mi>Tm</mi><mo stretchy="false">(</mo><mi>Δ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">[</mo><mi>γ</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\Delta, (\Gamma, A)) = (\gamma : \Delta \to \Gamma) \times (a : Tm(\Delta, A[\gamma]))</annotation></semantics></math></div>
<p>then the universal property of the context extension is that there is a natural isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi><mo>→</mo><mi>ext</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>P</mi><mo stretchy="false">(</mo><mi>Δ</mi><mo>,</mo><mo stretchy="false">(</mo><mi>Γ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Delta \to ext(\Gamma, A) \cong P(\Delta,(\Gamma,A))</annotation></semantics></math></p>

<h3 id="contextual_categories_or_csystems">Contextual categories, or C-systems</h3>

<p>Recall that</p>

<div class="num_defn" id="NotationForExtendedContexts">
<h6 id="definition_6">Definition</h6>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/comprehension+category">comprehension category</a> (def. <a class="maruku-ref" href="#ComprehensionCategory"></a>), <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma\in C</annotation></semantics></math> is a “context” and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi>E</mi> <mi>Γ</mi></msup></mrow><annotation encoding="application/x-tex">A\in E^\Gamma</annotation></semantics></math> is a “type” in context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>, then we denote by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma.A</annotation></semantics></math> the “extended context” in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> (remark <a class="maruku-ref" href="#MeaningOfComprehensionCategory"></a>).</p>
</div>

<div class="num_defn" id="ContextualCategory">
<h6 id="definition_7">Definition</h6>

<p>A <strong>contextual category</strong> (<a href="#Cartmell86">Cartmell 86</a>, <a href="#Streicher91">Streicher 91</a>) or <strong>C-system</strong> (<a href="#Voevodsky15a">Voevodsky 15</a>) is a category with attributes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> (def. <a class="maruku-ref" href="#CategoryWithAttributes"></a>) together with a <em>length function</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℓ</mi><mo>:</mo><mi>ob</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\ell : ob(C) \to \mathbb{N}</annotation></semantics></math> such that</p>

<ol>
<li>There is a unique object of length <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>, which is a <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>.</li>

<li>For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma\in C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi>E</mi> <mi>Γ</mi></msup></mrow><annotation encoding="application/x-tex">A\in E^\Gamma</annotation></semantics></math>, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℓ</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo>.</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ℓ</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\ell(\Gamma.A) = \ell(\Gamma)+1</annotation></semantics></math>.</li>

<li>For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Delta\in C</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℓ</mi><mo stretchy="false">(</mo><mi>Δ</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\ell(\Delta)\gt 0</annotation></semantics></math>, there exists a unique <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma\in C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi>E</mi> <mi>Γ</mi></msup></mrow><annotation encoding="application/x-tex">A\in E^\Gamma</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi><mo>=</mo><mi>Γ</mi><mo>.</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Delta = \Gamma.A</annotation></semantics></math> (with notation as in def. <a class="maruku-ref" href="#NotationForExtendedContexts"></a>).</li>
</ol>
</div>

<div class="num_remark">
<h6 id="remark_6">Remark</h6>

<p>Since def. <a class="maruku-ref" href="#ContextualCategory"></a> refers to <a class="existingWikiWord" href="/nlab/show/equality">equality</a> of objects, a contextual category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> must be a <a class="existingWikiWord" href="/nlab/show/strict+category">strict category</a>.</p>
</div>

<div class="num_remark">
<h6 id="remark_7">Remark</h6>

<p>The idea which distinguishes a contextual category is that “every context must be built out of types” in a unique way.</p>
</div>

<p>This makes for the closest match with type theory; in fact we have:</p>

<div class="num_theorem" id="CxtCareTT">
<h6 id="theorem_2">Theorem</h6>

<p>The category of contextual categories, def. <a class="maruku-ref" href="#ContextualCategory"></a>, and (strictly) structure-preserving functors is <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalent</a> to the <span class="newWikiWord">category of dependent type theories and interpretations<a href="/nlab/new/category+of+dependent+type+theories+and+interpretations">?</a></span>.</p>
</div>

<div class="num_remark">
<h6 id="remark_8">Remark</h6>

<p>Since contextual categories are <a class="existingWikiWord" href="/nlab/show/strict+categories">strict categories</a>, the category of such is really a <a class="existingWikiWord" href="/nlab/show/1-category">1-category</a>, or perhaps a <a class="existingWikiWord" href="/nlab/show/strict+2-category">strict 2-category</a>.</p>
</div>

<div class="num_example" id="ContextualFromAttributes">
<h6 id="example">Example</h6>

<p>Given any category with attributes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, def. <a class="maruku-ref" href="#CategoryWithAttributes"></a>, possessing a <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>, there is a canonical way to build a contextual category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cxt</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cxt(C)</annotation></semantics></math>, def. <a class="maruku-ref" href="#ContextualCategory"></a>, from it.</p>

<ol>
<li>
<p>Choose a <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">1\in C</annotation></semantics></math> (the resulting contextual category does not depend on this choice, up to isomorphism).</p>
</li>

<li>
<p>The <a class="existingWikiWord" href="/nlab/show/objects">objects</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cxt</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cxt(C)</annotation></semantics></math> are the finite <a class="existingWikiWord" href="/nlab/show/lists">lists</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>A</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A_0,A_1,\dots,A_n)</annotation></semantics></math></div>
<p>such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>0</mn></msub><mo>∈</mo><msup><mi>E</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">A_0 \in E^1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∈</mo><msup><mi>E</mi> <mrow><mn>1</mn><mo>.</mo><msub><mi>A</mi> <mn>0</mn></msub><mo>.</mo><msub><mi>A</mi> <mn>1</mn></msub><mo>.</mo><mi>⋯</mi><mo>.</mo><msub><mi>A</mi> <mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">A_{k+1} \in E^{1.A_0.A_1.\cdots .A_k}</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>.</p>
</li>

<li>
<p>The <a class="existingWikiWord" href="/nlab/show/morphisms">morphisms</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>A</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><msub><mi>B</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>B</mi> <mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A_0,\dots,A_n) \to (B_0,\dots,B_m)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cxt</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cxt(C)</annotation></semantics></math> are the morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>.</mo><msub><mi>A</mi> <mn>0</mn></msub><mo>.</mo><msub><mi>A</mi> <mn>1</mn></msub><mo>.</mo><mi>⋯</mi><mo>.</mo><msub><mi>A</mi> <mi>n</mi></msub><mo>→</mo><mn>1</mn><mo>.</mo><msub><mi>B</mi> <mn>0</mn></msub><mo>.</mo><msub><mi>B</mi> <mn>1</mn></msub><mo>.</mo><mi>⋯</mi><mo>.</mo><msub><mi>B</mi> <mi>m</mi></msub></mrow><annotation encoding="application/x-tex">1.A_0.A_1.\cdots.A_n \to 1.B_0.B_1.\cdots.B_m</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
</li>
</ol>

<p>All the rest of the structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cxt</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cxt(C)</annotation></semantics></math> is induced in an evident way from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. This construction is in fact right adjoint to the inclusion of contextual categories in categories with attributes; see <a href="#KapulkinLumsdaine16">Kapulkin-Lumsdaine, Proposition 4.4</a>.</p>
</div>

<h2 id="examples">Examples</h2>

<p>Comprehension categories and display map categories are easy to come by “in nature”, but it is more difficult to find examples of the “split” versions of the above structure (which are what is needed for modeling type theory). Here we summarize some basic known constructions.</p>

<p>However, first we should mention the examples that come from type theory itself.</p>

<h3 id="syntactic_categories">Syntactic categories</h3>

<div class="num_example">
<h6 id="example_2">Example</h6>

<p>The <a class="existingWikiWord" href="/nlab/show/syntactic+category">syntactic category</a> of any <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a> has all of the above structures. Its objects are <a class="existingWikiWord" href="/nlab/show/contexts">contexts</a> in the theory, and the types in context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> form the set or category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>E</mi> <mi>Γ</mi></msup></mrow><annotation encoding="application/x-tex">E^\Gamma</annotation></semantics></math>. The strict associativity of substitution in type theory makes this fibration automatically split.</p>
</div>

<h3 id="splitting_fibrations">Splitting fibrations</h3>

<p>There are standard constructions which can replace any <a class="existingWikiWord" href="/nlab/show/Grothendieck+fibration">Grothendieck fibration</a> by an equivalent <a class="existingWikiWord" href="/nlab/show/split+fibration">split fibration</a>. Therefore,</p>

<div class="num_example" id="FromComprehensionToContextual">
<h6 id="example_3">Example</h6>

<p>Given any comprehension category, def. <a class="maruku-ref" href="#ComprehensionCategory"></a>,</p>

<ol>
<li>
<p>we may replace it by a split comprehension category, def. <a class="maruku-ref" href="#FullAndSplitComprehensionCategory"></a>,</p>
</li>

<li>
<p>then consider the underlying category with attributes, def. <a class="maruku-ref" href="#CategoryWithAttributes"></a>,</p>
</li>

<li>
<p>and finally pass to a contextual category by the construction in example <a class="maruku-ref" href="#ContextualFromAttributes"></a>.</p>
</li>
</ol>
</div>

<p>Of course, comprehension categories are easy to come by; perhaps they arise most commonly as <a class="existingWikiWord" href="/nlab/show/display+map+categories">display map categories</a>. For instance, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> has all <a class="existingWikiWord" href="/nlab/show/pullbacks">pullbacks</a>, then we can take all maps to be <a class="existingWikiWord" href="/nlab/show/display+maps">display maps</a>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/category+of+fibrant+objects">category of fibrant objects</a>, we can take the <a class="existingWikiWord" href="/nlab/show/fibrations">fibrations</a> to be the display maps.</p>

<p>So, for the record, we have in particular:</p>

<div class="num_example" id="TypeTheoryModelFromLocallyCartesianClosedCategory">
<h6 id="example_4">Example</h6>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/locally+cartesian+closed+category">locally cartesian closed category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, it becomes a model for <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a> by regarding its <a class="existingWikiWord" href="/nlab/show/codomain+fibration">codomain fibration</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>I</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">C^I \to C</annotation></semantics></math> as a comprehension category, def. <a class="maruku-ref" href="#ComprehensionCategory"></a>, and then strictifying that as in example <a class="maruku-ref" href="#FromComprehensionToContextual"></a>.</p>
</div>

<div class="num_remark">
<h6 id="remark_9">Remark</h6>

<p>It turns out that for modeling additional <a class="existingWikiWord" href="/nlab/show/type-forming+operations">type-forming operations</a>, however, not all splitting constructions are created equal.</p>

<p>Given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math>, one construction due to <a class="existingWikiWord" href="/nlab/show/Benabou">Benabou</a> (called the “right adjoint splitting”), defines <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>′</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E'\to C</annotation></semantics></math>, where the objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">E'</annotation></semantics></math> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma\in C</annotation></semantics></math> are functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">/</mo><mi>Γ</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">C/\Gamma \to E</annotation></semantics></math> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> which map every morphism of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">/</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">C/\Gamma</annotation></semantics></math> to a cartesian arrow. Type-theoretically, we can think of such an object as a type together with <em>specified</em> compatible substitutions along any possible morphism. That type-formers may be extended in this case was proven by <a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a> for <a class="existingWikiWord" href="/nlab/show/dependent+sums">dependent sums</a> and <a class="existingWikiWord" href="/nlab/show/dependent+products">dependent products</a> and the <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a> of <a class="existingWikiWord" href="/nlab/show/extensional+type+theory">extensional type theory</a>. But this is not generally possible for the identity types of <a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional type theory</a> (particularly not their <a class="existingWikiWord" href="/nlab/show/term+elimination">eliminator</a>), which do not have a 1-categorical universal property and hence are not stable under pullback up to isomorphism.</p>

<p>A different construction (due to <a class="existingWikiWord" href="/nlab/show/John+Power">John Power</a>, called the “left adjoint splitting”) defines an object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">E'</annotation></semantics></math> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma\in C</annotation></semantics></math> to consist of a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Γ</mi><mo>→</mo><mi>Δ</mi></mrow><annotation encoding="application/x-tex">f:\Gamma \to \Delta</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> along with an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>. Type-theoretically, we can regard <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f,A)</annotation></semantics></math> as a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> with a “delayed substitution” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>. This produces a split fibration (the chosen cartesian arrows are given by composition of morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>), and it was proven by <a href="#LumsdaineWarren13">Lumsdaine and Warren</a> that essentially all type formers can be extended to it from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>.</p>
</div>

<h3 id="universes">Universes</h3>

<p>Suppose given a particular morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mover><mi>U</mi><mo>˜</mo></mover><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">p:\widetilde{U} \to U</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. We can then define a category with attributes, def. <a class="maruku-ref" href="#CategoryWithAttributes"></a>, as follows: the discrete fibration <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math> corresponds to the representable presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(-,U)</annotation></semantics></math>, and the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> is defined by pullback of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math>. We are thus treating <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> as a “<a class="existingWikiWord" href="/nlab/show/universe">universe</a>” of types. We may then of course pass to a contextual category, via example <a class="maruku-ref" href="#FromComprehensionToContextual"></a>.</p>

<p>Type-forming operations may be extended strictly in this case by performing them once in the “universal” case, then acting by composition. This construction is due to <a class="existingWikiWord" href="/nlab/show/Voevodsky">Voevodsky</a>. It also meshes quite well with type theories that contain internal universes – a <a class="existingWikiWord" href="/nlab/show/type+of+types">type of types</a>– , and in particular for modeling the <a class="existingWikiWord" href="/nlab/show/univalence+axiom">univalence axiom</a>.</p>

<p>Particular important universes include:</p>

<ul>
<li>
<p>Any <a class="existingWikiWord" href="/nlab/show/Grothendieck+universe">Grothendieck universe</a> in <a class="existingWikiWord" href="/nlab/show/Set">Set</a>, or more generally a <a class="existingWikiWord" href="/nlab/show/universe+in+a+topos">universe in a topos</a>. The resulting display maps are those with “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>-small fibers”.</p>
</li>

<li>
<p>In the category <a class="existingWikiWord" href="/nlab/show/Gpd">Gpd</a>, the groupoid of small groupoids. The resulting display maps are the <a class="existingWikiWord" href="/nlab/show/split+opfibrations">split opfibrations</a> with small fibers. Similarly, we can consider the groupoid of small sets, whose display maps are the <a class="existingWikiWord" href="/nlab/show/discrete+opfibrations">discrete opfibrations</a> with small fibers.</p>
</li>

<li>
<p>In the category <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a> of <a class="existingWikiWord" href="/nlab/show/simplicial+sets">simplicial sets</a>, there is a <a class="existingWikiWord" href="/nlab/show/universal+Kan+fibration">universal Kan fibration</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mover><mi>U</mi><mo>˜</mo></mover><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">p:\widetilde{U} \to U</annotation></semantics></math> which classifies all <a class="existingWikiWord" href="/nlab/show/Kan+fibrations">Kan fibrations</a> with small fibers.</p>
</li>
</ul>

<h3 id="simple_fibrations">Simple fibrations</h3>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be any category with finite products, and define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">E\to C</annotation></semantics></math> to be the <a class="existingWikiWord" href="/nlab/show/discrete+fibration">discrete fibration</a> corresponding to the presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">C^{op}\to Set</annotation></semantics></math> which is constant at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ob</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ob(C)</annotation></semantics></math>. Thus, the objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> are pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Γ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Gamma,A)</annotation></semantics></math> of objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, with the only morphisms being of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Γ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>Δ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Gamma,A) \to (\Delta,A)</annotation></semantics></math> induced by a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>→</mo><mi>Δ</mi></mrow><annotation encoding="application/x-tex">\Gamma\to\Delta</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>Define the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">E\to C^I</annotation></semantics></math> to take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Γ</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Gamma,A)</annotation></semantics></math> to the projection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma\times A \to \Gamma</annotation></semantics></math>. It is straightforward to check that this defines a category with attributes. The corresponding (split) full comprehension category is called the <em>simple fibration</em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>The dependent type theory which results from this structure “has no nontrivial dependency”. That is, whenever we have a dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Gamma \vdash (A \;type)</annotation></semantics></math>, it is already the case that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type in the empty context (that is, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊢</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thickmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vdash (A\; type)</annotation></semantics></math>), and so it cannot depend nontrivially on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>. In effect, it is not really a dependent type theory, but a <em>simple</em> (non-dependent) type theory — hence the name “simple fibration”.</p>

<h3 id="the_big_model_of_locally_cartesian_closed_categories">The big model of locally cartesian closed categories</h3>

<div class="num_example" id="BigModelLocallyCartesianClosed">
<h6 id="example_5">Example</h6>

<p>Ignoring coherence issues, the CwF induced by a locally cartesian closed (lcc) category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> (example <a class="maruku-ref" href="#TypeTheoryModelFromLocallyCartesianClosedCategory"></a>) is given explicitly by the “Explicit” column of the following table:</p>
<table><thead><tr><th></th><th>In <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>: Explicit</th><th>In terms of slices of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></th><th>Big model</th></tr></thead><tbody><tr><td style="text-align: left;">Contexts</td><td style="text-align: left;">Objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\Gamma \in \mathcal{C}</annotation></semantics></math></td><td style="text-align: left;">Slice categories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/ \Gamma}</annotation></semantics></math></td><td style="text-align: left;">Lcc categories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></td></tr>
<tr><td style="text-align: left;">Context Morphisms</td><td style="text-align: left;">Morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Γ</mi><mo>→</mo><mi>Δ</mi></mrow><annotation encoding="application/x-tex">f : \Gamma \rightarrow \Delta</annotation></semantics></math></td><td style="text-align: left;">Lcc functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mo>*</mo></msup><mo>:</mo><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Δ</mi></mrow></msub><mo>→</mo><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f^* : \mathcal{C}_{/ \Delta} \rightarrow \mathcal{C}_{/ \Gamma}</annotation></semantics></math> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math></td><td style="text-align: left;">Lcc functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Δ</mi><mo>→</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">f : \Delta \rightarrow \Gamma</annotation></semantics></math></td></tr>
<tr><td style="text-align: left;">Types</td><td style="text-align: left;">Morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><mo lspace="0em" rspace="thinmathspace">dom</mo><mi>σ</mi><mo>→</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\sigma : \operatorname{dom} \sigma \rightarrow \Gamma</annotation></semantics></math></td><td style="text-align: left;">Objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>∈</mo><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma \in \mathcal{C}_{/ \Gamma}</annotation></semantics></math></td><td style="text-align: left;">Objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>∈</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\sigma \in \Gamma</annotation></semantics></math></td></tr>
<tr><td style="text-align: left;">Terms</td><td style="text-align: left;">Sections <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>:</mo><mi>Γ</mi><mo>⇆</mo><mo lspace="0em" rspace="thinmathspace">dom</mo><mi>σ</mi><mo>:</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">s : \Gamma \leftrightarrows \operatorname{dom} \sigma : \sigma</annotation></semantics></math></td><td style="text-align: left;">Morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>:</mo><msub><mi mathvariant="normal">id</mi> <mi>σ</mi></msub><mo>→</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">s : \mathrm{id}_\sigma \rightarrow \sigma</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/ \Gamma}</annotation></semantics></math></td><td style="text-align: left;">Morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">s : 1 \rightarrow \sigma</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> is a terminal object.</td></tr>
<tr><td style="text-align: left;">Substitution</td><td style="text-align: left;">Pullback along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></td><td style="text-align: left;">Application of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math></td><td style="text-align: left;">Application of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></td></tr>
</tbody></table>
<p>The next column describes the same CwF in the terminology of slice categories: Every object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> corresponds to a slice category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/ \Gamma}</annotation></semantics></math> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/ \Gamma}</annotation></semantics></math> is also lcc. Every morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Γ</mi><mo>→</mo><mi>Δ</mi></mrow><annotation encoding="application/x-tex">f : \Gamma \rightarrow \Delta</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> induces a pullback functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mo>*</mo></msup><mo>:</mo><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Δ</mi></mrow></msub><mo>→</mo><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f^* : \mathcal{C}_{/ \Delta} \rightarrow \mathcal{C}_{/ \Gamma}</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math> preserves the finite limits and dependent products of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Δ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/ \Delta}</annotation></semantics></math> (i.e. it is an lcc functor), and the diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mi>𝒞</mi></mtd></mtr> <mtr><mtd></mtd> <mtd><msub><mrow></mrow> <mrow><msup><mi>Δ</mi> <mo>*</mo></msup></mrow></msub><mo>↙</mo></mtd> <mtd></mtd> <mtd><msub><mo>↘</mo> <mrow><msup><mi>Γ</mi> <mo>*</mo></msup></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Δ</mi></mrow></msub></mtd> <mtd></mtd> <mtd><mover><mrow><msup><mi>f</mi> <mo>*</mo></msup></mrow><mo>→</mo></mover></mtd> <mtd></mtd> <mtd><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    &amp;&amp; \mathcal{C}
    \\
    &amp; {}_{\Delta^*} \swarrow &amp;&amp; \searrow_{\Gamma^*}
    \\
    \mathcal{C}_{/ \Delta} &amp;&amp; \stackrel{\to}{f^*} &amp;&amp; \mathcal{C}_{/ \Gamma}
}

</annotation></semantics></math></div>
<p>commutes (up to unique isomorphism). Conversely, every lcc functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Δ</mi></mrow></msub><mo>→</mo><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/ \Delta} \rightarrow \mathcal{C}_{/ \Gamma}</annotation></semantics></math> under <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> is uniquely isomorphic to the pullback functor along some morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>→</mo><mi>Δ</mi></mrow><annotation encoding="application/x-tex">\Gamma \rightarrow \Delta</annotation></semantics></math>.</p>

<p>The last column describes the <strong>big model</strong> of type theory in the opposite category of lcc categories and lcc functors. Since the contexts of this model are itself models of type theory, it can be understood as a “model of models”. The definition of the big model can be arrived at by removing all reference to the fixed lcc category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> in the previous column. Instead of just the slice categories of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>, now all lcc categories are allowed as contexts. Context morphisms are generalized to general lcc functors instead of just the pullback functors of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>. The identity morphism on an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> is a terminal object in the slice category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>Γ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/ \Gamma}</annotation></semantics></math> and is thus generalized to a terminal object in any lcc category.</p>

<p>The usual model in a fixed lcc category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> can be recovered from the big model by slicing: The contextual core (example <a class="maruku-ref" href="#ContextualFromAttributes"></a>) of the slice of the big model over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> is equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>.</p>

<p>However, the naive definition of the big model above suffers from the same coherence issues as the standard models in individual lcc categories: Lcc functors preserve lcc structure (i.e. type formers) up to isomorphism, but not necessarily up to equality. These coherence problems can be resolved by working with a suitable model categorical presentation of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2, 1)</annotation></semantics></math>-category of lcc categories, lcc functors and natural isomorphisms. Note that the <a class="existingWikiWord" href="/nlab/show/model+category">model category</a> presenting a higher category is unique up to zig-zag of Quillen equivalences, but that the underlying 1-categories of these model categories can vary non-trivially. Because coherence issues are ultimately about equations in the underlying 1-category, we can thus hope that some model categories presenting the category of lcc categories will be better behaved than others for our purpose.</p>

<p>One possible way to construct such a well-behaved model category is as follows (see (<a href="#Bidlingmaier20">Bidlingmaier 2020</a>) for details):</p>

<ol>
<li>
<p>First one defines a model category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">Lcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{Lcc}</annotation></semantics></math> of lcc sketches. An <strong>lcc sketch</strong> is a category with some diagrams <a href="#Isaev2016">marked</a> as finite limits cones and evalution maps of dependent products. These marked diagrams do not need to satisfy the corresponding universal property, however. The model category structure is set up such that every object is cofibrant, and the fibrant objects are precisely the lcc categories with diagrams marked if and only if they satisfy the corresponding universal property. Thus the subcategory of fibrant objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">Lcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{Lcc}</annotation></semantics></math> corresponds to the usual category of lcc categories. Note however, that lcc categories in the sense of fibrant lcc sketches “have” finite limits and dependent products in the sense that these universal objects <em>merely exist</em>; there are no distinguished/assigned choices of universal objects. Thus preservation of universal objects by functors up to equality (i.e. strictness of substitution) cannot even be stated in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">Lcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{Lcc}</annotation></semantics></math>.</p>
</li>

<li>
<p>The model category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math> of <strong>strict lcc categories</strong> is defined as the category of <a class="existingWikiWord" href="/nlab/show/algebraically+fibrant+objects">algebraically fibrant objects</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">Lcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{Lcc}</annotation></semantics></math>; it is Quillen equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">Lcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{Lcc}</annotation></semantics></math>. Assigned lifts against the trivial cofibrations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">Lcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{Lcc}</annotation></semantics></math> correspond to distinguished choices of universal objects, and these choices are preserved by the morphisms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math>, the <strong>strict lcc functors</strong>. Thus <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math> supports substitutions that preserve type formers up to equality.</p>

<p>However, it does not support some dependent type formers in any obvious way, notably not <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> types. The problem is that the context extension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">\Gamma.\sigma</annotation></semantics></math> of some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mo lspace="0em" rspace="thinmathspace">Ob</mo><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\Gamma \in \operatorname{Ob} \mathrm{sLcc}</annotation></semantics></math> by a type (i.e. object) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> is given by freely (in the 1-categorical sense) adjoining a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">1 \rightarrow \sigma</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>. To interpret <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> types, one has to relate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">\Gamma.\sigma</annotation></semantics></math> with the slice category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Γ</mi> <mrow><mo stretchy="false">/</mo><mi>σ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Gamma_{/ \sigma}</annotation></semantics></math> in some way, and it appears that this is not generally possible. Note that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Γ</mi> <mrow><mo stretchy="false">/</mo><mi>σ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Gamma_{/ \sigma}</annotation></semantics></math> has the universal property of a context extension in the higher/bicategorical sense, but that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">\Gamma.\sigma</annotation></semantics></math> is defined purely 1-categorically.</p>
</li>

<li>
<p>To reconcile context extensions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">\Gamma.\sigma</annotation></semantics></math> with slice categories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Γ</mi> <mrow><mo stretchy="false">/</mo><mi>σ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Gamma_{/ \sigma}</annotation></semantics></math>, one can work with the <a href="#ChingRiehl2014">algebraically cofibrant objects</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math>. An algebraically cofibrant object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math> is a coalgebra for a fixed cofibrant replacement comonad. The category of such coalgebras has model category structure, and this model category is again Quillen equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math>.</p>

<p>A cofibrant object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math> has the property that every non-strict lcc functor (i.e. morphism of underlying lcc sketches) out of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> is isomorphic to a strict lcc functor. This property turns out to be sufficient to construct a weak equivalence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>σ</mi><mo>→</mo><msub><mi>Γ</mi> <mrow><mo stretchy="false">/</mo><mi>σ</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Gamma.\sigma \rightarrow \Gamma_{/ \sigma}</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math>. For <em>algebraically</em> cofibrant <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>, this weak equivalence is structure and hence preserved by coalgebra morphisms up to equality. This turns out to be sufficient to endow the category of algebraically cofibrant objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi mathvariant="normal">sLcc</mi></mrow><annotation encoding="application/x-tex">\mathrm{sLcc}</annotation></semantics></math> with CwF structure that supports finite limit, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> type constructors.</p>
</li>
</ol>
</div>

<h2 id="related_pages">Related pages</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/initiality+conjecture">initiality conjecture</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Awodey%27s+conjecture">Awodey's conjecture</a></p>
</li>
</ul>

<h2 id="references">References</h2>

<p>Another overview can be found in the <a href="https://ncatlab.org/homotopytypetheory/show/semantics">HoTT wiki</a>.</p>

<p>A general overview may be found in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, <em>Syntax and semantics of dependent types</em>, Semantics and logics of computation (Cambridge, 1995), Publ. Newton Inst., vol. 14, Cambridge Univ. Press, Cambridge, 1997, pp. 79–130</li>
</ul>

<p>Comprehension categories are defined in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Bart+Jacobs">Bart Jacobs</a>, <em>Comprehension categories and the semantics of type dependency</em>, Theoret. Comput. Sci. 107 (1993), no. 2, 169–207</li>
</ul>

<p>A 2-categorical treatment of variant kinds of comprehension category is given in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Paul-Andr%C3%A9+Melli%C3%A8s">Paul-André Melliès</a>, Nicolas Rolland, <em>Comprehension and quotient structures in the language of 2-categories</em>, (<a href="https://arxiv.org/abs/2005.10015">arXiv:2005.10015</a>)</li>
</ul>

<p>A correspondence with orthogonal factorization systems is discussed in</p>

<ul>
<li>Clemens Berger, Ralph M. Kaufmann, <em>Comprehensive factorisation systems</em> (<a href="https://arxiv.org/abs/1710.09438">pdf</a>)</li>
</ul>

<p>Display maps are discussed in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Paul+Taylor">Paul Taylor</a>, <em><a class="existingWikiWord" href="/nlab/show/Practical+Foundations+of+Mathematics">Practical Foundations of Mathematics</a></em>, section 8.3</li>
</ul>

<p>Categories with attributes are discussed in</p>

<ul>
<li>
<p>John Cartmell, <em>Generalised algebraic theories and contextual categories</em>, Ph.D. thesis, Oxford, 1978 (<a href="https://github.com/peterlefanulumsdaine/cartmell-thesis">GitHub LaTeXing project</a>, organised by <a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>. Currently only sections 1.0-1.4 are done)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Eugenio+Moggi">Eugenio Moggi</a>, <em>A category-theoretic account of program modules</em>, Math. Structures Comput. Sci. 1 (1991), no. 1, 103–139</p>
</li>

<li>
<p>Andrew M. Pitts, <em>Categorical logic</em>, Handbook of logic in computer science, Vol. 5, Handb. Log. Comput. Sci., vol. 5, Oxford Univ. Press, New York, 2000, pp. 39–128</p>
</li>
</ul>

<p>Categories with families are defined in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Peter+Dybjer">Peter Dybjer</a>, <em>Internal type theory</em>, Types for proofs and programs (Torino, 1995), Lecture Notes in Comput. Sci., vol. 1158, Springer, Berlin, 1996, pp. 120–134, <a href="http://www.cse.chalmers.se/~peterd/papers/InternalTT.pdf">PDF</a></li>
</ul>

<p>and shown to be equivalent to categories with attributes in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, <em>Syntax and semantics of dependent types</em>, <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.8985">citeseer</a>.</li>
</ul>

<p>The formulation in terms of representable natural transformations is in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Steve+Awodey">Steve Awodey</a>. (2018). <em>Natural models of homotopy type theory</em>, Mathematical Structures in Computer Science, 28(2), 241-286. <a href="https://arxiv.org/pdf/1406.3219.pdf">PDF</a></li>
</ul>

<p>See also</p>

<ul>
<li>Clive Newstead, <em>Algebraic models of dependent type theory</em> (<a href="https://arxiv.org/abs/2103.06155">arXiv:2103.06155</a>)</li>
</ul>

<p>A proof of initiality for dependent type theory is claimed in</p>

<ul>
<li>Simon Castellan, <em>Dependent type theory as the initial category with families</em>, 2014 (<a href="http://iso.mor.phis.me/archives/2011-2012/stage-2012-goteburg/report.pdf">pdf</a>)</li>
</ul>

<p>This was formalized inside type theory with set quotients of <a class="existingWikiWord" href="/nlab/show/higher+inductive+types">higher inductive types</a> in:</p>

<ul>
<li id="AltKap2015"><a class="existingWikiWord" href="/nlab/show/Thorsten+Altenkirch">Thorsten Altenkirch</a>, Ambrus Kaposi, <em>Type Theory in Type Theory using Quotient Inductive Types</em>, (2015) (<a href="http://www.cs.nott.ac.uk/~txa/publ/tt-in-tt.pdf">pdf</a>), (<a href="https://bitbucket.org/akaposi/tt-in-tt">formalisation in Agda</a>).</li>
</ul>

<p>Contextual categories were defined in</p>

<ul>
<li id="Cartmell86">
<p>John Cartmell, <em>Generalised algebraic theories and contextual categories</em>, Annals of Pure and Applied Logic Volume 32, 1986, Pages 209-243 (<a href="http://dx.doi.org/10.1016/0168-0072%2886%2990053-9">doi:10.1016/0168-0072(86)90053-9</a>)</p>
</li>

<li id="Streicher91">
<p><a class="existingWikiWord" href="/nlab/show/Thomas+Streicher">Thomas Streicher</a>, <em>Semantics of type theory</em>, Progress in Theoretical Computer Science, Birkhäuser Boston Inc., Boston, MA, 1991, Correctness, completeness and independence results.</p>
</li>
</ul>

<p>Review includes</p>

<ul>
<li id="KapulkinLumsdaine12"><a class="existingWikiWord" href="/nlab/show/Chris+Kapulkin">Chris Kapulkin</a>, <a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>, section 1.2 and appendix B of <em>The Simplicial Model of Univalent Foundations (after Voevodsky)</em> (<a href="https://arxiv.org/abs/1211.2851">arXiv:1211.2851</a>)</li>
</ul>

<p>Contextual categories as models for <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> are discussed in</p>

<ul>
<li id="KapulkinLumsdaine16">
<p><a class="existingWikiWord" href="/nlab/show/Chris+Kapulkin">Chris Kapulkin</a>, <a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>, <em>The homotopy theory of type theories</em> (<a href="https://arxiv.org/abs/1610.00037">arXiv:1610.00037</a>)</p>
</li>

<li id="Joyal17">
<p><a class="existingWikiWord" href="/nlab/show/Andr%C3%A9+Joyal">André Joyal</a>, <em>Notes on Clans and Tribes</em> (<a href="https://arxiv.org/abs/1710.10238">arXiv:1710.10238</a>)</p>
</li>

<li>
<p>See also <span class="newWikiWord">clan<a href="/nlab/new/clan">?</a></span>.</p>
</li>
</ul>

<p>Further discussion of contextual categories is in</p>

<ul>
<li id="Voevodsky15a">
<p><a class="existingWikiWord" href="/nlab/show/Vladimir+Voevodsky">Vladimir Voevodsky</a>, <em>A C-system defined by a universe category</em>, Theory Appl. Categ. 30 (2015), No. 37, 1181–1215, arXiv:1409.7925 (<a href="https://arxiv.org/abs/1409.7925">arXiv:1409.7925</a>)</p>
</li>

<li id="Voevodsky15b">
<p><a class="existingWikiWord" href="/nlab/show/Vladimir+Voevodsky">Vladimir Voevodsky</a>, <em>Martin-Löf identity types in the C-systems defined by a universe category</em> (<a href="https://arxiv.org/abs/1505.06446">arXiv:1505.06446</a>)</p>
</li>

<li id="Voevodsky15c">
<p><a class="existingWikiWord" href="/nlab/show/Vladimir+Voevodsky">Vladimir Voevodsky</a>, <em>Products of families of types in the C-systems defined by a universe category</em> (<a href="https://arxiv.org/abs/1503.07072">arXiv:1503.07072</a>)</p>
</li>

<li id="Voevodsky15d">
<p><a class="existingWikiWord" href="/nlab/show/Vladimir+Voevodsky">Vladimir Voevodsky</a>, <em>Subsystems and regular quotients of C-systems</em> (<a href="https://arxiv.org/abs/1406.7413">arXiv:1406.7413</a>)</p>
</li>
</ul>

<p>Strictification is discussed in</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, <em>On the interpretation of type theory in locally cartesian closed categories</em></p>
</li>

<li id="CurienGarnerHofmann">
<p><a class="existingWikiWord" href="/nlab/show/Pierre-Louis+Curien">Pierre-Louis Curien</a>, <a class="existingWikiWord" href="/nlab/show/Richard+Garner">Richard Garner</a>, <a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, <em>Revisiting the categorical interpretation of dependent type theory</em> (<a class="existingWikiWord" href="/nlab/files/CurienGarnerHofmann.pdf" title="pdf">pdf</a>)</p>
</li>

<li id="LumsdaineWarren13">
<p><a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>, <a class="existingWikiWord" href="/nlab/show/Michael+Warren">Michael Warren</a>, <em>The local universes model: An overlooked coherence construction for dependent type theory</em>, <a href="https://arxiv.org/abs/1411.1736">arXiv:1411.1736</a>, ACM Transactions on Computational Logic.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Vladimir+Voevodsky">Vladimir Voevodsky</a>, <a href="http://www.math.ias.edu/~vladimir/Site3/Univalent_Foundations_files/expressions_current.pdf">Notes on type systems</a></p>
</li>

<li id="Awodey2018">
<p><a class="existingWikiWord" href="/nlab/show/Steve+Awodey">Steve Awodey</a>. (2018). <em>Natural models of homotopy type theory</em>, Mathematical Structures in Computer Science, 28(2), 241-286. <a href="https://arxiv.org/pdf/1406.3219.pdf">PDF</a></p>
</li>
</ul>

<p>Comparisons of various models can be found in</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Benedikt+Ahrens">Benedikt Ahrens</a>, <a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>, <a class="existingWikiWord" href="/nlab/show/Vladimir+Voevodsky">Vladimir Voevodsky</a>, <em>Categorical structures for type theory in univalent foundations</em>, <a href="https://arxiv.org/abs/1705.04310">arxiv</a></p>
</li>

<li id="KapulkinLumsdaine16">
<p><a class="existingWikiWord" href="/nlab/show/Chris+Kapulkin">Chris Kapulkin</a> and <a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>, <em>The homotopy theory of type theories</em>, <a href="https://arxiv.org/abs/1610.00037">arXiv:1610.00037</a></p>
</li>
</ul>

<p>Recent work on abstract definitions of (models of) type theory include:</p>

<ul>
<li>
<p>Valery Isaev, <em>Algebraic Presentations of Dependent Type Theories</em> <a href="https://arxiv.org/abs/1602.08504">arXiv</a></p>
</li>

<li>
<p>Taichi Uemura, <em>A General Framework for the Semantics of Type Theory</em> <a href="https://arxiv.org/abs/1904.04097">arXiv</a></p>
</li>
</ul>

<p>A category with families structure is constructed on the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,1)</annotation></semantics></math>-category of all locally cartesian closed categories, which since locally presentable may be treated via model categories, in:</p>

<ul>
<li id="Bidlingmaier20">
<p>Martin Bidlingmaier, <em>An interpretation of dependent type theory in a model category of locally cartesian closed categories</em>, (<a href="https://arxiv.org/abs/2007.02900">arXiv:2007.02900</a>)</p>
</li>

<li id="ChingRiehl2014">
<p>Michael Ching, Emily Riehl, <em>Coalgebraic models for combinatorial model categories</em> <a href="https://arxiv.org/abs/1403.5303">arXiv:1403.5303</a></p>
</li>

<li id="Isaev2016">
<p>Valery Isaev, <em>Model category of marked objects</em> <a href="https://arxiv.org/abs/1610.08459">arXiv:1610.08459</a></p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on October 30, 2021 at 16:50:25.
    See the <a href="https://ncatlab.org/nlab/history/categorical model of dependent types" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/categorical+model+of+dependent+types" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/3853/#Item_41">Discuss</a><span class="backintime"><a href="/nlab/revision/categorical+model+of+dependent+types/53" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/categorical+model+of+dependent+types" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/categorical+model+of+dependent+types" accesskey="S" class="navlink" id="history" rel="nofollow">History (53 revisions)</a>
  <a href="https://ncatlab.org/nlab/show/categorical model of dependent types/cite" style="color: black">Cite</a>
  <a href="/nlab/print/categorical+model+of+dependent+types" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/categorical+model+of+dependent+types" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
