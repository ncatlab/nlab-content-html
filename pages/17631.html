
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      Catalan number in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />


  <link href="/stylesheets/instiki.css?1534097725" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #008B26;
    }
    a:visited.existingWikiWord {
      color: #005c19;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #005000;
}

a.existingWikiWord:visited {
color: #005000;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    
<span id="svg_logo"><svg version="1.1" width="100%" height="100%" viewBox='0 -1 180 198' xmlns='http://www.w3.org/2000/svg'>
      <path id="svg_logo_path" fill="#008B26" stroke-width='0.5' stroke='#000' d='
        M170,60c4,11-1,20-12,25c-9,4-25,3-20,15c5,5,15,0,24,1c11,1,21,11,14,21c-10,15-35,6-48-1c-5-3-27-23-32-10c-1,13,15,10,22,16
        c11,4,24,14,34,20c12,10,7,25-9,23c-11-1-22-9-30-16c-5-5-13-18-21-9c-2,6,2,11,5,14c9,9,22,14,22,31c-2,8-12,8-18,4c-4-3-9-8-11-13
        c-3-6-5-18-12-18c-14-1-5,28-18,30c-9,2-13-9-12-16c1-14,12-24,21-31c5-4,17-13,10-20c-9-10-19,12-23,16c-7,7-17,16-31,15
        c-9-1-18-9-11-17c5-7,14-4,23-6c6-1,15-8,8-15c-5-6-57,2-42-24c7-12,51,4,61,6c6,1,17,4,18-4c2-11-12-7-21-8c-21-2-49-14-49-34
        c0-5,3-11,8-11C31,42,34,65,42,67c6,1,9-3,8-9C49,49,38,40,40,25c1-5,4-15,13-14c10,2,11,18,13,29c1,8,0,24,7,28c15,0,5-22,4-30
        C74,23,78,7,87,1c8-4,14,1,16,9c2,11-8,21-2,30c8,2,11-6,14-12c9-14,36-18,30,5c-3,9-12,19-21,24c-6,4-22,10-23,19c-2,14,15,2,18-2
        c9-9,20-18,33-22C159,52,166,54,170,60' />
    </svg></span>
      <span class="webName">nLab</span><br />
      Catalan number
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/8188/#Item_31" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
    <a href="/nlab/feeds" title="Subscribe to changes by Atom">Feeds</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="combinatorics">Combinatorics</h4>

<div class="hide"><p><strong><a class="existingWikiWord" href="/nlab/show/combinatorics">combinatorics</a></strong></p><p><a class="existingWikiWord" href="/nlab/show/enumerative+combinatorics">enumerative combinatorics</a></p><p><a class="existingWikiWord" href="/nlab/show/graph+theory">graph theory</a></p><p><a class="existingWikiWord" href="/nlab/show/rewriting">rewriting</a></p><h3 id="basic_structures">Basic structures</h3><ul>
<li><a class="existingWikiWord" href="/nlab/show/binary+linear+code">binary linear code</a></li>

<li><a class="existingWikiWord" href="/nlab/show/chord+diagram">chord diagram</a></li>

<li><a class="existingWikiWord" href="/nlab/show/combinatorial+design">combinatorial design</a></li>

<li><a class="existingWikiWord" href="/nlab/show/graph">graph</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Latin+square">Latin square</a></li>

<li><a class="existingWikiWord" href="/nlab/show/matroid">matroid</a></li>

<li><a class="existingWikiWord" href="/nlab/show/partition">partition</a></li>

<li><a class="existingWikiWord" href="/nlab/show/permutation">permutation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/shuffle">shuffle</a></li>

<li><a class="existingWikiWord" href="/nlab/show/tree">tree</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Young+diagram">Young diagram</a></li>
</ul><h3 id="generating_functions">Generating functions</h3><ul>
<li><a class="existingWikiWord" href="/nlab/show/combinatorial+species">combinatorial species</a></li>

<li><a class="existingWikiWord" href="/nlab/show/generating+function">generating function</a></li>

<li><a class="existingWikiWord" href="/nlab/show/power+series">power series</a></li>
</ul><h3 id="proof_techniques">Proof techniques</h3><ul>
<li><a class="existingWikiWord" href="/nlab/show/bijective+proof">bijective proof</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Lagrange+inversion">Lagrange inversion</a></li>

<li><a class="existingWikiWord" href="/nlab/show/M%C3%B6bius+inversion">Möbius inversion</a>
<ul>
<li><a class="existingWikiWord" href="/nlab/show/order+polynomial">order polynomial</a></li>

<li><a class="existingWikiWord" href="/nlab/show/zeta+polynomial">zeta polynomial</a></li>
</ul>
</li>

<li><a class="existingWikiWord" href="/nlab/show/P%C3%B3lya+enumeration+theorem">Pólya enumeration theorem</a></li>
</ul><h3 id="combinatorial_identities">Combinatorial identities</h3><ul>
<li><a class="existingWikiWord" href="/nlab/show/binomial+theorem">binomial theorem</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Catalan+number">Catalan number</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Chu%E2%80%93Vandermonde+identity">Chu–Vandermonde identity</a></li>
</ul><h3 id="polytopes">Polytopes</h3><ul>
<li><a class="existingWikiWord" href="/nlab/show/associahedron">associahedron</a></li>
</ul><p><a href="http://ncatlab.org/nlab/edit/combinatorics+-+contents">edit this sidebar</a></p><div class="property">category: <a class="category_link" href="/nlab/all_pages/combinatorics">combinatorics</a></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class="maruku_toc"><ul><li><a href="#idea">Idea</a></li><li><a href="#some_structural_bijections">Some structural bijections</a><ul><li><a href="#rooted_planar_binary_trees_and_magma_words">Rooted planar binary trees and magma words</a></li><li><a href="#magma_words_and_rooted_planar_trees">Magma words and rooted planar trees</a></li><li><a href="#rooted_planar_trees_and_mountain_ranges">Rooted planar trees and mountain ranges</a></li><li><a href="#mountain_ranges_and_stayahead_races">Mountain ranges and stay-ahead races</a></li><li><a href="#mountain_ranges_and_monotonic_lattice_paths">Mountain ranges and monotonic lattice paths</a></li><li><a href="#monotonic_lattice_paths_and_pointed_inflationary_maps">Monotonic lattice paths and pointed inflationary maps</a></li></ul></li><li><a href="#structural_enumeration">Structural enumeration</a><ul><li><a href="#method_1">Method 1</a></li><li><a href="#method_2">Method 2</a></li><li><a href="#method_3">Method 3</a></li></ul></li><li><a href="#related_concepts">Related concepts</a></li><li><a href="#references">References</a></li></ul></div>
<h2 id="idea">Idea</h2>

<p>Catalan numbers are a specific sequence of <a class="existingWikiWord" href="/nlab/show/negative+number">nonnegative</a> <a class="existingWikiWord" href="/nlab/show/integers">integers</a>, here denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_n</annotation></semantics></math>, with a ubiquitous <a class="existingWikiWord" href="/nlab/show/combinatorics">combinatorial</a> interpretations. In terms of <a class="existingWikiWord" href="/nlab/show/binomial+coefficients">binomial coefficients</a> they are given by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></mfrac><mo>)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>)</mo></mrow><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>!</mo></mrow><mrow><mi>n</mi><mo>!</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex"> 
  C_n = \frac{1}{n+1}\binom{2 n}{n} = \frac1{2n+1}\binom{2n+1}{n} = \frac{(2n)!}{n!(n+1)!}
  \,.

</annotation></semantics></math></div>
<p>The Catalan numbers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_n</annotation></semantics></math> count a myriad of different families of objects, including:</p>

<ul>
<li>
<p>nonisomorphic (rooted planar) binary <a class="existingWikiWord" href="/nlab/show/trees">trees</a> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> internal <a class="existingWikiWord" href="/nlab/show/vertices">vertices</a>;</p>
</li>

<li>
<p>ways of unambiguously defining the product of elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_0,\dots,x_n</annotation></semantics></math> within an arbitrary (not necessarily <a class="existingWikiWord" href="/nlab/show/associative">associative</a>) <a class="existingWikiWord" href="/nlab/show/magma">magma</a>, or equivalently, ways of fully parenthesizing a string of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> letters;</p>
</li>

<li>
<p>elements of the free magma <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mag(x)</annotation></semantics></math> generated by a singleton <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> (called <em>words</em>) that have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> instances of the letter <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>;</p>
</li>

<li>
<p>nonisomorphic rooted planar <a class="existingWikiWord" href="/nlab/show/trees">trees</a> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/edges">edges</a>;</p>
</li>

<li>
<p>strings consisting of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> well-balanced pairs of parentheses (also known as “Dyck words”), or equivalently, <a class="existingWikiWord" href="/nlab/show/surjective">surjective</a> <a class="existingWikiWord" href="/nlab/show/monotone+functions">monotone functions</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo>:</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w : (n) + (n) \to (2n)</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><msub><mi>ι</mi> <mn>1</mn></msub><mi>j</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>w</mi><mo stretchy="false">(</mo><msub><mi>ι</mi> <mn>2</mn></msub><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(\iota_1 j) \le w(\iota_2 j)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le j \le n</annotation></semantics></math> (where we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k)</annotation></semantics></math> for the finite <a class="existingWikiWord" href="/nlab/show/ordinal">ordinal</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">(k) = \{1,\dots,k\}</annotation></semantics></math>);</p>
</li>

<li>
<p>monotonic lattice paths in an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math> grid which do not cross below the diagonal, or equivalently, <a class="existingWikiWord" href="/nlab/show/injective">injective</a> <a class="existingWikiWord" href="/nlab/show/monotone+functions">monotone functions</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p : [2n] \to [n] \times [n]</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>≤</mo><msub><mi>π</mi> <mn>2</mn></msub><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1 p(i) \le \pi_2 p(i)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \le i \le 2n</annotation></semantics></math> (where we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[k]</annotation></semantics></math> for the non-empty finite <a class="existingWikiWord" href="/nlab/show/ordinal">ordinal</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">[k] = \{0,\dots,k\}</annotation></semantics></math>);</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monotone+functions">monotone functions</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f : [n] \to [n]</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(0) = 0</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \le f(x)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \le x \le n</annotation></semantics></math>, or in other words, 1-cells <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f : [n] \to [n]</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Δ</mi> <mo>⊥</mo></msub></mrow><annotation encoding="application/x-tex">\Delta_\bot</annotation></semantics></math> (the sub-2-category of the <a class="existingWikiWord" href="/nlab/show/simplex+category">simplex 2-category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math> spanned by the first-element-preserving functions) which are <em>pointed</em> in the sense of being equipped with a 2-cell <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="0em" rspace="thinmathspace">id</mo> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msub><mo>⇒</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\id_{[n]} \Rightarrow f</annotation></semantics></math>;</p>
</li>

<li>
<p>“mountain ranges”, i.e., functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: [2n] \to \mathbb{N}</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(0) = 0 = f(2n)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(j+1) - f(j) \in \{1, -1\}</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \leq j \lt 2n</annotation></semantics></math> (so called because graphs of such depict mountain ranges);</p>
</li>

<li>
<p>“stay-ahead races”, i.e., functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f: [2n] \to \{1, -1\}</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mi>j</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum_{i=0}^j f(i) \gt 0</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \leq j \leq 2n</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>n</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2n} f(i) = 1</annotation></semantics></math> (see below for explanation of terminology);</p>
</li>
</ul>

<p>and many, many more besides (see the <a href="#Stanley2015">Stanley</a> references and OEIS <a href="#a000108">A000108</a>).</p>

<h2 id="some_structural_bijections">Some structural bijections</h2>

<p>In this section we describe some “canonical” isomorphisms between various structures named above.</p>

<h3 id="rooted_planar_binary_trees_and_magma_words">Rooted planar binary trees and magma words</h3>

<p>Each (finite) rooted planar binary tree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> internal vertices (i.e., vertices that have a left child and a right child) either consists of only a root (the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math>), or has a left subtree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>T</mi> <mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l</annotation></semantics></math> and a right subtree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>T</mi> <mi>r</mi></msub></mrow><annotation encoding="application/x-tex">T_r</annotation></semantics></math> adjacent to the root. The associated magma word <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(T) \in Mag(x)</annotation></semantics></math> is defined recursively according to these cases:</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">m(T) = x</annotation></semantics></math> in the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>l</mi></msub><mo stretchy="false">)</mo><mi>m</mi><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>r</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(T) = m(T_l) m(T_r)</annotation></semantics></math> [expressing the magma product by simple juxtaposition] in the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \gt 0</annotation></semantics></math>.</p>
</li>
</ul>

<p>Put slightly differently, the collection of isomorphism classes of rooted planar binary trees carries a magma structure, defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>l</mi></msub><mo>,</mo><msub><mi>T</mi> <mi>r</mi></msub><mo stretchy="false">)</mo><mo>↦</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">(T_l, T_r) \mapsto T</annotation></semantics></math> using the notation above, and we have the following result.</p>

<div class="num_prop">
<h6 id="proposition">Proposition</h6>

<p>The mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>↦</mo><mi>m</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T \mapsto m(T)</annotation></semantics></math> defines a bijection from the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Bin</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Bin_n</annotation></semantics></math> of isomorphism clases of rooted planar binary trees with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> internal vertices to the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Mag(x)_n</annotation></semantics></math> of magma words with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> instances of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>.</p>
</div>

<p>The inverse is given by the unique magma map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Bin</mi></mrow><annotation encoding="application/x-tex">Mag(x) \to Bin</annotation></semantics></math> that takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> to the isomorphism class of trees consisting of just a root.</p>

<h3 id="magma_words_and_rooted_planar_trees">Magma words and rooted planar trees</h3>

<p>It is often suggestive to use exponential notation to denote the magma operation: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>↦</mo><msup><mi>x</mi> <mi>y</mi></msup></mrow><annotation encoding="application/x-tex">(x, y) \mapsto x^y</annotation></semantics></math>. For each element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> of the free magma <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mag(x)</annotation></semantics></math>, there is thus an unary operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mi>a</mi></msup></mrow><annotation encoding="application/x-tex">(-)^a</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">Mag(x)^\ast</annotation></semantics></math> denotes the free monoid on the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mag(x)</annotation></semantics></math>, there is a unique monoid map</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mo>*</mo></msup><mo>→</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi: Mag(x)^\ast \to \hom(Mag(x), Mag(x))</annotation></semantics></math></div>
<p>that carries <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \in Mag(x)</annotation></semantics></math> to the unary operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mi>a</mi></msup></mrow><annotation encoding="application/x-tex">(-)^a</annotation></semantics></math>. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \in Mag(x)</annotation></semantics></math>, it is reasonable to denote the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mo>*</mo></msup><mover><mo>→</mo><mi>ϕ</mi></mover><mi>hom</mi><mo stretchy="false">(</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msub><mi>eval</mi> <mi>a</mi></msub></mrow></mover><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mag(x)^\ast \stackrel{\phi}{\to} \hom(Mag(x), Mag(x)) \stackrel{eval_a}{\to} Mag(x)</annotation></semantics></math></div>
<p>by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo>↦</mo><msup><mi>a</mi> <mi>w</mi></msup></mrow><annotation encoding="application/x-tex">w \mapsto a^w</annotation></semantics></math>. Denote the monoid product in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">Mag(x)^\ast</annotation></semantics></math> by simple juxtaposition. Under these conventions, we have for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>∈</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a, b, c \in Mag(x)</annotation></semantics></math> the exponential equation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>a</mi> <mi>b</mi></msup><msup><mo stretchy="false">)</mo> <mi>c</mi></msup><mo>=</mo><msup><mi>a</mi> <mrow><mi>b</mi><mi>c</mi></mrow></msup><mo>.</mo></mrow><annotation encoding="application/x-tex">(a^b)^c = a^{b c}.</annotation></semantics></math></div>
<p>If we regard the right-hand side of the exponential equation as a reduction of the left-hand side, then for any formal magma expression <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>a</mi> <mi>d</mi></msup></mrow><annotation encoding="application/x-tex">a^d</annotation></semantics></math>, either <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a = x</annotation></semantics></math>, or we may write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><msup><mi>b</mi> <mi>c</mi></msup></mrow><annotation encoding="application/x-tex">a = b^c</annotation></semantics></math> and then reduce <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>a</mi> <mi>d</mi></msup></mrow><annotation encoding="application/x-tex">a^d</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>b</mi> <mrow><mi>c</mi><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">b^{c d}</annotation></semantics></math>.</p>

<p>Continuing recursively in this manner, every word <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \in Mag(x)</annotation></semantics></math> can be eventually expressed as a “reduced form” (where no further reductions are possible), where we formally define a <strong>reduced form</strong> as follows:</p>

<ul>
<li>
<p>The expression <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a reduced form;</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>w</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>w</mi> <mn>2</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>w</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">w_1, w_2, \ldots, w_n</annotation></semantics></math> are reduced forms, then so is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>1</mn></msub><msub><mi>w</mi> <mn>2</mn></msub><mi>…</mi><msub><mi>w</mi> <mi>n</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x^{w_1 w_2 \ldots w_n}</annotation></semantics></math>.</p>
</li>
</ul>

<p>The reader who is following where this is going will have observed that this recursive description of reduced forms matches precisely the recursive description of rooted planar trees, formalized by saying the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tree</mi></mrow><annotation encoding="application/x-tex">Tree</annotation></semantics></math> of isomorphism classes of rooted planar trees is the least fixed point, or <a class="existingWikiWord" href="/nlab/show/initial+algebra+of+an+endofunctor">initial algebra</a>, of the <a class="existingWikiWord" href="/nlab/show/endofunctor">endofunctor</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>↦</mo><msup><mi>T</mi> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">T \mapsto T^\ast</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>.</p>

<p>To put it more visually: let us designate the term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> appearing as the base of a reduced form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>1</mn></msub><mi>…</mi><msub><mi>w</mi> <mi>n</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x^{w_1 \ldots w_n}</annotation></semantics></math> as the root of a corresponding tree. (If the reduced form is just <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, then that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is designated the root of a tree consisting of only a root.) The reduced forms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math> themselves have roots, and we draw an edge connecting those roots to the root <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> appearing in the base. Continuing this pattern, we climb recursively up the stacked exponentials, eventually obtaining a structure of rooted planar tree from a reduced form, whose vertices are just the instances of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> appearing in the reduced form.</p>

<p>In fact, there is no harm in identifying rooted planar trees with reduced forms, and we will repeatedly use this identification below.</p>

<p>Letting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Red</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Red(w)</annotation></semantics></math> denote the reduced form of a magma word <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w \in Mag(x)</annotation></semantics></math>, we thus have the following result.</p>

<div class="num_prop">
<h6 id="proposition_2">Proposition</h6>

<p>The mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo>↦</mo><mi>Red</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w \mapsto Red(w)</annotation></semantics></math> defines a bijection from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mag</mi><mo stretchy="false">(</mo><mi>x</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Mag(x)_n</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Tree</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Tree_n</annotation></semantics></math>, i.e., from magma words having <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> instances of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> to isomorphism classes of rooted planar trees with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> edges.</p>
</div>

<p>The inverse takes a reduced form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mi>w</mi></msup><mo>=</mo><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>1</mn></msub><msub><mi>w</mi> <mn>2</mn></msub><mi>…</mi><msub><mi>w</mi> <mi>n</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x^w = x^{w_1 w_2 \ldots w_n}</annotation></semantics></math> to the magma word <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mi>w</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu(x^w)</annotation></semantics></math> defined recursively by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>…</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mrow><mi>μ</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mrow></msup><msup><mo stretchy="false">)</mo> <mrow><mi>μ</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mi>…</mi><msup><mo stretchy="false">)</mo> <mrow><mi>μ</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">(\ldots ((x^{\mu(w_1)})^{\mu(w_2)})\ldots )^{\mu(w_n)}</annotation></semantics></math></div>
<p>and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\mu(x) = x</annotation></semantics></math>.</p>

<h3 id="rooted_planar_trees_and_mountain_ranges">Rooted planar trees and mountain ranges</h3>

<p>To each rooted planar tree or reduced form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>1</mn></msub><mi>…</mi><msub><mi>w</mi> <mi>n</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x^{w_1 \ldots w_n}</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> edges, we associate a mountain range <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: [2k] \to \mathbb{N}</annotation></semantics></math> as follows.</p>

<p>In the first place, there is a monoid structure on the set of mountain ranges, essentially given by juxtaposition. Formally, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>m</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: [2m] \to \mathbb{N}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g: [2n] \to \mathbb{N}</annotation></semantics></math> are mountain ranges, then their product</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>*</mo><mi>g</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f \ast g: [2(m+n)] \to \mathbb{N}</annotation></semantics></math></div>
<p>is defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>↦</mo><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j \mapsto f(j)</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mn>2</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">0 \leq j \leq 2m</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>↦</mo><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>2</mn><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j \mapsto g(j-2m)</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn><mi>m</mi><mo>≤</mo><mn>2</mn><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2m \leq 2(m+n)</annotation></semantics></math>, noting that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>*</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(f \ast g)(2m) = 0</annotation></semantics></math> in either case by definition of mountain range (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(2m) = 0 = g(0)</annotation></semantics></math>).</p>

<p>We define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Moun</mi><mo>:</mo><msup><mi>Tree</mi> <mo>*</mo></msup><mo>→</mo><mi>Range</mi></mrow><annotation encoding="application/x-tex">Moun: Tree^\ast \to Range</annotation></semantics></math>, from the free monoid on trees to mountain ranges, by the following recursive rules:</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Moun</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">Moun(x): \{0\} \to \mathbb{N}</annotation></semantics></math> takes the value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Moun</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mi>…</mi><mi>Moun</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Moun(w_1), \ldots Moun(w_n)</annotation></semantics></math> have been defined for reduced forms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>w</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>w</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">w_1, \ldots, w_n</annotation></semantics></math>, then</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Moun</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mn>1</mn></msub><mi>…</mi><msub><mi>w</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>Moun</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>*</mo><mi>…</mi><mo>*</mo><mi>Moun</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Moun(w_1 \ldots w_n) = Moun(w_1) \ast \ldots \ast Moun(w_n)</annotation></semantics></math>, as a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">[2k] \to \mathbb{N}</annotation></semantics></math> for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>, in which case</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Moun</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>1</mn></msub><mi>…</mi><msub><mi>w</mi> <mi>n</mi></msub></mrow></msup><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">Moun(x^{w_1 \ldots w_n}): [2(k+1)] \to \mathbb{N}</annotation></semantics></math> takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \leq j \leq 2k+1</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>+</mo><mi>Moun</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mn>1</mn></msub><mi>…</mi><msub><mi>w</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1 + Moun(w_1 \ldots w_n)(j-1)</annotation></semantics></math>.</p>
</li>
</ul>
</li>
</ul>

<p>Then define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ρ</mi><mo>:</mo><mi>Tree</mi><mo>→</mo><mi>Range</mi></mrow><annotation encoding="application/x-tex">\rho: Tree \to Range</annotation></semantics></math> to be the mapping that takes a tree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>=</mo><msup><mi>x</mi> <mi>w</mi></msup></mrow><annotation encoding="application/x-tex">T = x^w</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Moun</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Moun(w)</annotation></semantics></math>.</p>

<div class="num_prop">
<h6 id="proposition_3">Proposition</h6>

<p>The mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>↦</mo><mi>ρ</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T \mapsto \rho(T)</annotation></semantics></math> defines a bijection from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Tree</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Tree_n</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Range</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Range_n</annotation></semantics></math> , consisting of mountain ranges of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: [2n] \to \mathbb{N}</annotation></semantics></math>.</p>
</div>

<p>The inverse mapping can be described as follows. For each mountain range <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: [2n] \to \mathbb{N}</annotation></semantics></math>, we may subdivide the interval <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2n]</annotation></semantics></math> into subintervals according to subdivision points <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn><msub><mi>n</mi> <mi>k</mi></msub></mrow><annotation encoding="application/x-tex">2n_k</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><msub><mi>n</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(2n_k) = 0</annotation></semantics></math>. If there is at least one internal subdivision point given by an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>n</mi> <mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>&lt;</mo><msub><mi>n</mi> <mi>k</mi></msub><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \lt n_k \lt n</annotation></semantics></math>, then the restriction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> to the subintervals (before and after <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>n</mi> <mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math>) gives mountain ranges <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>f</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_1, f_2</annotation></semantics></math>, which by strong induction on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> have assigned reduced trees <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>1</mn></msub></mrow></msup><mo>=</mo><msup><mi>ρ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msub><mi>f</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>,</mo><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>2</mn></msub></mrow></msup><mo>=</mo><msup><mi>ρ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msub><mi>f</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x^{w_1} = \rho^{-1}(f_1), x^{w_2} = \rho^{-1}(f_2)</annotation></semantics></math>, and then we put <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ρ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mrow><msub><mi>w</mi> <mn>1</mn></msub><msub><mi>w</mi> <mn>2</mn></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\rho^{-1}(f) = x^{w_1 w_2}</annotation></semantics></math>. If there are no internal subdivision points, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f \geq 1</annotation></semantics></math> on the subinterval <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, \ldots, 2n-1\}</annotation></semantics></math>. Notice moreover that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1) = 1 = f(2n-1)</annotation></semantics></math>, using the mountain range conditions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(0) = 0 = f(2n)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(j+1) - f(j) \in \{1, -1\}</annotation></semantics></math>. This means the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>=</mo><mi>f</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g = f-1</annotation></semantics></math> defines a mountain range over the subinterval <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, \ldots, 2n-1\}</annotation></semantics></math>; by induction this has an assigned reduced tree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>=</mo><msup><mi>ρ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T = \rho^{-1}(g)</annotation></semantics></math>, and then we define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ρ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\rho^{-1}(f) = x^T</annotation></semantics></math>. This completes the description of the inverse mapping.</p>

<h3 id="mountain_ranges_and_stayahead_races">Mountain ranges and stay-ahead races</h3>

<p>The terminology “stay-ahead” race is suggested by the following scenario: a poll race is held between a proponent P and an opponent O. A vote for P is indicated by the value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>, a vote for O by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math>. Votes are counted one after another (tracked by a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f: [2n] \to \{1, -1\}</annotation></semantics></math>) and partial tallies are recorded. The stay-ahead conditions are that each partial tally has P ahead of O (i.e., <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mi>j</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sum_{i=0}^j f(i) \gt 0</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \in [2n]</annotation></semantics></math>), and that P wins in the end by just one vote: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>n</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2n} f(i) = 1</annotation></semantics></math>.</p>

<p>To each stay-ahead race <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f: [2n] \to \{1, -1\}</annotation></semantics></math> we associate a mountain range <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>=</mo><mi>Σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g = \Sigma(f): [2n] \to \mathbb{N}</annotation></semantics></math> by defining <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo>+</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mi>j</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(j) = -1 + \sum_{i=0}^j f(i)</annotation></semantics></math>.</p>

<div class="num_prop">
<h6 id="proposition_4">Proposition</h6>

<p>The mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>↦</mo><mi>Σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f \mapsto \Sigma(f)</annotation></semantics></math> defines a bijection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Race</mi> <mi>n</mi></msub><mo>→</mo><msub><mi>Range</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Race_n \to Range_n</annotation></semantics></math> from stay-ahead races <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">[2n] \to \{1, -1\}</annotation></semantics></math> to mountain ranges <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">[2n] \to \mathbb{N}</annotation></semantics></math>.</p>
</div>

<p>The inverse mapping takes a mountain range <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g: [2n] \to \mathbb{N}</annotation></semantics></math> to the stay-ahead race defined by the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>↦</mo><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j \mapsto g(j) - g(j-1)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \leq j \leq 2n</annotation></semantics></math>, making use of a nonce convention <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≔</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g(-1) \coloneqq -1</annotation></semantics></math>.</p>

<h3 id="mountain_ranges_and_monotonic_lattice_paths">Mountain ranges and monotonic lattice paths</h3>

<p>A mountain range <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: [2n] \to \mathbb{N}</annotation></semantics></math> (or more precisely, the graph of a mountain range) can easily be converted, by a linear transformation, to an injective poset mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>g</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g = (g_1, g_2): [2n] \to [n] \times [n]</annotation></semantics></math> satisfying the diagonal conditions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(0) = (0, 0)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(2n) = (n, n)</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mn>1</mn></msub><mo>≤</mo><msub><mi>g</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">g_1 \leq g_2</annotation></semantics></math>.</p>

<p>To wit: we remark that for a mountain range <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>, each value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(j)</annotation></semantics></math> has the same parity as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">f(j) \leq j</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \in [2n]</annotation></semantics></math>. (Both are simple consequences of the mountain range conditions.) Define</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_1(j) = \frac1{2}(j - f(j))</annotation></semantics></math>,</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_2(j) = \frac1{2}(j + f(j))</annotation></semantics></math>.</p>
</li>
</ul>

<p>Denote the poset map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>g</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g = (g_1, g_2)</annotation></semantics></math> thus defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda(f)</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Path</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Path_n</annotation></semantics></math> denote the set of monotonic lattice paths satisfying the diagonal conditions.</p>

<div class="num_prop">
<h6 id="proposition_5">Proposition</h6>

<p>The mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>↦</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f \mapsto \lambda(f)</annotation></semantics></math> defines a bijection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Range</mi> <mi>n</mi></msub><mo>→</mo><msub><mi>Path</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Range_n \to Path_n</annotation></semantics></math>.</p>
</div>

<p>The inverse mapping takes an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>g</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>∈</mo><msub><mi>Path</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">(g_1, g_2) \in Path_n</annotation></semantics></math> to the mountain range defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>↦</mo><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>g</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j \mapsto g_2(j) - g_1(j)</annotation></semantics></math>. The injectivity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>g</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g = (g_1, g_2)</annotation></semantics></math> forces each step of the path to go just one step (or block) north or just one block east, corresponding to the fact that the difference between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><msub><mi>g</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_2(j+1) - g_1(j+1)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>g</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_2(j) - g_1(j)</annotation></semantics></math> always lies in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1, -1\}</annotation></semantics></math>.</p>

<h3 id="monotonic_lattice_paths_and_pointed_inflationary_maps">Monotonic lattice paths and pointed inflationary maps</h3>

<p>Each injective map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>g</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">g = (g_1, g_2): [2n] \to [n] \times [n]</annotation></semantics></math> determines and is determined by a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f = \phi(g): [n] \to [n]</annotation></semantics></math> defined as follows: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \leq j \leq n</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>min</mi><mo stretchy="false">{</mo><msub><mi>g</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi>g</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>j</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(j) = \min \{g_2(k): g_1(k) = j\}</annotation></semantics></math>. (The injectivity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> implies that the lattice path crosses each line <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">x = j</annotation></semantics></math>.)</p>

<div class="num_prop">
<h6 id="proposition_6">Proposition</h6>

<p>The mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>↦</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g \mapsto \phi(g)</annotation></semantics></math> defines a bijection from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Path</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Path_n</annotation></semantics></math> to the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>PtInf</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">PtInf_n</annotation></semantics></math> consisting of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f: [n] \to [n]</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(0) = 0</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>≤</mo><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j \leq f(j)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \in [n]</annotation></semantics></math>.</p>
</div>

<p>Indeed, the pointed inflationary conditions on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> are direct consequences of the diagonal conditions on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>. The inverse mapping takes such a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> to the lattice path that proceeds north and east, interpolating through the points</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mi>…</mi><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">(0, 0)\;\; (0, f(1))\;\; (1, f(1))\;\; (1, f(2))\;\; \ldots\;\; (n, n).</annotation></semantics></math></div>
<h2 id="structural_enumeration">Structural enumeration</h2>

<p>The bijections of the last section indicate that all of the structures named above are counted by the same quantity <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_n</annotation></semantics></math>. There are several ways of establishing the binomial expressions for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_n</annotation></semantics></math> mentioned above.</p>

<h3 id="method_1">Method 1</h3>

<p>A tried-and-true approach (explained in <a href="#bd">Baez-Dolan</a>) is by means of generating functions. To enumerate rooted planar binary trees with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> internal indices, use the fact that there is just one such tree where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math> (i.e., <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C_0 = 1</annotation></semantics></math>), and that in the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \gt 0</annotation></semantics></math>, each tree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is determined by a pair <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>l</mi></msub><mo>,</mo><msub><mi>T</mi> <mi>r</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(T_l, T_r)</annotation></semantics></math> consisting of a left tree and right tree adjacent to the root; if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>T</mi> <mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l</annotation></semantics></math> has <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>n</mi> <mi>l</mi></msub></mrow><annotation encoding="application/x-tex">n_l</annotation></semantics></math> internal vertices and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>T</mi> <mi>r</mi></msub></mrow><annotation encoding="application/x-tex">T_r</annotation></semantics></math> has <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>n</mi> <mi>r</mi></msub></mrow><annotation encoding="application/x-tex">n_r</annotation></semantics></math> internal vertices, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>n</mi> <mi>l</mi></msub><mo>+</mo><msub><mi>n</mi> <mi>r</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n = n_l + n_r + 1</annotation></semantics></math>. Hence for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \geq 0</annotation></semantics></math> we have the recursive equation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>n</mi></mrow></munder><msub><mi>C</mi> <mi>j</mi></msub><msub><mi>C</mi> <mi>k</mi></msub><mo>.</mo></mrow><annotation encoding="application/x-tex">C_{n+1} = \sum_{j + k = n} C_j C_k.</annotation></semantics></math></div>
<p>Letting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></msub><msub><mi>C</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">C(x) = \sum_{n \geq 0} C_n x^n</annotation></semantics></math> be the generating function (really a formal power series), the recursion leads to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>x</mi><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">C(x) = 1 + x C(x)^2</annotation></semantics></math></div>
<p>which we solve as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><msqrt><mrow><mn>1</mn><mo>−</mo><mn>4</mn><mi>x</mi></mrow></msqrt></mrow><mrow><mn>2</mn><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">C(x) = \frac{1 - \sqrt{1 - 4x}}{2x}</annotation></semantics></math> in the formal power series sense. Starting with the <a class="existingWikiWord" href="/nlab/show/binomial+theorem">binomial theorem</a> to expand <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>4</mn><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(1 - 4x)^{1/2}</annotation></semantics></math> as a power series, a series of (somewhat tedious and unilluminating) manipulations eventually leads to the calculation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></mfrac><mo>)</mo></mrow><mo>.</mo></mrow><annotation encoding="application/x-tex">C_n = \frac1{n+1}\binom{2n}{n}.</annotation></semantics></math></div>
<h3 id="method_2">Method 2</h3>

<p>A more structural derivation can be obtained by counting stay-ahead races, in the following manner. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> be the set of functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f: [2n] \to \{1, -1\}</annotation></semantics></math> for which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>n</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{2n} f(i) = 1</annotation></semantics></math>. Each such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> takes the value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> a total of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> times, and the value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math> a total of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> times, so the cardinality of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></mfrac><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{2n}{n}</annotation></semantics></math>.</p>

<p>We let the <a class="existingWikiWord" href="/nlab/show/cyclic+group">cyclic group</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}/(2n+1)</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/group+action">act</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>, by precomposing functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f: [2n] \to \{1, -1\}</annotation></semantics></math> with powers of the cyclic <a class="existingWikiWord" href="/nlab/show/permutation">permutation</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>τ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mspace width="thickmathspace"></mspace><mn>1</mn><mspace width="thickmathspace"></mspace><mi>…</mi><mspace width="thickmathspace"></mspace><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mn>2</mn><mi>n</mi><mo stretchy="false">]</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">\tau = (0\; 1\; \ldots\; 2n): [2n] \to [2n].</annotation></semantics></math></div>
<p>The number of stay-ahead races in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Race</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Race_n</annotation></semantics></math> is seen to be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">C_n = \frac1{2n+1}\binom{2n+1}{n}</annotation></semantics></math>, as soon as we establish the following result.</p>

<div class="num_prop">
<h6 id="proposition_7">Proposition</h6>

<p>Each <a class="existingWikiWord" href="/nlab/show/orbit">orbit</a> of the cyclic group action on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> contains exactly one stay-ahead race, and has exactly <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n+1</annotation></semantics></math> elements.</p>
</div>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>Given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">f \in S_n</annotation></semantics></math>, form the unique extension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>f</mi><mo stretchy="false">˜</mo></mover><mo>:</mo><mi>ℤ</mi><mo>→</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\tilde{f}: \mathbb{Z} \to \{1, -1\}</annotation></semantics></math> that is periodic with period <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n+1</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g = \sigma(f)</annotation></semantics></math> be the unique function such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g(0) = 0</annotation></semantics></math> and</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mover><mi>f</mi><mo stretchy="false">˜</mo></mover><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(j+1) - g(j) = \tilde{f}(j)</annotation></semantics></math></div>
<p>for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>∈</mo><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">j \in \mathbb{Z}</annotation></semantics></math>. For example, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></msub><mover><mi>f</mi><mo stretchy="false">˜</mo></mover><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(j) = \sum_{0 \leq i \lt j} \tilde{f}(i)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">j \geq 0</annotation></semantics></math>.</p>

<p>Observe that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g(j+2n+1) = g(j)+1</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math>, so that the line <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{g, j}</annotation></semantics></math> with slope <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac1{2n+1}</annotation></semantics></math> that passes through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(j, g(j))</annotation></semantics></math> also passes through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(j+2n+1, g(j+2n+1))</annotation></semantics></math>, but passes through no other <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k, g(k))</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>k</mi><mo>&lt;</mo><mi>j</mi><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j \lt k \lt j+2n+1</annotation></semantics></math> since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(k)</annotation></semantics></math> is integral but <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{g, j}(k)</annotation></semantics></math> is not, being strictly between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(j)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g(j)+1</annotation></semantics></math>. This implies that the lines <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{g, j}</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math> ranging over a period block <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>j</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>2</mn><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{j, j+1, \ldots, j+2n\}</annotation></semantics></math> are all distinct, i.e., the cyclic group action on these <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{g, j}</annotation></semantics></math> according to the formula <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\tau L_{g, j} = L_{g, j+1}</annotation></semantics></math> is faithful.</p>

<p>Pick <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math> so that the line <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">L_j</annotation></semantics></math> is “lowest”; all the lines have the same slope <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac1{2n+1}</annotation></semantics></math>, so that lowest just means <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_j(0)</annotation></semantics></math> is minimal. Minimality implies that that for every other <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">k \neq j</annotation></semantics></math> within a periodic block, the point <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k, g(k))</annotation></semantics></math> lies above the line <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>L</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = L_j(x)</annotation></semantics></math>. Translating this picture horizontally by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math> by considering <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>∘</mo><msup><mi>τ</mi> <mi>j</mi></msup></mrow><annotation encoding="application/x-tex">g \circ \tau^j</annotation></semantics></math>, and then vertically by subtracting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>g</mi><mo>∘</mo><msup><mi>τ</mi> <mi>j</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(j) = (g \circ \tau^j)(0)</annotation></semantics></math>, i.e., putting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo>∘</mo><msup><mi>τ</mi> <mi>j</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = \sigma(f \circ \tau^j)</annotation></semantics></math>, this means that all points <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>,</mo><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k, h(k))</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1, \ldots, 2n+1</annotation></semantics></math> stay above the line <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>L</mi> <mrow><mi>h</mi><mo>,</mo><mn>0</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = L_{h, 0}(x) = \frac1{2n+1}(x)</annotation></semantics></math>. In other words, these values <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(k)</annotation></semantics></math> are all positive and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h(2n+1) = 1</annotation></semantics></math>: precisely the stay-ahead conditions for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∘</mo><msup><mi>τ</mi> <mi>j</mi></msup></mrow><annotation encoding="application/x-tex">f \circ \tau^j</annotation></semantics></math>. Thus the orbit of any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">f \in S_n</annotation></semantics></math> contains a stay-ahead race. Moreover, this is the only stay-ahead race in the orbit since the stay-ahead positivity condition is equivalent to the minimality condition on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">L_j</annotation></semantics></math>, and all the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">L_j</annotation></semantics></math> are distinct.</p>

<p>Finally, the stabilizer of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> must be trivial, else we would have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>L</mi> <mrow><mi>g</mi><mo>,</mo><mi>j</mi><mo>+</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{g, j} = L_{g, j+k}</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> a non-multiple of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n+1</annotation></semantics></math>: as we saw before, this can’t happen.</p>
</div>

<h3 id="method_3">Method 3</h3>

<p>Yet another proof of the formula is based on Jean-Luc Rémy’s algorithm for generating binary trees uniformly at random <a href="#KnuthTACP4a">(see Knuth TACP 4A, Section 7.2.1.6)</a>, which can be described as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> iterations of the following simple rule:</p>

<ul>
<li>
<p>Pick any edge of the tree.</p>
</li>

<li>
<p>Create a new internal node by splitting the edge in two and budding off a freshly-labelled leaf, either to the left or to the right of the new internal node.</p>
</li>
</ul>

<p>Starting from the trivial binary tree (containing no internal nodes and a single leaf labelled “0”), this algorithm will generate a binary tree with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> internal nodes, together with a labelling of its leaves by distinct labels in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mi>…</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \dots n</annotation></semantics></math>. Moreover, it does so exhaustively and without repetition, that is, every binary tree equipped with a permutation of its leaves will be generated exactly once. (An easy way to see this is by thinking of applying the algorithm “in reverse” to an arbitrary leaf-labelled binary tree, repeatedly pruning off the leaf with the largest label while recording whether it is a left leaf or a right leaf, until only the root edge remains.)</p>

<p>Since at the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>th iteration of the algorithm there are exactly <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(2k-1)\cdot 2</annotation></semantics></math> possible choices of an edge and a direction, after <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> iterations we obtain the identity:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub><mo>⋅</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><mo>!</mo><mo>⋅</mo><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">C_n\cdot (n+1)! = (2n-1)!! \cdot 2^n</annotation></semantics></math></div>
<p>(where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><mo>!</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mi>⋯</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">(2n-1)!! = (2n-1)(2n-3)\cdots 1</annotation></semantics></math> is the double-factorial), which implies that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><mo>!</mo><mo>⋅</mo><msup><mn>2</mn> <mi>n</mi></msup><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>!</mo></mrow><mrow><mi>n</mi><mo>!</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">C_n = (2n-1)!! \cdot 2^n/(n+1)! = \frac{(2n)!}{n!(n+1)!} \,.</annotation></semantics></math></div>
<h2 id="related_concepts">Related concepts</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/associahedron">associahedron</a></li>
</ul>

<h2 id="references">References</h2>

<p>General references:</p>

<ul>
<li>Wikipedia, <em><a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a></em></li>

<li><a class="existingWikiWord" href="/nlab/show/Richard+P.+Stanley">Richard P. Stanley</a>, <em>Catalan addendum</em>, (to problems in Chapter 6 of <em>Enumerative Combinatorics</em>, vol. 2) 96 pp. <a href="http://www-math.mit.edu/~rstan/ec/catadd.pdf">pdf</a></li>

<li id="Stanley2015"><a class="existingWikiWord" href="/nlab/show/Richard+P.+Stanley">Richard P. Stanley</a>, <em>Catalan numbers</em>, 215 pp., Cambridge University Press 2015</li>
</ul>

<p>Other references:</p>

<ul>
<li id="KnuthTACP4a">
<p><a class="existingWikiWord" href="/nlab/show/Donald+E.+Knuth">Donald E. Knuth</a>, <em>The Art of Computer Programming, Volume 4A: Combinatorial Algorithms, Part 1</em>, Addison-Wesley, 2011. See Section 7.2.1.6 on “Generating all trees” (also available as a <a href="http://www.cs.utsa.edu/~wagner/knuth/fasc4a.pdf">pre-fascicle</a>).</p>
</li>

<li id="a000108">
<p>Sequence <a href="https://oeis.org/A000108">A000108</a> in the <a href="https://oeis.org/">OEIS</a></p>
</li>
</ul>

<p>For an interpretation in terms of <a class="existingWikiWord" href="/nlab/show/species">species</a> (or <em>structure types</em>) see</p>

<ul>
<li id="bd"><a class="existingWikiWord" href="/nlab/show/John+Baez">John Baez</a>, <a class="existingWikiWord" href="/nlab/show/James+Dolan">James Dolan</a>, <em>From Finite Sets to Feynman Diagrams</em>, (<a href="https://arxiv.org/abs/math/0004133">arXiv:math/0004133</a>, p. 19).</li>
</ul>
</body></html>

</div>

<div class="revisedby">
  <p>
  Last revised on September 11, 2018 at 07:49:43.
  See the <a href="https://ncatlab.org/nlab/history/Catalan number" style="color: #005c19">history</a> of this page for a list of all contributions to it.
  </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/Catalan+number" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a> | <a href="/nlab/revision/Catalan+number/21" accesskey="B" class="navlink" id="to_previous_revision" rel="nofollow">Back in time</a> <span class='revisions'>(21 revisions)</span> | <a href="/nlab/show/diff/Catalan+number" accesskey="C" class="navlink" id="see_changes" rel="nofollow">See changes</a> | <a href="/nlab/history/Catalan+number" accesskey="S" class="navlink" id="history" rel="nofollow">History</a>
  | <a href="https://ncatlab.org/nlab/show/Catalan number/cite" style="color: black">Cite</a>
  <span class="views">
    | Views:
    <a href="/nlab/print/Catalan+number" accesskey="p" id="view_print" rel="nofollow">Print</a>
    |
    <a href="/nlab/tex/Catalan+number" id="view_tex" rel="nofollow">TeX</a>
    |
    <a href="/nlab/source/Catalan+number" id="view_source" rel="nofollow">Source</a>
  </span>

  


</div>


    <div id="footer">
    <div>This site is running on <a href="http://golem.ph.utexas.edu/instiki/show/HomePage">Instiki 0.19.7(MML+)</a></div>
    <div>Powered by <a href="http://rubyonrails.com/">Ruby on Rails</a>  2.3.18</div>
    </div>

</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
