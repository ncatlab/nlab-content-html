
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      type theory in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1655769146" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1653745287" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1653745287" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1655769146" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1653745287" type="text/javascript"></script>
<script src="/javascripts/effects.js?1653745287" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1653745287" type="text/javascript"></script>
<script src="/javascripts/controls.js?1653745287" type="text/javascript"></script>
<script src="/javascripts/application.js?1653745287" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1653745287" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1653745287" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      type theory
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/271/#Item_94" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="type_theory">Type theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></strong> <a class="existingWikiWord" href="/nlab/show/metalanguage">metalanguage</a>, <a class="existingWikiWord" href="/nlab/show/practical+foundations">practical foundations</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/judgement">judgement</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hypothetical+judgement">hypothetical judgement</a>, <a class="existingWikiWord" href="/nlab/show/sequent">sequent</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/antecedents">antecedents</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/consequent">consequent</a>, <a class="existingWikiWord" href="/nlab/show/succedents">succedents</a></li>
</ul>
</li>
</ul>

<ol>
<li><a class="existingWikiWord" href="/nlab/show/type+formation+rule">type formation rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+introduction+rule">term introduction rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/term+elimination+rule">term elimination rule</a></li>

<li><a class="existingWikiWord" href="/nlab/show/computation+rule">computation rule</a></li>
</ol>

<p><strong><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></strong> (<a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent</a>, <a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional</a>, <a class="existingWikiWord" href="/nlab/show/observational+type+theory">observational type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>)</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a></li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/syntax">syntax</a></strong> <a class="existingWikiWord" href="/nlab/show/object+language">object language</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/theory">theory</a>, <a class="existingWikiWord" href="/nlab/show/axiom">axiom</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>/<a class="existingWikiWord" href="/nlab/show/type">type</a> (<a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/definition">definition</a>/<a class="existingWikiWord" href="/nlab/show/proof">proof</a>/<a class="existingWikiWord" href="/nlab/show/program">program</a> (<a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/theorem">theorem</a></p>
</li>
</ul>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></strong> = <br /> <strong><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/programs+as+proofs">programs as proofs</a></strong> +<strong><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation type theory/category theory</a></strong></p>

<table><thead><tr><th><a class="existingWikiWord" href="/nlab/show/logic">logic</a></th><th><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></th><th><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></th></tr></thead><tbody><tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/true">true</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>/<a class="existingWikiWord" href="/nlab/show/%28-2%29-truncated+object">(-2)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+0">h-level 0</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/unit+type">unit type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/false">false</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>, <a class="existingWikiWord" href="/nlab/show/truth+value">truth value</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28-1%29-truncated+object">(-1)-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-proposition">h-proposition</a>, <a class="existingWikiWord" href="/nlab/show/mere+proposition">mere proposition</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof">proof</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/program">program</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+rule">cut rule</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/composition">composition</a> of <a class="existingWikiWord" href="/nlab/show/classifying+morphisms">classifying morphisms</a> / <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of <a class="existingWikiWord" href="/nlab/show/display+maps">display maps</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/substitution">substitution</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/cut+elimination">cut elimination</a> for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/counit">counit</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/beta+reduction">beta reduction</a></td></tr>
<tr><td style="text-align: left;">introduction rule for <a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/unit">unit</a> for hom-tensor adjunction</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/eta+conversion">eta conversion</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/logical+conjunction">logical conjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product">product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/product+type">product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/disjunction">disjunction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/sum+type">sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/implication">implication</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/negation">negation</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a> into <a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+type">function type</a> into <a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universal+quantification">universal quantification</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+product+type">dependent product type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/existential+quantification">existential quantification</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> (<a class="existingWikiWord" href="/nlab/show/%28-1%29-truncation">(-1)-truncation</a> of)</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a> (<a class="existingWikiWord" href="/nlab/show/bracket+type">bracket type</a> of)</td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence">equivalence</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/path+space+object">path space object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/identity+type">identity type</a>/<a class="existingWikiWord" href="/nlab/show/path+type">path type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/equivalence+class">equivalence class</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient">quotient</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+type">quotient type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/W-type">W-type</a>, <a class="existingWikiWord" href="/nlab/show/M-type">M-type</a></td></tr>
<tr><td style="text-align: left;">higher <a class="existingWikiWord" href="/nlab/show/induction">induction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></td></tr>
<tr><td style="text-align: left;">-</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/0-truncated">0-truncated</a> <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-colimit">higher colimit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quotient+inductive+type">quotient inductive type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinduction">coinduction</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/limit">limit</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/coinductive+type">coinductive type</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/preset">preset</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type">type</a> without <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/completely+presented+set">completely presented set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/discrete+object">discrete object</a>/<a class="existingWikiWord" href="/nlab/show/0-truncated+object">0-truncated object</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/h-level+2">h-level 2</a>-<a class="existingWikiWord" href="/nlab/show/type">type</a>/<a class="existingWikiWord" href="/nlab/show/set">set</a>/<a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/groupoid+object+in+an+%28infinity%2C1%29-category">internal 0-groupoid</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>/<a class="existingWikiWord" href="/nlab/show/setoid">setoid</a> with its <a class="existingWikiWord" href="/nlab/show/pseudo-equivalence+relation">pseudo-equivalence relation</a> an actual <a class="existingWikiWord" href="/nlab/show/equivalence+relation">equivalence relation</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/set">set</a> of <a class="existingWikiWord" href="/nlab/show/truth+values">truth values</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+of+propositions">type of propositions</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/universe">universe</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/type+universe">type universe</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modality">modality</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/closure+operator">closure operator</a>, (<a class="existingWikiWord" href="/nlab/show/idempotent+monad">idempotent</a>) <a class="existingWikiWord" href="/nlab/show/monad">monad</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/modal+type+theory">modal type theory</a>, <a class="existingWikiWord" href="/nlab/show/monad+%28in+computer+science%29">monad (in computer science)</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+logic">linear logic</a></td><td style="text-align: left;">(<a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric</a>, <a class="existingWikiWord" href="/nlab/show/closed+monoidal+category">closed</a>) <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal category</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/linear+type+theory">linear type theory</a>/<a class="existingWikiWord" href="/nlab/show/quantum+computation">quantum computation</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/proof+net">proof net</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/string+diagram">string diagram</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/quantum+circuit">quantum circuit</a></td></tr>
<tr><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/contraction+rule">contraction rule</a></td><td style="text-align: left;">(absence of) <a class="existingWikiWord" href="/nlab/show/diagonal">diagonal</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/no-cloning+theorem">no-cloning theorem</a></td></tr>
<tr><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/synthetic+mathematics">synthetic mathematics</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/domain+specific+embedded+programming+language">domain specific embedded programming language</a></td></tr>
</tbody></table>

</div>
<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+levels">homotopy levels</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-type+theory">2-type theory</a>, <a class="existingWikiWord" href="/michaelshulman/show/2-categorical+logic">2-categorical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory+-+contents">homotopy type theory - contents</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/univalence">univalence</a>, <a class="existingWikiWord" href="/nlab/show/function+extensionality">function extensionality</a>, <a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+type+theory">cohesive homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/directed+homotopy+type+theory">directed homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/HoTT+methods+for+homotopy+theorists">HoTT methods for homotopy theorists</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/semantics">semantics</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>, <a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/display+map">display map</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+a+topos">internal logic of a topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Mitchell-Benabou+language">Mitchell-Benabou language</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kripke-Joyal+semantics">Kripke-Joyal semantics</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type-theoretic+model+category">type-theoretic model category</a></li>
</ul>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/type+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>

<h4 id="deduction_and_induction">Deduction and Induction</h4>

<div class="hide"><div>
<p><strong><a class="existingWikiWord" href="/nlab/show/deductive+reasoning">deductive reasoning</a></strong>, <a class="existingWikiWord" href="/nlab/show/deduction">deduction</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sequent">sequent</a></p>

<p><a class="existingWikiWord" href="/nlab/show/hypothesis">hypothesis</a>/<a class="existingWikiWord" href="/nlab/show/context">context</a>/<a class="existingWikiWord" href="/nlab/show/antecedent">antecedent</a> <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_77a3b8c239221bcb6b2f5d78b1dd70489c654f80_1"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/conclusion">conclusion</a>/<a class="existingWikiWord" href="/nlab/show/consequence">consequence</a>/<a class="existingWikiWord" href="/nlab/show/succedent">succedent</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/logical+framework">logical framework</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/deductive+system">deductive system</a>,</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/sequent+calculus">sequent calculus</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/inductive+reasoning">inductive reasoning</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/induction">induction</a>, <a class="existingWikiWord" href="/nlab/show/recursion">recursion</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></p>
</li>
</ul></div></div>

<h4 id="constructivism_realizability_computability">Constructivism, Realizability, Computability</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a></strong>, <strong><a class="existingWikiWord" href="/nlab/show/realizability">realizability</a></strong>, <strong><a class="existingWikiWord" href="/nlab/show/computability">computability</a></strong></p>

<p><a class="existingWikiWord" href="/nlab/show/intuitionistic+mathematics">intuitionistic mathematics</a></p>

<p><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>, <a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>, <a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></p>

<h3 id="constructive_mathematics">Constructive mathematics</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/topos">topos</a>, <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-topos">homotopy topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+form">canonical form</a>, <a class="existingWikiWord" href="/nlab/show/univalence">univalence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>, <a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/decidable+equality">decidable equality</a>, <a class="existingWikiWord" href="/nlab/show/decidable+subset">decidable subset</a>, <a class="existingWikiWord" href="/nlab/show/inhabited+set">inhabited set</a>, <a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a></p>
</li>
</ul>

<h3 id="realizability">Realizability</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+topos">realizability topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+model">realizability model</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+interpretation">realizability interpretation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/effective+topos">effective topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kleene%27s+first+algebra">Kleene's first algebra</a>, <a class="existingWikiWord" href="/nlab/show/Kleene%27s+second+algebra">Kleene's second algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/function+realizability">function realizability</a></p>
</li>
</ul>

<h3 id="computability">Computability</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/computability">computability</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computation">computation</a>, <a class="existingWikiWord" href="/nlab/show/computational+type+theory">computational type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+function">computable function</a>, <a class="existingWikiWord" href="/nlab/show/partial+recursive+function">partial recursive function</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+analysis">computable analysis</a>, <a class="existingWikiWord" href="/nlab/show/constructive+analysis">constructive analysis</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Type+Two+Theory+of+Effectivity">Type Two Theory of Effectivity</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+function+%28analysis%29">computable function (analysis)</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/exact+real+computer+arithmetic">exact real computer arithmetic</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+set">computable set</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/persistent+homology">persistent homology</a>, <a class="existingWikiWord" href="/nlab/show/effective+homology">effective homology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+physics">computable physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Church-Turing+thesis">Church-Turing thesis</a></p>
</li>
</ul>
</div></div>

<h4 id="foundations">Foundations</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundations">foundations</a></strong></p>

<h2 id="the_basis_of_it_all">The basis of it all</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/mathematical+logic">mathematical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/first-order+logic">first-order logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/material+set+theory">material set theory</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/ZFC">ZFC</a></li>

<li><a class="existingWikiWord" href="/nlab/show/ZFA">ZFA</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural set theory</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a></li>

<li><a class="existingWikiWord" href="/nlab/show/SEAR">SEAR</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/universe">universe</a></p>
</li>
</ul>

<h2 id="foundational_axioms">Foundational axioms</h2>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundational+axiom">foundational axiom</a></strong></p>

<ul>
<li>
<p>basic constructions:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+cartesian+products">axiom of cartesian products</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+disjoint+unions">axiom of disjoint unions</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+the+empty+set">axiom of the empty set</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+fullness">axiom of fullness</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+function+sets">axiom of function sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+power+sets">axiom of power sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+quotient+sets">axiom of quotient sets</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/material+set+theory">material axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+extensionality">axiom of extensionality</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+foundation">axiom of foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+anti-foundation">axiom of anti-foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Mostowski%27s+axiom">Mostowski's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+pairing">axiom of pairing</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+transitive+closure">axiom of transitive closure</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+union">axiom of union</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+materialization">axiom of materialization</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theoretic axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+K">axiom K</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+UIP">axiom UIP</a></li>

<li><a class="existingWikiWord" href="/nlab/show/univalence+axiom">univalence axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Whitehead%27s+principle">Whitehead's principle</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/axioms+of+choice">axioms of choice</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+countable+choice">axiom of countable choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+dependent+choice">axiom of dependent choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+excluded+middle">axiom of excluded middle</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+existence">axiom of existence</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+multiple+choice">axiom of multiple choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Markov%27s+axiom">Markov's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/presentation+axiom">presentation axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/small+cardinality+selection+axiom">small cardinality selection axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+small+violations+of+choice">axiom of small violations of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+weakly+initial+sets+of+covers">axiom of weakly initial sets of covers</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/large+cardinal+axioms">large cardinal axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+infinity">axiom of infinity</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+universes">axiom of universes</a></li>

<li><a class="existingWikiWord" href="/nlab/show/regular+extension+axiom">regular extension axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/inaccessible+cardinal">inaccessible cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/measurable+cardinal">measurable cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/elementary+embedding">elementary embedding</a></li>

<li><a class="existingWikiWord" href="/nlab/show/supercompact+cardinal">supercompact cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Vop%C4%9Bnka%27s+principle">Vopěnka's principle</a></li>
</ul>
</li>

<li>
<p>strong axioms</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+separation">axiom of separation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+replacement">axiom of replacement</a></li>
</ul>
</li>

<li>
<p>further</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/reflection+principle">reflection principle</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="removing_axioms">Removing axioms</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a></li>

<li><a class="existingWikiWord" href="/nlab/show/predicative+mathematics">predicative mathematics</a></li>
</ul>
<div>
<p>
  <a href="/nlab/edit/foundations+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#CategoricalSemantics'>As a formal language for category theory</a></li>
<ul>
<li><a href='#TheInternalLanguageOfACategory'>The internal language of a category</a></li>
<ul>
<li><a href='#types_terms_and_variables'>Types, terms, and variables</a></li>
<li><a href='#evaluation'>Evaluation</a></li>
<li><a href='#TypeConstructors'>Type constructors</a></li>
<li><a href='#dependent_types'>Dependent types</a></li>
</ul>
<li><a href='#logic_versus_type_theory_in_categorical_semantics'>Logic versus type theory in categorical semantics</a></li>
<ul>
<li><a href='#logic_over_type_theory'>Logic over type theory</a></li>
<li><a href='#propositions_as_types'>Propositions as types</a></li>
</ul>
<li><a href='#syntactic_categories_and_free_models'>Syntactic categories and free models</a></li>
</ul>
<li><a href='#Syntax'>Syntax of type theory</a></li>
<ul>
<li><a href='#structural_rules'>Structural rules</a></li>
<li><a href='#typeforming_rules'>Type-forming rules</a></li>
<li><a href='#universes'>Universes</a></li>
<li><a href='#dependent_types_2'>Dependent types</a></li>
<li><a href='#propositions'>Propositions</a></li>
<li><a href='#additional_dependencies'>Additional dependencies</a></li>
</ul>
<li><a href='#typetheoretical_foundations'>Type-theoretical foundations</a></li>
<ul>
<li><a href='#syntax_of_typetheoretical_foundations'>Syntax of type-theoretical foundations</a></li>
<li><a href='#type_theory_versus_set_theory'>Type theory versus set theory</a></li>
<li><a href='#semantics_of_typetheoretical_foundations'>Semantics of type-theoretical foundations</a></li>
<li><a href='#term_models'>Term models</a></li>
</ul>
<li><a href='#ExtensionalIntensional'>Extensional vs Intensional</a></li>
<ul>
<li><a href='#extensional_and_intensional_function_types'>Extensional and intensional function types</a></li>
<li><a href='#quotient_types_and_exact_completion'>Quotient types and exact completion</a></li>
<li><a href='#identity_types'>Identity types</a></li>
<li><a href='#highercategorical_semantics'>Higher-categorical semantics</a></li>
</ul>
<li><a href='#particular_type_theories'>Particular type theories</a></li>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#References'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>Type theory is a branch of mathematical <a class="existingWikiWord" href="/nlab/show/symbolic+logic">symbolic logic</a>, which derives its name from the fact that it formalizes not only mathematical <a class="existingWikiWord" href="/nlab/show/terms">terms</a> – such as a <a class="existingWikiWord" href="/nlab/show/variable">variable</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, or a <a class="existingWikiWord" href="/nlab/show/function">function</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> – and operations on them, but also formalizes the idea that each such term is of some definite <em><a class="existingWikiWord" href="/nlab/show/type">type</a></em>, for instance that the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> of a <a class="existingWikiWord" href="/nlab/show/natural+number">natural number</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">x : \mathbb{N}</annotation></semantics></math> is different from the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N} \to \mathbb{N}</annotation></semantics></math> of a <a class="existingWikiWord" href="/nlab/show/function">function</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f : \mathbb{N} \to \mathbb{N}</annotation></semantics></math> between natural numbers.</p>

<p>Explicitly, type theory is a formal language, essentially a set of rules for rewriting certain strings of symbols, that describes the <a class="existingWikiWord" href="/nlab/show/introduction+rule">introduction</a> of types and their terms, and computations with these, in a sensible way.</p>

<p>What may seem like a triviality on first sight turns out to have deep implications:</p>

<ol>
<li>
<p><strong>foundations of mathematics</strong>. On the one hand, <a class="existingWikiWord" href="/nlab/show/logic">logic</a> itself is subsumed in the plain idea of operations on terms of types, by observing that any type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> may be thought of as the type of terms satisfying some <a class="existingWikiWord" href="/nlab/show/proposition">proposition</a>. Under this <em><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions are types</a></em>-paradigm a <a class="existingWikiWord" href="/nlab/show/proof">proof</a> of the proposition is nothing but a <a class="existingWikiWord" href="/nlab/show/term">term</a> of the corresponding type. This identification leads to a very fruitful identification of operations on types with logical operations.</p>
</li>

<li>
<p><strong>programming language</strong>. Since such a proof is <a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive</a>, the term witnessing it being a concrete implementation, and since type theory strictly works by rewriting rules, one may identify the construction of a term in type theory as a <em>program</em> whose output is a certain type. Under this <a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>-paradigm, type theory is a mathematical formalization of a <em>programming language</em>. (For instance, <em><a class="existingWikiWord" href="/nlab/show/Coq">Coq</a></em> and <em><a class="existingWikiWord" href="/nlab/show/Agda">Agda</a></em> are concrete machine implementations of such a language. They are used both in computer science, where the typing provides <a class="existingWikiWord" href="/nlab/show/certified+programming">certified programming</a>, and may one day be usable in industry.)</p>
</li>

<li>
<p><strong>calculus for category theory</strong>. On the other hand, if one regards, as is natural, any <a class="existingWikiWord" href="/nlab/show/term">term</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">t : X</annotation></semantics></math> to exist in a <a class="existingWikiWord" href="/nlab/show/context">context</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> of other terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex"> x : \Gamma</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> is naturally identified with a “map” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mi>Γ</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">t : \Gamma \to X</annotation></semantics></math>, hence: with a <em><a class="existingWikiWord" href="/nlab/show/morphism">morphism</a></em>. Viewed this way the <a class="existingWikiWord" href="/nlab/show/types">types</a> and <a class="existingWikiWord" href="/nlab/show/terms">terms</a> of type theory are identified, respectively, with the <a class="existingWikiWord" href="/nlab/show/objects">objects</a> and <a class="existingWikiWord" href="/nlab/show/morphisms">morphisms</a> of <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a>. From this perspective, type theory provides a <a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">formal language for speaking about categories</a>. Indeed, from this perspective type theory is formalization along the lines of the <em><a class="existingWikiWord" href="/nlab/show/ETCS">Elementary Theory of the Category of Sets</a></em>.</p>
</li>
</ol>

<p>These aspects naturally harmonize, involving, reflecting on, and subsuming <a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a> of categories and <a class="existingWikiWord" href="/nlab/show/categorical+logic">categorical logic</a>/<a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a> in categories.</p>

<p>Moreover, when following the idea of type theory through seriously, it turns out to go well beyond these topics even: If all logical statements are to be witnessed by terms of the type that corresponds to the given proposition, then this should notably be true for what is maybe the most basic logical notion, that of <em><a class="existingWikiWord" href="/nlab/show/equality">equality</a></em>. Therefore it makes sense to demand for any two terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x,y : X</annotation></semantics></math> of a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> the existence of an <em><a class="existingWikiWord" href="/nlab/show/identity+type">identity type</a></em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Id</mi> <mi>X</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Id_X(x,y)</annotation></semantics></math> which <a class="existingWikiWord" href="/nlab/show/propositions+as+types">represents</a> the <a class="existingWikiWord" href="/nlab/show/proposition">proposition</a> that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/equality">equal</a> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math>, hence such that a <a class="existingWikiWord" href="/nlab/show/term">term</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><msub><mi>Id</mi> <mi>X</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p : Id_X(x,y)</annotation></semantics></math> is a proof of this fact. But this idea necessarily iterates, with the equality of two such proofs in turn being witnessed by a term of a second order identity type, and so on. Reflecting on this shows that the type-theoretic notion of equality resulting this way is not the traditional one, but is the notion of <em><a class="existingWikiWord" href="/nlab/show/homotopy+equivalence">homotopy equivalence</a></em> or <em><a class="existingWikiWord" href="/nlab/show/equivalence+in+an+%28%E2%88%9E%2C1%29-category">equivalence in an (∞,1)-category</a></em>. Type theory with such <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a> properly implemented is thus called <em><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></em>. It is a calculus now for <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+theory">(∞,1)-category theory</a>. See there for more details on this.</p>

<p>Notice that this is obtained not by adding something to the basic idea of type theory, but by removing something, namely the ad-hoc assumption of definite <a class="existingWikiWord" href="/nlab/show/equality">equality</a>.</p>

<p>Similarly, while plain vanilla type theory formalizes <a class="existingWikiWord" href="/nlab/show/intuitionistic+logic">intuitionistic logic</a>/<a class="existingWikiWord" href="/nlab/show/intuitionistic+mathematics">intuitionistic mathematics</a>, it is possible to add by hand, if necessary for some reason, axioms such as the <a class="existingWikiWord" href="/nlab/show/law+of+excluded+middle">law of excluded middle</a> to make type theory also describe <a class="existingWikiWord" href="/nlab/show/classical+logic">classical logic</a>. But by nature it is more general.</p>

<h2 id="CategoricalSemantics">As a formal language for category theory</h2>

<p>One way to look at type theory, from the point of view of a <a class="existingWikiWord" href="/nlab/show/category+theory">category theorist</a>, is as a <em><a class="existingWikiWord" href="/nlab/show/syntax">syntax</a> for describing the <span class="newWikiWord">construction<a href="/nlab/new/type+constructor">?</a></span> of <a class="existingWikiWord" href="/nlab/show/objects">objects</a> and <a class="existingWikiWord" href="/nlab/show/morphisms">morphisms</a> in a category</em>. (An introduction and historical background is for instance in <a href="#Taylor">Taylor</a> <a href="http://www.paultaylor.eu/ASD/foufct/cattype.html">section 2</a>.)</p>

<p>This interpretation can be called <em><a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></em>. More precisely, categorical semantics refers to an <em><a class="existingWikiWord" href="/nlab/show/adjunction">adjunction</a></em> or <em><a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalence of categories</a></em> between type theories and categories</p>

<p>(<a class="existingWikiWord" href="/nlab/show/category+of+contexts">category of contexts</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊣</mo></mrow><annotation encoding="application/x-tex">\dashv</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/internal+language">internal language</a>) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>:</mo><mo stretchy="false">(</mo><mi>Con</mi><mo>⊣</mo><mi>Lan</mi><mo stretchy="false">)</mo><mo>:</mo><mi>TypeTheories</mi><mover><munder><mo>→</mo><mi>Con</mi></munder><mover><mo>←</mo><mi>Lan</mi></mover></mover><mi>Categories</mi></mrow><annotation encoding="application/x-tex"> :  (Con \dashv Lan) :
  TypeTheories 
    \stackrel{\overset{Lan}{\leftarrow}}{\underset{Con}{\to}}
  Categories 
</annotation></semantics></math>.</p>

<p>This is discussed in detail at <em><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a></em>.</p>

<p>There are many different versions of this adjunction, depending on what kind of type theory we consider (e.g. <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent</a>, with <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a>, etc.) and what structure we impose on the categories in question. In each case</p>

<ul>
<li>
<p>the <a class="existingWikiWord" href="/nlab/show/left+adjoint">left adjoint</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Con</mi></mrow><annotation encoding="application/x-tex">Con</annotation></semantics></math> assigns to a type theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> the <em><a class="existingWikiWord" href="/nlab/show/category+of+contexts">category of contexts</a></em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> (a review is for instance in <a href="#Taylor">Taylor</a> <a href="www.paultaylor.eu/ASD/foufct/cattype.html">section 2.8</a>), which has structure (such as <a class="existingWikiWord" href="/nlab/show/limits">limits</a>, <a class="existingWikiWord" href="/nlab/show/colimits">colimits</a>, etc.) derived from the operations in the type theory,</p>
</li>

<li>
<p>the <a class="existingWikiWord" href="/nlab/show/right+adjoint">right adjoint</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Lan</mi></mrow><annotation encoding="application/x-tex">Lan</annotation></semantics></math> assigns to a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a canonically defined type theory, called its <em><a class="existingWikiWord" href="/nlab/show/internal+language">internal language</a></em> (a review is for instance in <a href="#Taylor99">Taylor 99</a> <a href="http://www.cs.man.ac.uk/~pt/Practical_Foundations/html/s76.html">section 7.6</a>).</p>
</li>
</ul>

<p>A <em><a class="existingWikiWord" href="/nlab/show/model">model</a></em> of a <a class="existingWikiWord" href="/nlab/show/theory">theory</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> in a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is equivalently a <a class="existingWikiWord" href="/nlab/show/functor">functor</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Con</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">Con(T)\to C</annotation></semantics></math> or a morphism of type theories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>→</mo><mi>Lan</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T \to Lan(C)</annotation></semantics></math>. This means that every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> has a tautological model in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Con</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Con(T)</annotation></semantics></math>, and for every category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> there is a tautological model of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Lan</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Lan(C)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. For the category theorist who is most accustomed to think about categories, it is natural to approach type theory by studying the structure of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Lan</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Lan(C)</annotation></semantics></math> and how it is interpreted in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> via this tautological model. We will do this in this section somewhat informally; in the next section we give a more formal definition of type theories.</p>

<p>A couple of side notes for experts:</p>

<ul>
<li>
<p>1-categorical semantics is only relevant to <em><a class="existingWikiWord" href="/nlab/show/extensional+type+theory">extensional</a></em> type theory; see the section on <a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional type theory</a> vs. <a class="existingWikiWord" href="/nlab/show/extensional+type+theory">extensional type theory</a> <a href="#ExtensionalIntensional">below</a>.</p>
</li>

<li>
<p>The description given below is a somewhat simplified one, in that we identify objects of the category with single types, rather than contexts. This is strictly speaking only okay in type theories with a <a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> operation, which allows us to reinterpret every <a class="existingWikiWord" href="/nlab/show/context">context</a> as a single type. An alternative approach which avoids this problem is to use <a class="existingWikiWord" href="/nlab/show/cartesian+multicategories">cartesian multicategories</a>.</p>
</li>
</ul>

<h3 id="TheInternalLanguageOfACategory">The internal language of a category</h3>

<p>Given a <a class="existingWikiWord" href="/nlab/show/category">category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>, we may speak about its <strong>internal language</strong> as a type theory (see e.g. in <a href="#Taylor">Taylor</a>, <a href="http://www.paultaylor.eu/ASD/foufct/cattype.html">section 2.8</a>).</p>

<p>There is a whole page on <a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>, but here our goal is to exhibit it as a particular type theory, to help explain the meaning of type-theoretic notions. The <a class="existingWikiWord" href="/nlab/show/syntax">syntactic</a> constructs corresponding to <a class="existingWikiWord" href="/nlab/show/object">object</a>s and <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a>s are called <em><a class="existingWikiWord" href="/nlab/show/type">type</a>s</em> and <em><a class="existingWikiWord" href="/nlab/show/terms">terms</a></em>, respectively. The types correspond to <a class="existingWikiWord" href="/nlab/show/object">object</a>s (with various subtleties), while the <a class="existingWikiWord" href="/nlab/show/terms">terms</a> denote <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a>s by using <em><a class="existingWikiWord" href="/nlab/show/variables">variables</a></em> to indicate <a class="existingWikiWord" href="/nlab/show/domain">domain</a>s.</p>

<h4 id="types_terms_and_variables">Types, terms, and variables</h4>

<ul>
<li>
<p>In <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a> a <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> with <a class="existingWikiWord" href="/nlab/show/domain">domain</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> and <a class="existingWikiWord" href="/nlab/show/codomain">codomain</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is in symbols</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>B</mi><mover><mo>→</mo><mi>f</mi></mover><mi>A</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">  B \stackrel{f}{\to} A\,. </annotation></semantics></math></div></li>

<li>
<p>In the internal language of the category the same is a <em><a class="existingWikiWord" href="/nlab/show/term">term</a></em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math> of <em><a class="existingWikiWord" href="/nlab/show/type">type</a></em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a <em><a class="existingWikiWord" href="/nlab/show/free+variable">free variable</a></em> of <em>type</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, which in symbols is given by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>B</mi><mo>⊢</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex"> x\colon B \vdash f(x)\colon A\,. </annotation></semantics></math></div></li>
</ul>

<p>We may think of the <em>free variables</em> here as being placeholders for all the <a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a>s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mover><mo>→</mo><mi>x</mi></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">U \stackrel{x}{\to} B</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. Then the assertion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>B</mi><mo>⊢</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x\colon B \vdash f(x)\colon A</annotation></semantics></math> indicates that with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mover><mo>→</mo><mi>f</mi></mover><mi>A</mi></mrow><annotation encoding="application/x-tex">B \stackrel{f}{\to} A</annotation></semantics></math> given we may send <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mover><mo>→</mo><mi>x</mi></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">U \stackrel{x}{\to} B</annotation></semantics></math> to the <a class="existingWikiWord" href="/nlab/show/composition">composition</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>U</mi><mover><mo>→</mo><mi>x</mi></mover><mi>B</mi><mover><mo>→</mo><mi>f</mi></mover><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>U</mi><mover><mo>→</mo><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mover><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(U \stackrel{x}{\to} B \stackrel{f}{\to}A ) = (U \stackrel{f(x)}{\to} A)</annotation></semantics></math>.</p>

<p>So the notation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>B</mi><mo>⊢</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x\colon B \vdash f(x)\colon A</annotation></semantics></math> is a direct reflection of the description of the morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> under the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>↪</mo><mi>Func</mi><mo stretchy="false">(</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C \hookrightarrow Func(C^{op}, Set)</annotation></semantics></math>. Since the Yoneda embedding is a <a class="existingWikiWord" href="/nlab/show/full+and+faithful+functor">full and faithful functor</a>, this is indeed an entirely equivalent characterization of the morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>.</p>

<h4 id="evaluation">Evaluation</h4>

<p>Generally, <a class="existingWikiWord" href="/nlab/show/composition">composition</a> of morphisms in the category</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>C</mi><mover><mo>→</mo><mi>f</mi></mover><mi>B</mi><mover><mo>→</mo><mi>g</mi></mover><mi>A</mi><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mo>=</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mi>C</mi><mover><mo>→</mo><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></mover><mi>A</mi></mrow><annotation encoding="application/x-tex">
  C \stackrel{f}{\to} B \stackrel{g}{\to} A 
  \;\;
  =
  \;\; C \stackrel{g \circ f }{\to} A

</annotation></semantics></math></div>
<p>corresponds to <em>substitution</em> in type theory of a term for a free variable: the morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> are interpreted as terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(y)</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> respectively, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> are variables of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> respectively. The composite morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g\circ f</annotation></semantics></math> is the term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(f(x))</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is again a variable of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>In symbols this is written as:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>⊢</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>B</mi><mspace width="2em"></mspace><mi>y</mi><mo lspace="verythinmathspace">:</mo><mi>B</mi><mo>⊢</mo><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>A</mi></mrow><mrow><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>⊢</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \frac { x\colon C \vdash f(x)\colon B \qquad y\colon B \vdash g(y)\colon A }
         { x\colon C \vdash g(f(x))\colon A } 
</annotation></semantics></math></div>
<p>Here the horizontal bar indicates that we have written down a <em>rule</em>, the rule that the <a class="existingWikiWord" href="/nlab/show/judgement">judgement</a> on the bottom is valid whenever the judgements on the top are valid.</p>

<p>What is an <a class="existingWikiWord" href="/nlab/show/identity+morphism">identity morphism</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mover><mo>→</mo><mrow><mi>f</mi><mo>=</mo><msub><mi>Id</mi> <mi>A</mi></msub></mrow></mover><mi>A</mi></mrow><annotation encoding="application/x-tex">A \stackrel{f = Id_A}{\to} A</annotation></semantics></math> in category theory is a term representing the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = x</annotation></semantics></math> in type theory, namely the variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> itself regarded as a term: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a term of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>

<p>In symbols:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi><mo>⊢</mo><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \frac {}{ x\colon A \vdash x\colon A } </annotation></semantics></math></div>
<h4 id="TypeConstructors">Type constructors</h4>

<p>What sorts of additional syntactical constructions you allow on types and terms corresponds to the structure of the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> in which the <a class="existingWikiWord" href="/nlab/show/semantics">semantics</a> is intended to occur.</p>

<p>For example, if our semantic categories have binary <a class="existingWikiWord" href="/nlab/show/products">products</a>, then the syntax of the type theory includes a <em>type constructor</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math> allowing us to build a new <a class="existingWikiWord" href="/nlab/show/product+type">product type</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math> from two given types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>

<p>It will also have <em>term constructors</em> allowing us to build, for example, a <a class="existingWikiWord" href="/nlab/show/term">term</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a,b\rangle</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math> from any given terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, and to build terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_1(z)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_2(z)</annotation></semantics></math> from any term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math>, with rules that say that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\pi_1\langle a,b\rangle = a</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\pi_2 \langle a,b\rangle = b</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\langle \pi_1(z),\pi_2(z)\rangle = z</annotation></semantics></math>.</p>

<p>Note the great advantage of the type-theoretic formalism: the notation (and thought process) can be very set-theoretic, but because the terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math> can denote morphisms with arbitrary domain (i.e. generalized elements), this really describes the full universal property of a categorical cartesian product.</p>

<h4 id="dependent_types">Dependent types</h4>

<p>An important extension of type theory involves <em><a class="existingWikiWord" href="/nlab/show/dependent+type">dependent type</a>s</em> : types which are a “function” of the <em>elements</em> of some other type. For instance, the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(m)</annotation></semantics></math> of “days of the month” is a function of the element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> of the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> of months, since different months have different allowable collections of days.</p>

<p>In category theory language a <em>type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math> dependent on</em> an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is (again) a <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>C</mi></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo><mpadded width="0"><mi>p</mi></mpadded></mtd></mtr> <mtr><mtd><mi>A</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    C
    \\
    \downarrow\mathrlap{p}
    \\
    A
  } 

</annotation></semantics></math></div>
<p>thought of as an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>-indexed family of objects/types – a <a class="existingWikiWord" href="/nlab/show/bundle">bundle</a> of objects. In type theory language this is written</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">
  x : A \vdash C(x) : Type

</annotation></semantics></math></div>
<p>and read “<em>for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> there is a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math></em>” or “<em>for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> there is a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math></em>.”</p>

<p>Here the variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is again a placeholder for <a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a>s, but now the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> denotes not postcomposition with a morphism, but <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> along a morphism: for every <a class="existingWikiWord" href="/nlab/show/generalized+element">generalized element</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mover><mo>→</mo><mi>x</mi></mover><mi>A</mi></mrow><annotation encoding="application/x-tex">U \stackrel{x}{\to} A</annotation></semantics></math>, we have the <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mo>*</mo></msup><mi>C</mi><mo>:</mo><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x^* C := C(x)</annotation></semantics></math> in</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>C</mi></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><mpadded width="0"><mi>p</mi></mpadded></mtd></mtr> <mtr><mtd><mi>U</mi></mtd> <mtd><mover><mo>→</mo><mi>x</mi></mover></mtd> <mtd><mi>A</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
    C(x) &amp;\to&amp; C
    \\
    \downarrow &amp;&amp; \downarrow\mathrlap{p}
    \\
    U &amp;\stackrel{x}{\to}&amp; A
  }
  \,.

</annotation></semantics></math></div>
<p>This <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math> is the type (relative to the domain of definition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>) that is the “value” of the dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> at the parameter value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> (which also has domain of definition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>).</p>

<p>If we have a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">h : A\to D</annotation></semantics></math> regarded as a term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>h</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>:</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">a:A \vdash h(a):D</annotation></semantics></math> (rather than as a generalized element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>), then the corresponding <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> functor on <a class="existingWikiWord" href="/nlab/show/overcategories">overcategories</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>h</mi> <mo>*</mo></msup><mo>:</mo><mi>𝒞</mi><mo stretchy="false">/</mo><mi>D</mi><mo>→</mo><mi>𝒞</mi><mo stretchy="false">/</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  h^* : \mathcal{C}/D \to \mathcal{C}/A
  \,.

</annotation></semantics></math></div>
<p>represents the “reindexing” or “substitution” operation: a dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>:</mo><mi>D</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">y:D\vdash C(y):Type</annotation></semantics></math> gives rise to a dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">x:A \vdash C(h(x)):Type</annotation></semantics></math>.</p>

<p>Now the <a class="existingWikiWord" href="/nlab/show/left+adjoint">left adjoint</a> of this pullback functor always exists, and is given by postcomposition with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math>. This sends a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">p : C \to A</annotation></semantics></math> (representing a dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">x:A \vdash C(x):Type</annotation></semantics></math>) to the morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mover><mo>→</mo><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mover><mi>D</mi></mrow><annotation encoding="application/x-tex">C  \stackrel{h(p)}{\to} D</annotation></semantics></math>. Now suppose in particular that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>=</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">D = *</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>. Then this operation takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> with all its fibers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math> and regards it as an independent type, i.e. an object of the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>, consisting of the “disjoint union” of all these fibers. In the type theory, this operation is called the <a class="existingWikiWord" href="/nlab/show/dependent+sum">dependent sum</a> and written</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></munder><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  \sum_{x : A} C(x) 

</annotation></semantics></math></div>
<p>This is another <em>type constructor</em> that constructs the new type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{x : A} C(x)</annotation></semantics></math> from the dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x:A\vdash C(x)</annotation></semantics></math>.</p>

<p>Now by the universal property of the <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a>, an element</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>z</mi><mspace width="thickmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></munder><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  z \;:\; \sum_{x : A} C(x)

</annotation></semantics></math></div>
<p>of this sum type, i.e. a morphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>z</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">
  z : U \to C

</annotation></semantics></math></div>
<p>determines a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≔</mo><mi>p</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>U</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x \coloneqq p(z)\colon U\to A</annotation></semantics></math>, i.e. a term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math>, along with a section <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mo>*</mo></msup><mi>C</mi></mrow><annotation encoding="application/x-tex">x^*C</annotation></semantics></math>, i.e. a term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>:</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y:C(x)</annotation></semantics></math>.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>U</mi></mtd> <mtd><mover><mo>→</mo><mi>z</mi></mover></mtd> <mtd><mi>C</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mi>Id</mi></mpadded></msup></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><mpadded width="0"><mi>p</mi></mpadded></mtd></mtr> <mtr><mtd><mi>U</mi></mtd> <mtd><mover><mo>→</mo><mrow><mi>x</mi><mo>:</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>A</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    U &amp;\stackrel{z}{\to}&amp; C
    \\
    \downarrow^{\mathrlap{Id}} &amp;&amp; \downarrow\mathrlap{p}
    \\
    U &amp;\stackrel{x := p(z)}{\to}&amp; A
  }

</annotation></semantics></math></div>
<p>Thus, we can think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C = \sum_{x : A } C(x)</annotation></semantics></math> as the the <em>type of pairs</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x : A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>:</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y : C(x)</annotation></semantics></math>. This is reflected in the type-theoretic rules for the dependent sum.</p>

<p>Similarly, the <a class="existingWikiWord" href="/nlab/show/right+adjoint">right adjoint</a> to the <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> functor is, if it exists, the <em><a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a></em> operation , which sends the dependent type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">p : C \to A</annotation></semantics></math> to the type</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>Π</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  \Pi_{x:A} C(x)

</annotation></semantics></math></div>
<p>regarded as the <em>type of functions</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> such that for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x\in A</annotation></semantics></math>, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)\in B(x)</annotation></semantics></math>. This right adjoint exists in any <a class="existingWikiWord" href="/nlab/show/locally+cartesian+closed+category">locally cartesian closed category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>.</p>

<h3 id="logic_versus_type_theory_in_categorical_semantics">Logic versus type theory in categorical semantics</h3>

<p>How does type theory relate to logic? Well, <em><a class="existingWikiWord" href="/nlab/show/propositional+logic">propositional logic</a></em> is just the type theory whose semantic categories are <em>posets</em>. In this case, the types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>,</mo><mi>Q</mi><mo>,</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">P,Q,\dots</annotation></semantics></math> are usually called <em>propositions</em>, and the existence of a (necessarily unique) term of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math>, having a free variable of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>, is just the assertion that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>≤</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P\le Q</annotation></semantics></math> (or, in more logical language, “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> implies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math>”). The type constructor for binary products is usually written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math> and called “and,” the type constructor for binary coproducts is usually written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\vee</annotation></semantics></math> and called “or,” and so on. The term constructors are generally called <em>inference rules</em>, since they allow us to infer new theorems from old ones.</p>

<p>Now, it turns out that there are (at least) two ways to reconcile propositional logic (the type theory of posets) with type theory of more general categories, producing <a class="existingWikiWord" href="/nlab/show/predicate+logic">predicate logic</a>.</p>

<h4 id="logic_over_type_theory">Logic over type theory</h4>

<p>In the first approach, which can be described as <em>typed predicate logic</em> or <em>logic over type theory</em>, we keep the propositions separate from the types. (Since, as we have seen, propositional logic is a specific kind of type theory, this means we really have two interacting type theories. However, in this case we generally reserve “type” for the second kind of type as distinguished from the “propositions.”)</p>

<p>In this case, the syntax has collections of types and terms, together with constructors, and also rules for forming propositions out of types and terms, and inference rules for forming implications between propositions. The types and terms form the underlying type theory of the logic, and the propositions ‘depend’ on these. For instance, given two terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, we can often form a proposition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x=y</annotation></semantics></math> which asserts that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> are equal. Other important “proposition constructors” are the <a class="existingWikiWord" href="/nlab/show/quantifiers">quantifiers</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∃</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\exists x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\forall x</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable associated to a type (not a proposition). This can concisely be formalized as a <a class="existingWikiWord" href="/nlab/show/pure+type+system">pure type system</a> with one sort for types and another sort for propositions, such that propositions are allowed to depend on types, but not conversely.</p>

<p>The natural home for the semantics of typed predicate logic turns out to be an <em>indexed poset</em>: a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> together with a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Pos</mi></mrow><annotation encoding="application/x-tex">P:C^{op}\to Pos</annotation></semantics></math>. This is often described equivalently as a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> of propositions that is <a class="existingWikiWord" href="/nlab/show/Grothendieck+fibration">fibred over</a> the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> of terms, and whose fibers are posets. (Thus, an alternative way of thinking of propositional logic is as the ‘logic’ of a poset fibred over the trivial one-object category, which corresponds to the fact that the propositions do not contain or depend on typed terms.) The ordinary type theory happens in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> as described above, and a proposition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> with a free variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is interpreted by an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>ϕ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\phi]</annotation></semantics></math> of the poset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math> (the fiber over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>). The prototypical indexed poset is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>:</mo><msup><mi>Set</mi> <mi>op</mi></msup><mo>→</mo><mi>Pos</mi></mrow><annotation encoding="application/x-tex">P:Set^{op}\to Pos</annotation></semantics></math> sending each set to the poset of its <a class="existingWikiWord" href="/nlab/show/subset">subset</a>s, with an evident generalization to <a class="existingWikiWord" href="/nlab/show/subobject">subobject</a>s in any category; thus we think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>ϕ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\phi]</annotation></semantics></math> as “the set of all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x\in A</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math> is true.” Another way of describing this setup is as the <em>subobject fibration</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cod</mi><mo>:</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">cod:Sub(C)\to C</annotation></semantics></math>.</p>

<p>Just as the allowed constructions on types are reflected in the structure of the semantic category, the allowed constructions on propositions here are reflected in the structure of the semantic posets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math>. For instance, if we allow conjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math> of propositions, then each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(A)</annotation></semantics></math> must be a meet-<a class="existingWikiWord" href="/nlab/show/semilattice">semilattice</a>. The action of the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> on morphisms, usually written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mo>*</mo></msup><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^*:P(Y)\to
P(X)</annotation></semantics></math>, is used to model the substitution of the term represented by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> for the variable of a proposition, multiple variables and substitutions being interpreted by means of finite products, as in <a class="existingWikiWord" href="/nlab/show/Lawvere+theory">Lawvere theories</a>. In that case, the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>π</mi> <mo>*</mo></msup><mo>:</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi^*:P(X)\to
P(X\times Y)</annotation></semantics></math> interprets the adding of an unused variable to a context. The left and right <a class="existingWikiWord" href="/nlab/show/adjoint+functor">adjoints</a> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f^*</annotation></semantics></math>, when they exist, describe the semantics of the two quantifiers; thus we write them as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∃</mo> <mi>f</mi></msub><mo>⊣</mo><msup><mi>f</mi> <mo>*</mo></msup><mo>⊣</mo><msub><mo>∀</mo> <mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\exists_f \dashv f^* \dashv \forall_f</annotation></semantics></math>. The functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∃</mo> <mi>π</mi></msub></mrow><annotation encoding="application/x-tex">\exists_\pi</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>π</mi></msub></mrow><annotation encoding="application/x-tex">\forall_\pi</annotation></semantics></math> interpret the traditional existential and universal quantifiers.</p>

<p>The <a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a> of various sorts of categories are most naturally regarded as the typed predicate logic associated to the “poset of subobjects” functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Pos</mi></mrow><annotation encoding="application/x-tex">Sub:C^{op}\to Pos</annotation></semantics></math>, and the requisite levels of structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> induce the required semantic structure on both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi></mrow><annotation encoding="application/x-tex">Sub</annotation></semantics></math>. For instance, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/regular+category">regular</a>, then each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(X)</annotation></semantics></math> is a meet-semilattice and the adjoints <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∃</mo> <mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\exists_f</annotation></semantics></math> exist, while if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/Heyting+category">Heyting category</a>, then each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(X)</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/Heyting+algebra">Heyting algebra</a> and both adjoints <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∃</mo> <mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\exists_f</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\forall_f</annotation></semantics></math> exist. See also <a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>. However, not all indexed posets in which one wants to apply type theory are constructed from subobjects in some category; see for instance <a class="existingWikiWord" href="/nlab/show/tripos">tripos</a>.</p>

<h4 id="propositions_as_types">Propositions as types</h4>

<p>The second approach to reconciling type theory with logic is to blur the distinction between types and propositions; this is called the “<a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>” paradigm. Instead of requiring that a proposition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> be interpreted as merely true or false (that is, a <a class="existingWikiWord" href="/nlab/show/truth+value">truth value</a> or equivalently a <a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a>), we allow it to be interpreted by any set (that is, any object of the semantic category). One way to think of this is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>ϕ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\phi]</annotation></semantics></math> is the set of <em>proofs</em>, or <em>reasons</em>, why <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> is true; it is <a class="existingWikiWord" href="/nlab/show/inhabited+set">inhabited</a> iff <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> is true, but a true statement may have many distinct proofs (although, for technical reasons, this is not the case in naive categorical models of <a class="existingWikiWord" href="/nlab/show/classical+logic">classical logic</a>). Thus, for instance, instead of asserting that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>⇒</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\phi\Rightarrow
\psi</annotation></semantics></math>, we consider the <em>type</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>→</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\phi \to \psi</annotation></semantics></math> of all proofs that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> implies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math>, which is inhabited just when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> actually does imply <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math>. Similarly, the quantifiers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∃</mo></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math> become identified with the dependent type constructors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>.</p>

<p>In this case, the semantics involved is the more general <em>codomain fibration</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><msup><mi>C</mi> <mo>→</mo></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">p:C^\to\to C</annotation></semantics></math>, whose fibres are the <a class="existingWikiWord" href="/nlab/show/slice+categories">slice categories</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">/</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">C/A</annotation></semantics></math>. If we want to take the point of view of “proof irrelevance,” meaning that we only care whether something is true rather than how many proofs it has, then we can think of the semantics as living in the “poset reflections” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pos</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">/</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pos(C/A)</annotation></semantics></math> of these slice categories (in which all parallel morphisms are identified). Note also that the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pos</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">/</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pos(C/A)</annotation></semantics></math> is equivalent to the poset of subobjects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> in the <a class="existingWikiWord" href="/nlab/show/free+exact+completion">free exact completion</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, so this can also be regarded as doing “logic over type theory” with semantics valued in free exact completions.</p>

<h3 id="syntactic_categories_and_free_models">Syntactic categories and free models</h3>

<p>As mentioned above, there are two equivalent ways to describe formally the semantics of a given type theory (possibly with logic) in a category. There is an <a class="existingWikiWord" href="/nlab/show/adjunction">adjunction</a> (which is at least sometimes an <a class="existingWikiWord" href="/nlab/show/equivalence">equivalence</a>):</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>type</mi><mi>theories</mi><mspace width="1em"></mspace><munderover><mo>⇄</mo><mi>Lan</mi><mi>Con</mi></munderover><mspace width="1em"></mspace><mi>categories</mi></mrow><annotation encoding="application/x-tex"> type theories \quad \underoverset{Lan}{Con}{\rightleftarrows} \quad categories </annotation></semantics></math></div>
<p>in which</p>

<ul>
<li>
<p>the right adjoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Lan</mi></mrow><annotation encoding="application/x-tex">Lan</annotation></semantics></math> (sometimes called “semantics”) assigns to a category its <a class="existingWikiWord" href="/nlab/show/internal+logic">internal type theory</a> whose types and terms (and propositions, if present) are the objects and morphisms (and subobjects) of the category, while</p>
</li>

<li>
<p>the left adjoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Con</mi></mrow><annotation encoding="application/x-tex">Con</annotation></semantics></math> (sometimes called “syntax”) builds the <a class="existingWikiWord" href="/nlab/show/context">syntactic category</a> of a type theory, whose objects, morphisms, and subobjects are the types (or contexts), terms, and propositions of the type theory.</p>
</li>
</ul>

<p>Thus, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is a type theory and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a category with corresponding structure, it is equivalent to give a structure-preserving functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Con</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">Con(T) \to C</annotation></semantics></math>, or to give a translation of type theories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>→</mo><mi>Lan</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T\to Lan(C)</annotation></semantics></math>. Either one is called a “model” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. For more details on the construction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Con</mi></mrow><annotation encoding="application/x-tex">Con</annotation></semantics></math>, see <a class="existingWikiWord" href="/nlab/show/syntactic+category">syntactic category</a>, and for more details on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Lan</mi></mrow><annotation encoding="application/x-tex">Lan</annotation></semantics></math>, see <a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>. For a description of the adjunction/equivalence, see <a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a>.</p>

<p>By the way, it should be noted that there are various technical difficulties in making this precise. For instance, categories of any sort form a 2-category (or something more, if they are higher categories themselves), so we have to either make type theories into a 2-category as well, or consider strict categorical structures that form a 1-category. Also, there is a bit of a mismatch in that <em>substitution</em> in type theory is usually “implicit,” which implies that it is strictly associative, but the corresponding categorical operation of <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> is not generally strictly associative. For this reason, various people have defined technical intermediaries between type theories and categories, which mostly boil down to a category equipped with a <a class="existingWikiWord" href="/nlab/show/split+fibration">split fibration</a> replacing its <a class="existingWikiWord" href="/nlab/show/codomain+fibration">codomain fibration</a>. These go by names like <em>comprehension category</em>, <em>category with attributes</em>, or <em>contextual category</em>; see <a class="existingWikiWord" href="/nlab/show/categorical+model+of+dependent+types">categorical model of dependent types</a>.</p>

<h2 id="Syntax">Syntax of type theory</h2>

<p>It’s hard to give a universal definition of “a type theory,” but the following very general setup covers most cases.</p>

<p>Generally, a type theory is formulated by the rules called <em><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></em>, which declare the nature of each kind of type by a 4-step rule:</p>

<ol>
<li>
<p><strong><a class="existingWikiWord" href="/nlab/show/type+formation">type formation</a> rules</strong>, which say on which basis a new <a class="existingWikiWord" href="/nlab/show/type">type</a> can be introduced</p>
</li>

<li>
<p><strong><a class="existingWikiWord" href="/nlab/show/term+introduction">term introduction</a> rules</strong>, which say how that new type can be inhabited by <a class="existingWikiWord" href="/nlab/show/terms">terms</a></p>
</li>

<li>
<p><strong><a class="existingWikiWord" href="/nlab/show/term+elimination">term elimination</a> rules</strong>, which say how from a term of the new type one gets terms of other types</p>
</li>

<li>
<p><strong><a class="existingWikiWord" href="/nlab/show/computation+rules">computation rules</a></strong> which constrain the result of combining term introduction with term elimination.</p>
</li>
</ol>

<p>Note that in general, the following definitions are mutually <a class="existingWikiWord" href="/nlab/show/recursion">recursive</a>.</p>

<ul>
<li>
<p>A <strong>typing declaration</strong> is something of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t:A</annotation></semantics></math>. We say that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> is a <strong>term</strong> (of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>) and that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is the <strong>type</strong>. In some type theories, there is a fixed collection of allowable types, while in others the types are themselves terms belonging to some other type (often called <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math>).</p>
</li>

<li>
<p>A <strong><a class="existingWikiWord" href="/nlab/show/context">context</a></strong> is a list of typing declarations, in which each term is a fresh variable (i.e. one not occurring to the left of its typing declaration). If the list of types is not fixed, then one requires that each type occurring in a context be well-formed relative to the sub-context appearing to its left. In other words, for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma, x:A</annotation></semantics></math> to be a valid context, the <a class="existingWikiWord" href="/nlab/show/judgment">judgment</a> (see below) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash A:Type</annotation></semantics></math> must be derivable.</p>
</li>

<li>
<p>A <strong><a class="existingWikiWord" href="/nlab/show/judgment">judgment</a></strong> or <em><a class="existingWikiWord" href="/nlab/show/hypothetical+judgment">hypothetical judgment</a></em> is symbols of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>𝒥</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash \mathcal{J}</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> is a valid context – a <a class="existingWikiWord" href="/nlab/show/sequent">sequent</a>. Different type theories allow different things in the place of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒥</mi></mrow><annotation encoding="application/x-tex">\mathcal{J}</annotation></semantics></math>, but the most common are <em>typing declarations</em> and <em>equalities</em> between terms of the same type. For example, the judgment</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>N</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>N</mi><mo>⊢</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>:</mo><mi>N</mi></mrow><annotation encoding="application/x-tex"> x:N, y:N \vdash x+y :N </annotation></semantics></math></div>
<p>asserts that any two natural numbers have a sum, which is also a natural number. Similarly,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>N</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>N</mi><mo>,</mo><mi>z</mi><mo>:</mo><mi>N</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>:</mo><mi>N</mi></mrow><annotation encoding="application/x-tex"> x:N, y:N, z:N \vdash (x+y)+z = x+(y+z) :N </annotation></semantics></math></div>
<p>asserts that natural number addition is associative.</p>
</li>

<li>
<p>A <strong>rule</strong> asserts that if some given list of judgments are valid, then so is another one of a specified form derived from them. Of course, to be interesting such rules must contain “meta-variables” which range over contexts, types, or terms. Rules are generally written in the following form:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><msub><mi>Γ</mi> <mn>1</mn></msub><mo>⊢</mo><msub><mi>t</mi> <mn>1</mn></msub><mo>:</mo><msub><mi>A</mi> <mn>1</mn></msub><mspace width="2em"></mspace><mi>…</mi><mspace width="2em"></mspace><msub><mi>Γ</mi> <mi>n</mi></msub><mo>⊢</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>:</mo><msub><mi>A</mi> <mi>n</mi></msub></mrow><mrow><mi>Δ</mi><mo>⊢</mo><mi>s</mi><mo>:</mo><mi>B</mi></mrow></mfrac><mo>.</mo></mrow><annotation encoding="application/x-tex"> \frac{\Gamma_1 \vdash t_1:A_1 \qquad \dots \qquad \Gamma_n \vdash t_n:A_n}{\Delta \vdash s:B}. </annotation></semantics></math></div>
<p>This is to be read as a rule asserting that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Γ</mi> <mn>1</mn></msub><mo>⊢</mo><msub><mi>t</mi> <mn>1</mn></msub><mo>:</mo><msub><mi>A</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\Gamma_1 \vdash t_1:A_1</annotation></semantics></math> through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Γ</mi> <mi>n</mi></msub><mo>⊢</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>:</mo><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\Gamma_n \vdash t_n:A_n</annotation></semantics></math> are valid judgments, then so is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi><mo>⊢</mo><mi>s</mi><mo>:</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Delta \vdash s:B</annotation></semantics></math>.</p>
</li>
</ul>

<p>A given type theory is determined by its collections of types, judgments, and rules. Rules can of course be classified in various ways; here are some of the most common.</p>

<h3 id="structural_rules">Structural rules</h3>

<p>Structural rules say essentially that variables can be substituted, reordered, and ignored in appropriate ways. For instance, there is an “exchange” structural rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>,</mo><mi>Δ</mi><mo>⊢</mo><mo>?</mo></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>Δ</mi><mo>⊢</mo><mo>?</mo></mrow></mfrac><mo>.</mo></mrow><annotation encoding="application/x-tex"> \frac{ \Gamma, x:A, y:B, \Delta \vdash ?}{ \Gamma, y:B, x:A, \Delta \vdash ?}.</annotation></semantics></math></div>
<p>which asserts that variables in the context can be reordered. (In the presence of dependent types, there is a restriction here that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> cannot depend on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>.)</p>

<p>Some type theories, such as <a class="existingWikiWord" href="/nlab/show/linear+type+theory">linear type theory</a> related to <a class="existingWikiWord" href="/nlab/show/linear+logic">linear logic</a>, omit some of the structural rules, but most of the time the structural rules are taken for granted.</p>

<h3 id="typeforming_rules">Type-forming rules</h3>

<p>Most of the most interesting rules involve forming new types. For instance, we may want to assert that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> are types then so is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math>. It may not appear that we have a kind of judgment meaning “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type,” but we can solve this by treating every <em>type</em> as being itself also a <em>term</em> of a type such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math> (which is sometimes written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>*</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math>). Thus, for instance, the product-forming rule is written</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><mi>Type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo>:</mo><mi>Type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>:</mo><mi>Type</mi></mrow></mfrac><mo>.</mo></mrow><annotation encoding="application/x-tex">\frac{\Gamma\vdash A:Type \qquad \Gamma \vdash B:Type}{\Gamma \vdash A\times B:Type}.</annotation></semantics></math></div>
<p>It then comes with attendant rules for forming terms of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math>, such as:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><mi>Type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo>:</mo><mi>Type</mi></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo>⊢</mo><mo stretchy="false">⟨</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">⟩</mo><mo>:</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma\vdash A:Type \qquad \Gamma \vdash B:Type}{\Gamma, x:A, y:B \vdash \langle x,y\rangle : A\times B}</annotation></semantics></math></div>
<p>and for extracting the original terms out, such as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><mi>Type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo>:</mo><mi>Type</mi></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>t</mi><mo>:</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>⊢</mo><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>:</mo><mi>Type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo>:</mo><mi>Type</mi></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>t</mi><mo>:</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>⊢</mo><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma\vdash A:Type \qquad \Gamma \vdash B:Type}{\Gamma, t:A\times B \vdash \pi_1(t):A} \qquad
\frac{\Gamma\vdash A:Type \qquad \Gamma \vdash B:Type}{\Gamma, t:A\times B \vdash \pi_2(t):B}

</annotation></semantics></math></div>
<p>and the obvious rules saying that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">⟨</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\pi_1\langle x,y\rangle = x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">⟨</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">⟩</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\pi_2\langle x,y\rangle = y</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>π</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">⟩</mo><mo>=</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\langle \pi_1(t), \pi_2(t)\rangle = t</annotation></semantics></math>.</p>

<h3 id="universes">Universes</h3>

<p>Of course, this raises the question—what is the type of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math>? We don’t strictly need it to have one—nothing says that everything has to be a term of some type. But it is also sometimes convenient to write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi><mo>=</mo><msub><mi>Type</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">Type = Type_0</annotation></semantics></math> and introduce a hierarchy of additional “universes,” so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Type</mi> <mn>0</mn></msub><mo>:</mo><msub><mi>Type</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Type_0 : Type_1</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Type</mi> <mn>1</mn></msub><mo>:</mo><msub><mi>Type</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Type_1:Type_2</annotation></semantics></math>, and so on. A technique called “universe polymorphism” means that usually we can forget about the indices and just treat “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math>” as a single entity to which everything belongs, unless we do perverse things to try to get paradoxes.</p>

<h3 id="dependent_types_2">Dependent types</h3>

<p>As suggested above, we can have types which depend on terms, and type constructors which apply to these. For instance, we can have a rule of dependent product formation:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>Π</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma, x:A \vdash B(x):Type}{\Gamma \vdash \Pi_{x:A} B(x) : Type}

</annotation></semantics></math></div>
<p>Note that in the case when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is independent of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, this includes a “function type” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\to B</annotation></semantics></math>. Similarly, we have dependent sums <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Σ</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">\Sigma_{x:A} B(x):Type</annotation></semantics></math>, which in the non-dependent case include ordinary products <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math>.</p>

<p>The original dependent type theory was <a class="existingWikiWord" href="/nlab/show/Martin-L%C3%B6f+dependent+type+theory">Martin-Löf dependent type theory</a>.</p>

<h3 id="propositions">Propositions</h3>

<p>As mentioned above, one way to deal with logic over type theory is to represent a proposition simply by a type, regarded as the type of all its proofs, or of all reasons why it is true. A different way is to introduce a separate type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math>, perhaps living at the same “level” as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math>, and allow propositions to depend on types, in the same way that types depend on types. The same sorts of type constructors, but acting on propositions, then implement the logical connectives and quantifiers. For instance, the analogue of dependent product formation becomes a rule of universal quantification:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Prop</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mo>∀</mo> <mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Prop</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma, x:A \vdash B(x):Prop}{\Gamma \vdash \forall_{x:A} B(x) : Prop}

</annotation></semantics></math></div>
<p>and similarly <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> becomes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∃</mo></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math>.</p>

<p>In either case, asserting that a proposition is “true” is the same as asserting that it is <a class="existingWikiWord" href="/nlab/show/inhabited+type">inhabited</a>, i.e. exhibiting a term of that type. Thus, we don’t need to introduce a new kind of judgment for logic; we can continue to use the same sorts of judgments of the form “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> is a term of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>,” only now <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> can be a proposition and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> a proof or reason why <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is true. In particular, the <em>axioms</em> of a logical theory can also be formulated as term-forming rules.</p>

<h3 id="additional_dependencies">Additional dependencies</h3>

<p>It is also possible to have types depending on propositions, propositions depending on propositions, kinds depending on types, etc. etc. See, for instance, <a class="existingWikiWord" href="/nlab/show/pure+type+system">pure type systems</a> and the <a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a>.</p>

<h2 id="typetheoretical_foundations">Type-theoretical foundations</h2>

<p>From a <a class="existingWikiWord" href="/nlab/show/foundations">foundational</a> point of view, type theory can also be regarded as the language in which <a class="existingWikiWord" href="/nlab/show/mathematics">mathematics</a> is written. This has several aspects, notably <em><a class="existingWikiWord" href="/nlab/show/syntax">syntax</a></em> (the language) and <em><a class="existingWikiWord" href="/nlab/show/semantics">semantics</a></em> (what it means).</p>

<h3 id="syntax_of_typetheoretical_foundations">Syntax of type-theoretical foundations</h3>

<p>At the most basic level, what we do when we do mathematics is <em>manipulate symbols according to specified rules</em>. Just as in chess the rules state that a knight moves like <em>so</em> and not like <em>so</em>, in mathematics the rules state that a quantifier can be eliminated like <em>so</em> and not like <em>so</em>. The actual rules of the game of mathematics are extremely complicated, but the idea of foundations is to derive them from a much simpler list of fundamental rules. Type theory says that these fundamental rules are a <em>calculus of terms</em>, and that each term comes equipped with a <em>type</em>. Thus, the rules define one or more <em>types</em>, and one of the judgments one can make (that is, one of the “moves” of the game) is of the form “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> is a well-formed term of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. This corresponds to the syntax described above.</p>

<p>If we include enough type constructors, then we can use type theory as a foundation for much of mathematics. Instead of building mathematical objects out of <a class="existingWikiWord" href="/nlab/show/sets">sets</a> as in foundational set theories such as <a class="existingWikiWord" href="/nlab/show/ZFC">ZFC</a> or <a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a>, we build mathematical objects out of types. The presence of dependent types, with sums and products, is usually quite convenient for this purpose. That is, instead of defining a group to be a set equipped with (among other things) a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>×</mo><mi>G</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">G\times G\to G</annotation></semantics></math>, we could interpret a group as a <em>type</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> equipped with (among other things) a <em>term</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">m(x,y):G</annotation></semantics></math> with free variables <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">x:G</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>:</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">y:G</annotation></semantics></math>.</p>

<h3 id="type_theory_versus_set_theory">Type theory versus set theory</h3>

<p>Alternately, we could change our terminology so that what we have been calling “types” are instead called “sets”. However, in order for this to accord with the common usages of “<a class="existingWikiWord" href="/nlab/show/set">set</a>”, we need to include enough type constructors that our types can mimic the behavior of sets, and in particular be “extensional” and have “<a class="existingWikiWord" href="/nlab/show/quotient+types">quotient types</a>”. See the section on <em><a href="#ExtensionalIntensional">Extensional vs Intensional type theory</a></em>, below.</p>

<p>On the other hand, type theory is, among other things, a convenient language for formulating <a class="existingWikiWord" href="/nlab/show/first+order+logic">first-order logical theories</a>, and among these theories are <a class="existingWikiWord" href="/nlab/show/foundations">foundational</a> set theories such as <a class="existingWikiWord" href="/nlab/show/ZFC">ZFC</a> and <a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a>. For instance, ZFC has two types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math>, proposition-forming rules saying that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">x:Set</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>:</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">y:Set</annotation></semantics></math> then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Prop</mi></mrow><annotation encoding="application/x-tex">(x=y):Prop</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Prop</mi></mrow><annotation encoding="application/x-tex">(x\in y):Prop</annotation></semantics></math>, the usual rules of logical inference and a <a class="existingWikiWord" href="/nlab/show/ZFC">collection of axioms</a>. The same with <a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a>, which it is convenient to write with three types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Function</mi></mrow><annotation encoding="application/x-tex">Function</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math>.</p>

<p>Especially when we intend a theory like ZFC or ETCS as a foundation for all of mathematics, it is convenient to call the type-theoretic language in which these theories are written the “meta-language” or “meta-theory,” while ZFC/ETCS is the “object language” or “object theory.” On the other hand, for a more complex and powerful type theory with many type-constructors, which is suitable to serve as a foundation for mathematics itself, it is natural to say that this type theory is <em>itself</em> the <em>object-theory</em> in a meta-theory having meta-types such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Term</mi></mrow><annotation encoding="application/x-tex">Term</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Judgment</mi></mrow><annotation encoding="application/x-tex">Judgment</annotation></semantics></math>.</p>

<p>Thus, words like “type” and “set” and “class” are really quite fungible. This sort of level-switch is especially important when we want to study the mathematics <em>of</em> type theory, i.e. the mathematical theory of manipulating symbols according to the rules of type theory, analogous to the mathematical theory of moving pieces around on a chessboard according to the usual rules. When we study type theory in this way, we are <em>doing</em> mathematics, just like when we’re doing group theory or ring theory or whatever. It’s just that our objects of study are called “types”, “terms”, and so on. However, what we do in this mathematical theory <em>can</em>, like any other area of mathematics, be formalized in any particular chosen foundation, be it ZFC or ETCS or a type theory at a higher level. Now the type theory is itself the “object-theory” and ZFC is the “meta-theory”!</p>

<p>Here are some blog discussions about the difference between type theory and set theory:</p>

<ul>
<li><a href="http://golem.ph.utexas.edu/category/2009/09/towards_a_computeraided_system.html#c026984">one</a></li>

<li><a href="http://golem.ph.utexas.edu/category/2009/10/syntax_semantics_and_structura.html#c028459">two</a></li>

<li><a href="https://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html">three</a></li>
</ul>

<h3 id="semantics_of_typetheoretical_foundations">Semantics of type-theoretical foundations</h3>

<p>Now, intuitively, we generally think of a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> as denoting some “collection” of “things”, and a term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t:A</annotation></semantics></math> as indicating a “particular one” of those things. In order for this to make sense, the type theory has to exist in some metatheory (which might or might not be formalized) having a notion of “set” to specify the relevant “collections of things”. In particular, there must be a set of types, and for each type there is a set of terms which can be judged to be of that type. The judgment rules for propositions then become the study of formal logic; we say that a proposition is “provable” or is a “theorem” if it can be judged to be true.</p>

<p>Now, a <em>model</em> of this theory (in the category of sets) assigns a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[A]</annotation></semantics></math> (in the meta-theoretic sense) to every type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and a function of appropriate arity to every term, in a way so that the rules and axioms are satisfied. Thus, for instance, a model of Peano arithmetic consists of a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[N]</annotation></semantics></math>, an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>∈</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0]\in [N]</annotation></semantics></math>, a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mo lspace="verythinmathspace">:</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s]\colon [N]\to[N]</annotation></semantics></math>, and so on. Likewise, a model of the type theory of ZFC (here the levels get confusing) consists of a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[Set]</annotation></semantics></math>, a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mo>∈</mo><mo stretchy="false">]</mo><mo lspace="verythinmathspace">:</mo><mo stretchy="false">[</mo><mi>Set</mi><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mi>Set</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>Prop</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[{\in}]\colon [Set]\times [Set] \to [Prop]</annotation></semantics></math>, and so on.</p>

<p>One can then prove, under certain hypotheses, various things about the relationship between syntax and semantics, such as:</p>

<ul>
<li>The <em>Soundness Theorem</em>: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math> is a proposition which is provable from the axioms of a theory, then the corresponding statement <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>φ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\varphi]</annotation></semantics></math> in any model is actually true (in the sense of the metatheory). Equivalently, if a theory has at least one model, then it doesn’t prove a contradiction.</li>

<li>The <em>Completeness Theorem</em>: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>φ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\varphi]</annotation></semantics></math> is true in every model of a theory, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math> is provable in that theory. Equivalently, if a theory doesn’t prove a contradiction, then it has at least one model.</li>

<li>The (first) <em>Incompleteness Theorem</em>: if a theory doesn’t prove a contradiction, then there exist statements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math> such that neither <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math> nor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mi>φ</mi></mrow><annotation encoding="application/x-tex">\not\varphi</annotation></semantics></math> is provable in the theory.</li>

<li>Corollary to the completeness and incompleteness theorems: if a theory doesn’t prove a contradiction, then it has more than one model.</li>
</ul>

<p>The “certain hypotheses” is where we get into the difference between <em>first-order</em> and <em>higher-order</em>. We say that a type theory is <em>higher-order</em> if it involves type constructors such as function-types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>B</mi> <mi>A</mi></msup></mrow><annotation encoding="application/x-tex">B^A</annotation></semantics></math> (intended to represent the “type of all functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\to B</annotation></semantics></math>”) or power-types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">P A</annotation></semantics></math> (intended to represent the “type of all subtypes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>). Otherwise it is <em>first-order</em>. (We have to deal with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> specially in first-order logic. If we actually have a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math>, then the theory should be higher-order, since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi><mo>≅</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">Prop \cong P 1</annotation></semantics></math>; thus in first-order logic we take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> to be a ”kind“ on the same level as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Type</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math>, which doesn’t participate in type operations.) We say ”second-order“ if we never iterate the power-type operation.</p>

<div class="query">
<p>I don't buy your argument that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> must be treated specially; perhaps I don't understand what you're saying, but I'll pretend that I do. First, I don't see the relevance of your premise, that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> makes things higher-order because it is a power type. You might as well say that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> makes things higher-order because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>≅</mo><mi>P</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">1 \cong P 0</annotation></semantics></math>. What really makes things higher order is the ability to form <em>arbitrary</em> power types or function types, not the existence of one or two special cases. And second, I don't agree with the conclusion, that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> can't participate in type operations. It's true that many type theories <em>do</em> treat <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> specially and forbid its participation in type operations, but allowing it to participate in first-order type operations like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math> is not going to make things higher order. Conversely, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi><mo>≅</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Prop \cong 1 + 1</annotation></semantics></math> in some type theories, in which case you can hardly stop it from participating in type operations! —Toby</p>

<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: This seems to be basically a dispute about the meaning of “higher-order”? To me, for something to be first-order, it should be interpretable in a <a class="existingWikiWord" href="/nlab/show/Heyting+category">Heyting category</a>, which does not necessarily have a <a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a> (though it does, as you point out, have a power object for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>). I also expect that the presence of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> as a type is sufficient to make the Completeness Theorem fail, as described in the next paragraph. Probably “participate in type operations” is the wrong claim to be making, rather the claim should be something along the lines of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi></mrow><annotation encoding="application/x-tex">Prop</annotation></semantics></math> being a kind, rather than a type, i.e. we don’t have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi><mo>:</mo><mi>Type</mi></mrow><annotation encoding="application/x-tex">Prop:Type</annotation></semantics></math>, or at least not <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prop</mi><mo>:</mo><msub><mi>Type</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">Prop:Type_0</annotation></semantics></math>.</p>
</div>

<p>The Soundness Theorem is true for all theories, but <em>the Completeness Theorem is true only for first-order theories</em>. The Incompleteness Theorem as stated above is true for higher-order theories, but the corollary fails since the completeness theorem does. In particular, a higher-order theory can sometimes be <em>categorical</em> in the logician’s sense: having exactly one model (at least, up to isomorphism). The second-order version of Peano Arithmetic has this property. (At this level, there is little fundamental difference between first-order and higher-order theories; they each have advantages and disadvantages. However, when we move up to the metalevel and talk about the term calculus itself, we always get a first-order theory. This is why some people believe that first-order logic is the only truly “foundational” logic.)</p>

<h3 id="term_models">Term models</h3>

<p>One usually proves the Completeness Theorem by building a “tautological” model out of the theory itself. That is, for each type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> we simply take the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[A]</annotation></semantics></math> to be the set of terms of type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> with no free variables (or “ground terms”). However, without modification, this naive idea fails for two reasons.</p>

<p>First of all, there might not be enough ground terms. Some of the axioms of the theory might assert that there exists something with some property, without there being a corresponding term constructor actually producing something with that property. This is obviously the case for the usual version of ZFC, which has no term constructors at all (hence no ground terms at all!) but lots of axioms that assert the existence of things. This problem is easily remedied, however, by introducing new constant terms or term constructors into the language.</p>

<p>The second problem is that we may not know how to define all the necessary relations on the ground terms in order to have a model. Suppose, for instance, we have a couple of ground terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math> in some augmented version of ZFC; how can we tell whether <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mn>1</mn></msub><mo>∈</mo><msub><mi>t</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1\in t_2</annotation></semantics></math> should hold in our tautological model? Certainly if the axioms of the theory imply <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mn>1</mn></msub><mo>∈</mo><msub><mi>t</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1\in t_2</annotation></semantics></math>, then it should hold, and if they imply <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mn>1</mn></msub><mo>∉</mo><msub><mi>t</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1\notin t_2</annotation></semantics></math>, then it shouldn’t, but they might not imply either one. The usual way to remedy this is to enumerate all such statements and one by one decide arbitrarily whether to make them true or false in the model we’re constructing.</p>

<p>This works, but the model we get (though small, even countable, and concrete) isn’t really <em>canonical</em>; we had to make a bunch of arbitrary choices. In particular, this means we can’t prove the completeness theorem this way, since the statements true in this model will no longer be <em>precisely</em> those that are derivable in the theory.</p>

<p>In the case of Peano Arithmetic, we can avoid introducing new constant terms and obtain a model which is “canonical” and in fact the “smallest” in some sense: it consists of the terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">(</mo><mi>…</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>…</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(s(\dots(s(0))\dots))</annotation></semantics></math>, which can of course be identified with “the” natural numbers in the meta-theory. But this doesn’t work for most other theories. Suppose, for instance, that we augment ZF with term constructors for all of its existence axioms. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math> be a sentence independent of ZF; then our term-constructor for the <a class="existingWikiWord" href="/nlab/show/axiom+of+separation">axiom of separation</a> gives us a term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>∅</mi><mo stretchy="false">|</mo><mi>φ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\emptyset | \varphi\}</annotation></semantics></math>. Does the relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>∅</mi><mo>∈</mo><mo stretchy="false">{</mo><mi>∅</mi><mo stretchy="false">|</mo><mi>φ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\emptyset \in \{\emptyset | \varphi\}</annotation></semantics></math> hold in the term model? We have to make an arbitrary choice.</p>

<p>(It <em>is</em> true that any <em>given</em> model of ZF contains a <span class="newWikiWord">minimal model<a href="/nlab/new/minimal+model+of+ZF">?</a></span>, i.e. a smallest <a class="existingWikiWord" href="/nlab/show/transitive+set">transitive set</a> which is a model of ZF. However, different models of ZF have different minimal models, and the construction of the minimal model is not “syntactic” in this sense.)</p>

<p>The slicker categorial approach described above using categories of <a class="existingWikiWord" href="/nlab/show/contexts">contexts</a> does produce a really canonical model, but only with an expanded notion of “model”: instead of each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[A]</annotation></semantics></math> being a set, we take it to be an object of some fixed category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒮</mi></mrow><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math> with enough structure. We can then build a much more “tautological” model because we have the freedom to build the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒮</mi></mrow><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math> along with the model. In the resulting model, the true statements are <em>precisely</em> the statements provable in the theory, and it’s even initial among all models of the theory in the appropriate sort of category.</p>

<h2 id="ExtensionalIntensional">Extensional vs Intensional</h2>

<p>There is an important distinction between <em><a class="existingWikiWord" href="/nlab/show/extensional+type+theory">extensional</a></em> type theories and <em><a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional</a></em> ones. The meanings of these words is probably clearest when dealing with function types, such as an exponential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Y^X</annotation></semantics></math>, but also arises in respect to quotient types and identity types.</p>

<h3 id="extensional_and_intensional_function_types">Extensional and intensional function types</h3>

<p>A <a class="existingWikiWord" href="/nlab/show/function+type">function type</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Y^X</annotation></semantics></math> is said to be <strong>extensional</strong> if whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi><mo lspace="verythinmathspace">:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f,g\colon X\to Y</annotation></semantics></math> are functions such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=g(x)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x\in X</annotation></semantics></math>, then in fact <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f=g</annotation></semantics></math> as elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Y^X</annotation></semantics></math>. This clearly corresponds to the modeling of function types by <a class="existingWikiWord" href="/nlab/show/function+sets">function sets</a> in the set-theoretic semantics, or more generally by <a class="existingWikiWord" href="/nlab/show/exponential+objects">exponential objects</a> in the categorical semantics discussed above. The uniqueness clause of the defining assertion of an exponential object, i.e. that any map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo>×</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">Z\times X\to Y</annotation></semantics></math> factors through a <em>unique</em> map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo>→</mo><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Z\to Y^X</annotation></semantics></math>, precisely models this “extensionality” property. Thus, the standard categorical semantics is most closely allied to type theories which have such an “extensionality” axiom.</p>

<p>By contrast, suppose that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> are interpreted by <a class="existingWikiWord" href="/nlab/show/data+types">data types</a> in some <a class="existingWikiWord" href="/nlab/show/programming+language">programming language</a>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Y^X</annotation></semantics></math> is interpreted by some type of computable functions from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Y^X</annotation></semantics></math>. Of course, many differently coded functions can have the same “extensional behavior,” i.e. the same output for any given input, but we may still want to distinguish between these functions because they may not share other properties (such as running time or complexity). Thus, this type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Y^X</annotation></semantics></math> is not extensional—equality of functions, as elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">Y^X</annotation></semantics></math>, is “implementation-sensitive,” a finer measure than mere equality on all inputs. We say instead that these function types are <strong>intensional</strong>.</p>

<p>In type theory, extensional function-types generally come with both a “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-rule,” which specifies the computational behavior of a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\lambda x. t)(y) = t[y/x]</annotation></semantics></math>), and an “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math>-rule,” which specifies that a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction is determined by its behavior (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f = (\lambda x. f(x))</annotation></semantics></math>). In the categorical semantics, the first specifies the existence of factorizations, while the second requires them to be unique. In intensional type theory, we generally keep the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-rule (it is certainly natural from a computational standpoint) but discard the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math>-rule. Thus, one natural sort of semantics for intensional type theory is valued in a category with “weak exponentials,” i.e. objects which satisfy the existence but not uniqueness property of an exponential (and similarly for dependent type theory with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types and weak <a class="existingWikiWord" href="/nlab/show/dependent+product">dependent product</a>s).</p>

<h3 id="quotient_types_and_exact_completion">Quotient types and exact completion</h3>

<p><a class="existingWikiWord" href="/nlab/show/intensional+type+theory">Intensional type theory</a> is also popular among adherents of <a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a> and especially <a class="existingWikiWord" href="/nlab/show/predicative+mathematics">predicative mathematics</a>, because of its computational content. <a class="existingWikiWord" href="/nlab/show/Per+Martin-Lof">Per Martin-Löf</a>‘s original <a class="existingWikiWord" href="/nlab/show/Martin-L%C3%B6f+dependent+type+theory">dependent type theory</a> is often presented from this perspective.</p>

<p>When viewing intensional type theory as a foundation for mathematics (rather than, say, a syntax for reasoning about computer programs), it is natural to view the types as representing <a class="existingWikiWord" href="/nlab/show/presets">presets</a>, rather than sets. This is in line with the classical constructivist viewpoint that “a set is defined by a collection of things together with an equality relation.” Note that in intensional type theory, the “equality” between terms is free to be the “syntactic” equality, which is entirely computable and preserved by everything in sight. In particular, if we adopt the viewpoint of <a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>, then “the axiom of choice is trivially valid” for functions between types (i.e. presets) since to assert that something exists is to give an element of a sum type, which is exactly to give a witness and thereby a way to choose such a thing.</p>

<p>If we then define “sets” to be types equipped with equality relations (sometimes called <a class="existingWikiWord" href="/nlab/show/setoids">setoids</a>), then the sets will have more familiar properties, such as existence of extensional exponentials (obtained by equipping the intensional exponentials with an extensional equality relation), as well as the existence of <a class="existingWikiWord" href="/nlab/show/quotient+sets">quotient sets</a>. (The existence of quotient types is often assumed in extensional type theory, but not in intensional type theory.) In categorical terms, the <a class="existingWikiWord" href="/nlab/show/syntactic+category">syntactic category</a> of an intensional type theory has only weak exponentials (resp. dependent products), but that is sufficient to ensure that its <a class="existingWikiWord" href="/nlab/show/free+exact+completion">free exact completion</a> has actual exponentials (resp. dependent products). Note also that free exact completions always also validate <a class="existingWikiWord" href="/nlab/show/COSHEP">COSHEP</a>, since every object of the starting category (here the category of types) is projective. This matches the above observations about the axiom of choice.</p>

<h3 id="identity_types">Identity types</h3>

<div class="query">
<p>Quick comment: Even in internal type theory, one needs identity types to validate COSHEP. Type theory without identity types is very strange (the category of contexts may not have all pullbacks, and not every morphism need be a display morphism).</p>

<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: I’m not sure that that’s so strange. At least, not to the type theorists. (-: Categorically, I think of display maps as being fibrations in some model-category-type structure, which makes sense to me, although in semantics valued in an honest higher-category I would expect every morphism to be equivalent to a display morphism.</p>

<p>Actually, don’t you need <em>extensional</em> identity types in order to get all pullbacks and make every morphism display? I think intensional identity types just mean that you can factor every morphism through a display morphism which is “equivalent” in some sense, i.e. you have the <span class="newWikiWord">identity type weak factorization system<a href="/nlab/new/identity+type+weak+factorization+system">?</a></span>.</p>

<p>And I didn’t know that about COSHEP, why is that? Isn’t it true that all types are projective, at least in the propositions-as-types logic, since to assert that something exists is to give a construction of it? Or are you saying that you need identity types in order to even construct the category of setoids, since you need the category of types to have at least weak finite limits?</p>

<p><em>Toby</em>: I mean that you need identity types in order to have the free functor from presets to sets that allows every type (preset) to be interpreted as a set. So every set is a quotient (in a sense) of a preset, and every preset is projective (in a sense), but it's not a projective <em>set</em>. We merely have that the free set on that preset is projective <em>if</em> it exists.</p>

<p>I really meant to work out a clean example of such a type theory on <a href="tobybartels:HomePage">my personal web</a>, but I never did (so you don't need to look there).</p>

<p>PS: You're right about the display maps; that part's not so strange. Maybe it's not strange at all, but Martin-Löf (at least) considers identity types indispensible (and they are, in his framework, for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math>-types to work).</p>
</div>

<p>(to be written…)</p>

<p>Relation between <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a> and <a class="existingWikiWord" href="/nlab/show/path+space+objects">path space objects</a> in a <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">category with weak equivalences</a>.</p>

<h3 id="highercategorical_semantics">Higher-categorical semantics</h3>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></li>
</ul>

<p>(to be written…)</p>

<h2 id="particular_type_theories">Particular type theories</h2>

<p>The following particular type theories are important enough to (potentially) have pages of their own.</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/simple+type+theory">simple type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/simply+typed+lambda+calculus">simply typed lambda calculus</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Martin-Lof+dependent+type+theory">Martin-Löf dependent type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/pure+type+system">pure type system</a></p>
</li>

<li>
<p>the <a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a></p>
</li>

<li>
<p>the <a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a> of various kinds of categories, including the <a class="existingWikiWord" href="/nlab/show/Mitchell-Benabou+language">Mitchell-Benabou language</a> of an <a class="existingWikiWord" href="/nlab/show/elementary+topos">elementary topos</a></p>
</li>

<li>
<p>the <span class="newWikiWord">internal logic of a (2,1)-topos<a href="/nlab/new/internal+logic+of+a+%282%2C1%29-topos">?</a></span></p>
</li>

<li>
<p>the <a class="existingWikiWord" href="/nlab/show/internal+logic+of+an+%28%E2%88%9E%2C1%29-topos">internal logic of an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cubical+type+theory">cubical type theory</a></p>
</li>
</ul>

<h2 id="related_concepts">Related concepts</h2>

<ul>
<li>
<p><strong>type theory</strong>, <a class="existingWikiWord" href="/nlab/show/logic">logic</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/logical+framework">logical framework</a>, <a class="existingWikiWord" href="/nlab/show/meaning+explanation">meaning explanation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a>, <a class="existingWikiWord" href="/nlab/show/calculus+of+constructions">calculus of constructions</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a>, <a class="existingWikiWord" href="/nlab/show/Martin-L%C3%B6f+dependent+type+theory">Martin-Löf dependent type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/intensional+type+theory">intensional type theory</a>, <a class="existingWikiWord" href="/nlab/show/extensional+type+theory">extensional type theory</a>, <a class="existingWikiWord" href="/nlab/show/observational+type+theory">observational type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+checking">type checking</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/calculus+of+inductive+constructions">calculus of inductive constructions</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/initiality+conjecture">initiality conjecture</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/modal+type+theory">modal type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computational+type+theory">computational type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+type+theory">geometric type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/linear+type+theory">linear type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/two-level+type+theory">two-level type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+form">canonical form</a>, <a class="existingWikiWord" href="/nlab/show/normal+form">normal form</a>, <a class="existingWikiWord" href="/nlab/show/beta-reduction">beta-reduction</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>, <a class="existingWikiWord" href="/nlab/show/predicative+topos">predicative topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/coercion">coercion</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/intrinsic+and+extrinsic+views+of+typing">intrinsic and extrinsic views of typing</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/bidirectional+typechecking">bidirectional typechecking</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relation+between+category+theory+and+type+theory">relation between category theory and type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+topology">relation between type theory and topology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-type+theory">2-type theory</a>, <a class="existingWikiWord" href="/nlab/show/2-logic">2-logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-type+theory">(∞,1)-type theory</a>, <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-logic">(∞,1)-logic</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/directed+homotopy+type+theory">directed homotopy type theory</a></p>

<p><a class="existingWikiWord" href="/nlab/show/opetopic+type+theory">opetopic type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computer+science">computer science</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/data+type">data type</a></li>
</ul>
</li>
</ul>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/type">type</a></strong>, <a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>, <a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/W-type">W-type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/empty+type">empty type</a>, <a class="existingWikiWord" href="/nlab/show/unit+type">unit type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/pointed+type">pointed type</a></p>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/dependent+type">dependent type</a></strong>, <a class="existingWikiWord" href="/nlab/show/dependent+type+theory">dependent type theory</a>, <a class="existingWikiWord" href="/nlab/show/Martin-L%C3%B6f+dependent+type+theory">Martin-Löf dependent type theory</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/dependent+sum+type">dependent sum type</a>, <a class="existingWikiWord" href="/nlab/show/dependent+product+type">dependent product type</a></li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></strong>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/identity+type">identity type</a>, <a class="existingWikiWord" href="/nlab/show/dependent+identity+type">dependent identity type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+n-type">homotopy n-type</a>, <a class="existingWikiWord" href="/nlab/show/connected+type">connected type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+homotopy+type">geometric homotopy type</a>, <a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+type">cohesive homotopy type</a></p>
</li>
</ul>
</div>
<h2 id="References">References</h2>

<p>The concept of typing in the <a class="existingWikiWord" href="/nlab/show/foundations+of+mathematics">foundations of mathematics</a> is implicit in <a class="existingWikiWord" href="/nlab/show/Gottlob+Frege">Gottlob Frege</a>‘s work and, inspired by that, appears explicitly for the first time in</p>

<ul>
<li id="Russell03"><a class="existingWikiWord" href="/nlab/show/Bertrand+Russell">Bertrand Russell</a>, appendix of <em><a href="http://en.wikipedia.org/wiki/The_Principles_of_Mathematics">The principles of mathematics</a></em> 1903 (<a href="http://fair-use.org/bertrand-russell/the-principles-of-mathematics/appendix-b">online</a>)</li>
</ul>

<p>where it has the famous passage</p>

<blockquote>
<p>Every propositional function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math> — so it is contended - has, in addition to its range of truth, a range of significance, i.e. a range in which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> must lie if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math> is to be a proposition at all, whether true or false. This is the first point in the theory of types; the second point is that ranges of significance form types, i.e. if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> belongs to the range of significance of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math>, then there is a class of objects, the type of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, all of which must also belong to the range of significance of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math>, however <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> may be varied;</p>
</blockquote>

<p>Also</p>

<ul>
<li id="RussellWhitehead10"><a class="existingWikiWord" href="/nlab/show/Bertrand+Russell">Bertrand Russell</a>, <a class="existingWikiWord" href="/nlab/show/Alfred+Whitehead">Alfred Whitehead</a>, <em><a class="existingWikiWord" href="/nlab/show/Principia+Mathematica">Principia Mathematica</a></em>, 1910</li>
</ul>

<p>and later work by Russell, where it is used to prevent <a class="existingWikiWord" href="/nlab/show/paradoxes">paradoxes</a> of <a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a> such as the <a class="existingWikiWord" href="/nlab/show/liar%27s+paradox">liar's paradox</a> (via a “<a class="existingWikiWord" href="/nlab/show/ramified+type">ramified hierarchy</a>” of types) and <a class="existingWikiWord" href="/nlab/show/Russell%27s+paradox">Russell's paradox</a> (via an “extensional hierarchy” of types). This then evolved into the “<a class="existingWikiWord" href="/nlab/show/simple+type+theory">simple type theory</a>”:</p>

<ul>
<li id="Russell08">
<p><a class="existingWikiWord" href="/nlab/show/Bertrand+Russell">Bertrand Russell</a>, <em>Mathematical Logic as Based on the Theory of Types</em>, American Journal of Mathematics, Vol. 30, No. 3 (Jul., 1908), pp. 222-262</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Alonzo+Church">Alonzo Church</a>, <em>A Formulation of the Simple Theory of Types</em>, The Journal of Symbolic Logic Vol. 5, No. 2 (Jun., 1940), pp. 56-68 (<a href="http://www.jstor.org/stable/2266170?seq=1#page_scan_tab_contents">JSTOR</a>)</p>
</li>
</ul>

<p>This is reviewed for instance in</p>

<ul>
<li>Jean van Heijenoort, <em>From Frege to Gödel</em>, A Source Book in Mathematical Logic, 1879-1931</li>
</ul>

<p>The introduction of <a class="existingWikiWord" href="/nlab/show/identity+types">identity types</a> in “intuitionistic type theory” is due to</p>

<ul>
<li id="MartinLoef75">
<p><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a>, §1.7 in: <em>An intuitionistic theory of types: predicative part</em>, in: H. E. Rose, J. C. Shepherdson (eds.), <em>Logic Colloquium ‘73, Proceedings of the Logic Colloquium</em>, Studies in Logic and the Foundations of Mathematics <strong>80</strong> Pages 73-118, Elsevier 1975 (<a href="https://doi.org/10.1016/S0049-237X(08)71945-1">doi:10.1016/S0049-237X(08)71945-1</a>, <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.926">CiteSeer</a>)</p>
</li>

<li>
<p>Bengt Nordström, Kent Petersson, Jan M. Smith, §8.1 of: <em>Programming in Martin-Löf’s Type Theory</em>, Oxford University Press (1990) &lbrack;<a href="https://www.cse.chalmers.se/research/group/logic/book/">webpage</a>, <a href="https://www.cse.chalmers.se/research/group/logic/book/book.pdf">pdf</a>, <a class="existingWikiWord" href="/nlab/files/NordstromPeterssonSmith-TypeTheory.pdf" title="pdf">pdf</a>&rbrack;</p>
</li>
</ul>

<p>The development of that to <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> followed insights by (<a href="#HofmannStreicher98">Hofmann-Streicher 98</a>) and others and was laid out in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Univalent+Foundations+Project">Univalent Foundations Project</a>, <em><a class="existingWikiWord" href="/nlab/show/Homotopy+Type+Theory+--+Univalent+Foundations+of+Mathematics">Homotopy Type Theory – Univalent Foundations of Mathematics</a></em>, 2013</li>
</ul>

<p>Survey of the history of type theoryL</p>

<ul>
<li>
<p>Stanford Encyclopedia of Philosophy, <em><a href="http://plato.stanford.edu/entries/type-theory/">Type theory</a></em></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Harley+Eades">Harley Eades</a>, <em>Type Theory and Applications</em>, 2012 (<a href="https://metatheorem.org/includes/pubs/comp.pdf">pdf</a>, <a class="existingWikiWord" href="/nlab/files/EadesTypeTheoryAndApplications.pdf" title="pdf">pdf</a>)</p>
</li>
</ul>

<p>Of course there is also discussion of formalized <a class="existingWikiWord" href="/nlab/show/types">types</a> originating in <a class="existingWikiWord" href="/nlab/show/computer+science">computer science</a> as <em><a class="existingWikiWord" href="/nlab/show/data+types">data types</a></em>, see there for references.</p>

<ul>
<li>Leon Chwistek, The Theory of Constructive Types: Principles of Logic and Mathematics, Krakow: University Press, 1925, 98 pp. Extracted from the Annales de la Société Polonaise de Mathématique. (In DjVu format) <a href="http://www.monoskop.org/Leon_Chwistek">Linked from this page, under Bibliography, On logic and mathematics.</a></li>
</ul>

<p>Surveys of and introductions to type theory include</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a>, <em>Intuitionistic type theory</em>, Studies in Proof Theory 1, Bibliopolis, Naples, 1984 (<a href="http://intuitionistic.files.wordpress.com/2010/07/martin-lof-tt.pdf">pdf</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Thomas+Streicher">Thomas Streicher</a>, <em>Investigations into intensional type theory</em>, habilitation 2003, <a href="http://www.mathematik.tu-darmstadt.de/~streicher/HabilStreicher.pdf">pdf</a>;</p>
</li>

<li id="MartinLoef96">
<p><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a>, <em>On the Meanings of the Logical Constants and the Justifications of the Logical Laws</em>, Nordic Journal of Philosophical Logic, 1(1): 11–60, 1996, (<a href="http://docenti.lett.unisi.it/files/4/1/1/6/martinlof4.pdf">pdf</a>, <a class="existingWikiWord" href="/nlab/files/MartinLofOnTheMeaning96.pdf" title="pdf">pdf</a>)</p>
</li>

<li>
<p>Rober Constable, <em>The Triumph of Types: Creating a Logic of Computational Reality</em> (<a class="existingWikiWord" href="/nlab/files/ConstableTriumphOfTypes.pdf" title="pdf">pdf</a>)</p>
</li>

<li>
<p>Herman Geuvers, <em>Introduction to type theory</em>, Lecture notes 2008 (<a href="http://www.cs.ru.nl/~herman/PUBS/IntroTT-improved.pdf">pdf</a>)</p>
</li>

<li>
<p>N. G. de Bruijn, <em>On the roles of types in mathematics</em>, Cahier du Centre de Logique (vol 8) (<a href="http://alexandria.tue.nl/repository/freearticles/597627.pdf">pdf</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bart+Jacobs">Bart Jacobs</a>, <em>Categorical Logic and Type Theory</em>, Studies in Logic and the Foundations of Mathematics 141, North Holland, Elsevier (1999)</p>

<p><em>Categorical Type Theory</em> PhD. Thesis, University of Nijmegen (1991) (<a href="http://www.cs.ru.nl/B.Jacobs/PAPERS/PhD.ps">ps</a> <a class="existingWikiWord" href="/nlab/files/JacobsCategoricalTypeTheory.pdf" title="pdf">pdf</a>)</p>
</li>

<li id="Bauer17">
<p><a class="existingWikiWord" href="/nlab/show/Andrej+Bauer">Andrej Bauer</a>, <em>Spartan Type Theory</em>, UniMath School, 2017 (<a href="http://math.andrej.com/wp-content/uploads/2017/12/Spartan-Type-Theory.pdf">pdf</a>)</p>
</li>

<li>
<p>wikipedia: <em><a href="http://en.wikipedia.org/wiki/Type_theory">type theory</a></em>, <em><a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory">intuitionistic type theory</a></em>, <a href="http://en.wikipedia.org/wiki/Typed_lambda_calculus">typed lambda calculus</a>, <a href="http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard correspondence</a>, <a href="http://en.wikipedia.org/wiki/Per_Martin-L&amp;#246;f">Per Martin-Löf</a></p>
</li>
</ul>

<p>Textbook accounts in from the point of view of <a class="existingWikiWord" href="/nlab/show/programming+languages">programming languages</a> include</p>

<ul>
<li>
<p>Bengt Nordström, Kent Petersson Jan M. Smith, <em>Programming in Martin-Löf’s type theory</em>, Oxford University Press 1990 (<a href="http://www.cse.chalmers.se/research/group/logic/book/book.pdf">pdf</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Robert+Harper">Robert Harper</a>, <em><a class="existingWikiWord" href="/nlab/show/Practical+Foundations+for+Programming+Languages">Practical Foundations for Programming Languages</a></em></p>
</li>
</ul>

<p>Further discussion of type theory in the context of (<a class="existingWikiWord" href="/nlab/show/functional+programming">functional</a>) <a class="existingWikiWord" href="/nlab/show/programming+languages">programming languages</a>:</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Simon+Thompson">Simon Thompson</a>, <em><a class="existingWikiWord" href="/nlab/show/Type+Theory+and+Functional+Programming">Type Theory and Functional Programming</a></em>, Addison-Wesley (1991) &lbrack;ISBN:0-201-41667-0, <a href="http://www.cs.kent.ac.uk/people/staff/sjt/TTFP">webpage</a>, <a href="http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf">pdf</a>&rbrack;</p>
</li>

<li id="Girard89">
<p><a class="existingWikiWord" href="/nlab/show/Jean-Yves+Girard">Jean-Yves Girard</a> (translated and with appendiced by <a class="existingWikiWord" href="/nlab/show/Paul+Taylor">Paul Taylor</a> and <a class="existingWikiWord" href="/nlab/show/Yves+Lafont">Yves Lafont</a>), <em>Proofs and Types</em>, Cambridge University Press (1989) &lbrack;<a href="">ISBN:978-0-521-37181-0</a>, <a href="http://www.paultaylor.eu/stable/Proofs+Types.html">webpage</a>, <a href="https://www.paultaylor.eu/stable/prot.pdf">pdf</a>&rbrack;</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Benjamin+Pierce">Benjamin Pierce</a>, <em>Types and Programming Languages</em>, <a href="http://www.cis.upenn.edu/~bcpierce/tapl/index.html">book page</a></p>
</li>
</ul>

<p>Discussion aimed at <a class="existingWikiWord" href="/nlab/show/foundations">foundations</a> include</p>

<ul>
<li id="Taylor99">
<p><a class="existingWikiWord" href="/nlab/show/Paul+Taylor">Paul Taylor</a>, <em><a class="existingWikiWord" href="/nlab/show/Practical+Foundations+of+Mathematics">Practical Foundations of Mathematics</a></em>, Number 59 in Cambridge Studies in Advanced Mathematics. Cambridge University Press (1999) (<a href="http://www.cs.man.ac.uk/~pt/Practical_Foundations/html/">webpage</a>)</p>
</li>

<li id="Taylor">
<p><a class="existingWikiWord" href="/nlab/show/Paul+Taylor">Paul Taylor</a>, <em>Foundations for computable topology</em> (<a href="http://www.paultaylor.eu/ASD/foufct/abstract.html">web</a>)</p>
</li>
</ul>

<p>Work leading up to <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> includes</p>

<ul>
<li id="HofmannStreicher98">
<p><a class="existingWikiWord" href="/nlab/show/Martin+Hofmann">Martin Hofmann</a>, <a class="existingWikiWord" href="/nlab/show/Thomas+Streicher">Thomas Streicher</a> <em>The groupoid interpretation of type theory</em>, in: <a class="existingWikiWord" href="/nlab/show/Giovanni+Sambin">Giovanni Sambin</a> et al. (eds.), <em>Twenty-five years of constructive type theory</em>, Proceedings of a congress, Venice, Italy, October 19—21, 1995. Oxford: Clarendon Press. Oxf. Logic Guides. 36, 83-111 (1998). (<a href="https://global.oup.com/academic/product/twenty-five-years-of-constructive-type-theory-9780198501275">ISBN:9780198501275</a>, <a href="http://www.mathematik.tu-darmstadt.de/~streicher/venedig.ps.gz">ps</a>,<a class="existingWikiWord" href="/nlab/files/HofmannStreicherGroupoidInterpretation.pdf" title="pdf">pdf</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Thomas+Streicher">Thomas Streicher</a>, <em>Identity Types and Weak Omega-Groupoids</em> 2006 <a href="http://www.mathematik.tu-darmstadt.de/~streicher/TALKS/uppsala.pdf.gz">pdf.gz</a></p>
</li>
</ul>

<p>Formalization of parts of <a class="existingWikiWord" href="/nlab/show/mathematics">mathematics</a> in type theory is discussed in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Thierry+Coquand">Thierry Coquand</a>, <em><a href="http://wiki.portal.chalmers.se/cse/pmwiki.php/ForMath/ForMath">ForMath</a></em></li>
</ul>

<p>for <a class="existingWikiWord" href="/nlab/show/homological+algebra">homological algebra</a>:</p>

<ul>
<li id="CoquandSpiwack"><a class="existingWikiWord" href="/nlab/show/Thierry+Coquand">Thierry Coquand</a>, <a class="existingWikiWord" href="/nlab/show/Arnaud+Spiwack">Arnaud Spiwack</a>, <em>Towards constructive homological algebra in type theory</em> (<a href="http://assert-false.net/arnaud/papers/Towards%20constructive%20homological%20algebra%20in%20type%20theory.pdf">pdf</a>)</li>
</ul>

<p>Thoughts about type theory and <a class="existingWikiWord" href="/nlab/show/metaphysics">metaphysics</a> are in</p>

<ul>
<li id="MartinLoef90"><a class="existingWikiWord" href="/nlab/show/Per+Martin-L%C3%B6f">Per Martin-Löf</a>, <em>A path from logic to metaphysics</em>, talk at <em>Nuovi problemi della logica e della filosofia della scienza</em>, Jan 1990 (<a href="http://archive-pml.github.io/martin-lof/pdfs/A-path-from-logic-to-metaphysics-1991.pdf">pdf</a>)</li>
</ul>

<p>For a type theory suitable for non-cartesian monoidal categories see</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Michael+Shulman">Michael Shulman</a>, <em>A practical type theory for symmetric monoidal categories</em>, (<a href="https://arxiv.org/abs/1911.00818">arXiv:1911.00818</a>)</li>
</ul>

<p>Further online resources include</p>

<ul>
<li>
<p>Type theory summer school Göteborg 2005, (<a href="http://www.cse.chalmers.se/research/group/logic/TypesSS05/program.html">materials</a>)</p>
</li>

<li>
<p><a href="http://mathoverflow.net/questions/tagged/type-theory">type-theory questions</a> on MathOverflow</p>
</li>

<li>
<p><a href="http://cstheory.stackexchange.com/questions/tagged/type-theory">type-theory questions</a> on CS StackExchange</p>
</li>

<li>
<p><a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list">types mailing list</a></p>
</li>

<li>
<p><a href="http://lists.seas.upenn.edu/mailman/listinfo/types-announce">types-announce mailing list</a></p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on September 25, 2022 at 13:55:40.
    See the <a href="/nlab/history/type+theory" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/type+theory" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/271/#Item_94">Discuss</a><span class="backintime"><a href="/nlab/revision/type+theory/130" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/type+theory" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/type+theory" accesskey="S" class="navlink" id="history" rel="nofollow">History (130 revisions)</a>
  <a href="/nlab/show/type+theory/cite" style="color: black">Cite</a>
  <a href="/nlab/print/type+theory" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/type+theory" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
