
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      Trimble on ETCS III in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      Trimble on ETCS III
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/10491/#Item_1" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>ETCS : Building joins and coproducts</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="foundations">Foundations</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundations">foundations</a></strong></p>

<h2 id="the_basis_of_it_all">The basis of it all</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/mathematical+logic">mathematical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/first-order+logic">first-order logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/universe">universe</a></p>
</li>
</ul>

<h2 id="set_theory"> Set theory</h2>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a></strong></p>

<ul>
<li>presentations of set theory
<ul>
<li><a class="existingWikiWord" href="/nlab/show/unsorted+set+theory">unsorted set theory</a></li>

<li><a class="existingWikiWord" href="/nlab/show/two-sorted+set+theory">two-sorted set theory</a></li>

<li><a class="existingWikiWord" href="/nlab/show/dependently+sorted+set+theory">dependently sorted set theory</a></li>

<li><a class="existingWikiWord" href="/nlab/show/structurally+presented+set+theory">structurally presented set theory</a></li>
</ul>
</li>

<li>structuralism in set theory
<ul>
<li><a class="existingWikiWord" href="/nlab/show/material+set+theory">material set theory</a>
<ul>
<li><a class="existingWikiWord" href="/nlab/show/ZFC">ZFC</a></li>

<li><a class="existingWikiWord" href="/nlab/show/ZFA">ZFA</a></li>

<li><a class="existingWikiWord" href="/nlab/show/New+Foundations">New Foundations</a></li>
</ul>
</li>

<li><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural set theory</a>
<ul>
<li><a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a>
<ul>
<li><a class="existingWikiWord" href="/nlab/show/fully+formal+ETCS">fully formal ETCS</a></li>

<li><a class="existingWikiWord" href="/nlab/show/ETCS+with+elements">ETCS with elements</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+I">Trimble on ETCS I</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+II">Trimble on ETCS II</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+III">Trimble on ETCS III</a></li>
</ul>
</li>

<li><a class="existingWikiWord" href="/nlab/show/SEAR">SEAR</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="foundational_axioms">Foundational axioms</h2>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundational+axiom">foundational axiom</a></strong></p>

<ul>
<li>
<p>basic constructions:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+cartesian+products">axiom of cartesian products</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+disjoint+unions">axiom of disjoint unions</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+the+empty+set">axiom of the empty set</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+fullness">axiom of fullness</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+function+sets">axiom of function sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+power+sets">axiom of power sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+quotient+sets">axiom of quotient sets</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/material+set+theory">material axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+extensionality">axiom of extensionality</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+foundation">axiom of foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+anti-foundation">axiom of anti-foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Mostowski%27s+axiom">Mostowski's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+pairing">axiom of pairing</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+transitive+closure">axiom of transitive closure</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+union">axiom of union</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+materialization">axiom of materialization</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theoretic axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+K">axiom K</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+UIP">axiom UIP</a></li>

<li><a class="existingWikiWord" href="/nlab/show/univalence+axiom">univalence axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Whitehead%27s+principle">Whitehead's principle</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/axioms+of+choice">axioms of choice</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+countable+choice">axiom of countable choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+dependent+choice">axiom of dependent choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+excluded+middle">axiom of excluded middle</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+existence">axiom of existence</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+multiple+choice">axiom of multiple choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Markov%27s+axiom">Markov's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/presentation+axiom">presentation axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/small+cardinality+selection+axiom">small cardinality selection axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+small+violations+of+choice">axiom of small violations of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+weakly+initial+sets+of+covers">axiom of weakly initial sets of covers</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/large+cardinal+axioms">large cardinal axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+infinity">axiom of infinity</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+universes">axiom of universes</a></li>

<li><a class="existingWikiWord" href="/nlab/show/regular+extension+axiom">regular extension axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/inaccessible+cardinal">inaccessible cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/measurable+cardinal">measurable cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/elementary+embedding">elementary embedding</a></li>

<li><a class="existingWikiWord" href="/nlab/show/supercompact+cardinal">supercompact cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Vop%C4%9Bnka%27s+principle">Vopěnka's principle</a></li>
</ul>
</li>

<li>
<p>strong axioms</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+separation">axiom of separation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+replacement">axiom of replacement</a></li>
</ul>
</li>

<li>
<p>further</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/reflection+principle">reflection principle</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="removing_axioms">Removing axioms</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a></li>

<li><a class="existingWikiWord" href="/nlab/show/predicative+mathematics">predicative mathematics</a></li>
</ul>
<div>
<p>
  <a href="/nlab/edit/foundations+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<p><em>This is Part III of an exposition by <a class="existingWikiWord" href="/nlab/show/Todd+Trimble">Todd Trimble</a> on <a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a></em>.</p>

<p>See also</p>

<ul>
<li>
<p>Part I. <a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+I">ZFC and ETCS</a></p>
</li>

<li>
<p>Part II. <a class="existingWikiWord" href="/nlab/show/Trimble+on+ETCS+II">ETCS: Internalizing the logic</a></p>
</li>
</ul>
<hr />
<h2 id="etcs__building_joins_and_coproducts">ETCS : Building joins and coproducts</h2>

<p>After a long hiatus, I’d like to renew the discussion of axiomatic categorical set theory, more specifically the Elementary Theory of the Category of Sets (<a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a>). <a href="http://topologicalmusings.wordpress.com/2008/09/10/etcs-internalizing-the-logic">Last time</a> I blogged about this, I made some initial forays into “internalizing logic” in <a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a>, and described in broad brushstrokes how to use that internal logic to derive a certain amount of the structure one associates with a category of sets. Today I’d like to begin applying some of the results obtained there to the problem of constructing <em>colimits</em> in a category satisfying the ETCS axioms (an <em><a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a> category</em>, for short).</p>

<p>(If you’re just joining us now, and you already know some of the jargon, an <em><a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a> category</em> is a well-pointed topos that satisfies the axiom of choice and with a natural numbers object. We are trying to build up some of the elementary theory of such categories from scratch, with a view toward foundations of mathematics.)</p>

<p>But let’s see — where were we? Since it’s been a while, I was tempted to review the philosophy behind this undertaking (why one would go to all the trouble of setting up a categories-based alternative to ZFC, when time-tested ZFC is able to express virtually all of present-day mathematics on the basis of a reasonably short list of axioms?). But in the interest of time and space, I’ll confine myself to a few remarks.</p>

<p>As we said, a chief difference between ZFC and ETCS resides in how ETCS treats the issue of membership. In ZFC, membership is a global binary relation: we can take any two “sets” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B</annotation></semantics></math> and ask whether <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \in B</annotation></semantics></math>. Whereas in ETCS, membership is a relation between entities of different sorts: we have “sets” on one side and “elements” on another, and the two are not mixed ( <em>e.g.</em>, elements are not themselves considered sets).</p>

<p>Further, and far more radical: in ETCS the membership relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x \in A</annotation></semantics></math> is a <em>function</em>, that is, an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> “belongs” to only one set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> at a time. We can think of this as “declaring” how we are thinking of an element, that is, declaring which set (or which type) an element is being considered as belonging to. (In the jargon, ETCS is a <em>typed theory</em>.) This reflects a general and useful philosophic principle: that elements in isolation are considered inessential, that what counts are the aggregates or contexts in which elements are organized and interrelated. For instance, the numeral “2” in isolation has no meaning; what counts is the context in which we think of it ( <em>qua</em> rational number or <em>qua</em> complex number, <em>etc.</em>). Similarly the set of real numbers has no real sense in isolation; what counts is which category we view it in.</p>

<p>I believe it is reasonable to grant this principle a foundational status, but: rigorous adherence to this principle completely changes the face of what set theory looks like. If elements “belong” only to one set at a time, how then do we even <em>define</em> such basic concepts as subsets and intersections? These are some of the issues we discussed last time.</p>

<p>There are other significant differences between ZFC and ETCS: stylistically, or in terms of presentation, ZFC is more “top-down” and ETCS is more “bottom-up”. For example, in ZFC, one can pretty much define a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mi>P</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ x \in X : P \}</annotation></semantics></math> by writing down a first-order formula <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> in the language; the <a class="existingWikiWord" href="/nlab/show/comprehension">comprehension</a> (or <a class="existingWikiWord" href="/nlab/show/axiom+of+separation">separation</a>) axiom scheme is a mighty sledgehammer that takes care of the rest. In the axioms of ETCS, there is no such sledgehammer: the closest thing one has to a comprehension scheme in the ETCS axioms is the power set axiom (a single axiom, not an axiom scheme). However, in the formal development of ETCS, one <em>derives</em> a comprehension scheme as one manually constructs the internal logic, in stages, using the simple tools of adjunctions and universal properties. We started doing some of that in our last post. So: with ZFC it’s more as if you can just hop in the car and go; with ETCS you build the car engine from smaller parts with your bare hands, but in the process you become an expert mechanic, and are not so rigidly attached to a particular make and model ( <em>e.g.</em>, much of the theory is built just on the axioms of a topos, which allows a lot more semantic leeway than one has with ZF).</p>

<p>But, in all fairness, that is perhaps the biggest obstacle to learning ETCS: at the outset, the tools available [mainly, the idea of a universal property] are quite simple but parsimonious, and one has to learn how to build some set-theoretic and logical concepts normally taken as “obvious” from the ground up. (Talk about “foundations”!) On the plus side, by building big logical machines from scratch, one gains a great deal of insight into the inner workings of logic, with a corresponding gain in precision and control and modularity when one would like to use these developments to design, say, automated deduction systems (where there tend to be strong advantages to using type-theoretic frameworks).</p>

<dl>
<dt>Enough philosophy for now; readers may refer to my <a href="http://topologicalmusings.wordpress.com/2008/09/01/zfc-and-etcs-elementary-theory-of-the-category-of-sets">earlier</a> <a href="http://topologicalmusings.wordpress.com/2008/09/10/etcs-internalizing-the-logic/">posts</a> for more. Let’s get to work, shall we? Our last post was about the structure of (and relationships between) posets of subobjects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(X)</annotation></semantics></math> <em>relative</em> to objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, and now we want to exploit the results there to build some <em>absolute</em> constructions, in particular finite coproducts and coequalizers. In this post we will focus on coproducts.</dt>

<dd>
<p><strong>Note to the experts.</strong> Most textbook treatments of the formal development of topos theory (as for example Mac Lane–Moerdijk) are efficient but highly technical, involving for instance the slice theorem for toposes and, in the construction of colimits, recourse to Beck’s theorem in monad theory applied to the double power-set monad [following the elegant construction of Par]. The very abstract nature of this style of argumentation (which in the application of Beck’s theorem expresses ideas of fourth-order set theory and higher) is no doubt partly responsible for the somewhat fearsome reputation of topos theory.</p>
</dd>

<dd>
<p>In these notes I take a much less efficient but much more elementary approach, based on an arrangement of ideas which I hope can be seen as “natural” from the point of view of naive set theory. I learned of this approach from Myles Tierney, who was my PhD supervisor, and who with Bill Lawvere co-founded elementary topos theory, but I am not aware of any place where the details of this approach have been written up before now. I should also mention that the approach taken here is not as “purist” as many topos theorists might want; for example, here and there I take advantage of the strong extensionality axiom of ETCS to simplify some arguments.</p>
</dd>
</dl>

<h3 id="the_empty_set_and_twovalued_logic">The Empty Set and Two-Valued Logic</h3>

<p>We begin with the easy observation that a terminal category, <em>i.e.</em>, a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math> with just one object and one morphism (the identity), satisfies all the ETCS axioms. Ditto for any category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math> (where every object is terminal). Such boring ETCS categories are called <em>degenerate</em>; obviously our interest is in the structure of nondegenerate ETCS categories.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math> be an ETCS category (see <a href="http://topologicalmusings.wordpress.com/2008/09/01/zfc-and-etcs-elementary-theory-of-the-category-of-sets">here</a> for the ETCS axioms). Objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math> are generally called “sets”, and morphisms are generally called “functions” or “maps”.</p>

<p><strong>Proposition 0.</strong> If an ETCS category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math> is a preorder, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math> is degenerate.</p>

<p><strong>Proof.</strong> Recall that a preorder is a category in which there is at most one morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math> for any two objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B</annotation></semantics></math>. Every morphism in a preorder is vacuously monic. If there is a nonterminal set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, then the monic <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A \to 1</annotation></semantics></math> to any terminal set defines a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A \subseteq 1</annotation></semantics></math> distinct from the subset defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \to 1</annotation></semantics></math>, thus giving (in an ETCS category) distinct classifying maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>,</mo><mi>t</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_A, t : 1 \to P(1)</annotation></semantics></math>, contradicting the preorder assumption. Therefore all objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> are terminal. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>Assume from now on that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math> is a nondegenerate ETCS category.</p>

<p><strong>Proposition 1.</strong> There are at least two <em>truth values</em>, <em>i.e.</em>, two elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1 \to P(1)</annotation></semantics></math>, in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> By proposition 0, there exist sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X, Y</annotation></semantics></math> and two distinct functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f, g : X \to Y</annotation></semantics></math>. By the axiom of strong extensionality, there exists <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x : 1 \to X</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mi>x</mi><mo>≠</mo><mi>g</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">f x \neq g x</annotation></semantics></math>. The equalizer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">E \to 1</annotation></semantics></math> of the pair <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mi>x</mi><mo>,</mo><mi>g</mi><mi>x</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f x, g x : 1 \to Y</annotation></semantics></math> is then a proper subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>, and therefore there are at least two distinct elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>E</mi></msub><mo>,</mo><msub><mi>χ</mi> <mn>1</mn></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_E, \chi_1 : 1 \to P(1)</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Proposition 2.</strong> There are at most two truth values <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1 \to P(1)</annotation></semantics></math>; equivalently, there are at most two subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>,</mo><mi>V</mi><mo>⊆</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">U, V \subseteq 1</annotation></semantics></math> are distinct subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>, then either <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>≠</mo><mi>U</mi><mo>∩</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U \neq U \cap V</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>≠</mo><mi>U</mi><mo>∩</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">V \neq U \cap V</annotation></semantics></math>, say the former. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mn>1</mn> <mi>U</mi></msub><mo>:</mo><mi>U</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">1_U : U \subseteq U</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>∩</mo><mi>V</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">U \cap V \subseteq U</annotation></semantics></math> are distinct subsets, with distinct classifying maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mrow><msub><mn>1</mn> <mi>U</mi></msub></mrow></msub><mo>,</mo><msub><mi>χ</mi> <mrow><mi>U</mi><mo>∩</mo><mi>V</mi></mrow></msub><mo>:</mo><mi>U</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_{1_U}, \chi_{U \cap V} : U \to P(1)</annotation></semantics></math>. By strong extensionality, there exists <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">x : 1 \to U</annotation></semantics></math> distinguishing these classifying maps. Because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> is terminal, we then infer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">1 \subseteq U</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>⊆</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">U \subseteq 1</annotation></semantics></math>, so <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">U = 1</annotation></semantics></math> as subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>, and in that case only <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> can be a proper subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>By Propositions 1 and 2, there is a unique proper subset of the terminal object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \to 1</annotation></semantics></math> denote this subset. Its domain may be called an “empty set”; by the preceding proposition, it has no proper subsets. The classifying map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \to P1</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>⊆</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \subseteq 1</annotation></semantics></math> is the truth value we call “false”.</p>

<p><strong>Proposition 3.</strong> 0 is an initial object, <em>i.e.</em>, for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> there exists a unique function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">0 \to X</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> Uniqueness: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi><mo>:</mo><mn>0</mn><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f, g : 0 \to X</annotation></semantics></math> are maps, then their equalizer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>E</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x : E \to 0</annotation></semantics></math>, which is monic, must be an isomorphism since 0 has no proper subsets. Therefore <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f = g</annotation></semantics></math>. Existence: there are monos</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mn>0</mn><mo>→</mo><mn>1</mn><mover><mo>→</mo><mrow><msub><mi>t</mi> <mi>X</mi></msub></mrow></mover><mi>P</mi><mi>X</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle 0 \to 1 \stackrel{t_X}{\to} P X</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>X</mi><mover><mo>→</mo><mi>σ</mi></mover><mi>P</mi><mi>X</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle X \stackrel{\sigma}{\to} P X</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">t_X</annotation></semantics></math> is “global truth” (classifying the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \subseteq X</annotation></semantics></math>) on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is the “singleton mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>↦</mo><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">x \mapsto \{ x \}</annotation></semantics></math>” on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, defined as the classifying map of the diagonal map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>X</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\delta : X \subseteq X \times X</annotation></semantics></math> (last time we saw <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is monic). Take their pullback. The component of the pullback parallel to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is a mono <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">P \to 0</annotation></semantics></math> which again is an isomorphism, whence we get a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≅</mo><mi>P</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">0 \cong P \to X</annotation></semantics></math> using the other component of the pullback. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Remark.</strong> For the “purists”, an alternative construction of the initial set 0 that avoids use of the strong extensionality axiom is to define the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>⊆</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \subseteq 1</annotation></semantics></math> to be “the intersection all subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>”. Formally, one takes the extension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>ϕ</mi><mo>]</mo></mrow><mo>⊆</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left[\phi\right] \subseteq 1</annotation></semantics></math> of the map</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>ϕ</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mover><mo>→</mo><mrow><msub><mi>t</mi> <mrow><mi>P</mi><mn>1</mn></mrow></msub></mrow></mover><mi>PP</mi><mn>1</mn><mover><mo>→</mo><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo></mover><mi>P</mi><mn>1</mn><mo stretchy="false">)</mo><mo>;</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \phi = (1 \stackrel{t_{P1}}{\to} PP1 \stackrel{\bigcap}{\to} P1);</annotation></semantics></math></div>
<p>where the first arrow represents the class of all subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P1</annotation></semantics></math>, and the second is the internal intersection operator defined at the end of our last post. Using formal properties of intersection developed later, this intersection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>⊆</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \subseteq 1</annotation></semantics></math> has no proper subsets, and then the proof of proposition 3 carries over verbatim. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Corollary 1.</strong> For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">0 \times X</annotation></semantics></math> is initial.</p>

<p><strong>Proof.</strong> By <a href="http://topologicalmusings.wordpress.com/2008/09/10/etcs-internalizing-the-logic">cartesian closure</a>, maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>×</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">0 \times X \to Y</annotation></semantics></math> are in bijection with maps of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>→</mo><msup><mi>Y</mi> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">0 \to Y^X</annotation></semantics></math>, and there is exactly one of these since 0 is initial. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Corollary 2.</strong> If there exists <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f : X \to 0</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is initial.</p>

<p><strong>Proof.</strong> The composite of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>f</mi><mo>,</mo><msub><mn>1</mn> <mi>X</mi></msub><mo stretchy="false">⟩</mo><mo>:</mo><mi>X</mi><mo>→</mo><mn>0</mn><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\langle f, 1_X \rangle : X \to 0 \times X</annotation></semantics></math> followed by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>2</mn></msub><mo>:</mo><mn>0</mn><mo>×</mo><mi>X</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\pi_2 : 0 \times X \to X</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mn>1</mn> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">1_X</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\pi_2</annotation></semantics></math> followed by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>f</mi><mo>,</mo><msub><mn>1</mn> <mi>X</mi></msub><mo stretchy="false">⟩</mo><mo>:</mo><mi>X</mi><mo>→</mo><mn>0</mn><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\langle f, 1_X \rangle : X \to 0 \times X</annotation></semantics></math> is also an identity since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">0 \times X</annotation></semantics></math> is initial by Corollary 1. Hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is isomorphic to an initial object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">0 \times X</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>By Corollary 2, for any object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> the arrow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">0 \to Y</annotation></semantics></math> is vacuously monic, hence defines a subset.</p>

<p><strong>Proposition 4.</strong> If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>¬</mo><mo>≅</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">X \not\cong 0</annotation></semantics></math>, then there exists an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x : 1 \to X</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> Under the assumption, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> has at least two distinct subsets: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">0 \subseteq X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mn>1</mn> <mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">1_X : X \subseteq X</annotation></semantics></math>. By strong extensionality, their classifying maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>χ</mi> <mn>1</mn></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\chi_0, \chi_1 : X \to P1</annotation></semantics></math> are distinguished by some element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x : 1 \to X</annotation></semantics></math>.</p>

<h3 id="external_unions_and_internal_joins">External Unions and Internal Joins</h3>

<p>One of the major goals in this post is to construct finite coproducts in an ETCS category. As in ordinary set theory, we will construct these as disjoint unions. This means we need to discuss unions first; as should be expected by now, in ETCS unions are considered locally, <em>i.e.</em>, we take unions of <em>subsets of a given set</em>. So, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A, B \subseteq X</annotation></semantics></math> be subsets.</p>

<p>To define the union <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \cup B \subseteq X</annotation></semantics></math>, the idea is to take the intersection of all subsets containing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. That is, we apply the internal intersection operator (constructed <a href="http://topologicalmusings.wordpress.com/2008/09/10/etcs-internalizing-the-logic/">last time</a> ),</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mo>:</mo><mi>P</mi><mi>P</mi><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>,</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \bigcap : P P X \to P X,</annotation></semantics></math></div>
<dl>
<dt>to the element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>P</mi><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">1 \to P P X</annotation></semantics></math> that represents the set of all subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> containing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>; the resulting element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">1 \to P X</annotation></semantics></math> represents <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math>. The element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>P</mi><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">1 \to P P X</annotation></semantics></math> corresponds to the intersection of two subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo><mspace width="mediummathspace"></mspace><mo>∩</mo><mspace width="mediummathspace"></mspace><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>B</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo><mo>⊆</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\{ C \in P X : A \subseteq C \} \:\cap\: \{ C \in P X : B \subseteq C \} \subseteq P X</annotation></semantics></math>.</dt>

<dd>
<p><strong>Remark.</strong> Remember that in ETCS we are using <em>generalized</em> elements: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">C \in P X</annotation></semantics></math> really means a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">C : U \to P X</annotation></semantics></math> over some domain <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, which in turn classifies a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mi>C</mi><mo>]</mo></mrow><mo>⊆</mo><mi>U</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\left[C\right] \subseteq U \times X</annotation></semantics></math>. On the other hand, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> here is a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math>. How then do we interpret the condition “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \subseteq C</annotation></semantics></math>”? We first pull back <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\chi_A : 1 \to P X</annotation></semantics></math> over to the domain <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> (that is, we form the composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>U</mi><mover><mo>→</mo><mo>!</mo></mover><mn>1</mn><mover><mo>→</mo><mrow><msub><mi>χ</mi> <mi>A</mi></msub></mrow></mover><mi>P</mi><mi>X</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle U \stackrel{!}{\to} 1 \stackrel{\chi_A}{\to} P X</annotation></semantics></math>) and consider the condition that this is bounded above by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">C : U \to P X</annotation></semantics></math>. (We will write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>≤</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\chi_A \leq C</annotation></semantics></math>, thinking of the left side as constant over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>.) Externally, in terms of subsets, this corresponds to the condition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>×</mo><mi>A</mi><mo>⊆</mo><mrow><mo>[</mo><mi>C</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">U \times A \subseteq \left[C\right]</annotation></semantics></math>.</p>
</dd>
</dl>

<p>We need to construct the subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo><mo>,</mo><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>B</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ C \in P X : A \subseteq C \}, \{ C \in P X : B \subseteq C \}</annotation></semantics></math>. In ZFC, we could construct those subsets by applying the comprehension axiom scheme, but the axioms of ETCS have no such blanket axiom scheme. (In fact, as we said earlier, much of the work on “internalizing logic” goes to show that in ETCS, we instead <em>derive</em> a comprehension scheme!) However, one way of defining subsets in ETCS is by taking loci of equations; here, we express the condition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \subseteq C</annotation></semantics></math>, more pedantically <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mrow><mo>[</mo><mi>C</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">A \subseteq \left[C\right]</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>≤</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\chi_A \leq C</annotation></semantics></math>, as the equation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>χ</mi> <mi>A</mi></msub><mo>⇒</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>t</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">(\chi_A \Rightarrow C) = t_X</annotation></semantics></math></div>
<p>where the right side is the predicate “true over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>”.</p>

<p>Thus we construct the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{C \in P X: A \subseteq C\}</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">P X</annotation></semantics></math> via the pullback:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">{</mo><mi>C</mi><mo>:</mo><mi>A</mi><mo>≤</mo><mi>C</mi><mo stretchy="false">}</mo></mtd> <mtd><mo>⟶</mo></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><mpadded width="0"><mstyle scriptlevel="1"><mrow><msub><mi>t</mi> <mi>X</mi></msub></mrow></mstyle></mpadded></mtd></mtr> <mtr><mtd><mi>P</mi><mi>X</mi></mtd> <mtd><munder><mo>⟶</mo><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>⇒</mo><mo lspace="verythinmathspace" rspace="0em">−</mo></mrow></munder></mtd> <mtd><mi>P</mi><mi>X</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\begin{matrix}
\{ C : A \le C \} &amp; \longrightarrow &amp; 1 \\
\downarrow &amp; &amp; \downarrow \mathrlap{\scriptsize{t_X}} \\
P X &amp; \underset{\chi_A \Rightarrow -}{\longrightarrow} &amp; P X
\end{matrix}

</annotation></semantics></math></div>
<p>Let me take a moment to examine what this diagram means exactly. <a href="http://topologicalmusings.wordpress.com/2008/09/10/etcs-internalizing-the-logic">Last time</a> we constructed an internal implication operator</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>⇒</mo><mo>:</mo><mi>P</mi><mn>1</mn><mo>×</mo><mi>P</mi><mn>1</mn><mo>→</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\Rightarrow : P1 \times P1 \to P1</annotation></semantics></math></div>
<p>and now, in the pullback diagram above, what we are implicitly doing is lifting this to an operator</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mo>⇒</mo> <mi>X</mi></msub><mo>:</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>PX</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\Rightarrow_X : P X \times PX \to P X</annotation></semantics></math></div>
<p>The easy and cheap way of doing this is to remember the isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mi>X</mi><mo>≅</mo><mi>P</mi><msup><mn>1</mn> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">P X \cong P1^X</annotation></semantics></math> we used last time to uncover the cartesian closed structure, and apply this to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>P</mi><msup><mn>1</mn> <mi>X</mi></msup><mo>×</mo><mi>P</mi><msup><mn>1</mn> <mi>X</mi></msup><mo>≅</mo><mo stretchy="false">(</mo><mi>P</mi><mn>1</mn><mo>×</mo><mi>P</mi><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>X</mi></msup><mover><mo>→</mo><mrow><msup><mo>⇒</mo> <mi>X</mi></msup></mrow></mover><mi>P</mi><msup><mn>1</mn> <mi>X</mi></msup></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle P1^X \times P1^X \cong (P1 \times P1)^X \stackrel{\Rightarrow^X}{\to} P1^X</annotation></semantics></math></div>
<p>to define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>⇒</mo> <mi>X</mi></msub><mo>:</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\Rightarrow_X : P X \times P X \to P X</annotation></semantics></math>. This map classifies a certain subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">X \times P X \times P X</annotation></semantics></math>, which I’ll just write down (leaving it as an exercise which involves just chasing the relevant definitions):</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>T</mi><mo>,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>T</mi><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ (x, T, S) \in X \times P X \times P X : x \in_X T \Rightarrow x \in_X S \}</annotation></semantics></math></div>
<p><strong>Remark.</strong> Similarly we can define a meet operator <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∧</mo> <mi>X</mi></msub><mo>:</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\wedge_X : P X \times P X \to P X</annotation></semantics></math> by exponentiating the internal meet <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mn>1</mn><mo>×</mo><mi>P</mi><mn>1</mn><mo>→</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P1 \times P 1 \to P 1</annotation></semantics></math>. It is important to know that the general Heyting algebra identities which we established last time for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P1</annotation></semantics></math> lift to the corresponding identities for the operators <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∧</mo> <mi>X</mi></msub><mo>,</mo><msub><mo>⇒</mo> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\wedge_X, \Rightarrow_X</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">P X</annotation></semantics></math>. Ultimately this rests on the fact that the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">(-)^X</annotation></semantics></math>, being a right adjoint, preserves products, and therefore preserves any algebraic identity which can be expressed as a commutative diagram of operations between such products.</p>

<p>Hence, for the fixed subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> (classified by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\chi_A : 1 \to P X</annotation></semantics></math>), the operator</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>⇒</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>:</mo><mi>P</mi><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\chi_A \Rightarrow - : P X \to P X</annotation></semantics></math></div>
<p>classifies the subset</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>:</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>A</mi><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">}</mo><mo>↪</mo><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\{ (x, S) : x \in_X A \Rightarrow x \in_X S \} \hookrightarrow X \times P X</annotation></semantics></math></div>
<p>Finally, in the pullback diagram above, we are pulling back the operator <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>⇒</mo><mo lspace="verythinmathspace" rspace="0em">−</mo></mrow><annotation encoding="application/x-tex">\chi_A \Rightarrow -</annotation></semantics></math> against <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">t_X</annotation></semantics></math>. But, from <a href="http://topologicalmusings.wordpress.com/2008/09/10/etcs-internalizing-the-logic">last time</a>, that was exactly the method we used to construct <a class="existingWikiWord" href="/nlab/show/universal+quantification">universal quantification</a>. That is, given a subset</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">R \subseteq X \times Y</annotation></semantics></math></div>
<p>we defined <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\forall_Y R \subseteq X</annotation></semantics></math> to be the pullback of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mi>Y</mi></msub><mo>:</mo><mn>1</mn><mo>↪</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">t_Y : 1 \hookrightarrow PY</annotation></semantics></math> along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">\chi_R : X \to PY</annotation></semantics></math>.</p>

<p>Putting all this together, the pullback diagram above expresses the definition</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo><mo>:</mo><mo>=</mo><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><msub><mo>∀</mo> <mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mspace width="mediummathspace"></mspace><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>A</mi><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>C</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ C \in P X : A \subseteq C \} := \{ C \in P X : \forall_{x \in X} \: x \in_X A \Rightarrow x \in_X C \}</annotation></semantics></math></div>
<p>that one would expect “naively”.</p>

<p>Now that all the relevant constructions are in place, we show that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math> is the join of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> in the poset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(X)</annotation></semantics></math>. There is nothing intrinsically difficult about this, but as we are still in the midst of <em>constructing</em> the internal logic, we will have to hunker down and prove some logic things normally taken for granted or zipped through without much thought. For example, the internal intersection operator was defined with the help of internal universal quantification, and we will need to establish some formal properties of that.</p>

<p>Here is a useful general principle for doing internal logic calculations. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">\chi_R : X \to PY</annotation></semantics></math> be the classifying map of a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">R \subseteq X \times Y</annotation></semantics></math>, and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : U \to X</annotation></semantics></math> be a function. Then the composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mi>f</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">\chi_R f : U \to PY</annotation></semantics></math> classifies the subset</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>×</mo><msub><mn>1</mn> <mi>Y</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>U</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">(f \times 1_Y)^{-1}(R) \subseteq U \times Y</annotation></semantics></math></div>
<p>so that one has the general identity <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mi>f</mi><mo>=</mo><msub><mi>χ</mi> <mrow><mo stretchy="false">(</mo><mi>f</mi><mo>×</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">\chi_R f = \chi_{(f \times 1)^{-1}(R)}</annotation></semantics></math>. In passing back and forth between the external and internal viewpoints, the general principle is to try to render “complicated” functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>→</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">U \to PY</annotation></semantics></math> into a form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mi>f</mi></mrow><annotation encoding="application/x-tex">\chi_R f</annotation></semantics></math> which one can more easily recognize. For lack of a better term, I’ll call this the “pullback principle”.</p>

<p><strong>Lemma 1.</strong> Given a relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>↪</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">R \hookrightarrow X \times Y</annotation></semantics></math> and a constant <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">c : 1 \to Y</annotation></semantics></math>, there is an inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi><mo>⊆</mo><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>×</mo><mi>c</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_Y R \subseteq (1_X \times c)^{-1}(R)</annotation></semantics></math></div>
<p>as subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. (In traditional logical syntax, this says that for any element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">c : 1 \to Y</annotation></semantics></math>,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mrow><mi>y</mi><mo>:</mo><mi>Y</mi></mrow></msub><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mspace width="1em"></mspace><mi>implies</mi><mspace width="1em"></mspace><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_{y : Y} R(x, y) \quad implies \quad R(x, c)</annotation></semantics></math></div>
<p>as predicates over elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math>. This is the type of thing that ordinarily “goes without saying”, but which we actually have to prove here!)</p>

<p><strong>Proof.</strong> As we recalled above, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\forall_Y R \subseteq X</annotation></semantics></math> was defined to be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>χ</mi> <mi>R</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>Y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_R^{-1}(t_Y)</annotation></semantics></math>, the pullback of global truth <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>t</mi> <mi>Y</mi></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">t_Y : 1 \to PY</annotation></semantics></math> along the classifying map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">\chi_R : X \to PY</annotation></semantics></math>. Hold that thought.</p>

<p>Let</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Pc</mi><mo>:</mo><mi>PY</mi><mo>→</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">Pc : PY \to P1</annotation></semantics></math></div>
<p>be the map which classifies the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>PY</mi><mo>:</mo><mi>c</mi><msub><mo>∈</mo> <mi>Y</mi></msub><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ S \in PY : c \in_Y S\}</annotation></semantics></math>. Equivalently, this is the map</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>P</mi><msup><mn>1</mn> <mi>c</mi></msup><mo>:</mo><mi>P</mi><msup><mn>1</mn> <mi>Y</mi></msup><mo>→</mo><mi>P</mi><msup><mn>1</mn> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">P1^c: P1^Y \to P1^1</annotation></semantics></math></div>
<p>under the canonical isomorphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PY</mi><mo>≅</mo><mi>P</mi><msup><mn>1</mn> <mi>Y</mi></msup></mrow><annotation encoding="application/x-tex">PY \cong P1^Y</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><msup><mn>1</mn> <mn>1</mn></msup><mo>≅</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P1^1 \cong P1</annotation></semantics></math>. Intuitively, this maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>↦</mo><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f \mapsto f(c)</annotation></semantics></math>, <em>i.e.</em>, plugs an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">c \in Y</annotation></semantics></math> into an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>P</mi><msup><mn>1</mn> <mi>Y</mi></msup></mrow><annotation encoding="application/x-tex">f \in P1^Y</annotation></semantics></math>.</p>

<p>Using the adjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>×</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>⊣</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mi>Y</mi></msup></mrow><annotation encoding="application/x-tex">(- \times Y) \dashv (-)^Y</annotation></semantics></math> of cartesian closure, the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>X</mi><mover><mo>→</mo><mrow><msub><mi>χ</mi> <mi>R</mi></msub></mrow></mover><mi>PY</mi><mover><mo>→</mo><mi>Pc</mi></mover><mi>P</mi><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle X \stackrel{\chi_R}{\to} PY \stackrel{Pc}{\to} P1</annotation></semantics></math></div>
<p>transforms to the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mn>1</mn><mover><mo>→</mo><mrow><msub><mn>1</mn> <mi>X</mi></msub><mo>×</mo><mi>c</mi></mrow></mover><mi>X</mi><mo>×</mo><mi>Y</mi><mover><mo>→</mo><mrow><msub><mi>χ</mi> <mi>R</mi></msub></mrow></mover><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">X \times 1 \stackrel{1_X \times c}{\to} X \times Y \stackrel{\chi_{R}}{\to} P1</annotation></semantics></math></div>
<p>so by the pullback principle, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Pc</mi><mo stretchy="false">)</mo><msub><mi>χ</mi> <mi>R</mi></msub><mo>:</mo><mi>X</mi><mo>×</mo><mn>1</mn><mo>→</mo><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">(Pc)\chi_R : X \times 1 \to P1</annotation></semantics></math> classifies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>×</mo><mi>c</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>X</mi><mo>×</mo><mn>1</mn><mo>≅</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">(1_X \times c)^{-1}(R) \subseteq X \times 1 \cong X</annotation></semantics></math>.</p>

<p>Equivalently,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>×</mo><mi>c</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>χ</mi> <mi>R</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>Pc</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="2em"></mspace><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1_X \times c)^{-1}(R) = \chi_{R}^{-1} (Pc)^{-1}(t) \qquad (1)</annotation></semantics></math></div>
<p>Also, as subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PY</mi></mrow><annotation encoding="application/x-tex">PY</annotation></semantics></math>, we have the inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>Y</mi></msub><mo>:</mo><mn>1</mn><mo>↪</mo><mi>PY</mi><mo stretchy="false">)</mo><mo>⊆</mo><mo stretchy="false">(</mo><mi>Pc</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="2em"></mspace><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t_Y : 1 \hookrightarrow PY) \subseteq (Pc)^{-1}(t) \qquad (2)</annotation></semantics></math></div>
<p>[this just says that  belongs to the subset classified by , or equivalently that  is in the subset ]. Applying the pullback operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>χ</mi> <mi>R</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\chi_{R}^{-1}</annotation></semantics></math> to (2), and comparing to (1), Lemma 1 follows. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Lemma 2.</strong> If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \subseteq S</annotation></semantics></math> as subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \times Y</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi><mo>⊆</mo><msub><mo>∀</mo> <mi>Y</mi></msub><mi>S</mi></mrow><annotation encoding="application/x-tex">\forall_Y R \subseteq \forall_Y S</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> From the last post, we have an adjunction:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>×</mo><mi>Y</mi><mo>⊆</mo><mi>S</mi><mspace width="1em"></mspace><mi>if</mi><mi>and</mi><mi>only</mi><mi>if</mi><mspace width="1em"></mspace><mi>T</mi><mo>⊆</mo><msub><mo>∀</mo> <mi>Y</mi></msub><mi>S</mi></mrow><annotation encoding="application/x-tex">T \times Y \subseteq S \quad if and only if \quad T \subseteq \forall_Y S</annotation></semantics></math></div>
<p>for any subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">T \subseteq X</annotation></semantics></math>. So it suffices to show <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi><mo>×</mo><mi>Y</mi><mo>⊆</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\forall_Y R \times Y \subseteq S</annotation></semantics></math>. But</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi><mo>×</mo><mi>Y</mi><mo>⊆</mo><mi>R</mi><mo>⊆</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\forall_Y R \times Y \subseteq R \subseteq S</annotation></semantics></math></div>
<p>where the first inclusion follows from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi><mo>⊆</mo><msub><mo>∀</mo> <mi>Y</mi></msub><mi>R</mi></mrow><annotation encoding="application/x-tex">\forall_Y R \subseteq \forall_Y R</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>Next, recall from the <a href="http://topologicalmusings.wordpress.com/2008/09/10/etcs-internalizing-the-logic">last post</a> that the internal intersection of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">F : 1 \to P P X</annotation></semantics></math> was defined by interpreting the following formula on the right:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mi>F</mi><mo>=</mo><msub><mo>∀</mo> <mrow><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><msub><mo>∈</mo> <mrow><mi>P</mi><mi>X</mi></mrow></msub><mi>F</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \bigcap F = \forall_{S \in P X} (S \in_{P X} F) \Rightarrow (x \in_X S)</annotation></semantics></math></div>
<p><strong>Lemma 3.</strong> If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>≤</mo><mi>G</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">F \leq G : 1 \to P P X</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mi>G</mi><mo>≤</mo><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mi>F</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>X</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \bigcap G \leq \bigcap F : 1 \to P X</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">F : 1 \to P P X</annotation></semantics></math> classifies the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>S</mi><msub><mo>∈</mo> <mrow><mi>P</mi><mi>X</mi></mrow></msub><mi>F</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ S \in P X : S \in_{P X} F \}</annotation></semantics></math>, <em>i.e.</em>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is identified with the predicate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><msub><mo>∈</mo> <mrow><mi>P</mi><mi>X</mi></mrow></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">S \in_{P X} F</annotation></semantics></math> in the argument <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, so by hypothesis <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><msub><mo>∈</mo> <mrow><mi>P</mi><mi>X</mi></mrow></msub><mi>F</mi><mo stretchy="false">)</mo><mo>≤</mo><mo stretchy="false">(</mo><mi>S</mi><msub><mo>∈</mo> <mrow><mi>P</mi><mi>X</mi></mrow></msub><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S \in_{P X} F) \leq (S \in_{P X} G)</annotation></semantics></math> as predicates on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>. Internal implication <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math> is contravariant in the argument <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> [see the following remark], so</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mo>[</mo><mo stretchy="false">(</mo><mi>S</mi><mo>∈</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">)</mo><mo>]</mo></mrow><mo>≤</mo><mrow><mo>[</mo><mo stretchy="false">(</mo><mi>S</mi><mo>∈</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">)</mo><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[(S \in G) \Rightarrow (x \in S)\right] \leq \left[(S \in F) \Rightarrow (x \in S)\right]</annotation></semantics></math></div>
<dl>
<dt>Now apply Lemma 2 to complete the proof. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></dt>

<dd>
<p><strong>Remark.</strong> The contravariance of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">- \Rightarrow b</annotation></semantics></math>, that is, the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math> implies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≤</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y \Rightarrow b) \leq (x \Rightarrow b)</annotation></semantics></math>, is a routine exercise using the adjunction [discussed last time] <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∧</mo><mi>c</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \wedge c \leq b</annotation></semantics></math> if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>≤</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">c \leq (a \Rightarrow b).</annotation></semantics></math></p>
</dd>

<dd>
<p>Indeed, we have</p>
</dd>
</dl>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>y</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>b</mi><mspace width="2em"></mspace><mo stretchy="false">(</mo><mo>*</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \wedge (y \Rightarrow b) \leq y \wedge (y \Rightarrow b) \leq b \qquad (*)</annotation></semantics></math></div>
<p>where the first inequality follows from the hypothesis <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math>, and the second follows from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>⇒</mo><mi>b</mi><mo>≤</mo><mi>y</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y \Rightarrow b \leq y \Rightarrow b</annotation></semantics></math>. By the adjunction, the inequality <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo>*</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(*)</annotation></semantics></math> implies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≤</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y \Rightarrow b) \leq (x \Rightarrow b)</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Theorem 1.</strong> For subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math> is an upper bound of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, <em>i.e.</em>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>⊆</mo><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B \subseteq A \cup B</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> It suffices to prove that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>A</mi><mo>=</mo><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle A = \bigcap \{C \in P X : A \subseteq C\}</annotation></semantics></math>, since then we need only apply Lemma 3 to the trivially true inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo><mspace width="mediummathspace"></mspace><mo>∩</mo><mspace width="mediummathspace"></mspace><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>B</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo><mo>⊆</mo><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ C \in P X : A \subseteq C \} \:\cap\: \{ C \in P X : B \subseteq C \} \subseteq \{ C \in P X : A \subseteq C \}</annotation></semantics></math></div>
<p>to infer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \subseteq A \cup B</annotation></semantics></math>, and similarly <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>⊆</mo><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">B \subseteq A \cup B</annotation></semantics></math>. (Actually, we need only show <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>A</mi><mo>⊆</mo><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mo stretchy="false">{</mo><mi>C</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">}</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle A \subseteq \bigcap \{ C \in P X : A \subseteq C \}</annotation></semantics></math>. We’ll do that first, and then show full equality.)</p>

<p>The condition we want,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><msub><mo>∀</mo> <mrow><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi></mrow></msub><mo stretchy="false">(</mo><mi>A</mi><mo>⊆</mo><mi>S</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">A \subseteq \{ x \in X : \forall_{S \in P X} (A \subseteq S) \Rightarrow (x \in_X S) \},</annotation></semantics></math></div>
<p>is, by the adjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>×</mo><mi>P</mi><mi>X</mi><mo stretchy="false">)</mo><mo>⊣</mo><msub><mo>∀</mo> <mrow><mi>P</mi><mi>X</mi></mrow></msub><mo>:</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(- \times P X) \dashv \forall_{P X} : Sub(X \times P X) \to Sub(X)</annotation></semantics></math>, equivalent to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo>⊆</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>S</mi><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A \times P X \subseteq \{ (x, S) : A \subseteq S \Rightarrow (x \in_X S) \}</annotation></semantics></math></div>
<p>which, by a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> adjunction, is equivalent to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo stretchy="false">)</mo><mo>∩</mo><mo stretchy="false">(</mo><mi>X</mi><mo>×</mo><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>S</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>⊆</mo><mspace width="mediummathspace"></mspace><msub><mo>∈</mo> <mi>X</mi></msub><mspace width="2em"></mspace><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \times P X) \cap (X \times \{ S \in P X : A \subseteq S \}) \subseteq \: \in_X \qquad (1)</annotation></semantics></math></div>
<p>as subsets of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">X \times P X</annotation></semantics></math>. So we just have to prove (1). At this point we recall, from our earlier analysis, that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>S</mi><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><msub><mo>∀</mo> <mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>A</mi><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ S \in P X : A \subseteq S \} = \{ S \in P X : \forall_{x \in X} x \in_X A \Rightarrow x \in_X S \}</annotation></semantics></math></div>
<p>Using the adjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>×</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>⊣</mo><msub><mo>∀</mo> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">(X \times -) \dashv \forall_X</annotation></semantics></math>, as in the proof of Lemma 2, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><msub><mo>∀</mo> <mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>A</mi><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X \times \{ S \in P X : \forall_{x \in X} x \in_X A \Rightarrow x \in_X S \}</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>⊆</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>S</mi><mo stretchy="false">)</mo><mo>:</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>A</mi><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">}</mo><mo>:</mo><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo stretchy="false">)</mo><mo>⇒</mo><msub><mo>∈</mo> <mi>X</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">\subseteq \{ (x, S) : x \in_X A \Rightarrow x \in_X S \} := (A \times P X) \Rightarrow \in_X,</annotation></semantics></math></div>
<p>which shows that the left side of (1) is contained in</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo stretchy="false">)</mo><mo>∩</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>P</mi><mi>X</mi><mo stretchy="false">)</mo><mo>⇒</mo><msub><mo>∈</mo> <mi>X</mi></msub><mo stretchy="false">)</mo><mo>⊆</mo><mspace width="mediummathspace"></mspace><msub><mo>∈</mo> <mi>X</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">(A \times P X) \cap ((A \times P X) \Rightarrow \in_X) \subseteq \: \in_X,</annotation></semantics></math></div>
<p>where the last inclusion uses another <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> adjunction. Thus we have established (1) and therefore also the inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>A</mi><mo>⊆</mo><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>S</mi><mo stretchy="false">}</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle A \subseteq \bigcap \{S \in P X : A \subseteq S\}</annotation></semantics></math></div>
<p>Now we prove the opposite inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mo lspace="thinmathspace" rspace="thinmathspace">⋂</mo><mo stretchy="false">{</mo><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mi>S</mi><mo stretchy="false">}</mo><mo>⊆</mo><mi>A</mi><mo>,</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \bigcap \{ S \in P X : A \subseteq S \} \subseteq A,</annotation></semantics></math></div>
<p>that is to say</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><msub><mo>∀</mo> <mrow><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi></mrow></msub><mi>A</mi><mo>⊆</mo><mi>S</mi><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">}</mo><mo>⊆</mo><mi>A</mi><mspace width="2em"></mspace><mo stretchy="false">(</mo><mo>*</mo><mo>*</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{ x \in X : \forall_{S \in P X} A \subseteq S \Rightarrow x \in_X S \} \subseteq A \qquad (**)</annotation></semantics></math></div>
<p>Here we just use Lemma 1, applied to the particular element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>A</mi></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\chi_A : 1 \to P X</annotation></semantics></math>: we see that the left side of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo>*</mo><mo>*</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(**)</annotation></semantics></math> is contained in</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mi>A</mi><mo>⊆</mo><mrow><mo>[</mo><msub><mi>χ</mi> <mi>A</mi></msub><mo>]</mo></mrow><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ x \in X : A \subseteq \left[\chi_A\right] \Rightarrow x \in_X A\}</annotation></semantics></math></div>
<p>which collapses to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>A</mi><mo stretchy="false">}</mo><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\{ x \in X : x \in_X A \} = A</annotation></semantics></math>, since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>[</mo><msub><mi>χ</mi> <mi>A</mi></msub><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">A = \left[\chi_A\right]</annotation></semantics></math>. This completes the proof. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p><strong>Theorem 2.</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup B</annotation></semantics></math> is the least upper bound of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B</annotation></semantics></math>, <em>i.e.</em>, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">C \subseteq X</annotation></semantics></math> is a subset containing both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A \subseteq X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">B \subseteq X</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \cup B \subseteq C</annotation></semantics></math>.</p>

<p><strong>Proof.</strong> We are required to show that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><msub><mo>∀</mo> <mrow><mi>S</mi><mo>∈</mo><mi>P</mi><mi>X</mi></mrow></msub><mspace width="mediummathspace"></mspace><mo stretchy="false">(</mo><mi>A</mi><mo>⊆</mo><mi>S</mi><mo>∧</mo><mi>B</mi><mo>⊆</mo><mi>S</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>S</mi><mo stretchy="false">}</mo><mo>⊆</mo><mi>C</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">\{ x \in X : \forall_{S \in P X} \: (A \subseteq S \wedge B \subseteq S) \Rightarrow x \in_X S \} \subseteq C.</annotation></semantics></math></div>
<p>Again, we just apply Lemma 1 to the particular element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>C</mi></msub><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\chi_C : 1 \to P X</annotation></semantics></math>: the left-hand side of the claimed inclusion is contained in</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mo stretchy="false">(</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo>∧</mo><mi>B</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>C</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ x \in X : (A \subseteq C \wedge B \subseteq C) \Rightarrow x \in_X C \}</annotation></semantics></math></div>
<p>but since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>⊆</mo><mi>C</mi><mo>∧</mo><mi>B</mi><mo>⊆</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \subseteq C \wedge B \subseteq C)</annotation></semantics></math> is true by hypothesis (is globally true as a predicate on the implicit variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math>), this last subset collapses to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><msub><mi>t</mi> <mi>X</mi></msub><mo>⇒</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>C</mi><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>:</mo><mi>x</mi><msub><mo>∈</mo> <mi>X</mi></msub><mi>C</mi><mo stretchy="false">}</mo><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\{ x \in X : t_X \Rightarrow x \in_X C \} = \{ x \in X : x \in_X C \} = C</annotation></semantics></math></div>
<p>which completes the proof. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>□</mo></mrow><annotation encoding="application/x-tex">\Box</annotation></semantics></math></p>

<p>Theorems 1 and 2 show that for any set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, the external poset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(X)</annotation></semantics></math> admits joins. One may go on to show (just on the basis of the topos axioms) that as in the case of meets, the global external operation of taking joins is natural in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, so that by the Yoneda principle, it is classified by an internal join operation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∨</mo><mo>:</mo><mi>P</mi><mn>1</mn><mo>×</mo><mi>P</mi><mn>1</mn><mo>→</mo><mi>P</mi><mn>1</mn><mo>,</mo></mrow><annotation encoding="application/x-tex">\vee : P1 \times P1 \to P1,</annotation></semantics></math></div>
<p>namely, the map which classifies the union of the subsets</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mrow><mo>[</mo><msub><mi>π</mi> <mn>1</mn></msub><mo>]</mo></mrow><mo>=</mo><mi>P</mi><mn>1</mn><mo>×</mo><mn>1</mn><mover><mo>↪</mo><mrow><mn>1</mn><mo>×</mo><mi>t</mi></mrow></mover><mi>P</mi><mn>1</mn><mo>×</mo><mi>P</mi><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \left[\pi_1\right] = P1 \times 1 \stackrel{1 \times t}{\hookrightarrow} P1 \times P1</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mrow><mo>[</mo><msub><mi>π</mi> <mn>2</mn></msub><mo>]</mo></mrow><mo>=</mo><mn>1</mn><mo>×</mo><mi>P</mi><mn>1</mn><mover><mo>↪</mo><mrow><mi>t</mi><mo>×</mo><mn>1</mn></mrow></mover><mi>P</mi><mn>1</mn><mo>×</mo><mi>P</mi><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \left[\pi_2\right] = 1 \times P1 \stackrel{t \times 1}{\hookrightarrow} P1 \times P1</annotation></semantics></math></div>
<p>and this operation satisfies all the expected identities. In short, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P 1</annotation></semantics></math> carries an internal Heyting algebra structure, as does <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mi>X</mi><mo>≅</mo><mi>P</mi><msup><mn>1</mn> <mi>X</mi></msup></mrow><annotation encoding="application/x-tex">P X \cong P 1^X</annotation></semantics></math> for any set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>.</p>

<p>We will come back to this point later, when we show (as a consequence of strong extensionality) that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">P1</annotation></semantics></math> is actually an internal Boolean algebra.</p>

<h3 id="construction_of_coproducts">Construction of Coproducts</h3>

<p>Next, we construct coproducts just as we do in ordinary set theory: as disjoint unions. Letting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X, Y</annotation></semantics></math> be sets (objects in an ETCS category), a <em>disjoint union</em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is a pair of monos</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>X</mi><mo>↪</mo><mi>Z</mi><mspace width="2em"></mspace><mi>j</mi><mo>:</mo><mi>Y</mi><mo>↪</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">i : X \hookrightarrow Z \qquad j : Y \hookrightarrow Z</annotation></semantics></math></div>
<p>whose intersection is empty, and whose union or join in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(Z)</annotation></semantics></math> is all of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>. We will show that disjoint unions exist and are essentially unique, and that they satisfy the universal property for coproducts. We will use the notation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X + Y</annotation></semantics></math> for a disjoint union.</p>

<p><strong>Theorem 3.</strong> A disjoint union of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> exists.</p>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>It’s enough to embed <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X, Y</annotation></semantics></math> disjointly into <em>some</em> set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, since the union of the two monos in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(C)</annotation></semantics></math> would then be the requisite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>. The idea now is that if a disjoint union or coproduct <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X+Y</annotation></semantics></math> exists, then there’s a canonical isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">P(X + Y) \cong P X \times P Y</annotation></semantics></math>. Since the singleton map</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo>→</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">\sigma : X + Y \to P(X + Y) \cong P X \times P Y</annotation></semantics></math></div>
<p>is monic, one thus expects to be able to embed <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> disjointly into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">P X \times P Y</annotation></semantics></math>. Since we can easily work out how all this goes in ordinary naive set theory, we just write out the formulas and hope it works out in ETCS.</p>

<p>In detail, define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">i_X : X \to P X \times P Y</annotation></semantics></math> to be</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>X</mi><mo>≅</mo><mi>X</mi><mo>×</mo><mn>1</mn><mover><mo>→</mo><mrow><msub><mi>σ</mi> <mi>X</mi></msub><mo>×</mo><msub><mi>χ</mi> <mn>0</mn></msub></mrow></mover><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle X \cong X \times 1 \stackrel{\sigma_X \times \chi_0}{\to} P X \times P Y</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>σ</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_X</annotation></semantics></math> is the singleton mapping and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\chi_0</annotation></semantics></math> classifies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>↪</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">0 \hookrightarrow Y</annotation></semantics></math>; similarly, define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>Y</mi></msub><mo>:</mo><mi>Y</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">i_Y :Y \to P X \times P Y</annotation></semantics></math> to be</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>Y</mi><mo>≅</mo><mn>1</mn><mo>×</mo><mi>Y</mi><mover><mo>→</mo><mrow><msub><mi>χ</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>σ</mi> <mi>Y</mi></msub></mrow></mover><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi><mo>.</mo></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle Y \cong 1 \times Y \stackrel{\chi_0 \times \sigma_Y}{\to} P X \times P Y.</annotation></semantics></math></div>
<p>Clearly <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">i_X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">i_Y</annotation></semantics></math> are monic, so to show disjointness we just have to show that their pullback is empty. But their pullback is isomorphic to the cartesian product of the pullbacks of the diagrams</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle displaystyle="true"><mi>X</mi><mover><mo>→</mo><mrow><msub><mi>σ</mi> <mi>X</mi></msub></mrow></mover><mi>P</mi><mi>X</mi><mover><mo>←</mo><mrow><msub><mi>χ</mi> <mn>0</mn></msub></mrow></mover><mn>1</mn><mspace width="2em"></mspace><mn>1</mn><mover><mo>→</mo><mrow><msub><mi>χ</mi> <mn>0</mn></msub></mrow></mover><mi>P</mi><mi>Y</mi><mover><mo>←</mo><mrow><msub><mi>σ</mi> <mi>Y</mi></msub></mrow></mover><mi>Y</mi></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle X \stackrel{\sigma_X}{\to} P X \stackrel{\chi_0}{\leftarrow} 1 \qquad 1 \stackrel{\chi_0}{\to} P Y \stackrel{\sigma_Y}{\leftarrow} Y</annotation></semantics></math></div>
<p>so it would be enough to show that each (or just one) of these two pullbacks is empty, let’s say the first.</p>

<p>Suppose given a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">h: A \to X</annotation></semantics></math> which makes the square</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable rowalign="center axis center"><mtr><mtd><mo lspace="0em" rspace="thinmathspace">A</mo></mtd> <mtd><mo>⟶</mo></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mpadded width="0" lspace="-100%width"><mstyle scriptlevel="1"><mi>h</mi></mstyle></mpadded><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><mpadded width="0"><mstyle scriptlevel="1"><mrow><msub><mi>χ</mi> <mn>0</mn></msub></mrow></mstyle></mpadded></mtd></mtr> <mtr><mtd><mi>X</mi></mtd> <mtd><munder><mo>⟶</mo><mrow><msub><mi>σ</mi> <mi>X</mi></msub></mrow></munder></mtd> <mtd><mi>P</mi><mi>X</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
\arrayopts{\rowalign{center axis center}}
\A &amp; \longrightarrow &amp; 1 \\
\mathllap{\scriptsize{h}} \downarrow &amp; &amp; \downarrow \mathrlap{\scriptsize{\chi_0}} \\
X &amp; \underset{\dlap{\sigma_X}}{\longrightarrow} &amp; P X
}
</annotation></semantics></math></div>
<p>commute. Using the pullback principle, the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mn>1</mn><mover><mo>→</mo><mrow><msub><mi>χ</mi> <mn>0</mn></msub></mrow></mover><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">A \to 1 \stackrel{\chi_0}{\to} P X</annotation></semantics></math> classifies</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>×</mo><mi>A</mi><mo>↪</mo><mi>X</mi><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">0 \times A \hookrightarrow X \times A</annotation></semantics></math></div>
<p>which is just the empty subset. This must be the same subset as classified by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>σ</mi> <mi>X</mi></msub><mi>h</mi><mo>=</mo><msub><mi>χ</mi> <mi>δ</mi></msub><mi>h</mi></mrow><annotation encoding="application/x-tex">\sigma_X h = \chi_{\delta} h</annotation></semantics></math> (where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>X</mi><mo>↪</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\delta : X \hookrightarrow X \times X</annotation></semantics></math> is the diagonal), which by the pullback principle is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>×</mo><mi>h</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>δ</mi><mo stretchy="false">)</mo><mo>↪</mo><mi>X</mi><mo>×</mo><mi>A</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">(1_X \times h)^{-1}(\delta) \hookrightarrow X \times A.</annotation></semantics></math></div>
<p>An elementary calculation shows this to be the equalizer of the pair of maps</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mn>1</mn></msub><mo>,</mo><mi>h</mi><msub><mi>π</mi> <mn>2</mn></msub><mo>:</mo><mi>X</mi><mo>×</mo><mi>A</mi><mover><mo>→</mo><mo>→</mo></mover><mi>X</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">\pi_1, h\pi_2 : X \times A \stackrel{\to}{\to} X.</annotation></semantics></math></div>
<p>So this equalizer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> is empty. But notice that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>h</mi><mo>,</mo><mn>1</mn><mo stretchy="false">⟩</mo><mo>:</mo><mi>A</mi><mo>→</mo><mi>X</mi><mo>×</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\langle h, 1 \rangle : A \to X \times A</annotation></semantics></math> equalizes this pair of maps. Therefore we have a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>E</mi><mo>≅</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A \to E \cong 0</annotation></semantics></math>. By Corollary 2 above, we infer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≅</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A \cong 0</annotation></semantics></math>. This applies to the case where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is the pullback, so the pullback is empty, as was to be shown.</p>
</div>

<p><strong>Theorem 4.</strong> Any two disjoint unions of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X, Y</annotation></semantics></math> are canonically isomorphic.</p>

<div class="proof">
<h6 id="proof_2">Proof</h6>

<p>Suppose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi><mo>←</mo><mi>Y</mi><mo>:</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i : X \rightarrow Z \leftarrow Y : j</annotation></semantics></math> is a disjoint union. Define a map</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>=</mo><mo stretchy="false">⟨</mo><msub><mi>ϕ</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>ϕ</mi> <mn>2</mn></msub><mo stretchy="false">⟩</mo><mo>:</mo><mi>Z</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">\phi = \langle \phi_1, \phi_2 \rangle : Z \to P X \times P Y</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mo>:</mo><mi>Z</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\phi_1 : Z \to P X</annotation></semantics></math> classifies the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>,</mo><mi>i</mi><mo stretchy="false">⟩</mo><mo>:</mo><mi>X</mi><mo>→</mo><mi>X</mi><mo>×</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">\langle 1_X, i \rangle : X \to X \times Z</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>2</mn></msub><mo>:</mo><mi>Z</mi><mo>→</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">\phi_2 : Z \to P Y</annotation></semantics></math> classifies the subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mn>1</mn> <mi>Y</mi></msub><mo>,</mo><mi>j</mi><mo stretchy="false">⟩</mo><mo>:</mo><mi>Y</mi><mo>→</mo><mi>Y</mi><mo>×</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">\langle 1_Y, j \rangle : Y \to Y \times Z</annotation></semantics></math>. Applying the pullback principle, the composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mi>i</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\phi_1 i : X \to P X</annotation></semantics></math> classifies</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>×</mo><mi>i</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mo stretchy="false">⟨</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>,</mo><mi>i</mi><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo>↪</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">(1_X \times i)^{-1}(\langle 1_X, i \rangle) \hookrightarrow X \times X</annotation></semantics></math></div>
<p>which is easily seen to be the diagonal on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. Hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mi>i</mi><mo>=</mo><msub><mi>σ</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\phi_1 i = \sigma_X</annotation></semantics></math>. On the other hand, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mi>j</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\phi_1 j : Y \to P X</annotation></semantics></math> classifies the subset</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>×</mo><mi>j</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mo stretchy="false">⟨</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>,</mo><mi>i</mi><mo stretchy="false">⟩</mo><mo stretchy="false">)</mo><mo>↪</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">(1_X \times j)^{-1}(\langle 1_X, i \rangle) \hookrightarrow X \times Y</annotation></semantics></math></div>
<p>which is empty because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math> are disjoint embeddings, so <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mi>j</mi><mo>=</mo><msub><mi>χ</mi> <mn>0</mn></msub><mo>:</mo><mi>Y</mi><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\phi_1 j = \chi_0 : Y \to P X</annotation></semantics></math>. Similar calculations yield</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>2</mn></msub><mi>i</mi><mo>=</mo><msub><mi>χ</mi> <mn>0</mn></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mi>Y</mi><mspace width="2em"></mspace><msub><mi>ϕ</mi> <mn>2</mn></msub><mi>j</mi><mo>=</mo><msub><mi>σ</mi> <mi>Y</mi></msub><mo>:</mo><mi>Y</mi><mo>→</mo><mi>P</mi><mi>Y</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">\phi_2 i = \chi_0 : X \to P Y \qquad \phi_2 j = \sigma_Y : Y \to P Y.</annotation></semantics></math></div>
<p>Putting all this together, we conclude that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mi>i</mi><mo>=</mo><msub><mi>i</mi> <mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">\phi i = i_X : X \to P X \times P Y</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mi>j</mi><mo>=</mo><msub><mi>i</mi> <mi>Y</mi></msub><mo>:</mo><mi>Y</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">\phi j = i_Y : Y \to P X \times P Y</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">i_X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">i_Y</annotation></semantics></math> were defined in the proof of Theorem 3.</p>

<p>Next, we show that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> is monic. If not, then by strong extensionality, there exist distinct elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>,</mo><mi>d</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">c, d : 1 \to Z</annotation></semantics></math> for which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(c) = \phi(d)</annotation></semantics></math>; therefore, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mi>c</mi><mo>=</mo><msub><mi>ϕ</mi> <mn>1</mn></msub><mi>d</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>P</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\phi_1 c = \phi_1 d : 1 \to P X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>2</mn></msub><mi>c</mi><mo>=</mo><msub><mi>ϕ</mi> <mn>2</mn></msub><mi>d</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>PY</mi></mrow><annotation encoding="application/x-tex">\phi_2 c = \phi_2 d : 1 \to PY</annotation></semantics></math>. By the pullback principle, these equations say (respectively)</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>c</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>d</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>↪</mo><mn>1</mn><mspace width="2em"></mspace><msup><mi>c</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>d</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>↪</mo><mn>1</mn><mo>.</mo></mrow><annotation encoding="application/x-tex"> c^{-1}(i) = d^{-1}(i) \hookrightarrow 1 \qquad c^{-1}(j) = d^{-1}(j) \hookrightarrow 1.</annotation></semantics></math></div>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>c</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c^{-1}(i) = 1</annotation></semantics></math>, then both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>,</mo><mi>d</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">c, d : 1 \to Z</annotation></semantics></math> factor through the mono <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">i : X \to Z</annotation></semantics></math>. However, since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mi>i</mi><mo>=</mo><msub><mi>i</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">\phi i = i_X</annotation></semantics></math> is monic, this would imply that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>≠</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi (c) \neq \phi (d)</annotation></semantics></math>, contradiction. Therefore <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>c</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>∩</mo><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c^{-1}(i) = c \cap i = 0</annotation></semantics></math>. By similar reasoning, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>∩</mo><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c \cap j = 0</annotation></semantics></math>. Therefore</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>⊆</mo><mo>¬</mo><mi>c</mi><mspace width="2em"></mspace><mi>j</mi><mo>⊆</mo><mo>¬</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">i \subseteq \neg c \qquad j \subseteq \neg c</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⇒</mo><mn>0</mn><mo stretchy="false">)</mo><mo>:</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\neg = (- \Rightarrow 0) : Sub(Z) \to Sub(Z)</annotation></semantics></math> is the negation operator. But then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>∪</mo><mi>j</mi><mo>⊆</mo><mo>¬</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">i \cup j \subseteq \neg c</annotation></semantics></math>. And since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>:</mo><mi>Z</mi><mo>↪</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">1 : Z \hookrightarrow Z</annotation></semantics></math> is the union <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>∪</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \cup j</annotation></semantics></math> by assumption, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">\neg c</annotation></semantics></math> must be the top element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo><mo>∈</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\top \in Sub(Z)</annotation></semantics></math>, whence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">c : 1 \to Z</annotation></semantics></math> is the bottom element 0. This contradicts the assumption that the topos is nondegenerate. Thus we have shown that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> must be monic.</p>

<p>The argument above shows that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>Z</mi><mo>↪</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">\phi : Z \hookrightarrow P X \times P Y</annotation></semantics></math> is an upper bound of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">i_X : X \to P X \times P Y</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>Y</mi></msub><mo>:</mo><mi>Y</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">i_Y : Y \to P X \times P Y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(P X \times P Y)</annotation></semantics></math>. It follows that the join <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X + Y</annotation></semantics></math> constructed in Theorem 3 is contained in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>Z</mi><mo>→</mo><mi>P</mi><mi>X</mi><mo>×</mo><mi>P</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">\phi : Z \to P X \times P Y</annotation></semantics></math>, and hence can be regarded as the join of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(Z)</annotation></semantics></math>. But <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> is their join in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub(Z)</annotation></semantics></math> by assumption of being a disjoint union, so the containment <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi><mo>⊆</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X + Y \subseteq Z</annotation></semantics></math> must be an equality. The proof is now complete.</p>
</div>

<p><strong>Theorem 5.</strong> The inclusions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">i_X : X \to X + Y</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mi>Y</mi></msub><mo>:</mo><mi>Y</mi><mo>→</mo><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">i_Y : Y \to X + Y</annotation></semantics></math> exhibit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X + Y</annotation></semantics></math> as the coproduct of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>.</p>

<div class="proof">
<h6 id="proof_3">Proof</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : X \to B</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mi>Y</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">g : Y \to B</annotation></semantics></math> be given functions. Then we have monos</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mn>1</mn> <mi>X</mi></msub><mo>,</mo><mi>f</mi><mo stretchy="false">⟩</mo><mo>:</mo><mi>X</mi><mo>↪</mo><mi>X</mi><mo>×</mo><mi>B</mi><mspace width="2em"></mspace><mo stretchy="false">⟨</mo><msub><mn>1</mn> <mi>Y</mi></msub><mo>,</mo><mi>g</mi><mo stretchy="false">⟩</mo><mo>:</mo><mi>Y</mi><mo>↪</mo><mi>Y</mi><mo>×</mo><mi>B</mi><mspace width="2em"></mspace><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\langle 1_X, f \rangle : X \hookrightarrow X \times B \qquad \langle 1_Y, g \rangle : Y \hookrightarrow Y \times B \qquad (1)</annotation></semantics></math></div>
<p>Now the operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>×</mo><mi>B</mi><mo>:</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">- \times B : Sub(C) \to Sub(C \times B)</annotation></semantics></math> certainly preserves finite meets, and also preserves finite joins because it is left adjoint to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∀</mo> <mi>B</mi></msub><mo>:</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Sub</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall_B : Sub(C \times B) \to Sub(C)</annotation></semantics></math>. Therefore this operation preserves disjoint unions; we infer that the monos</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mi>B</mi><mover><mo>→</mo><mrow><msub><mi>i</mi> <mi>X</mi></msub><mo>×</mo><mi>B</mi></mrow></mover><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>B</mi><mspace width="2em"></mspace><mi>Y</mi><mo>×</mo><mi>B</mi><mover><mo>→</mo><mrow><msub><mi>i</mi> <mi>Y</mi></msub><mo>×</mo><mi>B</mi></mrow></mover><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>B</mi><mspace width="2em"></mspace><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \times B \stackrel{i_X \times B}{\to} (X + Y) \times B \qquad Y \times B \stackrel{i_Y \times B}{\to} (X + Y) \times B \qquad (2)</annotation></semantics></math></div>
<p>exhibit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">(X + Y) \times B</annotation></semantics></math> as a disjoint union of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>×</mo><mi>B</mi><mo>,</mo><mi>Y</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">X \times B, Y \times B</annotation></semantics></math>. Composing the monos of (1) and (2), we have disjoint embeddings of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">(X + Y) \times B</annotation></semantics></math>. Using Theorem 4, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X + Y</annotation></semantics></math> is isomorphic to the join of these embeddings; this means we have an inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mn>1</mn><mo>,</mo><mi>h</mi><mo stretchy="false">⟩</mo><mo>:</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo>↪</mo><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\langle 1, h \rangle : X + Y \hookrightarrow (X + Y) \times B</annotation></semantics></math></div>
<p>whose restriction to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> yields <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>i</mi> <mi>X</mi></msub><mo>,</mo><mi>f</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle i_X, f \rangle</annotation></semantics></math> and whose restriction to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> yields <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><msub><mi>i</mi> <mi>Y</mi></msub><mo>,</mo><mi>g</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle i_Y, g \rangle</annotation></semantics></math>. Hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>:</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">h : X + Y \to B</annotation></semantics></math> extends <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>. It is the unique extension, for if there were two extensions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>,</mo><mi>h</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">h, h'</annotation></semantics></math>, then their equalizer would be an upper bound of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X, Y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sub</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sub((X + Y) \times B)</annotation></semantics></math>, contradicting the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>+</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X + Y</annotation></semantics></math> is the least upper bound. This completes the proof.</p>
</div>

<p>I think that’s enough for one day. I will continue to explore the categorical structure and logic of ETCS next time.</p>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on December 12, 2021 at 05:07:11.
    See the <a href="/nlab/history/Trimble+on+ETCS+III" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/Trimble+on+ETCS+III" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/10491/#Item_1">Discuss</a><span class="backintime"><a href="/nlab/revision/Trimble+on+ETCS+III/15" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/Trimble+on+ETCS+III" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/Trimble+on+ETCS+III" accesskey="S" class="navlink" id="history" rel="nofollow">History (15 revisions)</a>
  <a href="/nlab/show/Trimble+on+ETCS+III/cite" style="color: black">Cite</a>
  <a href="/nlab/print/Trimble+on+ETCS+III" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/Trimble+on+ETCS+III" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
