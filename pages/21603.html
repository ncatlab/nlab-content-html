
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      CompLF/HOAS in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1553353531" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1592003439" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span><br />
      CompLF/HOAS
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/11554/#Item_4" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
    <a href="/nlab/feeds" title="Subscribe to changes by Atom">Feeds</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#secondorder_formulation_of_rules'>Second-order formulation of rules</a></li>
<ul>
<li><a href='#miscellaneous'>Miscellaneous</a></li>
<li><a href='#equality'>Equality</a></li>
<li><a href='#identity'>Identity</a></li>
<li><a href='#functions'>Functions</a></li>
<li><a href='#intersection'>Intersection</a></li>
<li><a href='#subset'>Subset</a></li>
<li><a href='#computations'>Computations</a></li>
<li><a href='#booleans'>Booleans</a></li>
<li><a href='#per'>PER</a></li>
</ul>
<li><a href='#judgmentlevel_reasoning'>Judgment-level reasoning</a></li>
<ul>
<li><a href='#vs_reasoning_about_reflected_judgments'>Vs reasoning about Reflected Judgments</a></li>
<ul>
<li><a href='#open_vs_closed_terms'>Open vs “Closed Terms”</a></li>
<li><a href='#presuppositions'>Presuppositions</a></li>
<li><a href='#DiffPresup'>Type Expressions differing only in their Presuppositions</a></li>
<li><a href='#related_pairs_of_computations'>Related Pairs of Computations</a></li>
<li><a href='#lessons'>Lessons</a></li>
</ul>
<li><a href='#nonnegatable_types'>“Non-negatable” Types</a></li>
<ul>
<li><a href='#membership_in_a_type_formerly'>Membership in a Type (Formerly)</a></li>
<li><a href='#TpOK'>Type Validity</a></li>
<li><a href='#membership_in_a_type_sometimes'>Membership in a Type (Sometimes)</a></li>
</ul>
<li><a href='#combined_truth'>Combined Truth</a></li>
<ul>
<li><a href='#CombElim'>Elimination into Combined Truth</a></li>
</ul>
<li><a href='#IdType'>Identity</a></li>
</ul>
<li><a href='#CheckingMode'>Checking Mode</a></li>
<ul>
<li><a href='#basics'>Basics</a></li>
<li><a href='#functions_2'>Functions</a></li>
<li><a href='#caveat'>Caveat</a></li>
</ul>
<li><a href='#strengthening_type_validity'>Strengthening Type Validity</a></li>
<ul>
<li><a href='#TpV'>Type Validity</a></li>
<li><a href='#custom_presuppositions'>Custom Presuppositions</a></li>
</ul>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>The <a class="existingWikiWord" href="/nlab/show/CompLF+v1">rules of CompLF</a> have been designed so that <a class="existingWikiWord" href="/nlab/show/structural+rules">structural rules</a> (e.g. weakening and substitution) are admissible, and the remaining rules can be expressed as higher-order abstract syntax (HOAS) axioms in <a class="existingWikiWord" href="/nlab/show/logical+frameworks">logical frameworks</a> like <a class="existingWikiWord" href="/nlab/show/LF">LF</a> or <a class="existingWikiWord" href="/nlab/show/Isabelle">Isabelle</a>/Pure. (Except the variable rule, which isn’t needed in HOAS form.) This is a significant (but superficial) difference from Nuprl. Two major interesting things happen with this HOAS formulation of CompLF.</p>

<p>First, the HOAS formulation highlights a connection between dependent type systems and partial logic. The connection is there for all dependent type systems formulated as deductive systems with judgments on raw terms (untyped <span class="newWikiWord">abstract syntax<a href="/nlab/new/abstract+syntax">?</a></span> trees), but Nuprl-like systems make more use of the connection than most.</p>

<p>Second, although the rules are not algorithmic, there is implicit propagation of type validity facts in the semantics, which is analogous to the type propagation of a dependent type checker. The primitive typing judgment form (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) outputs validity of the type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>). But using the inversion rules, it’s possible to derive rules for a defined typing judgment form that inputs type validity. This will hopefully be useful for verifying a bidirectional proof checker for CompLF and similar systems.</p>

<h2 id="secondorder_formulation_of_rules">Second-order formulation of rules</h2>

<p>This section repeats some of the rules of v1 in HOAS style, since variables and substitution (of terms) are technically expressed differently. For convenience, here is the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Nat</mi></mrow><annotation encoding="application/x-tex">Nat</annotation></semantics></math> elimination rule from <a class="existingWikiWord" href="/nlab/show/CompLF+v1">v1</a>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>n</mi><mo>⊩</mo><mi>Nat</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>zro</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>,</mo><mi>h</mi><mo>:</mo><mi>C</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>suc</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
\Gamma \vdash n \Vdash Nat \qquad
\Gamma,x:Nat \vdash C\,type \\
\Gamma \vdash c \Vdash C[zro/x] \\
\Gamma,x:Nat,h:C \vdash c \Vdash C[suc(x)/x]
\end{array}}
{\Gamma \vdash c \Vdash C[n/x]}
</annotation></semantics></math></div>
<p>And here it is in a traditional HOAS form:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>natElim</mi><mspace width="thinmathspace"></mspace><mo>:</mo><mspace width="thinmathspace"></mspace><mo>∀</mo><mi>n</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>C</mi><mo>.</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⊩</mo><mi>Nat</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⊩</mo><mi>Nat</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo></mrow><annotation encoding="application/x-tex">natElim\,:\,\forall n,c,C.(n \Vdash Nat) \Rightarrow
(\forall x.(x \Vdash Nat) \Rightarrow (C(x)\,type)) \Rightarrow</annotation></semantics></math><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>zro</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>,</mo><mi>h</mi><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⊩</mo><mi>Nat</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>h</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>suc</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\qquad (c \Vdash C(zro)) \Rightarrow
(\forall x,h.(x \Vdash Nat) \Rightarrow (h \Vdash C(x)) \Rightarrow (c \Vdash C(suc(x)))) \Rightarrow</annotation></semantics></math><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\qquad (c \Vdash C(n))</annotation></semantics></math></p>

<p>So in the HOAS formulation of rules, the judgment forms are atomic relation symbols in a predicate logic, and the rules are axioms. Note that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in this example rule is a <em>function</em> in the HOAS formulation. But it’s a function of the metalanguage, not of the object language. When rules quantify over functions, that’s second-order quantification.</p>

<p>Translating ordinary rules into HOAS lands in a second-order fragment. There’s a somewhat standard notation for rules of this fragment, which leaves the quantifiers implicit, and more resembles ordinary rules. (Meta)variables “declared” to the left of a turnstile in a “premise” are quantified just in that premise; the rest are quantified at the outside of the rule. Note that all the premise-local quantifiers only quantify over terms, which is first-order. Here is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>natElim</mi></mrow><annotation encoding="application/x-tex">natElim</annotation></semantics></math> in this “second-order” notation:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>n</mi><mo>⊩</mo><mi>Nat</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>zro</mi><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>x</mi><mo>:</mo><mi>Nat</mi><mo>,</mo><mi>h</mi><mo>:</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>suc</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}
n \Vdash Nat \qquad
x:Nat \vdash C[x]\,type \\
c \Vdash C[zro] \\
x:Nat,h:C[x] \vdash c \Vdash C[suc(x)]
\end{array}}
{c \Vdash C[n]}
</annotation></semantics></math></div>
<p>Much nicer, right? Note that the variable declarations effect both a quantifier and a typing hypothesis. So the special status of typing judgments working like context entries is built into the notation.</p>

<p>The rest of the rules we repeat in HOAS form will be given now in this second-order notation. Many rules will not be repeated because there’s no guesswork in translating them.</p>

<h3 id="miscellaneous">Miscellaneous</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{a \Vdash A}{A\,type}</annotation></semantics></math></div>
<h3 id="equality">Equality</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>p</mi><mn>1</mn><mo>=</mo><mi>p</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">(</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo>′</mo><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{a \Vdash A}{q \Vdash p1 = p2 \in (a = a \in A)} \\
\\
\frac{p \Vdash a = a' \in A}{a \Vdash A} \\
\\
\frac{p \Vdash a = a' \in A \qquad
x:A \vdash C[x]\,type \qquad
c \Vdash C[a]}
{c \Vdash C[a']}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="identity">Identity</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>t</mi><mo>≡</mo><mi>t</mi><mo>′</mo><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>t</mi><mo>′</mo><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{p \Vdash t \equiv t' \qquad c \Vdash C[t]}{c \Vdash C[t']}</annotation></semantics></math></div>
<h3 id="functions">Functions</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>f</mi><mspace width="thinmathspace"></mspace><mi>a</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>=</mo><mi>f</mi><mo>′</mo><mspace width="thinmathspace"></mspace><mi>x</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>f</mi><mo>=</mo><mi>f</mi><mo>′</mo><mo>∈</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{A\,type \qquad x:A \vdash B[x]\,type}{\Pi x:A.B[x]\,type} \\
\\
\frac{\Pi x:A.B[x]\,type}{A\,type} \\
\\
\frac{\Pi x:A.B[x]\,type \qquad a \Vdash A}{B[a]\,type} \\
\\
\\
\frac{f \Vdash \Pi x:A.B[x] \qquad a \Vdash A}{f\,a \Vdash B[a]} \\
\\
\frac{A\,type \qquad
x:A \vdash p[x] \Vdash f\,x = f'\,x \in B[x]}
{q \Vdash f = f' \in \Pi x:A.B[x]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="intersection">Intersection</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>b</mi><mo>⊩</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mo>∩</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{b \Vdash \cap x:A.B[x] \qquad a \Vdash A}{b \Vdash B[a]} \\
\\
\frac{A\,type \qquad
x:A \vdash p[x] \Vdash b = b' \in B[x]}
{q \Vdash b = b' \in \cap x:A.B[x]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="subset">Subset</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>b</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><mrow><mi>a</mi><mo>⊩</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>a</mi><mo>⊩</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊢</mo><mi>c</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{x:A \vdash B[x]\,type \qquad
a \Vdash A \qquad b \Vdash B[a]}
{a \Vdash \{x:A | B[x]\}} \\
\\
\frac{a \Vdash \{x:A | B[x]\} \qquad
x:A,y:B[x] \vdash c[x] \Vdash C[x]}
{c[a] \Vdash C[a]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="computations">Computations</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>x</mi><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>Comp</mi></mrow><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>Comp</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>y</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>x</mi><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>h</mi><mo>:</mo><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⊢</mo><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo>,</mo><mi>h</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>c</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo>′</mo><mo stretchy="false">[</mo><mi>x</mi><mo>′</mo><mo stretchy="false">]</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mi>q</mi><mo>⊩</mo><mi>c</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo>′</mo><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{x:Comp \vdash b[x] \Vdash Comp}{\lambda x.b[x] \Vdash Comp} \\
\\
\frac{\begin{array}{l}
a \Vdash A \qquad
y:A \vdash C[y]\,type \\
x:Comp,x':Comp,h:(x = x' \in A) \vdash
p[x,x',h] \Vdash c[x] = c'[x'] \in C[x]
\end{array}}
{q \Vdash c[a] = c'[a] \in C[a]}
\end{gathered}
</annotation></semantics></math></div>
<h3 id="booleans">Booleans</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>b</mi><mo>⊩</mo><mi>Bool</mi><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>tru</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>fls</mi><mo stretchy="false">]</mo></mrow><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{b \Vdash Bool \qquad
c \Vdash C[tru] \qquad
c \Vdash C[fls]}
{c \Vdash C[b]}
</annotation></semantics></math></div>
<h3 id="per">PER</h3>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>x</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>x</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>R</mi><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>y</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>s</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊃</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>1</mn><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>y</mi><mn>1</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>2</mn><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>y</mi><mn>3</mn><mo>:</mo><mi>Comp</mi><mo>⊢</mo><mi>t</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">]</mo><mo>⊩</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊃</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>2</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">]</mo><mo>⊃</mo><mi>R</mi><mo stretchy="false">[</mo><mi>y</mi><mn>1</mn><mo>,</mo><mi>y</mi><mn>3</mn><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>p</mi><mo>⊩</mo><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mo stretchy="false">{</mo><mi>x</mi><mn>1</mn><mo>=</mo><mi>x</mi><mn>2</mn><mo stretchy="false">|</mo><mi>R</mi><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo>,</mo><mi>x</mi><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mtd></mtr> <mtr><mtd><mi>R</mi><mo stretchy="false">[</mo><mi>t</mi><mn>1</mn><mo>,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>h</mi><mo>:</mo><mi>R</mi><mo stretchy="false">[</mo><mi>t</mi><mn>1</mn><mo>,</mo><mi>t</mi><mn>2</mn><mo stretchy="false">]</mo><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi></mtd></mtr></mtable><mrow><mi>c</mi><mo>⊩</mo><mi>C</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\begin{array}{l}
x1:Comp,x2:Comp \vdash R[x1,x2]\,type \\
y1:Comp,y2:Comp \vdash s[y1,y2] \Vdash R[y1,y2] \supset R[y2,y1] \\
y1:Comp,y2:Comp,y3:Comp \vdash t[y1,y2,y3] \Vdash R[y1,y2] \supset R[y2,y3] \supset R[y1,y3]
\end{array}}
{\{x1 = x2 | R[x1,x2]\}\,type} \\
\\
\frac{\begin{array}{l}
p \Vdash t1 = t2 \in \{x1 = x2 | R[x1,x2]\} \\
R[t1,t2]\,type \\
h:R[t1,t2] \vdash c \Vdash C
\end{array}}
{c \Vdash C}
\end{gathered}
</annotation></semantics></math></div>
<h2 id="judgmentlevel_reasoning">Judgment-level reasoning</h2>

<p>Reasoning at the judgment level using this metalanguage is not as convenient as having a type checker for terms, or even as convenient as having a Nuprl-like proof refiner that extracts the realizers. But it’s very straightforward and expressive. It can be used to prove derived rules, and other facts about derivability that aren’t of the form to be rules. For example, you can show that adding a certain new rule would allow deriving a contradiction.</p>

<p>Many unusual phenomena of Nuprl-like systems become clearer when analyzed in terms of judgment-level reasoning.</p>

<h3 id="vs_reasoning_about_reflected_judgments">Vs reasoning about Reflected Judgments</h3>

<p>In Nuprl-like systems, the semantic judgments are reflected internally as squashed types, and can be reasoned about using propositions-as-types. The metalanguage gives us a way to reason about formal judgments. Aside from the ability to reason about “large” judgment forms like type validity, is this judgment-level reasoning actually different from internal reasoning? It turns out it is.</p>

<p>For example, consider the metalanguage formula:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math></div>
<p>The puzzle is to find, assuming (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">B\,type</annotation></semantics></math>), a type that’s provably inhabited if and only if that formula is derivable. In more detail, we want some metalanguage function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> such that:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>.</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mo>∃</mo><mi>p</mi><mo>.</mo><mi>p</mi><mo>⊩</mo><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall A,B.(A\,type) \Rightarrow (B\,type) \Rightarrow
((\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)) \Leftrightarrow (\exists p.p \Vdash R(A,B)))
</annotation></semantics></math></div>
<p>A couple of perhaps-plausible-looking solutions for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A,B)</annotation></semantics></math> are (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.(t \in A) \to (t \in B)</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mo>⊤</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:\top.(t \in A) \to (t \in B)</annotation></semantics></math>). But both of these are wrong. The first is too weak (you get left-to-right only) and the second is not even a type (which makes existence of an element too strong).</p>

<p>The metalanguage formula we’re trying to represent turns out to be asserting that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a subtype of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, since it can be read as a special case of the subsumption rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>t</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>t</mi><mo>⊩</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{t \Vdash A}{t \Vdash B}</annotation></semantics></math></div>
<p>So we can take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A,B)</annotation></semantics></math> to be (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>). In fact, the first wrong answer is what we called “inclusion” (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math>).</p>

<h4 id="open_vs_closed_terms">Open vs “Closed Terms”</h4>

<p>So how come (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.(t \in A) \to (t \in B)</annotation></semantics></math>) don’t correspond? I mean, the intuitive reason is that subtyping is not just member inclusion, it must also preserve equations. But what is the formal reason? We have the fact that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>p</mi><mo>.</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>p</mi><mo>⊩</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p.(a \Vdash A) \Leftrightarrow (p \Vdash a \in A)</annotation></semantics></math></div>
<p>so the difference between (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊩</mo></mrow><annotation encoding="application/x-tex">\Vdash</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math>) is not the mismatch. The mismatch turns out to be the quantifiers used.</p>

<p>It turns out (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.(t \in A) \to (t \in B)</annotation></semantics></math>) is inhabited if and only if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>Comp</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash Comp) \Rightarrow (t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>). So there’s an extra (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t \Vdash Comp</annotation></semantics></math>) requirement making inclusion weaker than subtyping.</p>

<p>If you think about how adequacy of a HOAS representation works, the metalanguage quantifiers over terms are quantifying over <em>open</em> terms, specifically. Meanwhile the object language quantifiers range over the elements of a type, and in the PER semantics, elements of types are represented by <em>closed</em> terms. The open terms behave differently because PER semantics also enforces respect for typed equality, and in the formal system, this requirement is implicit.</p>

<p>But equality at the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> type is just computational equivalence, which is respected by all the semantic judgments. So when dealing with computations, the implicit respect requirements are vacuous, and the metalanguage reasoning about arbitrary open terms closely resembles semantic reasoning about arbitrary closed terms. This might be part of the reason why <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> is sometimes glossed as the type of all closed terms, although this technically doesn’t make sense. (Semantically, many types contain all the closed terms, while syntactically, no type can rule out variables.)</p>

<p>Another reason for the intuition that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> is the type of closed terms is that there’s an admissible rule saying that any closed term has type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. (This rule cannot be represented in HOAS style without some modal trick. The proof is by structural induction on the term, and uses the appropriate computation formation rule in each case. The motive needs to be generalized in order to handle binding forms.)</p>

<p>Returning to the issue of subtyping vs inclusion, one could think of inclusion as the closed special case of subtyping. It’s only because of the restriction to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> that the (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t \in A) \to (t \in B)</annotation></semantics></math>) part corresponds to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>), as explained in the next section.</p>

<h4 id="presuppositions">Presuppositions</h4>

<p>So if quantifying over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> adds an undesired (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t \Vdash Comp</annotation></semantics></math>) requirement, quantifying over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math> seems closer, since the requirement (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mo>⊤</mo></mrow><annotation encoding="application/x-tex">t \Vdash \top</annotation></semantics></math>) is trivial. But in general, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>D</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:D.(t \in A) \to (t \in B)</annotation></semantics></math>) corresponds to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>D</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash D) \Rightarrow ((t \in A)\,type \wedge ((t \Vdash A) \Rightarrow (t \Vdash B)))</annotation></semantics></math>). With (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t \Vdash Comp</annotation></semantics></math>), (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">(t \in A)\,type</annotation></semantics></math>) is derivable, but in general, its derivability depends on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>

<p>So since (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mo>⊤</mo></mrow><annotation encoding="application/x-tex">t \Vdash \top</annotation></semantics></math>) is trivial, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mo>⊤</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:\top.(t \in A) \to (t \in B)</annotation></semantics></math>) corresponds to just (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \in A)\,type \wedge ((t \Vdash A) \Rightarrow (t \Vdash B))</annotation></semantics></math>), but the (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\forall t.(t \in A)\,type</annotation></semantics></math>) part is too strong. Due to relaxed equality, it’s saying that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> is basically the same as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊤</mo></mrow><annotation encoding="application/x-tex">\top</annotation></semantics></math>, which is usually not so.</p>

<p>The root of the problem is that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) is not interderivable with (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x:A \vdash f\,x \Vdash B[x]</annotation></semantics></math>) in general, but rather (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A\,type) \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>). From the perspective of <a class="existingWikiWord" href="/nlab/show/intrinsic+and+extrinsic+views+of+typing">intrinsic typing</a>, it doesn’t make sense to regard (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) as part of the <em>truth</em> of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>). Instead, it’s a “presupposition”: something that has to be true for (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) to even <em>make sense</em>.</p>

<p>The full presupposition of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) is (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type</annotation></semantics></math>). That (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f \Vdash \Pi x:A.B[x]</annotation></semantics></math>) is interderivable with (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A\,type) \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>), and not (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>), (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>⇒</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type \Rightarrow (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>), or something even weirder, is due to the “presupposition policy” the judgment forms are using. (Is there a better term for this?) (Technically, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mi>x</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi x:A.B[x])\,type \wedge (x:A \vdash f\,x \Vdash B[x])</annotation></semantics></math>) is also interderivable, but it redundantly checks (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">x:A \vdash B[x]\,type</annotation></semantics></math>).)</p>

<p>As a practical matter, presuppositions don’t validate themselves, so a proof assistant needs some policy on when/how they get validated. In Nuprl-like systems, the presuppositions are all instances of the type validity judgment. Although they generally cannot be checked automatically, as mentioned in the <a href="#idea">idea section</a>, propagation of type validity resembles type propagation in a type checker. Presuppositions of judgments and a policy for handling them are analogous to (arguably even an instance of) <em>free logics</em>: predicate logics that support expressions that don’t necessarily denote. The case in type theory is the possibility of type expressions that don’t denote a valid type. Different styles of free logic turn out to correspond to different styles of type (validity) propagation, and provide a policy for handling presuppositions. This is discussed in more detail later. (TODO)</p>

<p>If the presuppositions can be checked automatically, the presupposition policy is not so visible to the user, but it’s still there. When trying to represent judgment-level assertions as types though, the details of the presupposition policy become important.</p>

<p>Getting back to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mo>⊤</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:\top.(t \in A) \to (t \in B)</annotation></semantics></math>) failing to correspond to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>), the problem is that the forms of implication generally don’t correspond, due to the implicit requirement to check that the type-level implication is a valid type. Assuming a <em>type</em> incurs an obligation to show that the expression is in fact a type, while assuming a <em>judgment</em> has no implicit obligation.</p>

<h4 id="DiffPresup">Type Expressions differing only in their Presuppositions</h4>

<p>It looks like the type-level assumption (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">(t \in A) \to ...</annotation></semantics></math>) is not going to work. Let’s take a closer look at what the solution (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) is doing instead. Subtyping was defined as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B\;\coloneqq\;(\lambda x.x) \in (A \to B)</annotation></semantics></math></p>

<p>Using the computation formation rules, we have (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo>⊩</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">\lambda x.x \Vdash Comp</annotation></semantics></math>). By assumption, we have (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">B\,type</annotation></semantics></math>), so by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> formation, we have (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">(A \to B)\,type</annotation></semantics></math>). Finally, equality formation gives us (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda x.x) \in (A \to B)</annotation></semantics></math>).</p>

<p>That this sort of representation is a type at all is actually the clever part. Using the representation of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>⊩</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \Vdash T</annotation></semantics></math>) as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">t \in T</annotation></semantics></math>), and the rules for functions, it’s now straightforward that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) represents (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)</annotation></semantics></math>).</p>

<p>But it seems like there’s a less tricky solution: (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>). Both (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) and this assume <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> itself, rather than (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">t \in A</annotation></semantics></math>). And that <em>is</em> the way you’re supposed to do it in type theory, after all. The standard wisdom is that typing judgments are not something you can assume. We have just covered in detail <em>why</em> that is still the case with Nuprl-like extensions.</p>

<p>(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>) does technically solve the problem: if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">B\,type</annotation></semantics></math>), then</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>p</mi><mo>.</mo><mo stretchy="false">(</mo><mo>∀</mo><mi>t</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>t</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>p</mi><mo>⊩</mo><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p.(\forall t.(t \Vdash A) \Rightarrow (t \Vdash B)) \Leftrightarrow (p \Vdash \Pi a:A.a \in B)</annotation></semantics></math></p>

<p>This implies that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>) is inhabited when it should be, and is squashed, moreover. There’s something disappointing about this solution though: while (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) is a type whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> are, validity of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>) entails that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a:A \vdash a \Vdash Relax(B)</annotation></semantics></math>). In other words, that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> equality is respected in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. This should only be a <em>consequence</em> of subtyping, not a <em>presupposition</em> of it.</p>

<p>Specifically,</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>⇔</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \lt\!\!:\;B)\,type \Leftrightarrow (A\,type \wedge (\underline{\;}:A \vdash B\,type))</annotation></semantics></math> and</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mo>⇔</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo>∧</mo><mo stretchy="false">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi a:A.a \in B)\,type \Leftrightarrow (A\,type \wedge (a:A \vdash a \Vdash Relax(B)))</annotation></semantics></math>.</li>
</ul>

<p>So these semantic judgments are true at the same time, but have different presuppositions. For the problem of representing semantic judgments as types, it seems that the moral of the story is to close off a term as much as possible before reasoning about membership, if you want to avoid presuppositions.</p>

<h4 id="related_pairs_of_computations">Related Pairs of Computations</h4>

<p>There is actually another solution though: the big-hammer approach of reasoning about pairs of computations: (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>t</mi><mo>:</mo><mi>Comp</mi><mo>.</mo><mi>Π</mi><mi>t</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi t:Comp.\Pi t':Comp.(t = t' \in A) \to (t = t' \in B)</annotation></semantics></math>). This representation makes it explicit that subtyping implies respect for equality. Thanks in part to the let-comp rule, this type is completely equivalent to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>): the presuppositions are the same, and they have the same PER.</p>

<h4 id="lessons">Lessons</h4>

<p>The puzzle of representing the subtyping judgment as a type operation has been chosen because the discussion of solutions, plausible false solutions, and partial solutions touches upon many important issues of judgment-level reasoning. Here is a summary of important lessons we tried to convey:</p>

<ul>
<li>The judgment forms that have interesting presuppositions are the <em>semantic</em> judgment forms, which are implemented as <em>type</em> operations.</li>

<li>The presupposition(s) of a semantic judgment represented as a type are simply the things you need to show in order to show that the type is valid.</li>

<li>The formal judgment forms don’t have interesting presuppositions; only that the expressions involved are syntactically well-formed, which can be checked while parsing.</li>

<li>Type-level implication (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math>) and judgment-level implication (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⇒</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \Rightarrow Y</annotation></semantics></math>) are not the same, even when the types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> represent the corresponding judgments <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, because of presuppositions.</li>

<li>Two type expressions can have the same meaning in case they’re both meaningful, but differ in their presuppositions, the conditions under which they’re meaningful.</li>

<li>Respect for typed equality is automatically enforced by “open” reasoning about arbitrary elements, but can/must be done manually when doing “closed” reasoning about computations.</li>
</ul>

<p>All but the last point also apply—via propositions-as-types—to a style of partial logic that <a class="existingWikiWord" href="/nlab/show/Peter+Aczel">Peter Aczel</a> called “Frege structures”. Partial logic is itself a style of free logic where propositions themselves are denoted by expressions, but well-formed expressions generally don’t denote propositions. Free logic, partial logic, Frege structures, and the connection to Nuprl-like systems are discussed below. (TODO!)</p>

<p>The last point—about respect for equality, except when dealing with elements of a particular type—seems very peculiar to PER semantics. You don’t need PER semantics to get those other “Frege phenomena”, and you don’t need PER semantics to get implicit respect for extensional equality, but the way they interact in PER semantics is quite extraordinary.</p>

<h3 id="nonnegatable_types">“Non-negatable” Types</h3>

<p>We have <a href="#DiffPresup">seen</a> that just because a judgment form is representable as a type operation doesn’t mean that that type operation gets you a valid type in all the situations you might want. In the most extreme case of this, the type is only meaningful when it’s true. In other words, the type presupposes itself. Karl Crary <a href="#KCThesis">called</a> these types “non-negatable”, since they’re intuitively either true or nonsense, never false. Assuming a non-negatable type with a type-level implication is guaranteed to be useless, since you must prove it in order to safely assume it.</p>

<h4 id="membership_in_a_type_formerly">Membership in a Type (Formerly)</h4>

<p>Crary’s main example of a non-negatable type was membership (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>). Membership is not non-negatable in Nuprl anymore, since Nuprl switched to a more liberal equality. It’s also not non-negatable in CompLF, which uses relaxed equality. Membership is still “harder to negate” than one might like, as we saw.</p>

<p>But in Martin-Löf type theory, and earlier versions of Nuprl, the equality semantic judgment/type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mn>1</mn><mo>=</mo><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a1 = a2 \in A</annotation></semantics></math>) presupposes (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mn>1</mn><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a1 \in A</annotation></semantics></math>) and (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a2 \in A</annotation></semantics></math>). Since the membership <em>type</em> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) is an abbreviation for equality (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a = a \in A</annotation></semantics></math>), it presupposed itself. (With membership non-negatable, Crary added subtyping as a primitive type constructor, or else it would’ve been non-negatable as well.)</p>

<h4 id="TpOK">Type Validity</h4>

<p>There is another semantic judgment which is still non-negatable: type validity. It’s kind of a weird trick that this judgment is representable as a type. (Coincidentally, Crary noticed the trick, and used it, arguing that it was more convenient than membership in an arbitrary universe.) It sounds like there’d be a size paradox, right? Well that’s why there’s probably nothing that can be done about the non-negatability.</p>

<p>So what’s the big trick? Basically, to use almost any trivially true proposition than mentions the type. We’ll use:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>A</mi><mo>⊃</mo><mo>⊤</mo></mrow><annotation encoding="application/x-tex">TpOK(A)\;\coloneqq\;A \supset \top</annotation></semantics></math></p>

<p>The trick is that it’s only “trivially true” when it’s a valid type, which requires that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a valid type. So it’s either true or nonsense; it’s non-negatable. We have:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>p</mi><mo>.</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>p</mi><mo>⊩</mo><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p.(A\,type) \Leftrightarrow (p \Vdash TpOK(A))</annotation></semantics></math></p>

<p>The right-to-left direction crucially relies on the sanity rule (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \Vdash A) \Rightarrow (A\,type)</annotation></semantics></math>) and an inversion rule.</p>

<h4 id="membership_in_a_type_sometimes">Membership in a Type (Sometimes)</h4>

<p>Although membership is not <em>always</em> non-negatable anymore, because (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) presupposes (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \Vdash Relax(A)</annotation></semantics></math>), it’s still non-negatable whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> are the same. This is precisely when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. (And in that case, Nuprl’s (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">A \cup Comp</annotation></semantics></math>) would be the same as well, so Nuprl’s membership would also be non-negatable.)</p>

<h3 id="combined_truth">Combined Truth</h3>

<p>Hopefully, the <a href="#TpOK">representability of type validity</a> shows better what’s “really” going on with representability of judgment forms. When truth of a squashed type is used at the judgment level, it’s not just the intuitive truth—which <em>presupposes</em> validity—that’s being used; it’s some “combined truth”, which <em>implies</em> validity, via the sanity rule.</p>

<p>When assuming the truth of a type using type-level implication, you assume the usual truth, and presuppositions are accumulated. But when assuming the truth of a type using judgment-level implication, you assume combined truth. Keep in mind that the derivation rules themselves are all assertions of judgment-level implications, and are thus working with combined truth.</p>

<p>So technically, combined truth comes from the (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) formal judgment form, when we only really care about whether <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is inhabited. In general, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> is an element of it. Meanwhile the type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) intuitively says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> is an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, <em>presupposing</em> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \Vdash Relax(A)</annotation></semantics></math>). Since the latter <em>implies</em> that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math>—and therefore <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>—are types, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) indirectly presupposes that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type. Combined truth of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math>) combines its intuitive truth with its presuppositions, and thus ends up the same as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>).</p>

<p>As for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpOK(A)</annotation></semantics></math>, the intuitive truth is vacuous, and the presupposition is basically just that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type, so the combined truth of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpOK(A)</annotation></semantics></math> says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type.</p>

<h4 id="CombElim">Elimination into Combined Truth</h4>

<p>Some of the elimination rules do not have a premise requiring that the elimination motive be a valid type family. The substitution instance of the motive appearing in the conclusion still must be a valid type, due to combined truth. But the validity of that substitution instance follows from the validity of substitution instances obtained from the premises.</p>

<p>This is the case for identity elimination (rewrite), subset elimination, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> elimination, and PER comprehension elimination. Although they’re ostensibly not eliminating anything, the direct computation rules are similar in that they can be used to rewrite with beta conversion in any typing goal.</p>

<p>Because combined truth allows many semantic judgment forms—even <a href="#TpOK">type validity</a>—to be represented as typing judgments, these “combined elimination” principles are stronger than they may look.</p>

<p>A common problem with the representation of judgment forms as type operations is the reliance on combined truth, which means that presuppositions are carrying some or all of the weight, but they don’t get propagated in the same way as ordinary truth.</p>

<p>If an elimination rule requires a premise showing that the motive is a valid type family, the presupposition part of combined truth effectively has to be shown prior to the application of the rule. In other words, such ordinary elimination rules help to conclude ordinary truth only. But with a combined elimination rule, there is no motive validity premise, so the rule helps to conclude the combined truth of the motive.</p>

<p>Here are some consequences of combined elimination on represented judgments:</p>

<ul>
<li>You can beta convert in the subject of a typing judgment, not just the type.</li>

<li>You can beta convert in a type validity judgment.</li>

<li>Same goes for rewriting with an identity.</li>

<li>You can branch on a boolean in a valid type.</li>
</ul>

<p>That last one—type-level branching—is provided by the following derived rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>b</mi><mo>⊩</mo><mi>Bool</mi><mspace width="2em"></mspace><mi>T</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>F</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mo stretchy="false">(</mo><mi>b</mi><mspace width="thinmathspace"></mspace><mi>T</mi><mspace width="thinmathspace"></mspace><mi>F</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{b \Vdash Bool \qquad T\,type \qquad F\,type}{(b\,T\,F)\,type}</annotation></semantics></math></div>
<p>This is shown by eliminating <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math> with the motive (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>≔</mo><mi>TpOK</mi><mo stretchy="false">(</mo><mi>x</mi><mspace width="thinmathspace"></mspace><mi>T</mi><mspace width="thinmathspace"></mspace><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C[x] \coloneqq TpOK(x\,T\,F)</annotation></semantics></math>). Since type validity is non-negatable, we would not be able to show this motive to be valid except by proving each case. But proving each case is exactly why we want to use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> elimination in the first place! So without the combined elimination, we’d be in an infinite regress. As for proving each case, it goes by beta reducing the applied Church boolean, yielding one of the premises.</p>

<h3 id="IdType">Identity</h3>

<p>(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>=</mo><mi>t</mi><mn>2</mn><mo>∈</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t1 = t2 \in Comp</annotation></semantics></math>) intuitively says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computationally equivalent. But it presupposes that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computations, so the combined truth is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are the same computation.</p>

<p>The identity type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>≡</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t1 \equiv t2</annotation></semantics></math>) also says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computationally equivalent, but the presupposition has been weakened, so that combined truth does <em>not</em> imply that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computations.</p>

<p>Because computational equivalence does not respect typed equality, except for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> type (and its subtypes), (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>≡</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t1 \equiv t2</annotation></semantics></math>) is not generally a type unless <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computations. That is, it’s only a type family over a pair of computations. But surprisingly, some instances of identity are valid types although <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are not computations. In particular, if the terms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">t1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t2</annotation></semantics></math> are computationally equivalent, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mn>1</mn><mo>≡</mo><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t1 \equiv t2</annotation></semantics></math>) is (combined) true.</p>

<p>That identity is often not known to be a type doesn’t get in the way of assuming it with <em>judgment-level</em> implication. For example, you can prove derived rules showing that identity is symmetric and transitive. Indeed, identity is in some sense the “real” equality of judgment-level reasoning: it’s intuitively a relation on <em>terms</em>, not elements of a type; it’s an equivalence relation; and it rewrites in any open type expression, not just valid type families.</p>

<p>(TODO: Explain how many presuppositions arise from intensional type equality, and that equality of identity types is extensional, making them valid when they’re pointwise true. Maybe on another page.)</p>

<h2 id="CheckingMode">Checking Mode</h2>

<p>The sanity rule says that the usual formal typing judgment (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) implies type validity (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>). This is analogous to the <em>admissible</em> sanity rule of unidirectional typing rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mspace width="thinmathspace"></mspace><mi>ctx</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mspace width="thinmathspace"></mspace><mo>:</mo><mspace width="thinmathspace"></mspace><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma\,ctx \qquad \Gamma \vdash a\,:\,A}{\Gamma \vdash A\,type}</annotation></semantics></math></div>
<p>In a unidirectional type checker, type validity being a conclusion of sanity goes well with the type expression itself being an output of the type checker. In a <a class="existingWikiWord" href="/nlab/show/bidirectional+typechecking">bidirectional type checker</a>, there are two modes: “synthesizing mode” inputs a term and (if it succeeds) outputs a type it has, and “checking mode” inputs a term and a type, and checks the term against the type.</p>

<p>Although CompLF’s primitive rules are not algorithmic, we can think of the typing judgment (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) as corresponding to the synthesizing mode of bidirectional typing, due to the sanity rule. This section defines another formal judgment form (metalanguage predicate) to correspond to the checking mode, and derives rules that propagate type validity bidirectionally.</p>

<h3 id="basics">Basics</h3>

<p>Here is the defined judgment:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \ni a\;\coloneqq\;(A\,type) \Rightarrow (a \Vdash A)</annotation></semantics></math></p>

<p>The intuition is that a derivation of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) includes a derivation of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">A\,type</annotation></semantics></math>), which is accessed using the sanity rule. So any rule that concludes with a judgment of form (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) is effectively outputting a derivation of type validity as well as typing.</p>

<p>By defining (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \ni a</annotation></semantics></math>) as an implication assuming type validity, a rule that concludes with a judgment of that form will be implicitly taking the type validity judgment as an extra premise, and inputting a derivation of it. (Intuitively, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \ni a</annotation></semantics></math>) inputs <em>and</em> outputs type validity, but it doesn’t matter because (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⇒</mo><mo stretchy="false">(</mo><mi>X</mi><mo>∧</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \Rightarrow (X \wedge Y)</annotation></semantics></math>) is equivalent to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⇒</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \Rightarrow Y</annotation></semantics></math>).)</p>

<p>So synthesizing mode (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>) outputs type validity, while checking mode (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \ni a</annotation></semantics></math>) inputs it. We can immediately derive the rules that change direction:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>A</mi><mo>∋</mo><mi>a</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{a \Vdash A}{A \ni a} \qquad
\frac{A\,type \qquad A \ni a}{a \Vdash A}
</annotation></semantics></math></div>
<p>The rule on the left has type validity coming in from both directions. For algorithmic rules, the types themselves would be coming in, and they would need to be compared. The rule here would just mean to check that they’re syntactically equal, and an algorithm for dependent type checking would usually do something much smarter. But since these rules are not algorithmic, we just do the stupid thing for illustration purposes.</p>

<p>The rule on the right explicitly takes type validity, and propagates it out in both directions. In algorithmic rules, the type itself would need to be given to the rule via a type annotation on the term in the conclusion.</p>

<p>Here’s a more interesting direction change rule using subsumption:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>t</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi><mo>∋</mo><mi>p</mi></mrow><mrow><mi>B</mi><mo>∋</mo><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{t \Vdash A \qquad A \lt\!\!:\;B \ni p}{B \ni t}</annotation></semantics></math></div>
<p>Deriving this rule, we receive the validity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> from the first premise, and the validity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> from the conclusion, form the validity of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;B</annotation></semantics></math>) in order to use the second premise, which lets us change <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> from an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> to a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>

<h3 id="functions_2">Functions</h3>

<p>With a unidirectional type checker (that does not use nonlocal inference), lambdas need a type annotation for the function domain. This corresponds to the type validity premise in the (derived) lambda rule of CompLF:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{A\,type \qquad x:A \vdash b[x] \Vdash B[x]}{\lambda x.b[x] \Vdash \Pi x:A.B[x]}</annotation></semantics></math></div>
<p>As with bidirectional type checking, we can avoid this by making the rule checking mode:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∋</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∋</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x:A \vdash B[x] \ni b[x]}{\Pi x:A.B[x] \ni \lambda x.b[x]}</annotation></semantics></math></div>
<p>Note that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∋</mo><mi>b</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x:A \vdash B[x] \ni b[x]</annotation></semantics></math>) is notation for (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∀</mo><mi>x</mi><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⊩</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⇒</mo><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∋</mo><mi>b</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall x.(x \Vdash A) \Rightarrow (B(x) \ni b(x))</annotation></semantics></math>). That is, context entries are always synthesizing mode in our notation.</p>

<p>The unidirectional rule for function application receives two candidates for the domain of the function: one from the function itself, one from the argument. So it needs to compare them. The bidirectional rule eliminates (or at least postpones) this check by using checking mode on the argument. We can derive an analogous rule for CompLF:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>f</mi><mo>⊩</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"></mspace><mi>A</mi><mo>∋</mo><mi>a</mi></mrow><mrow><mi>f</mi><mspace width="thinmathspace"></mspace><mi>a</mi><mo>⊩</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{f \Vdash \Pi x:A.B[x] \qquad A \ni a}{f\,a \Vdash B[a]}</annotation></semantics></math></div>
<p>(TODO: Put up more rules)</p>

<h3 id="caveat">Caveat</h3>

<p>When reasoning at the judgment level, the bidirectional rules don’t actually seem to make most things easier, and they make many things less convenient. There are now two judgment forms for typing, making rules incompatible without manually switching directions. Avoiding type validity premises is <em>usually</em> not that helpful because those premises are usually easy, so it’s easier to just follow your nose through them than cleverly avoid them. Since a main point of judgment-level reasoning is to derive new rules, sticking to a bidirectional style tends to multiply the number of derived rules you want, creating extra work.</p>

<p>It seems like a better idea to postpone a serious attempt at a bidirectional rule set until you have an actual algorithm in mind. At that point, the defined checking mode judgment might make it much easier to prove sound those bidirectional rules you will actually use.</p>

<p>Sometimes though, even for judgment-level reasoning, bidirectional rules can avoid a large number of very silly subgoals, like when introducing an element of a deeply nested type. In this case, the unidirectional rules would make you prove many copies of the same type validity goals, and bidirectional rules are the perfect plumbing.</p>

<h2 id="strengthening_type_validity">Strengthening Type Validity</h2>

<p>Most of the primitive type constructors have inversions for their formation rules. When deriving rules for a new “type constructor” defined using PER comprehension, an extra trick or two are needed to get the inversion rules you want.</p>

<p>The reason why inversion rules are usually desirable when deriving a type constructor is that the elimination rules typically need to know that the subexpressions of the type being eliminated are well-typed. (Type subexpressions are valid; element subexpressions have the appropriate type.) These facts are proven when forming the type, so it’s only fair to be able to get back what you’ve paid for. Otherwise they would need to be proven again whenever applying an elimination rule. (This is assuming the derived rules are for the primitive typing judgment, where the introduction rules establish type validity. For <a href="#CheckingMode">checking mode</a> rules you would expect introduction rules to avoid that, but this also requires inversion rules.)</p>

<p>The PER comprehension type constructor itself does not have any formation inversion rules. Partially this is because a later version of CompLF may strengthen the introduction rules in a way that’s incompatible with the obvious inversion rules. But mostly this is because the inversion rules wouldn’t really help. It’s easier and more flexible to add your own type validity conditions than to take whatever falls out of the PER comprehension.</p>

<p>For example, suppose we’re deriving <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> types. We should start with the PER for a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> type:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><mi>p</mi><mo>=</mo><mi>p</mi><mo>′</mo><mo stretchy="false">|</mo><mo>∃</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo>′</mo><mo>,</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>.</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo>∧</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>′</mo><mo>∈</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>∧</mo><mi>p</mi><mo>≡</mo><mo stretchy="false">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">⟩</mo><mo>∧</mo><mi>p</mi><mo>′</mo><mo>≡</mo><mo stretchy="false">⟨</mo><mi>a</mi><mo>′</mo><mo>,</mo><mi>b</mi><mo>′</mo><mo stretchy="false">⟩</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma' x:A.B[x]\;\coloneqq\;\{p = p' | \exists a,a',b,b':Comp.a = a' \in A \wedge b = b' \in B[a] \wedge p \equiv \lang a,b \rang \wedge p' \equiv \lang a',b' \rang\}</annotation></semantics></math></p>

<p>Where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∃</mo></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math> was defined as a squashed subset, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\lang a,b \rang</annotation></semantics></math> is some encoding of ordered pairs, suppose.</p>

<p>We could try to derive the inversion rules</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Sigma' x:A.B[x]\,type}{A\,type} \qquad
\frac{\Sigma' x:A.B[x]\,type \qquad a \Vdash A}{B[a]\,type}
</annotation></semantics></math></div>
<p>for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Sigma'</annotation></semantics></math> somehow by pulling things out of that (relatively) complicated PER comprehension. But it’s easier to just define another type operation (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma x:A.B[x]</annotation></semantics></math>) to be just like (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Sigma' x:A.B[x]</annotation></semantics></math>), but only a valid type if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Pi x:A.B[x]</annotation></semantics></math>) is. (The choice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> over the other type constructors with the same validity conditions is arbitrary.)</p>

<h3 id="TpV">Type Validity</h3>

<p>We can define a utility type constructor to add a type validity condition to another type, while leaving its PER unmodified:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⊃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">TpV(A | B)\;\coloneqq\;TpOK(B) \supset A</annotation></semantics></math></p>

<p>Intuitively, we want some kind of validity-level conjunction, so it’s unintuitive that this definition uses implication (non-dependent intersection). But for validity, intersection <em>is</em> actually a conjunction. (That’s another way to see why type-level implications mess up reasoning about combined truth.)</p>

<p>If we used</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">{</mo><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo stretchy="false">|</mo><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>wrong</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpV(A | B)\;\coloneqq\;\{\underline{\;}:A | TpOK(B)\} \qquad (wrong)</annotation></semantics></math></p>

<p>it would only add the validity condition (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><munder><mspace width="thickmathspace"></mspace><mo>̲</mo></munder><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\underline{\;}:A \vdash B\,type</annotation></semantics></math>). And if we used</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∧</mo><mi>A</mi><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>wrong</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TpV(A | B)\;\coloneqq\;TpOK(B) \wedge A \qquad (wrong)</annotation></semantics></math></p>

<p>it would squash <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, so the PER would generally not be the same. (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpOK</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⊃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">TpOK(B) \supset A</annotation></semantics></math>) is not the only way to do it, but it seems like a good way to do it.</p>

<p>Here are the derived rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>a</mi><mo>⊩</mo><mi>TpV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{A\,type \qquad B\,type}{TpV(A | B)\,type} \\
\\
\frac{TpV(A | B)\,type}{A\,type} \qquad
\frac{TpV(A | B)\,type}{B\,type} \\
\\
\\
\frac{B\,type \qquad a \Vdash A}{a \Vdash TpV(A | B)} \\
\\
\frac{a \Vdash TpV(A | B)}{a \Vdash A}
\end{gathered}
</annotation></semantics></math></div>
<p>With <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math>, we can complete the definition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> types as suggested above:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpV</mi><mo stretchy="false">(</mo><mi>Σ</mi><mo>′</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">|</mo><mspace width="thickmathspace"></mspace><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma x:A.B[x]\;\coloneqq\;TpV(\Sigma' x:A.B[x]\;|\;\Pi x:A.B[x])</annotation></semantics></math></p>

<p>Combining the inversion rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>, we get the desired inversion rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>. Inversion rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Sigma'</annotation></semantics></math> are not needed at all. In general, there seems to be no use for inversion rules for PER comprehension.</p>

<h3 id="custom_presuppositions">Custom Presuppositions</h3>

<p>It would not be dependent type theory if types depended only on types. In the primitive type constructors, aside from the trick of <a href="#CombElim">type-level branching</a>, the only dependency comes from the equality types. But for the equality type to be valid, the terms only need to be elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> for the appropriate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. When types depend on elements, we might want type validity to require well-typedness of the terms. And who knows, we might also want all sorts of other requirements for validity of a derived type constructor. What kinds of requirements can be added to type validity?</p>

<p>Because type validity is a judgment form without any term witness, the most we could hope to pack into type validity is truth of an arbitrary squashed type. And it turns out we can indeed do that. We would like to add inhabitedness of a type as a condition to type validity in the same way that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math> added a type validity condition. It suffices to define a type whose validity <em>is</em> combined truth of some type, and then add that to an existing type with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TpV</mi></mrow><annotation encoding="application/x-tex">TpV</annotation></semantics></math>.</p>

<p>We define a type constructor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)</annotation></semantics></math>, which is a non-negatable version of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>. (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> doesn’t actually have to be squashed, but validity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)</annotation></semantics></math> will only imply <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>P</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor P \rfloor</annotation></semantics></math>.)</p>

<p>It should validate the following rules:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>p</mi><mo>⊩</mo><mi>P</mi></mrow><mrow><mi>q</mi><mo>⊩</mo><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>p</mi><mo>⊩</mo><mo stretchy="false">⌊</mo><mi>P</mi><mo stretchy="false">⌋</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{p \Vdash P}{q \Vdash PreSup(P)} \\
\\
\frac{PreSup(P)\,type}{p \Vdash \lfloor P \rfloor}
\end{gathered}
</annotation></semantics></math></div>
<p>It would be pretty straightforward to just add a primitive type constructor to do this. And it’s kind of just a lucky break that we don’t have to.</p>

<p><a href="#DiffPresup">Recall</a> that there’s a “bad” definition of subtyping as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi a:A.a \in B</annotation></semantics></math>). Well actually we’ll use (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∩</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>a</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\cap a:A.a \in B</annotation></semantics></math>), which is just as bad. It’s bad as a definition of subtyping because it has the excessively strong presupposition that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≺</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \prec B</annotation></semantics></math>). Due to the inversion rules and the rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math>, we can actually <em>use</em> this presupposition if we know the bad subtyping is a valid type. This seems to be the most interesting fact we can get out of the primitive inversion rules, so we should encode inhabitedness of a type in terms of respect for equality.</p>

<p>We can define a type constructor for “Diaconescu booleans” that quotients <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> down to a singleton if and only if some type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> is inhabited. In the <a class="existingWikiWord" href="/nlab/show/Diaconescu-Goodman-Myhill+theorem">Diaconescu-Goodman-Myhill theorem</a>, these conditionally quotiented booleans are used to encode a proposition as an equation.</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mi>TpV</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>b</mi><mn>1</mn><mo>=</mo><mi>b</mi><mn>2</mn><mo stretchy="false">|</mo><mi>b</mi><mn>1</mn><mo>=</mo><mi>b</mi><mn>2</mn><mo>∈</mo><mi>Bool</mi><mo>∨</mo><mo stretchy="false">(</mo><mi>P</mi><mo>∧</mo><mi>b</mi><mn>1</mn><mo>∈</mo><mi>Bool</mi><mo>∧</mo><mi>b</mi><mn>2</mn><mo>∈</mo><mi>Bool</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo stretchy="false">|</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">DiaBool(P)\;\coloneqq\;TpV(\{b1 = b2 | b1 = b2 \in Bool \vee (P \wedge b1 \in Bool \wedge b2 \in Bool)\} | P)</annotation></semantics></math></p>

<p>Our <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi></mrow><annotation encoding="application/x-tex">DiaBool</annotation></semantics></math>-ical trick is that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi><mo stretchy="false">(</mo><mo>⊤</mo><mo stretchy="false">)</mo><mo>≺</mo><mi>DiaBool</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">DiaBool(\top) \prec DiaBool(P)</annotation></semantics></math>) if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">⌊</mo><mi>P</mi><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor P \rfloor</annotation></semantics></math>. So we define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi></mrow><annotation encoding="application/x-tex">PreSup</annotation></semantics></math> as:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo>∩</mo><mi>b</mi><mo>:</mo><mi>DiaBool</mi><mo stretchy="false">(</mo><mo>⊤</mo><mo stretchy="false">)</mo><mo>.</mo><mi>b</mi><mo>∈</mo><mi>DiaBool</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)\;\coloneqq\;\cap b:DiaBool(\top).b \in DiaBool(P)</annotation></semantics></math></p>

<p>This definition was motivated by getting respect to mean the right thing, but as it turns out, subtyping and respect coincide for instances of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>DiaBool</mi></mrow><annotation encoding="application/x-tex">DiaBool</annotation></semantics></math>. (Since they all have the same computations, namely the booleans.) So <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PreSup</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PreSup(P)</annotation></semantics></math> is non-negatable, and satisfies the rules above.</p>

<h2 id="references">References</h2>

<ul>
<li id="KCThesis">Karl Crary, <em>Type-Theoretic Methodology for Practical Programming Languages</em>, 1998 PhD thesis (<a href="http://www.nuprl.org/KB/show.php?ShowPub=Cra98">web</a>, <a href="http://www.nuprl.org/documents/Crary/Thesis-TypeTheoretic.pdf">pdf</a>)</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on July 30, 2020 at 02:31:15.
    See the <a href="https://ncatlab.org/nlab/history/CompLF/HOAS" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/CompLF%2FHOAS" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><span class="backintime"><a href="/nlab/revision/CompLF%2FHOAS/20" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Back in time</a> (20 revisions)</span><a href="/nlab/show/diff/CompLF%2FHOAS" accesskey="C" class="navlink" id="see_changes" rel="nofollow">See changes</a><a href="/nlab/history/CompLF%2FHOAS" accesskey="S" class="navlink" id="history" rel="nofollow">History</a>
  <a href="https://ncatlab.org/nlab/show/CompLF/HOAS/cite" style="color: black">Cite</a>
  <a href="/nlab/print/CompLF%2FHOAS" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/tex/CompLF%2FHOAS" id="view_tex" rel="nofollow">TeX</a>
    <a href="/nlab/source/CompLF%2FHOAS" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
