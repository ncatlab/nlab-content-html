
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      partial recursive function in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1553353531" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1592003439" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span><br />
      partial recursive function
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/9991/#Item_9" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="constructivism_realizability_computability">Constructivism, Realizability, Computability</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a></strong>, <strong><a class="existingWikiWord" href="/nlab/show/realizability">realizability</a></strong>, <strong><a class="existingWikiWord" href="/nlab/show/computability">computability</a></strong></p>

<p><a class="existingWikiWord" href="/nlab/show/intuitionistic+mathematics">intuitionistic mathematics</a></p>

<p><a class="existingWikiWord" href="/nlab/show/propositions+as+types">propositions as types</a>, <a class="existingWikiWord" href="/nlab/show/proofs+as+programs">proofs as programs</a>, <a class="existingWikiWord" href="/nlab/show/computational+trinitarianism">computational trinitarianism</a></p>

<h3 id="constructive_mathematics">Constructive mathematics</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/topos">topos</a>, <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-topos">homotopy topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+form">canonical form</a>, <a class="existingWikiWord" href="/nlab/show/univalence">univalence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bishop+set">Bishop set</a>, <a class="existingWikiWord" href="/nlab/show/h-set">h-set</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/decidable+equality">decidable equality</a>, <a class="existingWikiWord" href="/nlab/show/decidable+subset">decidable subset</a>, <a class="existingWikiWord" href="/nlab/show/inhabited+set">inhabited set</a>, <a class="existingWikiWord" href="/nlab/show/subsingleton">subsingleton</a></p>
</li>
</ul>

<h3 id="realizability">Realizability</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+topos">realizability topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+model">realizability model</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/realizability+interpretation">realizability interpretation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/effective+topos">effective topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kleene%27s+first+algebra">Kleene's first algebra</a>, <a class="existingWikiWord" href="/nlab/show/Kleene%27s+second+algebra">Kleene's second algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/function+realizability">function realizability</a></p>
</li>
</ul>

<h3 id="computability">Computability</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/computability">computability</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computation">computation</a>, <a class="existingWikiWord" href="/nlab/show/computational+type+theory">computational type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+function">computable function</a>, <a class="existingWikiWord" href="/nlab/show/partial+recursive+function">partial recursive function</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+analysis">computable analysis</a>, <a class="existingWikiWord" href="/nlab/show/constructive+analysis">constructive analysis</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Type+Two+Theory+of+Effectivity">Type Two Theory of Effectivity</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+function+%28analysis%29">computable function (analysis)</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/exact+real+computer+arithmetic">exact real computer arithmetic</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+set">computable set</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/persistent+homology">persistent homology</a>, <a class="existingWikiWord" href="/nlab/show/effective+homology">effective homology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/computable+physics">computable physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Church-Turing+thesis">Church-Turing thesis</a></p>
</li>
</ul>
</div></div>

<h4 id="deduction_and_induction">Deduction and induction</h4>

<div class="hide"><div>
<p><strong><a class="existingWikiWord" href="/nlab/show/deductive+reasoning">deductive reasoning</a></strong>, <a class="existingWikiWord" href="/nlab/show/deduction">deduction</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sequent">sequent</a></p>

<p><a class="existingWikiWord" href="/nlab/show/hypothesis">hypothesis</a>/<a class="existingWikiWord" href="/nlab/show/context">context</a>/<a class="existingWikiWord" href="/nlab/show/antecedent">antecedent</a> <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_77a3b8c239221bcb6b2f5d78b1dd70489c654f80_1"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/conclusion">conclusion</a>/<a class="existingWikiWord" href="/nlab/show/consequence">consequence</a>/<a class="existingWikiWord" href="/nlab/show/succedent">succedent</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/logical+framework">logical framework</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/deductive+system">deductive system</a>,</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/natural+deduction">natural deduction</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/sequent+calculus">sequent calculus</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/inductive+reasoning">inductive reasoning</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/induction">induction</a>, <a class="existingWikiWord" href="/nlab/show/recursion">recursion</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a>, <a class="existingWikiWord" href="/nlab/show/higher+inductive+type">higher inductive type</a></p>
</li>
</ul></div></div>

<h4 id="foundations">Foundations</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundations">foundations</a></strong></p>

<h2 id="the_basis_of_it_all">The basis of it all</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/mathematical+logic">mathematical logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/first-order+logic">first-order logic</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/type+theory">type theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/material+set+theory">material set theory</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/ZFC">ZFC</a></li>

<li><a class="existingWikiWord" href="/nlab/show/ZFA">ZFA</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural set theory</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/ETCS">ETCS</a></li>

<li><a class="existingWikiWord" href="/nlab/show/SEAR">SEAR</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/universe">universe</a></p>
</li>
</ul>

<h2 id="foundational_axioms">Foundational axioms</h2>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/foundational+axiom">foundational axiom</a></strong></p>

<ul>
<li>
<p>basic constructions:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+cartesian+products">axiom of cartesian products</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+disjoint+unions">axiom of disjoint unions</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+the+empty+set">axiom of the empty set</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+fullness">axiom of fullness</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+function+sets">axiom of function sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+power+sets">axiom of power sets</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+quotient+sets">axiom of quotient sets</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/material+set+theory">material axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+extensionality">axiom of extensionality</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+foundation">axiom of foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+anti-foundation">axiom of anti-foundation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Mostowski%27s+axiom">Mostowski's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+pairing">axiom of pairing</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+transitive+closure">axiom of transitive closure</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+union">axiom of union</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/structural+set+theory">structural axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+materialization">axiom of materialization</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/axioms+of+choice">axioms of choice</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+countable+choice">axiom of countable choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+dependent+choice">axiom of dependent choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+excluded+middle">axiom of excluded middle</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+existence">axiom of existence</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+multiple+choice">axiom of multiple choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Markov%27s+axiom">Markov's axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/presentation+axiom">presentation axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/small+cardinality+selection+axiom">small cardinality selection axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+small+violations+of+choice">axiom of small violations of choice</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+weakly+initial+sets+of+covers">axiom of weakly initial sets of covers</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Whitehead%27s+principle">Whitehead's principle</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/large+cardinal+axioms">large cardinal axioms</a>:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+infinity">axiom of infinity</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+universes">axiom of universes</a></li>

<li><a class="existingWikiWord" href="/nlab/show/regular+extension+axiom">regular extension axiom</a></li>

<li><a class="existingWikiWord" href="/nlab/show/inaccessible+cardinal">inaccessible cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/measurable+cardinal">measurable cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/elementary+embedding">elementary embedding</a></li>

<li><a class="existingWikiWord" href="/nlab/show/supercompact+cardinal">supercompact cardinal</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Vop%C4%9Bnka%27s+principle">Vopěnka's principle</a></li>
</ul>
</li>

<li>
<p>strong axioms</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/axiom+of+separation">axiom of separation</a></li>

<li><a class="existingWikiWord" href="/nlab/show/axiom+of+replacement">axiom of replacement</a></li>
</ul>
</li>

<li>
<p>further</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/reflection+principle">reflection principle</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="removing_axioms">Removing axioms</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a></li>

<li><a class="existingWikiWord" href="/nlab/show/predicative+mathematics">predicative mathematics</a></li>
</ul>
<div>
<p>
  <a href="/nlab/edit/foundations+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#definition'>Definition</a></li>
<li><a href='#properties'>Properties</a></li>
<li><a href='#the_ackermann_function'>The Ackermann function</a></li>
<li><a href='#busy_beaver_function'>Busy Beaver function</a></li>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>A <strong>partial recursive function</strong> (often “<a class="existingWikiWord" href="/nlab/show/computable+function">computable function</a>”, but see there for disambiguation) is a <a class="existingWikiWord" href="/nlab/show/partial+function">partial function</a> of <a class="existingWikiWord" href="/nlab/show/natural+numbers">natural numbers</a> which can be <a class="existingWikiWord" href="/nlab/show/definition">defined</a> by an <a class="existingWikiWord" href="/nlab/show/algorithm">algorithm</a> or computer <a class="existingWikiWord" href="/nlab/show/program">program</a> (e.g., a <a class="existingWikiWord" href="/nlab/show/Turing+machine">Turing machine</a>), taking finitely many <a class="existingWikiWord" href="/nlab/show/natural+numbers">natural numbers</a> as inputs, and which on input may run forever, but otherwise eventually halts and returns a natural number as output.</p>

<p>This idea as described is vague until it is circumscribed by a specific notion of computer program (Turing machines, register machines, abaci, etc.). There is a standard article of faith called the “<a class="existingWikiWord" href="/nlab/show/Church-Turing+thesis">Church-Turing thesis</a>”, identifying functions on natural numbers that are algorithmically computable with those that are computable using a Turing machine (or some variant class of machines that is Turing-complete).</p>

<p>A purely mathematical definition of the intended class of functions is given below.</p>

<h2 id="definition">Definition</h2>

<div class="num_defn" id="recursive">
<h6 id="definition_2">Definition</h6>

<p>A <em>partial recursive function</em> is a <a class="existingWikiWord" href="/nlab/show/partial+function">partial function</a> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℕ</mi> <mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^k</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> (where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/set">set</a> of <a class="existingWikiWord" href="/nlab/show/natural+numbers">natural numbers</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k \geq 0</annotation></semantics></math> is finite) that belongs to the smallest <a class="existingWikiWord" href="/nlab/show/class">class</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> of partial functions that</p>

<ul>
<li>
<p>includes all <a class="existingWikiWord" href="/nlab/show/constant+functions">constant functions</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">1 \to \mathbb{N}</annotation></semantics></math>;</p>
</li>

<li>
<p>includes all <a class="existingWikiWord" href="/nlab/show/projection">projection</a> maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>i</mi></msub><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\pi_i: \mathbb{N}^k \to \mathbb{N}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i = 1, \ldots, k</annotation></semantics></math>;</p>
</li>

<li>
<p>includes the successor function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">s: \mathbb{N} \to \mathbb{N}</annotation></semantics></math>;</p>
</li>

<li>
<p>is closed under <a class="existingWikiWord" href="/nlab/show/composition">composition</a>: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mn>1</mn></msub><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>f</mi> <mi>n</mi></msub><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f_1: \mathbb{N}^{k} \to \mathbb{N}, \ldots, f_n: \mathbb{N}^{k} \to \mathbb{N}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>ℕ</mi> <mi>n</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g: \mathbb{N}^n \to \mathbb{N}</annotation></semantics></math> belong to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>, then so does <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>∘</mo><mo stretchy="false">(</mo><msub><mi>f</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>f</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g \circ (f_1, \ldots, f_n): \mathbb{N}^{k} \to \mathbb{N}</annotation></semantics></math>;</p>
</li>

<li>
<p>is closed under primitive <a class="existingWikiWord" href="/nlab/show/recursion">recursion</a>: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g: \mathbb{N}^k \to \mathbb{N}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>:</mo><msup><mi>ℕ</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">h: \mathbb{N}^{k+2} \to \mathbb{N}</annotation></semantics></math> belong to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>, then the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℕ</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N}^{k+1} \to \mathbb{N}</annotation></semantics></math> defined recursively by the equations (for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">y \in \mathbb{N}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo>∈</mo><msup><mi>ℕ</mi> <mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{x} \in \mathbb{N}^k</annotation></semantics></math>)</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(0, \mathbf{x}) = g(\mathbf{x})</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mspace width="thinmathspace"></mspace></mrow><annotation encoding="application/x-tex">\,</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo><mo>,</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(y+1, \mathbf{x}) = h(y, f(y, \mathbf{x}), \mathbf{x})</annotation></semantics></math></div>
<p>also belongs to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>;</p>
</li>

<li>
<p>is closed under minimization: given any <em><a class="existingWikiWord" href="/nlab/show/total+function">total</a></em> function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℕ</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N}^{k+1} \to \mathbb{N}</annotation></semantics></math> belonging to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>, the partial function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g: \mathbb{N}^k \to \mathbb{N}</annotation></semantics></math>, defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">g(\mathbf{x}) = c</annotation></semantics></math> iff <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(c, \mathbf{x}) = 0</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>d</mi><mo>,</mo><mstyle mathvariant="bold"><mi>x</mi></mstyle><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(d, \mathbf{x}) \gt 0</annotation></semantics></math> whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>d</mi><mo>≤</mo><mi>c</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \leq d \leq c-1</annotation></semantics></math>, also belongs to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>.</p>
</li>
</ul>
</div>

<div class="num_defn">
<h6 id="definition_3">Definition</h6>

<p>A <em>primitive recursive function</em> is a function that belongs to the smallest class of functions of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}^k \to \mathbb{N}</annotation></semantics></math> that contains constants, projection maps, the successor map, is closed under composition, and is closed under primitive recursion.</p>
</div>

<p>Clearly the primitive recursive functions are a subclass of partial recursive functions. Notice that primitive recursive functions are not merely partial functions, but actual (<em>total</em>) functions.</p>

<div class="num_remark" id="Lawvere">
<h6 id="remark">Remark</h6>

<p>Both the class of partial recursive functions and the class of primitive recursive functions yield <a class="existingWikiWord" href="/nlab/show/Lawvere+theories">Lawvere theories</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Th</mi><mo stretchy="false">(</mo><mi>Comp</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Th(Comp)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Th</mi><mo stretchy="false">(</mo><mi>PrimRec</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Th(PrimRec)</annotation></semantics></math>, where a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \to 1</annotation></semantics></math> of the Lawvere theory is a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><msup><mi>ℕ</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^k \to \mathbb{N}^1</annotation></semantics></math> belonging to the class. It is straightforward to check that in either case, the generating object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> of the Lawvere theory (or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> if you prefer) is a parametrized <a class="existingWikiWord" href="/nlab/show/natural+numbers+object">NNO</a> in that category: this is the essence of primitive recursion.</p>
</div>

<div class="num_defn">
<h6 id="definition_4">Definition</h6>

<p>A <em>recursive relation</em> (or what is more usual nowadays, a <em>computable relation</em>) is a subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℕ</mi> <mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^k</annotation></semantics></math> whose characteristic function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>χ</mi><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\chi: \mathbb{N}^k \to \{0, 1\}</annotation></semantics></math> is recursive. Similarly, a primitive recursive relation is a relation whose characteristic function is primitive recursive.</p>
</div>

<h2 id="properties">Properties</h2>

<p>We may build up a stock of functions and relations that are primitive recursive as follows. (All closure properties mentioned will clearly also apply to partial recursive functions and relations.)</p>

<ol>
<li>
<p>Addition, multiplication, and exponentiation on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math>. The factorial function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>↦</mo><mi>n</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">n \mapsto n!</annotation></semantics></math> is primitive recursive. Binomial coefficients.</p>
</li>

<li>
<p>The predecessor function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Pred</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">Pred: \mathbb{N} \to \mathbb{N}</annotation></semantics></math>, defined by the recursion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Pred</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Pred(0) = 0</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Pred</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">Pred(n+1) = n</annotation></semantics></math>.</p>
</li>

<li>
<p><em>Truncated subtraction</em>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mi>y</mi><mo>=</mo><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \stackrel{\cdot}{-} y = x - y</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≥</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \geq y</annotation></semantics></math>, else <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>, is primitive recursive. It is defined by the recursion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mn>0</mn><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \stackrel{\cdot}{-} 0 = x</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>Pred</mi><mo stretchy="false">(</mo><mi>x</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \stackrel{\cdot}{-} (y+1) = Pred(x \stackrel{\cdot}{-} y)</annotation></semantics></math>.</p>
</li>

<li>
<p>The distance function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{|x-y|} = (x \stackrel{\cdot}{-} y) + (y \stackrel{\cdot}{-} x)</annotation></semantics></math>. The function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha(x) = 1 \stackrel{\cdot}{-} x</annotation></semantics></math>; this is the characteristic function of the unary relation or predicate “equals zero”. So “equals zero” is a computable relation. So is “doesn’t equal zero”, since this has characteristic function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(\alpha(x))</annotation></semantics></math>.</p>
</li>

<li>
<p>Therefore the equality relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">{|x-y|} = 0</annotation></semantics></math> is a primitive recursive relation. So is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \lt y</annotation></semantics></math>, being the relation “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mi>x</mi></mrow><annotation encoding="application/x-tex">y \stackrel{\cdot}{-} x</annotation></semantics></math> doesn’t equal zero”. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a (primitive) recursive function, then its graph defined by the relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = f(x)</annotation></semantics></math> is a (primitive) recursive relation.</p>
</li>

<li>
<p>(Boolean combinations) Similarly, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is a primitive recursive relation (so that its characteristic function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">\chi_R</annotation></semantics></math> is primitive recursive), then so is its negation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\neg R</annotation></semantics></math>, since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mrow><mo>¬</mo><mi>R</mi></mrow></msub><mo>=</mo><mi>α</mi><mo stretchy="false">(</mo><msub><mi>χ</mi> <mi>R</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_{\neg R} = \alpha(\chi_R)</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math> are primitive recursive relations, so is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>∧</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P \wedge Q</annotation></semantics></math>, since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mrow><mi>P</mi><mo>∧</mo><mi>Q</mi></mrow></msub><mo>=</mo><msub><mi>χ</mi> <mi>P</mi></msub><mo>⋅</mo><msub><mi>χ</mi> <mi>Q</mi></msub></mrow><annotation encoding="application/x-tex">\chi_{P \wedge Q} = \chi_P \cdot \chi_Q</annotation></semantics></math>. Hence Boolean combinations of primitive recursive relations are primitive recursive.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x, y, \mathbf{z})</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(y)</annotation></semantics></math> are primitive recursive, so is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo>≔</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(y, \mathbf{z}) \coloneqq \sum_{x=0}^{h(y)} f(x, y, \mathbf{z})</annotation></semantics></math></div>
<p>and similarly with the sum replaced by a product. It follows that primitive recursive predicates are closed under <em>bounded quantification</em>; e.g., if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(x, y, \mathbf{z})</annotation></semantics></math> is a primitive recursive predicate and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math> is a primitive recursive function, then the predicate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math> defined by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∀</mo> <mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow></msub><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo>≔</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">⋀</mo> <mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>y</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(y, \mathbf{z}) = \forall_{0 \leq x \lt y} R(x, y, \mathbf{z}) \coloneqq \bigwedge_{x=0}^{y-1} R(x, y, \mathbf{z})</annotation></semantics></math></div>
<p>is primitive recursive since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>Q</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>y</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>χ</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi_Q(y, \mathbf{z}) = \prod_{x=0}^{y-1} \chi_R(x, y, \mathbf{z})</annotation></semantics></math>.</p>
</li>

<li>
<p>(Bounded least choice operator) If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(x, y, \mathbf{z})</annotation></semantics></math> is a primitive recursive relation and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math> is a primitive recursive function, then the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(y, \mathbf{z})</annotation></semantics></math> defined to be “the least <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \leq h(y)</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(x, y, \mathbf{z})</annotation></semantics></math> if such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> exists, else <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math>” is primitive recursive. Indeed,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></munderover><mo stretchy="false">(</mo><mi>x</mi><mo>⋅</mo><msub><mi>χ</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>w</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>χ</mi> <mrow><mo>¬</mo><mi>R</mi></mrow></msub><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>+</mo><mi>y</mi><mo>⋅</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></munderover><msub><mi>χ</mi> <mrow><mo>¬</mo><mi>R</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mstyle mathvariant="bold"><mi>z</mi></mstyle><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">f(y, \mathbf{z}) = [\sum_{x=0}^{h(y)} (x \cdot \chi_R(x, y, \mathbf{z}) \cdot (\prod_{w=0}^{x-1} \chi_{\neg R}(w, y, \mathbf{z}))] + y \cdot \prod_{x=0}^{h(y)} \chi_{\neg R}(x, y, \mathbf{z}).</annotation></semantics></math></div></li>

<li>
<p>(Pairing and unpairing) There is an isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℕ</mi> <mn>2</mn></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}^2 \to \mathbb{N}</annotation></semantics></math> in the Lawvere theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Th</mi><mo stretchy="false">(</mo><mi>PrimRec</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Th(PrimRec)</annotation></semantics></math>, i.e., there is a primitive recursive function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℕ</mi> <mn>2</mn></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N}^2 \to \mathbb{N}</annotation></semantics></math> with a primitive recursive inverse <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><msup><mi>ℕ</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">g: \mathbb{N} \to \mathbb{N}^2</annotation></semantics></math>. For example, take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> to be the function</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>↦</mo><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f: (m, n) \mapsto \binom{m+n+1}{2} + n</annotation></semantics></math></div>
<p>Its inverse <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> to the pair</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mi>a</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mn>1</mn></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>,</mo><mi>m</mi><mo>−</mo><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mi>a</mi><mover><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo></mover><mn>1</mn></mrow><mn>2</mn></mfrac><mo>)</mo></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \stackrel{\cdot}{-} (m - \binom{a \stackrel{\cdot}{-} 1}{2}+2), m - \binom{a \stackrel{\cdot}{-} 1}{2})</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> is the least element less than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m+2</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo>(</mo><mfrac linethickness="0"><mi>a</mi><mn>2</mn></mfrac><mo>)</mo></mrow><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\binom{a}{2} \gt m</annotation></semantics></math>. By the aforementioned properties, this <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> is manifestly primitive recursive.</p>
</li>
</ol>

<p>As a consequence of this last property, there exist primitive recursive <a class="existingWikiWord" href="/nlab/show/isomorphisms">isomorphisms</a> between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℕ</mi> <mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{N}^k</annotation></semantics></math> for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k \gt 0</annotation></semantics></math>. Since partial/primitive recursive functions are closed under composition, it is sufficient (and sometimes convenient) to consider only partial/primitive recursive functions on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> itself. (The exception is the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math>, but this is trivial, since every partial function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">1 \to \mathbb{N}</annotation></semantics></math> is recursive.)</p>

<div class="num_remark">
<h6 id="remark_2">Remark</h6>

<p>To show that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℕ</mi> <mn>2</mn></msup><mo>≅</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}^2 \cong \mathbb{N}</annotation></semantics></math> in the category of primitive recursive functions, it is not enough just to exhibit a primitive recursive bijection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℕ</mi> <mn>2</mn></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N}^2 \to \mathbb{N}</annotation></semantics></math>, because it is not true that every primitive recursive bijection possesses a primitive recursive inverse. In other words, it is not true that the forgetful functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Th</mi><mo stretchy="false">(</mo><mi>PrimRec</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">Th(PrimRec) \to Set</annotation></semantics></math> (see Remark <a class="maruku-ref" href="#Lawvere"></a>) reflects isomorphisms. See Example <a class="maruku-ref" href="#inverse"></a> below.</p>
</div>

<div class="num_remark">
<h6 id="remark_3">Remark</h6>

<p>Similarly, it is not always true that if a graph of a function is a primitive recursive relation, then the function itself is primitive recursive. (For example, the graph of the Ackermann function, discussed below, is a primitive recursive relation.) However, we do have a sample theorem as follows.</p>
</div>

<div class="num_theorem" id="bound">
<h6 id="theorem">Theorem</h6>

<p>If a graph of a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a primitive recursive relation, and if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>≤</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \leq g</annotation></semantics></math> for some primitive recursive <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is itself primitive recursive.</p>
</div>

<p>The proof can be roughly expressed as follows: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(x, y)</annotation></semantics></math> is the functional computable relation, then let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math> be the least <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>≤</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \leq g(x)</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(x, y)</annotation></semantics></math>. The bounded least choice property shows that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math> is primitive recursive.</p>

<p>The point hovering in the background is that there are some computable functions which grow faster (in fact, much much much faster) than any primitive recursive function. This underscores the important role of the minimization axiom for partial recursive functions, which allows unboundedly large searches to take place. Indeed, we have the following crucial fact:</p>

<div class="num_theorem" id="graph">
<h6 id="theorem_2">Theorem</h6>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>⊆</mo><msup><mi>N</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R \subseteq{N}^2</annotation></semantics></math> is a graph of a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> and is a recursive relation, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a (total) recursive function. (The converse holds by one of the properties listed above.)</p>
</div>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>According to the minimization axiom in Definition <a class="maruku-ref" href="#recursive"></a>, given that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>χ</mi> <mi>R</mi></msub><mo>:</mo><msup><mi>ℕ</mi> <mn>2</mn></msup><mo>→</mo><mo stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\chi_R: \mathbb{N}^2 \to \{0, 1\}</annotation></semantics></math> is a recursive function, the function that takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> to the least <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">y \in \mathbb{N}</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>−</mo><msub><mi>χ</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1 - \chi_R(x, y) = 0</annotation></semantics></math> is also recursive. But this function is simply <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>. This completes the proof.</p>
</div>

<div class="num_corollary">
<h6 id="corollary">Corollary</h6>

<p>The inverse of a recursive bijection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is also recursive.</p>
</div>

<div class="proof">
<h6 id="proof_2">Proof</h6>

<p>The graph of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a recursive relation, and so is the opposite graph, which is the graph of the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f^{-1}</annotation></semantics></math>. Apply the preceding theorem.</p>
</div>

<p>Before passing on to general recursive functions, it is good to have some idea of the scope of primitive recursive functions. Some examples:</p>

<ul>
<li>The function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>p</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">f(n) = p_n</annotation></semantics></math>, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> prime, is primitive recursive.</li>
</ul>

<h2 id="the_ackermann_function">The Ackermann function</h2>

<div class="num_defn">
<h6 id="definition_5">Definition</h6>

<p>For each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, we define a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub><mo>:</mo><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">A_n: \mathbb{N} \to \mathbb{N}</annotation></semantics></math> by</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">A_0(m) = 2 m</annotation></semantics></math>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>n</mi></msub><msup><mo stretchy="false">)</mo> <mi>m</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A_{n+1}(m) = (A_n)^m(1)</annotation></semantics></math></p>
</li>
</ul>

<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mi>m</mi></msup></mrow><annotation encoding="application/x-tex">f^m</annotation></semantics></math> denotes the composition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> copies of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>. The <strong>Ackermann function</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">A: \mathbb{N} \to \mathbb{N}</annotation></semantics></math> is defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>m</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(m) = A_m(m)</annotation></semantics></math>.</p>
</div>

<p>(The function is named after <a class="existingWikiWord" href="/nlab/show/Wilhelm+Ackermann">Wilhelm Ackermann</a>. There are several variations of this function around, and one common version actually puts <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A_0(m)=m+1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>n</mi></msub><msup><mo stretchy="false">)</mo> <mi>m</mi></msup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A_{n+1}(m)=(A_n)^m(f(1))</annotation></semantics></math>.)</p>

<p>We show that while each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math> is primitive recursive, the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> grows faster than any primitive recursive function on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math>, hence is not itself primitive recursive. It does however belong to the class of partial recursive functions.</p>

<p>By property 1 above, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math> is primitive recursive. Supposing that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math> is primitive recursive, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>=</mo><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\phi = A_{n+1}</annotation></semantics></math> is also primitive recursive because it satisfies the recursion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\phi(0) = 1</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(m+1) = A_n (\phi(m))</annotation></semantics></math>.</p>

<p>By induction one may easily show <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">A_n(1) = 2</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">A_n(2) = 4</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. We have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A_{n+1}(3) = A_n(A_n(A_n(1))) = A_n(A_n(2)) = A_n(4)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. The function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">A_1</annotation></semantics></math> gives <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> powers of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>, the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">A_2</annotation></semantics></math> gives tetrations (iterated exponentials stacked <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> high) of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>, the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>3</mn></msub></mrow><annotation encoding="application/x-tex">A_3</annotation></semantics></math> gives iterated tetrations, and so on.</p>

<p>Some routine inductions establish the following facts:</p>

<ul>
<li>For all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math> is strictly increasing, and with the sole exception of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A_0(0) = 0</annotation></semantics></math>, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>&lt;</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m \lt A_n(m)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>, i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math> is strictly inflationary in arguments <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m \gt 0</annotation></semantics></math>. We also have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>&lt;</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n \lt A_n(3)</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>.</li>
</ul>

<div class="num_lemma">
<h6 id="lemma">Lemma</h6>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N}^k \to \mathbb{N}</annotation></semantics></math> is primitive recursive, then there exists <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>≤</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1, \ldots, x_k) \leq A_n(\max \{3, x_1, \ldots, x_k\})</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_1, \ldots, x_k</annotation></semantics></math>. (We say <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is <strong>dominated</strong> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math>, for short.)</p>
</div>

<div class="proof">
<h6 id="proof_3">Proof</h6>

<p>In the case where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is constant with value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>, take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n=m</annotation></semantics></math>. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> the successor, use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n = 0</annotation></semantics></math>. For each projection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>i</mi></msub><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\pi_i: \mathbb{N}^k \to \mathbb{N}</annotation></semantics></math>, again use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n = 0</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub><mo>=</mo><msub><mi>π</mi> <mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>≤</mo><msub><mi>A</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">x_i = \pi_i(x_1, \ldots, x_k) \leq A_0(\max \{3, x_1, \ldots, x_k\}).</annotation></semantics></math></div>
<p>Now proceed by induction on the construction of primitive recursive functions. Given that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup></mrow><annotation encoding="application/x-tex">f: \mathbb{N}^k</annotation></semantics></math> is dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>g</mi> <mi>k</mi></msub><mo>:</mo><msup><mi>ℕ</mi> <mi>m</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g_1, \ldots, g_k: \mathbb{N}^m \to \mathbb{N}</annotation></semantics></math> are dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{n+1}</annotation></semantics></math>, we calculate that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>=</mo><mi>f</mi><mo>∘</mo><mo stretchy="false">(</mo><msub><mi>g</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>g</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>:</mo><msup><mi>ℕ</mi> <mi>m</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">h = f \circ (g_1, \ldots, g_k): \mathbb{N}^m \to \mathbb{N}</annotation></semantics></math> is dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{n+2}</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>h</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>g</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>g</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>g</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">}</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>m</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>.</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
h(x_1, \ldots, x_m) &amp; = &amp; f(g_1(x_1, \ldots, x_m), \ldots, g_k(x_1, \ldots, x_m)) \\ 
 &amp; \leq &amp; A_n(\max \{3, g_1(x_1, \dots, x_m), \ldots, g_k(x_1, \ldots, x_m)\}) \\ 
 &amp; \leq &amp; A_n(A_{n+1}(\max\{3, x_1, \ldots, x_m\})) \\ 
 &amp; = &amp; A_{n+1}(\max\{3, x_1, \ldots, x_m\} + 1) \\ 
 &amp; \leq &amp; A_{n+2}(\max\{3, x_1, \ldots, x_m\}). 
}
</annotation></semantics></math></div>
<p>And given that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>ℕ</mi> <mi>k</mi></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">g: \mathbb{N}^k \to \mathbb{N}</annotation></semantics></math> is dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{n+1}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>:</mo><msup><mi>ℕ</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">h: \mathbb{N}^{k+2} \to \mathbb{N}</annotation></semantics></math> is dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math>, if we define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>ℕ</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N}^{k+1} \to \mathbb{N}</annotation></semantics></math> by recursion by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(0, x_1, \ldots, x_k) = g(x_1, \ldots, x_k)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(y+1, x_1, \ldots, x_k) = h(y, f(y, x_1, \ldots, x_k), x_1, \ldots, x_k)</annotation></semantics></math>, we calculate that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{n+3}</annotation></semantics></math>, in two steps. First we claim</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>≤</mo><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">f(y, x_1, \ldots, x_k) \leq A_{n+1}(y + \max\{3, x_1, \ldots, x_k\}).</annotation></semantics></math></div>
<p>Indeed, this is true by assumption for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y=0</annotation></semantics></math>. And then</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><mi>y</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><mi>y</mi><mo>,</mo><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
f(y+1, x_1, \ldots, x_k) &amp; = &amp; h(y, f(y, x_1, \ldots, x_k), x_1, \ldots, x_k) \\ 
 &amp; \leq &amp; A_n(\max\{3, y, f(y, x_1, \ldots, x_k), x_1, \ldots, x_k)\}) \\ 
 &amp; \leq &amp; A_n(\max\{3, y, A_{n+1}(y + \max\{3, x_1, \ldots, x_k\}), x_1, \ldots, x_k\}) \\ 
 &amp; \leq &amp; A_n(A_{n+1}(y + \max\{3, x_1, \ldots, x_k\})) \\ 
 &amp; = &amp; A_{n+1}(y+1+\max\{3, x_1, \ldots, x_k\})
}
</annotation></semantics></math></div>
<p>which justifies the claim. Finally, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mn>2</mn><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≤</mo></mtd> <mtd><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>3</mn></mrow></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mi>y</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
f(y, x_1, \ldots, x_k) &amp; \leq &amp; A_{n+1}(y + \max\{3, x_1, \ldots, x_k\}) \\ 
 &amp; \leq &amp; A_{n+1}(2\max\{3, y, x_1, \ldots, x_k\}) \\ 
 &amp; \leq &amp; A_{n+1}(A_{n+2}(\max\{3, y, x_1, \ldots, x_k\})) \\ 
 &amp; = &amp; A_{n+2}(\max\{3, y, x_1, \ldots, x_k\} + 1) \\ 
 &amp; \leq &amp; A_{n+3}(\max\{y, x_1, \ldots, x_k\})
}
</annotation></semantics></math></div>
<p>so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>3</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{n+3}</annotation></semantics></math>. This completes the proof.</p>
</div>

<div class="num_corollary">
<h6 id="corollary_2">Corollary</h6>

<p>The Ackermann function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is not primitive recursive.</p>
</div>

<div class="proof">
<h6 id="proof_4">Proof</h6>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>x</mi><mo>↦</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A: x \mapsto A_x(x)</annotation></semantics></math> were recursive, then so would be the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>x</mi><mo>↦</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\phi: x \mapsto A_x(x) + 1</annotation></semantics></math>. In that case, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math> is dominated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math> for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n \geq 3</annotation></semantics></math>. We then arrive at the contradiction</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>max</mi><mo stretchy="false">{</mo><mn>3</mn><mo>,</mo><mi>n</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">A_n(n) + 1 = \phi(n) \leq A_n(\max\{3, n\}) = A_n(n).</annotation></semantics></math></div></div>

<div class="num_prop">
<h6 id="proposition">Proposition</h6>

<p>The <em>graph</em> of the Ackermann function <em>is</em> a primitive recursive relation.</p>
</div>

<div class="proof">
<h6 id="proof_5">Proof</h6>

<p>The rough idea is to let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math> bound the search for solutions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">A_x(y) = z</annotation></semantics></math>. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x, y \gt 0</annotation></semantics></math> we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A_x(y) = A_{x-1}(A_x(y-1)) = A_x(y')</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>′</mo><mo>≔</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y' \coloneqq A_x(y-1)</annotation></semantics></math>. We have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>′</mo><mo>&lt;</mo><msub><mi>A</mi> <mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><mo>′</mo><mo stretchy="false">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y' \lt A_{x-1}(y') = z</annotation></semantics></math>. Starting with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub><mo>=</mo><mi>y</mi><mo>&lt;</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y_0 = y \lt z</annotation></semantics></math>, iterate this procedure so that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>z</mi><mo>=</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><msub><mi>y</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>y</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mrow><mi>x</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>y</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>…</mi><mo>=</mo><msub><mi>A</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>y</mi> <mi>x</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><msub><mi>y</mi> <mi>x</mi></msub></mrow><annotation encoding="application/x-tex">z = A_x(y_0) = A_{x-1}(y_1) = A_{x-2}(y_2) = \ldots = A_0(y_x) = 2 y_x</annotation></semantics></math></div>
<p>with each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>y</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math> less than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math>. (Explicitly, the iteration is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>≔</mo><msub><mi>A</mi> <mrow><mi>x</mi><mo>−</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y_{i+1} \coloneqq A_{x-i}(y_i - 1)</annotation></semantics></math>.)</p>

<p>Thus, after disposing of some trivial low number cases, WLOG we may take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi><mo>&gt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">z \gt 4</annotation></semantics></math>, where the ternary predicate</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>z</mi><mo>&gt;</mo><mn>4</mn><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(z \gt 4) \wedge (A_x(y) = z)</annotation></semantics></math></div>
<p>is equivalent to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&gt;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&lt;</mo><mi>z</mi><mo stretchy="false">)</mo><mo>∧</mo><msub><mo>∃</mo> <mrow><msub><mi>y</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><msub><mi>y</mi> <mi>x</mi></msub><mo>&lt;</mo><mi>z</mi></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><mo>=</mo><msub><mi>y</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><msub><mo>∀</mo> <mrow><mi>i</mi><mo>&lt;</mo><mi>x</mi></mrow></msub><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>A</mi> <mrow><mi>x</mi><mo>−</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mn>2</mn><msub><mi>y</mi> <mi>x</mi></msub><mo>=</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x \gt 0) \wedge (y \gt 2) \wedge (x \lt z) \wedge \exists_{y_0, y_1, \ldots y_x \lt z} (y = y_0) \wedge (\forall_{i \lt x} y_{i+1} = A_{x-i}(y_i - 1)) \wedge (2 y_x = z)</annotation></semantics></math></div>
<p>where the quantifications are manifestly bounded by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math>. This shows that the ternary predicate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">A_x(y) = z</annotation></semantics></math> is primitive recursive.</p>

<p>From this it follows that the binary relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">A_x(x) = z</annotation></semantics></math> is also primitive recursive, as claimed.</p>
</div>

<p>Combining this result with Theorem <a class="maruku-ref" href="#graph"></a>, we have</p>

<div class="num_corollary">
<h6 id="corollary_3">Corollary</h6>

<p>The Ackermann function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>x</mi><mo>↦</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A: x \mapsto A_x(x)</annotation></semantics></math> is recursive.</p>
</div>

<div class="num_example" id="inverse">
<h6 id="example">Example</h6>

<p>Here we exhibit a primitive recursive bijection whose inverse is not primitive recursive. The graph <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = A_x(x)</annotation></semantics></math> of the Ackermann function is primitive recursive binary predicate, and the image <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy="false">{</mo><mi>y</mi><mo>:</mo><msub><mo>∃</mo> <mi>x</mi></msub><mi>y</mi><mo>=</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">I = \{y: \exists_x y = A_x(x)\}</annotation></semantics></math> is a primitive recursive unary predicate, because the existential quantifier is a bounded quantifier applied to a primitive recursive relation:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>I</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">⋁</mo> <mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>y</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo stretchy="false">[</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo stretchy="false">]</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">I = \bigvee_{x=0}^{y-1} [A_x(x) = y].</annotation></semantics></math></div>
<p>Observe that both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> and its complement <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>¬</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\neg I</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> are infinite.</p>

<p>For any infinite set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi><mo>⊆</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">J \subseteq \mathbb{N}</annotation></semantics></math>, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>J</mi></msub><mo>:</mo><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">p_J: \mathbb{N} \to \mathbb{N}</annotation></semantics></math> be the function taking <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> to the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> (with respect to the usual order <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">\lt</annotation></semantics></math>). For example, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>I</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>A</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_I(x) = A_x(x)</annotation></semantics></math>. Now define a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>ℕ</mi><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f: \mathbb{N} \to \mathbb{N}</annotation></semantics></math> by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>2</mn><msubsup><mi>p</mi> <mi>I</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mtd> <mtd><mtext>if</mtext><mspace width="thickmathspace"></mspace><mi>m</mi><mo>∈</mo><mi>I</mi></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>2</mn><msubsup><mi>p</mi> <mrow><mo>¬</mo><mi>I</mi></mrow> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mtd> <mtd><mtext>if</mtext><mspace width="thickmathspace"></mspace><mi>m</mi><mo>∈</mo><mo>¬</mo><mi>I</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
f(m) &amp; = &amp; 2p_I^{-1}(m) &amp; \text{if} \; m \in I \\ 
     &amp; = &amp; 2p_{\neg I}^{-1}(m) + 1 &amp; \text{if} \; m \in \neg I
}
</annotation></semantics></math></div>
<p>Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>2</mn><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(m) \leq 2m + 1</annotation></semantics></math> and the graph of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is primitive recursive, so by Theorem <a class="maruku-ref" href="#bound"></a>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a primitive recursive function. It is a bijection by construction. But <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f^{-1}</annotation></semantics></math> is not primitive recursive, because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>f</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>p</mi> <mi>I</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^{-1}(2x) = p_I(x) = A(x)</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is not primitive recursive.</p>
</div>

<h2 id="busy_beaver_function">Busy Beaver function</h2>

<h2 id="related_concepts">Related concepts</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/recursive+subset">recursive subset</a></li>
</ul>
<div>

<p><strong><a class="existingWikiWord" href="/nlab/show/computability">computability</a></strong></p>

<table><thead><tr><th></th><th>type I computability</th><th>type II computability</th></tr></thead><tbody><tr><td style="text-align: left;">typical domain</td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/natural+numbers">natural numbers</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Baire+space+%28computability%29">Baire space</a> of infinite sequences <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝔹</mi><mo>=</mo><msup><mi>ℕ</mi> <mi>ℕ</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{B} = \mathbb{N}^{\mathbb{N}}</annotation></semantics></math></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/computable+functions">computable functions</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/partial+recursive+function">partial recursive function</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/computable+function+%28analysis%29">computable function (analysis)</a></td></tr>
<tr><td style="text-align: left;">type of <a class="existingWikiWord" href="/nlab/show/computable+mathematics">computable mathematics</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/recursive+mathematics">recursive mathematics</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/computable+analysis">computable analysis</a>, <a class="existingWikiWord" href="/nlab/show/Type+Two+Theory+of+Effectivity">Type Two Theory of Effectivity</a></td></tr>
<tr><td style="text-align: left;">type of <a class="existingWikiWord" href="/nlab/show/realizability">realizability</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/number+realizability">number realizability</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/function+realizability">function realizability</a></td></tr>
<tr><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/partial+combinatory+algebra">partial combinatory algebra</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Kleene%27s+first+partial+combinatory+algebra">Kleene's first partial combinatory algebra</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Kleene%27s+second+partial+combinatory+algebra">Kleene's second partial combinatory algebra</a></td></tr>
</tbody></table>

</div>
<h2 id="references">References</h2>

<p>A standard textbook in recursive functions is</p>

<ul>
<li>Hartley Rogers, Jr., <em>Theory of recursive functions and effective computability</em>, McGraw-Hill, 1967.</li>
</ul>

<p>Quite a bit of the arrangement and proofs above were taken from clear and useful lecture notes of Stephen Simpson,</p>

<ul>
<li>Stephen G. Simpson, <em>Foundations of Mathematics</em> (Lecture Notes), October 1, 2009. (<a href="http://www.math.psu.edu/simpson/notes/fom.pdf">pdf</a>)</li>
</ul>

<p>Of course, there is always good old Wikipedia:</p>

<ul>
<li>Wikipedia, <em><a href="http://en.wikipedia.org/wiki/Computable_function">Computable function</a></em></li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on May  7, 2021 at 09:14:35.
    See the <a href="https://ncatlab.org/nlab/history/partial recursive function" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/partial+recursive+function" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/9991/#Item_9">Discuss</a><span class="backintime"><a href="/nlab/revision/partial+recursive+function/19" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/partial+recursive+function" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/partial+recursive+function" accesskey="S" class="navlink" id="history" rel="nofollow">History (19 revisions)</a>
  <a href="https://ncatlab.org/nlab/show/partial recursive function/cite" style="color: black">Cite</a>
  <a href="/nlab/print/partial+recursive+function" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/partial+recursive+function" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
