
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      differences between CompLF v0 and v1 in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      differences between CompLF v0 and v1
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/11544/#Item_3" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#admissibility_vs_soundness'>Admissibility vs Soundness</a></li>
<li><a href='#relaxed_equality'>Relaxed Equality</a></li>
<ul>
<li><a href='#greatest_type_respected'>Greatest type respected</a></li>
<li><a href='#greatest_partition_thats_a_superset'>Greatest partition that’s a superset</a></li>
<li><a href='#kleene_equality'>Kleene equality</a></li>
</ul>
<li><a href='#BetaConv'>Shortcut Beta Conversion</a></li>
<li><a href='#letcomp'>Let-Comp</a></li>
<li><a href='#natural_numbers_type'>Natural Numbers Type</a></li>
<li><a href='#IdType'>Identity Types</a></li>
<li><a href='#miscellaneous'>Miscellaneous</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>This article documents the differences between versions <a class="existingWikiWord" href="/nlab/show/CompLF+v0">zero</a> and <a class="existingWikiWord" href="/nlab/show/CompLF+v1">one</a> of <a class="existingWikiWord" href="/nlab/show/CompLF">CompLF</a>. It also provides pointers to explanations of some of the theory that enables some of these differences, which is perhaps surprisingly (disappointingly?) subtle and deep. It gets into the connection between meaning explanations and partial logic, and the practical advantage of intensionality at the judgment level of dependent type theory.</p>

<h2 id="admissibility_vs_soundness">Admissibility vs Soundness</h2>

<p>One of the most important differences between v0 and v1 is that many of the rules that are merely <em>admissible</em> in v0 are actually primitive or <em>derivable</em> in v1. In this regard, v1 is closer to Nuprl, and does not continue v0’s “experiment” with admissible rules <a class="existingWikiWord" href="/nlab/show/CompLF#AdmissSem">discussed previously</a>.</p>

<p>The most conspicuous changes are the addition of some new rules in v1: the “sanity” or “presuppositionality” rule, and “inversion” rules for the type formation rules. Sanity is this one:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash a \Vdash A}{\Gamma \vdash A\,type}</annotation></semantics></math></div>
<p>There are (unfortunately) many inversion rules, but they all have the effect of saying merely that most of the type formation rules are invertible. For example, here are the inversions of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> formation:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" rowspacing="1.0ex"><mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr> <mtr><mtd></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>Π</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>B</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{gathered}
\frac{\Gamma \vdash \Pi x:A.B\,type}{\Gamma \vdash A\,type} \\
\\
\frac{\Gamma \vdash \Pi x:A.B\,type \qquad \Gamma \vdash a \Vdash A}
{\Gamma \vdash B[a/x]\,type}
\end{gathered}
</annotation></semantics></math></div>
<p>Note that there’s a substitution baked into the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> codomain rule. This is because substitution is still an admissible rule. Not baking in a substitution here would probably mess that up.</p>

<p>Less conspicuous, but just as important, are other changes throughout the rules of v0 that are possible because we no longer have to prove sanity and inversion by induction on formal derivations. Indeed, having sanity and inversion as primitive has the effect that many other rules become stronger: If you can derive <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \Vdash A</annotation></semantics></math>, then you also know that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and many of its subexpressions are all valid types. In v0, this was by carefully designing the rules so that all those extra consequences were already derivable. In v1, it’s actually revealing additional facts about the interpretation of the judgments. (Examples below.)</p>

<p>Due to the use of PER semantics, to make the inversion rules sound, semantic equality of types is now intensional, like in Nuprl (and intensional type theory!), and unlike in v0. (TODO: Write an explanation of this.) As for sanity, that was actually sound all along, but including it as a primitive rule would ruin admissibility of inversion, were that not also primitive.</p>

<p>Here is a list of changes to existing rules of v0 that are possible because sanity and inversion are primitive:</p>

<ul>
<li>
<p>The direct computation rule, which lets you beta convert in a type, (and which previously used the auxiliary judgment (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>≡</mo> <mi>β</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_\beta</annotation></semantics></math>) but now uses (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>⟶</mo> <mi>β</mi></msub></mrow><annotation encoding="application/x-tex">\longrightarrow_\beta</annotation></semantics></math>), which is discussed <a href="#BetaConv">separately</a>) no longer requires the new type to be proven valid as an extra premise. Indeed, the new type <em>must</em> be valid, since it’s semantically the same as the old one, which is valid by assumption.</p>
</li>

<li>
<p>As a consequence of the previous, the other old direct computation rule, which lets you beta convert in the subject, has become redundant and has been removed. To derive it, just switch the judgment to express membership with the equality type, use direct computation in that type, and switch back.</p>
</li>

<li>
<p>The “select right” rule of equality, which goes from (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a = a' \in A</annotation></semantics></math>) to (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>′</mo><mo>⊩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a' \Vdash A</annotation></semantics></math>) has become redundant and has been removed. Prove symmetry in the usual way, and combine with select left. (Maybe it was already redundant before, who knows?)</p>
</li>

<li>
<p>The subset elimination rule had a premise in v0 showing that the motive is a valid type family. In v1, this premise is removed. Semantically, it’s redundant because it follows from the typing premise for the sole case (and the additional free variable constraint).</p>
</li>

<li>
<p>Similarly, the PER elimination rule had the motive validity premise removed.</p>
</li>

<li>
<p>Yet another, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> elimination rule had the motive validity premise removed. This one is a bit more interesting, because this rule has <em>two</em> cases, which only show validity of a substitution instance of the motive. Luckily, a family over the booleans only <em>has</em> two substitution instances, semantically.</p>
</li>

<li>
<p>As a consequence of the previous, the rule saying booleans are computations has become redundant and has been removed. It follows from case analysis on the boolean, and the fact that both canonical booleans are obviously computations, by the computation formation rules. The reason this argument didn’t work in v0 is that you’d have trouble showing the motive is valid.</p>
</li>

<li>
<p>Another consequence of the strengthened <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> elimination which is perhaps much more surprising: The <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊥</mo></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math> elimination rule, which effectively said that the two booleans aren’t equal, has become redundant and has been removed. Like in type theory with universes, you can prove this by interpreting the booleans as true and false <em>types</em>. Why this is possible without universes is <a class="existingWikiWord" href="/nlab/show/CompLF%2FHOAS#CombElim">explained elsewhere</a>, but it boils down to types syntactically being terms, having primitive sanity and inversion, and the strengthened <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Bool</mi></mrow><annotation encoding="application/x-tex">Bool</annotation></semantics></math> elimination rule. (As icing on the cake, the derived <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊥</mo></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math> elimination rule doesn’t need a motive validity premise either. But this seems to require <a href="#IdType">identity</a>, a different v1 addition.)</p>
</li>
</ul>

<h2 id="relaxed_equality">Relaxed Equality</h2>

<p>Another important change is the new equality formation rule. Here is the v0 rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>A</mi><mo>≺</mo><mi>C</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>q</mi><mo>⊩</mo><mi>B</mi><mo>≺</mo><mi>C</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>b</mi><mo>⊩</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>∈</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash p \Vdash A \prec C \qquad
\Gamma \vdash q \Vdash B \prec C \qquad
\Gamma \vdash a \Vdash A \qquad \Gamma \vdash b \Vdash B}
{\Gamma \vdash a = b \in C\,type}
</annotation></semantics></math></div>
<p>Here is the v1 rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mn>1</mn><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mn>2</mn><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mn>1</mn><mo>=</mo><mi>a</mi><mn>2</mn><mo>∈</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash a1 \Vdash Relax(A) \qquad \Gamma \vdash a2 \Vdash Relax(A)}
{\Gamma \vdash a1 = a2 \in A\,type}
</annotation></semantics></math></div>
<p>The new rule uses the new type constructor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math>, instead of the defined notion of respect (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math>). Since respect is defined in terms of equality, respect-based equality was a rather annoying circularity in the rules, which made the soundness proof a nuisance. But that is <em>not</em> the main improvement. One could just make respect into a primitive type constructor to avoid the circularity.</p>

<p>The real improvement is that “relaxed equality” avoids the implicit quantification over types in the v0 formation rule. Notice that the v0 rule involves the types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> which are not mentioned in the conclusion. Because of this, it was not clear at all how to give a strong inversion rule for equality formation. With relaxed equality, the inversion rules are rather obvious.</p>

<p>Despite this major organizational improvement, the relaxed equality formation rule is saying essentially the same thing as the respect-based equality formation rule. This is because of a characterization of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> in terms of subtyping: (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>&lt;</mo><mspace width="negativethinmathspace"></mspace><mspace width="negativethinmathspace"></mspace><mo>:</mo><mspace width="thickmathspace"></mspace><mi>Relax</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \lt\!\!:\;Relax(B)</annotation></semantics></math>) if and only if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>≺</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \prec B</annotation></semantics></math>). So some miscellaneous v0 rules about respect:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>A</mi><mo>≺</mo><mi>A</mi></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>Comp</mi><mo>≺</mo><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash A\,type}{\Gamma \vdash p \Vdash A \prec A}
\qquad
\frac{\Gamma \vdash A\,type}{\Gamma \vdash p \Vdash Comp \prec A}
</annotation></semantics></math></div>
<p>are replaced by v1 rules about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac><mspace width="2em"></mspace><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>Comp</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⊩</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash a \Vdash A}{\Gamma \vdash a \Vdash Relax(A)}
\qquad
\frac{\Gamma \vdash A\,type \qquad \Gamma \vdash t \Vdash Comp}
{\Gamma \vdash t \Vdash Relax(A)}
</annotation></semantics></math></div>
<p>This allows the bootstrapping of general reasoning about respect to proceed in essentially the same way.</p>

<h3 id="greatest_type_respected">Greatest type respected</h3>

<p>To understand how <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> avoids quantification in the equality formation rule, it’s helpful to note that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> is the greatest type (ordered by subtyping) that’s respected by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. This is a corollary of that subtyping characterization of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math>. So starting from the v0 rule, to know that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math> are elements of <em>some</em> types <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> that are respected by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, it’s necessary and sufficient to check that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math> are elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(C)</annotation></semantics></math>.</p>

<h3 id="greatest_partition_thats_a_superset">Greatest partition that’s a superset</h3>

<p>There’s another way to think about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math>. Every type is a <a class="existingWikiWord" href="/nlab/show/subquotient">subquotient</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. A subquotient can be decomposed as a subset followed by a quotient, or as a quotient followed by a subset. So what happens if you decompose some arbitrary type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> in these ways?</p>

<p>It turns out there’s a unique subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> of which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a quotient. It’s (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi><mo>∩</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">Comp \cap A</annotation></semantics></math>), the type of computations that are also elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>

<p>It turns out that the other decomposition is <em>not</em> unique. But <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> is the greatest (ordered by subtyping) quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> of which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a subset.</p>

<p>Now here’s the cool part: Nuprl uses an equality formation rule that essentially uses the type (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">A \cup Comp</annotation></semantics></math>) in place of our <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math>. (Except Nuprl calls it <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Base</mi></mrow><annotation encoding="application/x-tex">Base</annotation></semantics></math> instead of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>.) And <em>that</em> type is the <em>least</em> quotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math> of which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is a subset!</p>

<p>Indeed, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">A \cup Comp</annotation></semantics></math>) can be understood as the type you get from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> by adding all computations, that <em>aren’t</em> elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, as additional elements. Meanwhile, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> instead adds <em>at most one</em> additional element, which is implemented by all computations that aren’t elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. That is, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">A \cup Comp</annotation></semantics></math>) and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> both add all the remaining computations, but (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>∪</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">A \cup Comp</annotation></semantics></math>) uses the finest possible equality, while <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> uses the coarsest.</p>

<h3 id="kleene_equality">Kleene equality</h3>

<p>Thinking of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> as adding at most one garbage element gives yet another way to think about it. The additional element can be regarded as an undefined element. It’s the element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math> whose realizers fail to denote an element of the desired type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. So <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> is sort of like a lifted domain, and equality in a lifted domain is <a class="existingWikiWord" href="/nlab/show/Kleene+equality">Kleene equality</a>. Indeed, this gives the actual PER of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> used in the semantics:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>≔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mi>a</mi><mo>∈</mo><mi>A</mi><mo>∨</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a = a' \in Relax(A))\;\coloneqq\;(a \in A \vee a' \in A) \to (a = a' \in A)</annotation></semantics></math></p>

<p>From that definition, the general intro and elim rules for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> type constructor should be relatively clear.</p>

<p>What this means for the equality type is that while it’s <em>strict</em> equality, when regarded as a relation on partial elements, it’s <em>non-strict</em> when regarded as a type-valued operation. That is, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a = a' \in A</annotation></semantics></math>) might be a valid type even if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and/or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">a'</annotation></semantics></math> are not elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> (non-strict), but it cannot be <em>true</em> unless both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">a'</annotation></semantics></math> are elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> (strict).</p>

<p>Meanwhile, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a = a' \in Relax(A)</annotation></semantics></math>) is non-strict in both senses, in terms of potential elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. But for elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math>, it’s strict in both senses. If (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a = a' \in Relax(A)</annotation></semantics></math>) is a valid type, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">a'</annotation></semantics></math> are elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(Relax(A))</annotation></semantics></math>. But that means they’re elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Relax(A)</annotation></semantics></math>, because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> is idempotent. (You can’t add computations to a type that already has all of them.)</p>

<p>All of this is provable internally, using the rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> and equality.</p>

<h2 id="BetaConv">Shortcut Beta Conversion</h2>

<p>To take a break from the big, important changes, here’s a minor, unimportant one. In v0, beta conversion was formulated as a judgment form (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>≡</mo> <mi>β</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_\beta</annotation></semantics></math>) which was defined to be the congruence closure of beta reduction. It turns out that that’s kind of a minor nuisance to spell out in a HOAS presentation of the rules. But because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> is the only binding form in the syntax, there’s a shortcut for getting full congruence. (In general, this shortcut does not avoid congruence rules for binding forms.)</p>

<p>In v1, “partially-compatible beta reduction” (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>⟶</mo> <mi>β</mi></msub></mrow><annotation encoding="application/x-tex">\longrightarrow_\beta</annotation></semantics></math>) has only two congruence rules: one for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>, and one for the argument of an application. Plus it’s not reflexive, symmetric, or transitive. But because the v1 direct computation rules explicitly allow reduction in either direction, and can implicitly be applied repeatedly, this is enough.</p>

<p>Obviously, consecutive applications of the direct computation rules allow rewriting with the reflexive, symmetric, transitive closure (equivalence closure) of (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>⟶</mo> <mi>β</mi></msub></mrow><annotation encoding="application/x-tex">\longrightarrow_\beta</annotation></semantics></math>). Let’s call that (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>↔</mo> <mi>β</mi></msub></mrow><annotation encoding="application/x-tex">\leftrightarrow_\beta</annotation></semantics></math>). It turns out to be the same as (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>≡</mo> <mi>β</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_\beta</annotation></semantics></math>).</p>

<p>What we seem to be missing is most of the congruence rules. But we have a trick: if (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><msub><mo>↔</mo> <mi>β</mi></msub><mi>a</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">a \leftrightarrow_\beta a'</annotation></semantics></math>), then</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><msub><mo>⟵</mo> <mi>β</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>a</mi><msub><mo>↔</mo> <mi>β</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>b</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mi>a</mi><mo>′</mo><msub><mo>⟶</mo> <mi>β</mi></msub><mi>b</mi><mo stretchy="false">[</mo><mi>a</mi><mo>′</mo><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">b[a/x] \longleftarrow_\beta
(\lambda x.b)\,a \leftrightarrow_\beta
(\lambda x.b)\,a' \longrightarrow_\beta
b[a'/x]</annotation></semantics></math></p>

<p>by application argument congruence (extended to the equivalence closure) and the beta rule.</p>

<p>So (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><msub><mo>↔</mo> <mi>β</mi></msub><mi>b</mi><mo stretchy="false">[</mo><mi>a</mi><mo>′</mo><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">b[a/x] \leftrightarrow_\beta b[a'/x]</annotation></semantics></math>). This lets us rewrite in any context <em>if</em> the hole does not appear under binders, <em>or</em> the thing we’re rewriting at least does not mention a bound variable. This actually seems to cover nearly all the cases of rewriting in practice, and then you don’t even need to bother with congruence rules, which is nice.</p>

<p>But for the proof, what we need is that it means we effectively have congruence rules for all non-binding forms. And we really have the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> congruence rule for the only binding form in the language. So we effectively have all the congruence rules.</p>

<h2 id="letcomp">Let-Comp</h2>

<p>Measured by utility, the most important change has got to be the addition of the “letcomp” rule:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left"><mtr><mtd><mi>Γ</mi><mo>⊢</mo><mi>a</mi><mo>⊩</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mtd></mtr> <mtr><mtd><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo>:</mo><mi>Comp</mi><mo>,</mo><mi>h</mi><mo>:</mo><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>c</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo>′</mo><mo stretchy="false">[</mo><mi>x</mi><mo>′</mo><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mi>x</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo>,</mo><mi>h</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo>′</mo><mo stretchy="false">)</mo></mtd></mtr></mtable><mrow><mi>Γ</mi><mo>⊢</mo><mi>q</mi><mo>⊩</mo><mi>c</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo>′</mo><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\begin{array}{l}\Gamma \vdash a \Vdash A \qquad
\Gamma,y:A \vdash C\,type \\
\Gamma,x:Comp,x':Comp,h:(x = x' \in A) \vdash
p \Vdash c[x/y] = c'[x'/y] \in C[x/y] \\
x,x',h \notin FV(c,c')\end{array}}
{\Gamma \vdash q \Vdash c[a/y] = c'[a/y] \in C[a/y]}
</annotation></semantics></math></div>
<p>In v0, quotienting was almost completely broken. It was <a class="existingWikiWord" href="/nlab/show/CompLF#PERtheory">explained</a> how it was <em>supposed</em> to work, with parenthetical remarks that it didn’t yet seem to work. In v1, letcomp is what makes it work.</p>

<p>Another solution presumably would’ve been to add a stronger elimination rule to PER comprehension. But this would not be taking full advantage of PER semantics, where quotienting is intuitively part of the very meaning of the judgments, and all types are implicitly subquotients.</p>

<p>Letcomp is a subquotient elimination rule, formulated to work on an arbitrary type by regarding it as a subquotient of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Comp</mi></mrow><annotation encoding="application/x-tex">Comp</annotation></semantics></math>. The name “letcomp” is based on the observation that it binds an element as a general pair of related computations.</p>

<p>Letcomp can also be understood as internalizing the meaning of the semantic hypothetical judgment form:</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>≫</mo><mi>c</mi><mo>=</mo><mi>c</mi><mo>′</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo>↔</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>≫</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mo stretchy="false">)</mo><mo>∧</mo><mo>∀</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo>′</mo><mo>.</mo><mo stretchy="false">(</mo><mi>a</mi><mo>=</mo><mi>a</mi><mo>′</mo><mo>∈</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo>′</mo><mo stretchy="false">[</mo><mi>a</mi><mo>′</mo><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>C</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x:A \gg c = c' \in C)\;\leftrightarrow\;((A\,type) \to ((x:A \gg C\,type) \wedge \forall a,a'.(a = a' \in A) \to (c[a/x] = c'[a'/x] \in C[a/x])))</annotation></semantics></math></p>

<p>With this grand purpose as an attempt to complete the internalization of the PER semantics, it may not be surprising that letcomp is very useful for deriving rules for type constructors defined by PER comprehension. But it’s not perfect. Rules that involve metavariables without an associated typing premise tend to cause trouble. Alas, it seems very difficult to do much about that. (“Pullback” types à la <a href="#MZFuncRefine">Melliès &amp; Zeilberger</a> might address the most serious gaps.) Notice however that intrinsic dependent type systems would not need rules with metavariables without typing premises. So the ability to derive type constructors and their rules seems quite substantial already.</p>

<p>There was actually an early version of letcomp for v0. But the soundness of letcomp was not established until after changing the semantics to support primitive inversions.</p>

<h2 id="natural_numbers_type">Natural Numbers Type</h2>

<p>CompLF v1 adds a type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Nat</mi></mrow><annotation encoding="application/x-tex">Nat</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/Dana+Scott">Scott</a>-encoded natural numbers. The Scott nats themselves are not new, of course. What’s new is having them collected into an inductive type, which actually gives CompLF some serious proof-theoretic strength. It’s expected to have the same strength as (first-order) <a class="existingWikiWord" href="/nlab/show/Peano+arithmetic">Peano arithmetic</a>, but the upper bound has not been checked.</p>

<p>The motive premise cannot be avoided in the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Nat</mi></mrow><annotation encoding="application/x-tex">Nat</annotation></semantics></math> elimination rule. One probable reason is that that would be too strong, since it would allow type-level recursion. But another reason has to do with technical details of PER semantics. (TODO: Explain.) Nuprl’s version of induction actually <em>does</em> avoid the motive premise. (Nuprl’s logic is much stronger than Peano arithmetic, by the way.) For some, this was a major advantage of Nuprl, since it’s a way to get nontrivial proofs of totality for recursive functions. But CompLF must pursue alternatives. (TODO: Explain!)</p>

<h2 id="IdType">Identity Types</h2>

<p>Identity types provide another kind of equality type that also provides subsumptive rewriting. Unlike the main equality, which is type-directed, and only rewrites in well-typed goals, identity is untyped, and rewrites in any goal at all: rewriting has no motive premise. This identity should be thought of as a relation that’s true only for things that are identical, not a type of “<a class="existingWikiWord" href="/nlab/show/identity+type">identifications</a>” of things that generally aren’t already identical.</p>

<p>The restriction that prevents the two notions from collapsing is that identity types are usually not valid unless they’re true. Only when dealing with computations is it safe to assume identity. But in that case, it coincides with equality. In fact, identity <em>is</em> equality of computations, in the semantics. The different rules are due entirely to the difference in when the types are valid. This is <a class="existingWikiWord" href="/nlab/show/CompLF%2FHOAS#IdType">explained elsewhere</a>, in terms of how presuppositions affect rules and other judgment-level reasoning. Because of the sanity rule, it’s implicit that for any term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>≡</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">t \equiv t</annotation></semantics></math>) is a valid type because it’s true. This is why identity has no inversion rules. Meanwhile, (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>=</mo><mi>t</mi><mo>∈</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t = t \in Comp</annotation></semantics></math>) is not true or even meaningful unless <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>Comp</mi></mrow><annotation encoding="application/x-tex">t \in Comp</annotation></semantics></math>.</p>

<p>When dealing with computations, where equality and identity coincide, the rules for identity types do indeed expose a stronger (derived) rewrite rule for equality. The motive premise is avoided:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>p</mi><mo>⊩</mo><mi>t</mi><mo>=</mo><mi>t</mi><mo>′</mo><mo>∈</mo><mi>Comp</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>c</mi><mo>⊩</mo><mi>C</mi><mo stretchy="false">[</mo><mi>t</mi><mo>′</mo><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Gamma \vdash p \Vdash t = t' \in Comp \qquad
\Gamma \vdash c \Vdash C[t/x]}
{\Gamma \vdash c \Vdash C[t'/x]}
</annotation></semantics></math></div>
<p>The identity type constructor <a href="#CompEqvITP13">comes from Nuprl</a>, where it’s called “computational equivalence”. That’s exactly what it is, semantically. But internally, it seems weird to think of it as a mere equivalence, since it’s the most intensional equality that can be expressed as a type. Nuprl has additional features that facilitate internal reasoning about computational equivalence. But in v1, identity seems scarcely different from beta conversion in practice.</p>

<h2 id="miscellaneous">Miscellaneous</h2>

<p>Certain rules in v0 (equality formation (via respect) and PER formation) used non-dependent function types (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math>) to express implications. In v1, non-dependent family intersection types (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊃</mo></mrow><annotation encoding="application/x-tex">\supset</annotation></semantics></math>) are used (in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Relax</mi></mrow><annotation encoding="application/x-tex">Relax</annotation></semantics></math> introduction and PER formation) instead. In some cases, the propositions involved are guaranteed to be proof-irrelevant, so it doesn’t matter. In PER formation, there’s no guarantee that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is proof-irrelevant, but there’s no good reason for the user to use a proof-relevant relation, since the proof is ignored. In both versions of PER formation, you can run into trouble trying to use a proof-relevant relation. (So the change doesn’t help or hurt.)</p>

<p>In v0, there was a reflexivity rule for equality, in addition to the uniqueness and selectivity rules. That was redundant. So now reflexivity is derived from uniqueness and select left.</p>

<p>There’s been some reordering of rules, premises, and renaming of metavariables.</p>

<h2 id="references">References</h2>

<ul>
<li id="CompEqvITP13">
<p>Vincent Rahli, Mark Bickford, Abhishek Anand, <em>Formal Program Optimization in Nuprl Using Computational Equivalence and Partial Types</em>, Interactive Theorem Proving (ITP) 2013 (<a href="http://www.nuprl.org/KB/show.php?ShowPub=RBA13">web</a>, <a href="http://www.nuprl.org/documents/Rahli/optimization_ITP_2013_04_22">pdf</a>)</p>
</li>

<li id="MZFuncRefine">
<p>Paul-André Melliès, Noam Zeilberger, <em>Functors are Type Refinement Systems</em>, POPL 2015 (<a href="https://www.irif.fr/~mellies/papers/functors-are-type-refinement-systems.pdf">pdf</a>)</p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on August 25, 2020 at 21:53:28.
    See the <a href="/nlab/history/differences+between+CompLF+v0+and+v1" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/differences+between+CompLF+v0+and+v1" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/11544/#Item_3">Discuss</a><span class="backintime"><a href="/nlab/revision/differences+between+CompLF+v0+and+v1/10" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/differences+between+CompLF+v0+and+v1" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/differences+between+CompLF+v0+and+v1" accesskey="S" class="navlink" id="history" rel="nofollow">History (10 revisions)</a>
  <a href="/nlab/show/differences+between+CompLF+v0+and+v1/cite" style="color: black">Cite</a>
  <a href="/nlab/print/differences+between+CompLF+v0+and+v1" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/differences+between+CompLF+v0+and+v1" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
