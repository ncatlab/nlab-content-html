
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      algebraic theory in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      algebraic theory
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/3609/#Item_13" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Algebraic theories</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="categorical_algebra">Categorical algebra</h4>

<div class="hide"><div>

<p><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a>+<a class="existingWikiWord" href="/nlab/show/algebra">algebra</a></p>

<p><strong><a class="existingWikiWord" href="/nlab/show/internalization">internalization</a> and <a class="existingWikiWord" href="/nlab/show/categorical+algebra">categorical algebra</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/monoid+object">monoid object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/group+object">group object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/ring+object">ring object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/algebra+object">algebra object</a> (associative, <a class="existingWikiWord" href="/nlab/show/Lie+algebra+object">Lie</a>, …)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/module+object">module object</a>/<a class="existingWikiWord" href="/nlab/show/action+object">action object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+locale">internal locale</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+category">internal category</a> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/internal+infinity-categories+contents">more</a>)</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+groupoid">internal groupoid</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+site">internal site</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+diagram">internal diagram</a></p>
</li>
</ul>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/universal+algebra">universal algebra</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/algebra+over+a+Lawvere+theory">algebras over</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="thinmathspace"></mspace></mrow><annotation encoding="application/x-tex">\,</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/algebraic+theories">algebraic theories</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/algebra+over+a+monad">algebras over</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="thinmathspace"></mspace></mrow><annotation encoding="application/x-tex">\,</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/monads">monads</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/algebra+over+an+operad">algebras over</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="thinmathspace"></mspace></mrow><annotation encoding="application/x-tex">\,</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/operads">operads</a></p>
</li>
</ul>

<p><strong><a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a>, <a class="existingWikiWord" href="/nlab/show/internal+language">internal language</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relation+between+category+theory+and+type+theory">relation between category theory and type theory</a></p>
</li>
</ul>
</div></div>

<h4 id="higher_algebra">Higher algebra</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/higher+algebra">higher algebra</a></strong></p>

<p><a class="existingWikiWord" href="/nlab/show/universal+algebra">universal algebra</a></p>

<h2 id="algebraic_theories">Algebraic theories</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/algebraic+theory">algebraic theory</a> / <a class="existingWikiWord" href="/nlab/show/2-algebraic+theory">2-algebraic theory</a> / <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-algebraic+theory">(∞,1)-algebraic theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monad">monad</a> / <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-monad">(∞,1)-monad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/operad">operad</a> / <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-operad">(∞,1)-operad</a></p>
</li>
</ul>

<h2 id="algebras_and_modules">Algebras and modules</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/algebra+over+a+monad">algebra over a monad</a></p>

<p><a class="existingWikiWord" href="/nlab/show/%E2%88%9E-algebra+over+an+%28%E2%88%9E%2C1%29-monad">∞-algebra over an (∞,1)-monad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/algebra+over+an+algebraic+theory">algebra over an algebraic theory</a></p>

<p><a class="existingWikiWord" href="/nlab/show/%E2%88%9E-algebra+over+an+%28%E2%88%9E%2C1%29-algebraic+theory">∞-algebra over an (∞,1)-algebraic theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/algebra+over+an+operad">algebra over an operad</a></p>

<p><a class="existingWikiWord" href="/nlab/show/%E2%88%9E-algebra+over+an+%28%E2%88%9E%2C1%29-operad">∞-algebra over an (∞,1)-operad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/action">action</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-action">∞-action</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/representation">representation</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-representation">∞-representation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/module">module</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-module">∞-module</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/associated+bundle">associated bundle</a>, <a class="existingWikiWord" href="/nlab/show/associated+%E2%88%9E-bundle">associated ∞-bundle</a></p>
</li>
</ul>

<h2 id="higher_algebras">Higher algebras</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/monoidal+%28%E2%88%9E%2C1%29-category">monoidal (∞,1)-category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+%28%E2%88%9E%2C1%29-category">symmetric monoidal (∞,1)-category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monoid+in+an+%28%E2%88%9E%2C1%29-category">monoid in an (∞,1)-category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/commutative+monoid+in+an+%28%E2%88%9E%2C1%29-category">commutative monoid in an (∞,1)-category</a></p>
</li>
</ul>
</li>

<li>
<p>symmetric monoidal (∞,1)-category of spectra</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/smash+product+of+spectra">smash product of spectra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+smash+product+of+spectra">symmetric monoidal smash product of spectra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/ring+spectrum">ring spectrum</a>, <a class="existingWikiWord" href="/nlab/show/module+spectrum">module spectrum</a>, <a class="existingWikiWord" href="/nlab/show/algebra+spectrum">algebra spectrum</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/A-%E2%88%9E+algebra">A-∞ algebra</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/A-%E2%88%9E+ring">A-∞ ring</a>, <a class="existingWikiWord" href="/nlab/show/A-%E2%88%9E+space">A-∞ space</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/C-%E2%88%9E+algebra">C-∞ algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/E-%E2%88%9E+ring">E-∞ ring</a>, <a class="existingWikiWord" href="/nlab/show/E-%E2%88%9E+algebra">E-∞ algebra</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%E2%88%9E-module">∞-module</a>, <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-module+bundle">(∞,1)-module bundle</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/multiplicative+cohomology+theory">multiplicative cohomology theory</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/L-%E2%88%9E+algebra">L-∞ algebra</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/deformation+theory">deformation theory</a></li>
</ul>
</li>
</ul>

<h2 id="model_category_presentations">Model category presentations</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+T-algebras">model structure on simplicial T-algebras</a> / <a class="existingWikiWord" href="/nlab/show/homotopy+T-algebra">homotopy T-algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+operads">model structure on operads</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebras+over+an+operad">model structure on algebras over an operad</a></p>
</li>
</ul>

<h2 id="geometry_on_formal_duals_of_algebras">Geometry on formal duals of algebras</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Isbell+duality">Isbell duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/derived+geometry">derived geometry</a></p>
</li>
</ul>

<h2 id="theorems">Theorems</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Deligne+conjecture">Deligne conjecture</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/delooping+hypothesis">delooping hypothesis</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monoidal+Dold-Kan+correspondence">monoidal Dold-Kan correspondence</a></p>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/higher+algebra+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="algebraic_theories">Algebraic theories</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<ul>
<li><a href='#categorical_formulation'>Categorical formulation</a></li>
<li><a href='#basic_intuitions'>Basic Intuitions</a></li>
<li><a href='#extensions'>Extensions</a></li>
<ul>
<li><a href='#infinitary_operations'>Infinitary operations</a></li>
<li><a href='#multisorted_operations'>Multi-sorted operations</a></li>
<li><a href='#generalized_algebraic_theories'>Generalized Algebraic Theories</a></li>
</ul>
</ul>
<li><a href='#definition'>Definition</a></li>
<ul>
<li><a href='#variations'>Variations</a></li>
<ul>
<li><a href='#essentially_algebraic_theories'>Essentially algebraic theories</a></li>
<li><a href='#multisorted_algebraic_theories'>Multisorted algebraic theories</a></li>
<li><a href='#commutative_theories'>Commutative theories</a></li>
</ul>
</ul>
<li><a href='#RelationToMonads'>Relation to monads</a></li>
<ul>
<li><a href='#the_monad_of_a_locally_small_lawvere_theory'>The monad of a locally small Lawvere theory</a></li>
<ul>
<li><a href='#theorem_1'>Theorem 1</a></li>
</ul>
<li><a href='#large_lawvere_theory_of_a_monad'>Large Lawvere theory of a monad</a></li>
<ul>
<li><a href='#theorem_2'>Theorem 2</a></li>
<li><a href='#theorem_3'>Theorem 3</a></li>
</ul>
<li><a href='#algebras_and_models'>Algebras and models</a></li>
<ul>
<li><a href='#theorem_4'>Theorem 4</a></li>
</ul>
</ul>
<li><a href='#metaphor'>Metaphor</a></li>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>An <em>algebraic <a class="existingWikiWord" href="/nlab/show/theory">theory</a></em> is a concept in <a class="existingWikiWord" href="/nlab/show/universal+algebra">universal algebra</a> that describes a specific type of algebraic gadget, such as <a class="existingWikiWord" href="/nlab/show/group">groups</a> or <a class="existingWikiWord" href="/nlab/show/ring">rings</a>. An individual group or ring is a <em>model</em> of the appropriate theory. Roughly speaking, an algebraic theory consists of a specification of operations and laws that these operations must satisfy.</p>

<h3 id="categorical_formulation">Categorical formulation</h3>

<p>Traditionally, algebraic theories were described in terms of <a class="existingWikiWord" href="/nlab/show/logic">logical syntax</a>, as <a class="existingWikiWord" href="/nlab/show/theory">first-order theories</a> whose <a class="existingWikiWord" href="/nlab/show/signatures">signatures</a> have only function symbols, no relation symbols, and all of whose <a class="existingWikiWord" href="/nlab/show/axioms">axioms</a> are <span class="newWikiWord">equational law<a href="/nlab/new/equational+law">?</a></span>s (<a class="existingWikiWord" href="/nlab/show/universal+quantifier">universally quantified</a> <a class="existingWikiWord" href="/nlab/show/equations">equations</a> between terms built out of these function symbols). Such descriptions may be viewed as <em>presentations</em> of a theory, analogous to <a class="existingWikiWord" href="/nlab/show/generators+and+relations">generators and relations</a> as presentations of <a class="existingWikiWord" href="/nlab/show/groups">groups</a>. In particular, different logical presentations can lead to equivalent mathematical objects.</p>

<p>In his thesis, <a class="existingWikiWord" href="/nlab/show/Bill+Lawvere">Bill Lawvere</a> undertook a more invariant description of (finitary) algebraic theories. Here <em>all</em> the definable operations of an algebraic theory, or rather their equivalence classes modulo the equational axioms imposed by the theory, are packaged together to form the morphisms of a category with finite products, called a <a class="existingWikiWord" href="/nlab/show/Lawvere+theory">Lawvere theory</a>. None of these operations are considered “primitive”, so a Lawvere theory doesn’t play favorites among operations.</p>

<p>This article is about generalized Lawvere theories. The article <a class="existingWikiWord" href="/nlab/show/Lawvere+theory">Lawvere theory</a> treats the traditional notion of finitary, single-sorted Lawvere theories, with worked examples. The core of the present article is a working out of the precise connection between infinitary (multi-sorted) Lawvere theories and monads.</p>

<h3 id="basic_intuitions">Basic Intuitions</h3>

<p>Intuitively, a Lawvere theory is the “generic category of products equipped with an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> of given algebraic type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>”. For example, the Lawvere theory of groups is what you get by assuming a category with products and with a <a class="existingWikiWord" href="/nlab/show/group+object">group object</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> inside, and nothing more; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> can be considered “the generic group”. Every object in the Lawvere theory is a finite power <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^n</annotation></semantics></math> of the generic object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>. The morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mi>n</mi></msup><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x^n \to x</annotation></semantics></math> are nothing but the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-ary operations it is possible to define on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>.</p>

<p>In other words, if we abstract away from the usual set-theoretic semantics, and consider a model for the theory of groups to be <em>any</em> category with finite products together with a specified group object inside, then the Lawvere theory of groups becomes a universal model of the theory, and carries all the information of the theory but independent of a particular presentation. In this way, theories and models of a theory are placed on an equal footing. A model of a Lawvere theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> in a category with products <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is nothing but (i.e., is equivalent to) a product-preserving functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">T \to C</annotation></semantics></math>; where the generic object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is sent to is the given model of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is the Lawvere theory of groups, then a product-preserving functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">T \to Set</annotation></semantics></math> is tantamount to an ordinary group.</p>

<p>The actual categorical construction of a Lawvere theory is described very easily and elegantly: it is the category opposite to the category of (finitely generated) free algebras of the theory. The free algebra on one generator becomes the generic object.</p>

<p>If theories and models are placed on an equal footing, then what feature sets “theories” <em>per se</em> apart? In some very abstract sense, any category with products <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> could be considered a theory, where the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>-models in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> are product-preserving functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C \to D</annotation></semantics></math>. Sometimes this is a useful point of view, but it is far removed from traditional syntactic considerations. To give a more “honest” answer, we remember that an ordinary (finitary, single-sorted) algebraic theory a la Lawvere is generated from a single object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, and that every other object should be (at least up to isomorphism) a finite power <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^n</annotation></semantics></math>. The exponent <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> serves to keep track of arities of operations.</p>

<p>The generic “category of arities” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> is, in the finitary case, the category opposite to the category of finite sets (opposite because the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> appears contravariantly in powers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^n</annotation></semantics></math>). This is also the Lawvere “theory of equality”, or if you prefer the theory generated by an empty signature. The answer to the question “what sets theories apart” is that a Lawvere theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> should come equipped with a product-preserving functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mo lspace="verythinmathspace" rspace="0em">−</mo></msup><mo>:</mo><msup><mi>FinSet</mi> <mi>op</mi></msup><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">x^{-}: FinSet^{op} \to T</annotation></semantics></math></div>
<p>that is essentially surjective (each object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is isomorphic to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^n</annotation></semantics></math> for some arity <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>). As we see below, this definition is a cornerstone to a very elegant theory of algebraic theories.</p>

<h3 id="extensions">Extensions</h3>

<h4 id="infinitary_operations">Infinitary operations</h4>

<p>Lawvere’s program can be extended to cover many theories with infinitary operations as well. In the best-behaved case, one has algebraic theories involving only operations of arity bounded by some <a class="existingWikiWord" href="/nlab/show/cardinal+number">cardinal number</a> — or, more precisely, belonging to some <a class="existingWikiWord" href="/nlab/show/arity+class">arity class</a> — and these can be understood category-theoretically with a suitable generalization of Lawvere theories. In this bounded case, the Lawvere theory can be described by a small category, and the category of models will be very well behaved, in particular it is a <a class="existingWikiWord" href="/nlab/show/locally+presentable+category">locally presentable category</a>. In such cases there is a satisfying duality between syntax and semantics along the lines of <a class="existingWikiWord" href="/nlab/show/Gabriel-Ulmer+duality">Gabriel-Ulmer duality</a>.</p>

<p>Lawvere’s program can to some degree be extended further: one can work with Lawvere theories which are locally small (not just small) categories. Here, the theory might not be bounded, but at least there is only a small set of operations of each arity. Examples of such large theories include</p>

<ul>
<li>
<p>The theory of algebras with arbitrary sums (one model of which is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>∞</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,\infty]</annotation></semantics></math>),</p>
</li>

<li>
<p>The theory of sup-lattices, in which there is one operation of each arity, and</p>
</li>

<li>
<p>The theory of compact Hausdorff spaces, where the operations are parametrized by ultrafilters.</p>
</li>
</ul>

<p>These examples go outside the bounded (small theory) case. Locally small theories in this sense are co-extensive with the notion of monad (on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>): there is a free-forgetful adjunction between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math> and the category of models, and algebras of the theory are equivalent to algebras of the monad.</p>

<p>In the worst case, there are algebraic theories where the number of definable operations explodes, so that there may be a proper class of operations of some fixed arity. In this case there are no free algebras, and Lawvere’s reformulation no longer applies. An example is the theory of complete Boolean algebras. (Note: category theorists who define a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">U: A \to Set</annotation></semantics></math> over sets to be <a class="existingWikiWord" href="/nlab/show/algebraic+category">algebraic</a> if it is <a class="existingWikiWord" href="/nlab/show/monadic+functor">monadic</a> would therefore not consider the variety of algebras in such cases to be “algebraic”).</p>

<p>Further commentary on these aspects may be found in the dozen or so comments in <a href="http://golem.ph.utexas.edu/category/2009/04/report_on_88th_peripatetic_sem.html#c023188">this thread</a>, dated April 13 - May 7, 2009.</p>

<p>In summary, then, here is the connection between the logical and categorial descriptions, based on <a href="#Johnstone">Johnstone</a>, §§3.7&amp;8. Say that a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is:</p>

<ul>
<li><em>small algebraic</em> if it is given by a (small) set of operation symbols and equations;</li>

<li><em><a class="existingWikiWord" href="/nlab/show/algebraic+category">algebraic</a></em> if it is given by a monad on the category of (small) sets;</li>

<li><em>large algebraic</em> if it is given by a (possibly proper) class of operation symbols and equations.</li>
</ul>

<p>Then any small algebraic category is algebraic, and any algebraic category is large algebraic, but neither implication may be reversed.</p>

<h4 id="multisorted_operations">Multi-sorted operations</h4>

<p>Lawvere theories can also be generalized to handle multi-sorted operations. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> is a set of sorts, then multisorted operations are of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow></munder><msup><mi>s</mi> <mrow><msub><mi>n</mi> <mi>s</mi></msub></mrow></msup><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\prod_{s \in S} s^{n_s} \to t</annotation></semantics></math></div>
<p>so that arities are functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">n: S \to Set</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> is seen as a discrete category. Thus, an infinitary multi-sorted Lawvere theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> involves an essentially surjective product-preserving functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>Set</mi> <mi>S</mi></msup><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">(Set^S)^{op} \to T</annotation></semantics></math></div>
<p>and the development goes through very much as in the single-sorted case.</p>

<h4 id="generalized_algebraic_theories">Generalized Algebraic Theories</h4>

<p>See <em><a class="existingWikiWord" href="/nlab/show/generalized+algebraic+theory">generalized algebraic theory</a></em>.</p>

<h2 id="definition">Definition</h2>

<p>For the moment we discuss the single-sorted case. The many-sorted case should be a straightforward extension.</p>

<p>For any <a class="existingWikiWord" href="/nlab/show/cardinal">cardinal</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math> be a set of that cardinality (sometimes we just use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>).</p>

<div class="un_def">
<h6 id="definition_2">Definition:</h6>

<p>A <strong>Lawvere theory</strong> or <strong>algebraic theory</strong> is a <a class="existingWikiWord" href="/nlab/show/locally+small+category">locally small category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> with small products that is equipped with an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> such that the (unique-up-to-isomorphism) product-preserving functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><msup><mi>Set</mi> <mi>op</mi></msup><mo>→</mo><mi>C</mi><mo>:</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>↦</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">i: Set^{op} \to C: [1] \mapsto x</annotation></semantics></math></div>
<p>is essentially surjective.</p>
</div>

<h3 id="variations">Variations</h3>

<p>Algebraic theories can be extended or specialized in various directions. Here are a few variations on the theme.</p>

<h4 id="essentially_algebraic_theories">Essentially algebraic theories</h4>

<p><em><a class="existingWikiWord" href="/nlab/show/essentially+algebraic+theory">Essentially algebraic theories</a></em> allow for partially-defined operations. Just as finitary algebraic theories can be understood as Lawvere theories, which live in the <a class="existingWikiWord" href="/nlab/show/doctrine">doctrine</a> of <a class="existingWikiWord" href="/nlab/show/cartesian+monoidal+category">cartesian monoidal categories</a>, so finitary essentially algebraic theories can be understood by a generalisation to <a class="existingWikiWord" href="/nlab/show/finitely+complete+category">finitely complete categories</a>.</p>

<h4 id="multisorted_algebraic_theories">Multisorted algebraic theories</h4>

<p><em><span class="newWikiWord">Multi-sorted theories<a href="/nlab/new/multi-sorted+theory">?</a></span></em> allow for more than one sort or type in the theory.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> be a set whose elements are called <em>sorts</em>. There is a canonical map</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>Ob</mi><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i: S \to Ob(Set/S)</annotation></semantics></math></div>
<p>which sends <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s \in S</annotation></semantics></math> to the object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">s: 1 \to S</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S</annotation></semantics></math>. Each object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">U \to S</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S</annotation></semantics></math> may be thought of as a monomial term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mi>s</mi></msub><msubsup><mi>x</mi> <mi>s</mi> <mrow><msub><mi>U</mi> <mi>s</mi></msub></mrow></msubsup></mrow><annotation encoding="application/x-tex">\prod_s x_{s}^{U_s}</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>x</mi> <mi>s</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{x_s\}</annotation></semantics></math> is a set of variables indexed by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, although it makes better sense to think of it that way when it is regarded as an object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math>.</p>

<p>Thus, objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math> are pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>n</mi><mo>→</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, x: n \to S)</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> is any set, and morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>m</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, x) \to (m, y)</annotation></semantics></math> are functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f: [m] \to [n]</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">y = x \circ f</annotation></semantics></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>y</mi> <mi>i</mi></msub><mo>=</mo><msub><mi>x</mi> <mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">y_i = x_{f(i)}</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [m]</annotation></semantics></math>. Clearly, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math> has small products. In fact, any object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, x)</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math> is a product of objects of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(s)</annotation></semantics></math>.</p>

<div class="num_prop">
<h6 id="proposition">Proposition</h6>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math> is the free category with small products generated by the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p>
</div>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be a category with small products and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Φ</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>Ob</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi: S \to Ob(C)</annotation></semantics></math> be any function. Define a functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Pi: (Set/S)^{op} \to C</annotation></semantics></math></div>
<p>so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>n</mi><mo>→</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, x: n \to S)</annotation></semantics></math> is taken to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>i</mi><mo>∈</mo><mi>n</mi></mrow></msub><mi>Φ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod_{i \in n} \Phi(x(i))</annotation></semantics></math>. It is immediate that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> is a product-preserving functor and is, up to unique isomorphism, the unique product-preserving functor that extends <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math>.</p>
</div>

<div class="num_def">
<h6 id="definition_3">Definition</h6>

<p>A <strong>multi-sorted algebraic theory</strong> over the set of sorts <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> consists of a locally small category with small products, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, together with a sort assignment <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Φ</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Phi: S \to C</annotation></semantics></math> such that the product-preserving extension</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Pi: (Set/S)^{op} \to C</annotation></semantics></math></div>
<p>is essentially surjective. An <strong>operation of arity</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x_1, \ldots, x_n \to y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a morphism of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Φ</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi(n, x) \to \Phi(y)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> has small products, a <strong>model</strong> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> is a product-preserving functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">M: C \to D</annotation></semantics></math>. A <strong>homomorphism of models</strong> is simply a natural transformation between product-preserving functors.</p>
</div>

<p>It violates the <a class="existingWikiWord" href="/nlab/show/principle+of+equivalence">principle of equivalence</a>, but is nevertheless harmless and sometimes convenient, to suppose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> is an isomorphism on objects, since we can define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">C'</annotation></semantics></math> to have the same objects as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S</annotation></semantics></math> and define hom-sets by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>′</mo><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C'(x, y) = C(\Pi(x), \Pi(y)</annotation></semantics></math>. Then, the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">(Set/S)^{op} \to C</annotation></semantics></math> evidently factors as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mover><mo>→</mo><mi>Π</mi></mover><mi>C</mi><mo>′</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">(Set/S)^{op} \stackrel{\Pi}{\to} C' \to C</annotation></semantics></math></div>
<p>where the second functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>′</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">C' \to C</annotation></semantics></math> is an equivalence, so we may as well work with the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Pi: (Set/S)^{op} \to C'</annotation></semantics></math>.</p>

<h4 id="commutative_theories">Commutative theories</h4>

<p><em><a class="existingWikiWord" href="/nlab/show/commutative+algebraic+theory">Commutative algebraic theories</a></em> are (single-sorted) algebraic theories for which each operation is an algebra homomorphism. These form an important subclass. Their categories of models are <a class="existingWikiWord" href="/nlab/show/closed+monoidal+category">closed</a>: the <a class="existingWikiWord" href="/nlab/show/hom+sets">hom sets</a> have a natural model-structure (algebra-structure), and the enriched Hom-functor has a <a class="existingWikiWord" href="/nlab/show/left+adjoint">left adjoint</a>, <em><a class="existingWikiWord" href="/nlab/show/tensor+product">tensor product</a></em>.</p>

<p>The theory of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>-modules for a fixed commutative ring <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is perhaps the most familiar example. The theory of complete lattices and supremum-preserving functions is an interesting non-finitary example.</p>

<h2 id="RelationToMonads">Relation to monads</h2>

<p>We flesh out the relationships between algebraic theories and <a class="existingWikiWord" href="/nlab/show/monads">monads</a>, starting from the most general situation and then adding conditions to cut down on the size of theories. The term “<a class="existingWikiWord" href="/nlab/show/Lawvere+theory">Lawvere theory</a>” as used here will mean a large (but locally small) <a class="existingWikiWord" href="/nlab/show/infinitary+Lawvere+theory">infinitary Lawvere theory</a>. (Under this relation ordinary finitary Lawvere theories correspond to <em><a class="existingWikiWord" href="/nlab/show/finitary+monads">finitary monads</a></em>.)</p>

<h3 id="the_monad_of_a_locally_small_lawvere_theory">The monad of a locally small Lawvere theory</h3>

<p>Suppose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a (locally small, multi-sorted) Lawvere theory, so we have a product-preserving functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Pi: (Set/S)^{op} \to C</annotation></semantics></math></div>
<p>which we may assume to be the identity on objects. We define an adjoint pair between the category of models <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mod</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mod(C, Set)</annotation></semantics></math>, consisting of product-preserving functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">C \to Set</annotation></semantics></math> and transformations between them, and the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S</annotation></semantics></math>. We also denote this model category by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Prod(C, Set)</annotation></semantics></math>.</p>

<div class="num_remark">
<h6 id="remark">Remark</h6>

<p>Observe that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math> is a Lawvere theory which is the theory of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>-multi-sorted sets,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mover><mo>≃</mo><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>∘</mo><mi>i</mi></mrow></mover><msup><mi>Set</mi> <mi>S</mi></msup><mo>≃</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">Prod((Set/S)^{op}, Set) \stackrel{- \circ i}{\simeq} Set^S \simeq Set/S,</annotation></semantics></math></div>
<p>where the first equivalence obtains precisely because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math> is the free category with products generated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p>
</div>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Mod</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y: C^{op} \to Mod(C, Set)</annotation></semantics></math> be the Yoneda embedding, taking <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> to the product-preserving functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>C</mi><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">hom(c, -): C \to Set</annotation></semantics></math>.</p>

<div class="un_thm">
<h6 id="theorem_1">Theorem 1</h6>

<p>The functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mover><mo>→</mo><mrow><msup><mi>Π</mi> <mi>op</mi></msup></mrow></mover><msup><mi>C</mi> <mi>op</mi></msup><mover><mo>→</mo><mi>y</mi></mover><mi>Mod</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Set/S \stackrel{\Pi^{op}}{\to} C^{op} \stackrel{y}{\to} Mod(C, Set)</annotation></semantics></math></div>
<p>is left adjoint to the functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>Π</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow></mover><mi>Prod</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Prod(C, Set) \stackrel{Prod(\Pi, Set)}{\to} Prod((Set/S)^{op}, Set) \simeq Set/S</annotation></semantics></math></div>
<p>(using the remark above).</p>
</div>

<div class="proof">
<h6 id="proof_2">Proof</h6>

<p>We must exhibit a natural isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Nat</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">(</mo><msup><mi>Π</mi> <mi>op</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mover><mo>→</mo><mi>x</mi></mover><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mover><mo>→</mo><mi>x</mi></mover><mi>S</mi><mo>,</mo><mi>G</mi><mo>∘</mo><mi>Π</mi><mo>∘</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Nat((y(\Pi^{op} (n \stackrel{x}{\to} S)), G) \cong Set/S(n \stackrel{x}{\to} S, G \circ \Pi \circ i)</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Nat</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Nat(-, -)</annotation></semantics></math> indicates the hom-functor on the functor category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mod</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mod(C, Set)</annotation></semantics></math>. The left side is naturally isomorphic to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>n</mi><mover><mo>→</mo><mi>x</mi></mover><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(\Pi(n \stackrel{x}{\to} S))</annotation></semantics></math></div>
<p>by the <a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a>. The right side is isomorphic to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mover><mo>→</mo><mi>x</mi></mover><mi>S</mi><mo>,</mo><mi>G</mi><mi>Π</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Set/S(n \stackrel{x}{\to} S, G\Pi i)</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>S</mi><mo>→</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">i: S \to (Set/S)^{op}</annotation></semantics></math> is the canonical embedding. Now both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>Π</mi></mrow><annotation encoding="application/x-tex">G \circ \Pi</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>G</mi><mi>Π</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Set/S(-, G\Pi i)</annotation></semantics></math> are product-preserving functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">(Set/S)^{op} \to Set</annotation></semantics></math>, so to check these functors are isomorphic, it suffices (by the universal property of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op}</annotation></semantics></math> to check they give isomorphic results when restricted along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>G</mi><mi>Π</mi><mi>i</mi><mo>≅</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mo>,</mo><mi>G</mi><mi>Π</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G \Pi i \cong Set/S(i-, G\Pi i)</annotation></semantics></math></div>
<p>However, because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>S</mi><mo>→</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">i: S \to (Set/S)^{op}</annotation></semantics></math> is itself a Yoneda embedding <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>y</mi> <mi>op</mi></msup><mo>:</mo><mi>S</mi><mo>→</mo><mo stretchy="false">(</mo><msup><mi>Set</mi> <mi>S</mi></msup><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">y^{op}: S \to (Set^S)^{op}</annotation></semantics></math>, the last isomorphism is just an instance of the Yoneda lemma, and this concludes the proof.</p>
</div>

<p>The <strong>monad of a Lawvere theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></strong> is the monad <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>:</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo>→</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T: Set/S \to Set/S</annotation></semantics></math> associated with this adjunction.</p>

<h3 id="large_lawvere_theory_of_a_monad">Large Lawvere theory of a monad</h3>

<p>Now let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>:</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo>→</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T: Set/S \to Set/S</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/monad">monad</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S</annotation></semantics></math>, with unit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>u</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">u: 1 \to T</annotation></semantics></math> and multiplication <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>:</mo><mi>T</mi><mi>T</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">m: T T \to T</annotation></semantics></math>.</p>

<div class="un_def">
<h6 id="definition_4">Definition</h6>

<p>The <strong>large Lawvere theory</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Th</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Th(T)</annotation></semantics></math> <strong>of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></strong> is the <a class="existingWikiWord" href="/nlab/show/opposite+category">opposite</a> of the <a class="existingWikiWord" href="/nlab/show/Kleisli+category">Kleisli category</a>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">Kl(T)^{op}</annotation></semantics></math>.</p>
</div>

<p>The left adjoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo>→</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Set/S \to Kl(T)</annotation></semantics></math> is coproduct-preserving, so we have a product-preserving functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">(Set/S)^{op} \to Kl(T)^{op}</annotation></semantics></math></div>
<p>which is a bijection on the classes of objects. Therefore <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">Kl(T)^{op}</annotation></semantics></math> is indeed a (large, multi-sorted) Lawvere theory.</p>

<div class="un_thm">
<h6 id="theorem_2">Theorem 2</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> be a monad on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S</annotation></semantics></math>. The monad associated with the theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Th</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Th(T)</annotation></semantics></math> is isomorphic to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>.</p>
</div>

<div class="proof">
<h6 id="proof_3">Proof</h6>

<p>In other words, we claim the monad of the adjunction</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mover><mo>→</mo><mrow><msup><mi>Π</mi> <mi>op</mi></msup></mrow></mover><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mi>y</mi></mover><mi>Prod</mi><mo stretchy="false">(</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⊣</mo><mo stretchy="false">(</mo><mi>Prod</mi><mo stretchy="false">(</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>Π</mi><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mover><mi>Prod</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S \stackrel{\Pi^{op}}{\to} Kl(T) \stackrel{y}{\to} Prod(Kl(T)^{op}, Set)) \dashv (Prod(Kl(T)^{op}, Set) \stackrel{Prod(\Pi, 1)}{\to} Prod((Set/S)^{op}, Set) \simeq Set/S</annotation></semantics></math></div>
<p>is isomorphic to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. Now the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Π</mi> <mi>op</mi></msup><mo>:</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo>→</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Pi^{op}: Set/S \to Kl(T)</annotation></semantics></math> is left adjoint to the underlying functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">U: Kl(T) \to Set/S</annotation></semantics></math>, and the underlying monad there is of course <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. It is obvious that the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mover><mo>→</mo><mrow><msup><mi>Π</mi> <mi>op</mi></msup></mrow></mover><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mi>y</mi></mover><mi>Prod</mi><mo stretchy="false">(</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>Π</mi><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mover><mi>Prod</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Set/S \stackrel{\Pi^{op}}{\to} Kl(T) \stackrel{y}{\to} Prod(Kl(T)^{op}, Set) \stackrel{Prod(\Pi, 1)}{\to} Prod((Set/S)^{op}, Set)</annotation></semantics></math></div>
<p>takes an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">f: X \to S</annotation></semantics></math> to</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>Π</mi> <mi>op</mi></msup><mo>−</mo><mo>,</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>U</mi><mi>Π</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Kl(T)(\Pi^{op}-, \Pi(f)) \cong Set/S(-, U \Pi(f)) \cong Set/S(-, T(f))</annotation></semantics></math></div>
<p>and since the equivalence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Prod((Set/S)^{op}, Set) \to Set/S</annotation></semantics></math> is adjoint to the yoneda embedding, it takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Set/S(-, T(f))</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(f)</annotation></semantics></math>. This proves the claim.</p>
</div>

<p>In the other direction, we have</p>

<div class="un_thm">
<h6 id="theorem_3">Theorem 3</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>-sorted Lawvere theory. Then the Lawvere theory of the monad of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
</div>

<p>We assume for convenience that the product-preserving functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Pi: (Set/S)^{op} \to C</annotation></semantics></math> is the identity on the class of objects.</p>

<div class="proof">
<h6 id="proof_4">Proof</h6>

<p>We need to exhibit a comparison functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">Kl(T)^{op} \to C</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is the monad of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. Such a comparison functor exists provided that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Pi: (Set/S)^{op} \to C</annotation></semantics></math> has a left adjoint whose associated monad is isomorphic to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>. Now the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>op</mi></msup><mover><mo>→</mo><mi>y</mi></mover><mi>Prod</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>Π</mi><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mover><mi>Prod</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C^{op} \stackrel{y}{\to} Prod(C, Set) \stackrel{Prod(\Pi, 1)}{\to} Prod((Set/S)^{op}, Set)</annotation></semantics></math></div>
<p>sends an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">C^{op}</annotation></semantics></math> to the product-preserving functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mi>Π</mi><mo>−</mo><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">C(c, \Pi-): (Set/S)^{op} \to Set</annotation></semantics></math> which, by the remark above, is represented by an object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Set/S</annotation></semantics></math> which we denote as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>U</mi> <mi>op</mi></msup><mi>c</mi></mrow><annotation encoding="application/x-tex">U^{op} c</annotation></semantics></math>. In other words we have a natural isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mi>Π</mi><mo>−</mo><mo stretchy="false">)</mo><mo>≅</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo stretchy="false">(</mo><msup><mi>U</mi> <mi>op</mi></msup><mi>c</mi><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(c, \Pi-) \cong (Set/S)^{op}(U^{op} c, -)</annotation></semantics></math></div>
<p>and by the usual Yoneda yoga, we obtained a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>U</mi> <mi>op</mi></msup><mo>:</mo><mi>C</mi><mo>→</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">U^{op}: C \to (Set/S)^{op}</annotation></semantics></math> which is left adjoint to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>. The monad <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> is, by definition (see theorem 1) the monad associated with the adjoint pair <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>Π</mi> <mi>op</mi></msup><mo>:</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo>→</mo><mi>C</mi><mo stretchy="false">)</mo><mo>⊣</mo><mo stretchy="false">(</mo><mi>U</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Pi^{op}: Set/S \to C) \dashv (U: C \to Set/S)</annotation></semantics></math>.</p>

<p>We thus obtain the comparison functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">Kl(T)^{op} \to C</annotation></semantics></math>, and it is the identity on objects. On hom-sets it is given by the natural isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false">)</mo><mo>≅</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>T</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>U</mi><msup><mi>Π</mi> <mi>op</mi></msup><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>C</mi><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Kl(T)^{op}(f, g) \cong (Set/S)^{op}(f, T(g)) \cong (Set/S)^{op}(f, U\Pi^{op}(g)) \cong C(\Pi(f), \Pi(g))</annotation></semantics></math></div>
<p>and hence the comparison functor is an equivalence.</p>
</div>

<h3 id="algebras_and_models">Algebras and models</h3>

<p>Each <a class="existingWikiWord" href="/nlab/show/algebra+over+a+monad">algebra</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> of the monad <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> gives rise to a model <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>X</mi></msub></mrow><annotation encoding="application/x-tex">M_X</annotation></semantics></math> of the Lawvere theory:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>↪</mo><mi>Alg</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mover><mo>→</mo><mrow><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mover><mi>Set</mi></mrow><annotation encoding="application/x-tex">Kl(T)^{op} \hookrightarrow Alg(T)^{op} \stackrel{\hom(-, X)}{\to} Set</annotation></semantics></math></div>
<p>and similarly a morphism of algebras <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math> gives rise to a homomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>f</mi></msub><mo>:</mo><msub><mi>M</mi> <mi>X</mi></msub><mo>→</mo><msub><mi>M</mi> <mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">M_f: M_X \to M_Y</annotation></semantics></math>, so that we have a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>:</mo><mi>Alg</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Mod</mi><mo stretchy="false">(</mo><mi>Th</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M: Alg(T) \to Mod(Th(T), Set)</annotation></semantics></math>. This functor is an equivalence.</p>

<p>It is convenient to proceed as follows. By Theorem 2, the underlying functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">Prod(Kl(T)^{op}, Set) \to Set/S</annotation></semantics></math></div>
<p>has a left adjoint such that the associated monad is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>, and this yields a comparison functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>Prod</mi><mo stretchy="false">(</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Alg</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A: Prod(Kl(T)^{op}, Set) \to Alg(T)</annotation></semantics></math></div>
<div class="un_thm">
<h6 id="theorem_4">Theorem 4</h6>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is an equivalence.</p>
</div>

<div class="proof">
<h6 id="proof_5">Proof</h6>

<p>In outline, this proceeds as follows:</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is essentially surjective, because if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math>-algebra, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>X</mi></msub><mo>:</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">M_X: Kl(T)^{op} \to Set</annotation></semantics></math> is a product-preserving functor such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><msub><mi>M</mi> <mi>X</mi></msub><mo stretchy="false">)</mo><mo>≅</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A(M_X) \cong X</annotation></semantics></math>.</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is full, because any algebra map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math> gives rise to a model homomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>f</mi></msub><mo>:</mo><msub><mi>M</mi> <mi>X</mi></msub><mo>→</mo><msub><mi>M</mi> <mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">M_f: M_X \to M_Y</annotation></semantics></math>.</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is faithful. For this it suffices to prove that the underlying functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>Prod</mi><mo stretchy="false">(</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">U: Prod(Kl(T)^{op}, Set) \to Set/S</annotation></semantics></math></div>
<p>is faithful. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math> be a morphism of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Prod</mi><mo stretchy="false">(</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Prod(Kl(T)^{op}, Set)</annotation></semantics></math>. Now every object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">Kl(T)^{op}</annotation></semantics></math> is a product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mi>i</mi></msub><msub><mi>s</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\prod_i s_i</annotation></semantics></math> of objects in the image of</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>S</mi><mover><mo>→</mo><mi>i</mi></mover><mo stretchy="false">(</mo><mi>Set</mi><mo stretchy="false">/</mo><mi>S</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>→</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">S \stackrel{i}{\to} (Set/S)^{op} \to Kl(T)^{op}</annotation></semantics></math></div>
<p>From the naturality of the diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>X</mi><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mi>i</mi></munder><msub><mi>s</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><mi>f</mi><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mi>i</mi></munder><msub><mi>s</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mi>i</mi></munder><msub><mi>s</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mpadded width="0" lspace="-100%width"><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">)</mo></mrow></mpadded><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><mpadded width="0"><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>π</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mpadded></mtd></mtr> <mtr><mtd><mi>X</mi><mo stretchy="false">(</mo><msub><mi>s</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><munder><mo>→</mo><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>s</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></munder></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>s</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
X(\prod_i s_i) &amp; \overset{f(\prod_i s_i)}{\to} &amp; Y(\prod_i s_i) \\
\mathllap{X(\pi)} \downarrow &amp; &amp; \downarrow \mathrlap{Y(\pi_i)} \\
X(s_i) &amp; \underset{f(s_i)}{\to} &amp; Y(s_i)
}
</annotation></semantics></math></div>
<p>and the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> preserves products, we see that the component of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mi>i</mi></msub><msub><mi>s</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\prod_i s_i</annotation></semantics></math> is uniquely determined from the components <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(s): X(s) \to Y(s)</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> ranges over the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mi>i</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>Kl</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">\Pi i: S \to Kl(T)^{op}</annotation></semantics></math>, in other words that the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>X</mi><mi>Π</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">U(X) = X \Pi i</annotation></semantics></math> is faithful.</p>
</li>
</ul>

<p>Thus <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is an equivalence, with essential inverse <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>.</p>
</div>

<h2 id="metaphor">Metaphor</h2>

<p>Ring theory is a branch of mathematics with a well-developed terminology. A ring <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> determines and is determined by an algebraic theory, whose models are left <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>-modules and whose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-ary operations have the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>a</mi> <mn>1</mn></msub><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>a</mi> <mi>n</mi></msub><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">(x_1,\ldots ,x_n) \to a_1 x_1 + \cdots + a_n x_n</annotation></semantics></math></div>
<p>for some n-tuple <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1,\ldots ,a_n)</annotation></semantics></math> of elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. We may call such an algebraic theory <strong>annular</strong>. The pun <em>model/module</em> is due to <a class="existingWikiWord" href="/nlab/show/Jon+Beck">Jon Beck</a>. The notion that an algebraic theory is a generalized ring is often a fertile one, that automatically provides a slew of suggestive terminology and interesting problems. Many fundamental ideas of ring/module-theory are simply the restriction to annular algebraic theories of ideas that apply more widely to algebraic theories and their models.</p>

<p>Let us denote the category of models and homomorphisms (in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>) of an algebraic theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mi>Mod</mi></mrow><annotation encoding="application/x-tex">A Mod</annotation></semantics></math>. Then compare the following to their counterparts in ring theory:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/tensor+product+theory">Tensor Product of Theories</a></li>

<li><a class="existingWikiWord" href="/nlab/show/matrix+theory">Matrix Theories</a></li>

<li><a class="existingWikiWord" href="/nlab/show/bimodel">Bimodels</a></li>
</ul>

<h2 id="related_concepts">Related concepts</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/essentially+algebraic+theory">essentially algebraic theory</a></p>
</li>

<li>
<p><strong>algebraic theory</strong> / <a class="existingWikiWord" href="/nlab/show/Lawvere+theory">Lawvere theory</a> / <a class="existingWikiWord" href="/nlab/show/2-Lawvere+theory">2-Lawvere theory</a> / <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-algebraic+theory">(∞,1)-algebraic theory</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/algebraic+side+effect">algebraic side effect</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/generalized+algebraic+theory">generalized algebraic theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/globular+theory">globular theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monad">monad</a> / <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-monad">(∞,1)-monad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/operad">operad</a> / <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-operad">(∞,1)-operad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/finitely+complete+category">finitely complete category</a>, <a class="existingWikiWord" href="/nlab/show/cartesian+functor">cartesian functor</a>, <a class="existingWikiWord" href="/nlab/show/cartesian+logic">cartesian logic</a>, <a class="existingWikiWord" href="/nlab/show/cartesian+theory">cartesian theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/regular+category">regular category</a>, <a class="existingWikiWord" href="/nlab/show/regular+functor">regular functor</a>, <a class="existingWikiWord" href="/nlab/show/regular+logic">regular logic</a>, <a class="existingWikiWord" href="/nlab/show/regular+theory">regular theory</a>, <a class="existingWikiWord" href="/nlab/show/regular+coverage">regular coverage</a>, <a class="existingWikiWord" href="/nlab/show/regular+topos">regular topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/coherent+category">coherent category</a>, <a class="existingWikiWord" href="/nlab/show/coherent+functor">coherent functor</a>, <a class="existingWikiWord" href="/nlab/show/coherent+logic">coherent logic</a>, <a class="existingWikiWord" href="/nlab/show/coherent+theory">coherent theory</a>, <a class="existingWikiWord" href="/nlab/show/coherent+coverage">coherent coverage</a>, <a class="existingWikiWord" href="/nlab/show/coherent+topos">coherent topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+category">geometric category</a>, <strong>geometric functor</strong>, <a class="existingWikiWord" href="/nlab/show/geometric+logic">geometric logic</a>, <a class="existingWikiWord" href="/nlab/show/geometric+theory">geometric theory</a></p>
</li>
</ul>

<h2 id="references">References</h2>

<ul>
<li id="Manes76">
<p><a class="existingWikiWord" href="/nlab/show/Ernest+G.+Manes">Ernest G. Manes</a>, <em>Algebraic Theories</em>, Springer (1976) &lbrack;<a href="https://doi.org/10.1007/978-1-4612-9860-1">doi:10.1007/978-1-4612-9860-1</a>&rbrack;</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Ji%C5%99%C3%AD+Ad%C3%A1mek">Jiří Adámek</a>, <a class="existingWikiWord" href="/nlab/show/Ji%C5%99%C3%AD+Rosick%C3%BD">Jiří Rosický</a>, <a class="existingWikiWord" href="/nlab/show/Enrico+Vitale">Enrico Vitale</a>, <em>Algebraic theories</em>, Cambridge University Press (2011) &lbrack;<a href="https://doi.org/10.1017/CBO9780511760754">doi:10.1017/CBO9780511760754</a>, <a href="https://perso.uclouvain.be/enrico.vitale/gab_CUP2.pdf">pdf</a>&rbrack;</p>
</li>

<li id="Johnstone">
<p><a class="existingWikiWord" href="/nlab/show/Peter+Johnstone">Peter Johnstone</a>, <em><a class="existingWikiWord" href="/nlab/show/Stone+Spaces">Stone Spaces</a></em></p>
</li>

<li>
<p>B. Badzioch, “Algebraic Theories in Homotopy Theory”, Annals of Mathematics, 155, 895–913 (2002).</p>
</li>

<li id="keml-diagrams">
<p><a class="existingWikiWord" href="/nlab/show/Andreas+Nuyts">Andreas Nuyts</a>, <em>Understanding Universal Algebra Using Kleisli-Eilenberg-Moore-Lawvere Diagrams</em>, <a href="https://anuyts.github.io/files/keml-diagrams.pdf">note</a></p>
</li>
</ul>

<p>For a framework to compare different notions of algebraic theory see</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Soichiro+Fujii">Soichiro Fujii</a>, <em>A unified framework for notions of algebraic theory</em>, (<a href="https://arxiv.org/abs/1904.08541">arXiv:1904.08541</a>)</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on February 14, 2023 at 11:29:00.
    See the <a href="/nlab/history/algebraic+theory" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/algebraic+theory" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/3609/#Item_13">Discuss</a><span class="backintime"><a href="/nlab/revision/algebraic+theory/69" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/algebraic+theory" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/algebraic+theory" accesskey="S" class="navlink" id="history" rel="nofollow">History (69 revisions)</a>
  <a href="/nlab/show/algebraic+theory/cite" style="color: black">Cite</a>
  <a href="/nlab/print/algebraic+theory" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/algebraic+theory" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
