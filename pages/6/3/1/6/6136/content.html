
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      propagating flow in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      propagating flow
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussions/?CategoryID=0" title="Discuss this page on the nForum. It does not yet have a dedicated thread; feel free to create one, giving it the same name as the title of this page" style="color:black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="mapping_space">Mapping space</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a>/<a class="existingWikiWord" href="/nlab/show/mapping+space">mapping space</a></strong></p>

<h3 id="general_abstract">General abstract</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/hom-set">hom-set</a>, <a class="existingWikiWord" href="/nlab/show/hom-object">hom-object</a>, <a class="existingWikiWord" href="/nlab/show/internal+hom">internal hom</a>, <a class="existingWikiWord" href="/nlab/show/exponential+object">exponential object</a>, <a class="existingWikiWord" href="/nlab/show/derived+hom-space">derived hom-space</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/loop+space+object">loop space object</a>, <a class="existingWikiWord" href="/nlab/show/free+loop+space+object">free loop space object</a>, <a class="existingWikiWord" href="/nlab/show/derived+loop+space">derived loop space</a></p>
</li>
</ul>

<h3 id="topology">Topology</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+space">mapping space</a> (<a class="existingWikiWord" href="/nlab/show/compact-open+topology">compact-open topology</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/topology+of+mapping+spaces">topology of mapping spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/evaluation+fibration+of+mapping+spaces">evaluation fibration of mapping spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/loop+space">loop space</a>, <a class="existingWikiWord" href="/nlab/show/free+loop+space">free loop space</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/free+loop+space+of+a+classifying+space">free loop space of a classifying space</a></li>
</ul>
</li>
</ul>

<h3 id="simplicial_homotopy_theory">Simplicial homotopy theory</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/simplicial+mapping+complex">simplicial mapping complex</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/inertia+groupoid">inertia groupoid</a></p>
</li>
</ul>

<h3 id="differential_topology">Differential topology</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/differential+topology+of+mapping+spaces">differential topology of mapping spaces</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/C-k+topology">C-k topology</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/manifold+structure+of+mapping+spaces">manifold structure of mapping spaces</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/tangent+spaces+of+mapping+spaces">tangent spaces of mapping spaces</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/smooth+loop+space">smooth loop space</a></p>
</li>
</ul>

<h3 id="stable_homotopy_theory">Stable homotopy theory</h3>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/mapping+spectrum">mapping spectrum</a></li>
</ul>

<h3 id="geometric_homotopy_theory">Geometric homotopy theory</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+stack">mapping stack</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/inertia+stack">inertia stack</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/free+loop+stack">free loop stack</a></p>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/mapping+space+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#definition'>Definition</a></li>
<li><a href='#construction'>Construction</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p><a class="existingWikiWord" href="/nlab/show/smooth+mapping+space">Smooth mapping spaces</a> are very nice examples of <a class="existingWikiWord" href="/nlab/show/infinite+dimensional+smooth+manifolds">infinite dimensional smooth manifolds</a>.</p>

<p>One reason for their nice behaviour is that it is often possible to use the structure of the <a class="existingWikiWord" href="/nlab/show/target+space">target space</a> (a finite <a class="existingWikiWord" href="/nlab/show/dimension">dimension</a>al <a class="existingWikiWord" href="/nlab/show/manifold">manifold</a>) to study the mapping space. This provides a route from finite dimensional <a class="existingWikiWord" href="/nlab/show/differential+topology">differential topology</a> to that of infinite dimensions. It is usually the case that one needs stronger structure on the target space to do this than would be needed just for the finite dimensional result, but as the target space is a finite dimensional manifold that stronger structure is usually there anyway.</p>

<p>An example of this is the concept of a <a class="existingWikiWord" href="/nlab/show/tubular+neighbourhood">tubular neighbourhood</a> of an <a class="existingWikiWord" href="/nlab/show/embedding">embedding</a>. As shown at <a class="existingWikiWord" href="/nlab/show/A+Not-So-Nice+Submanifold">A Not-So-Nice Submanifold</a>, not all embeddings of infinite dimensional manifolds - even of mapping spaces - admit tubular neighbourhoods. However, if the embedding is of a coincidental nature then it is possible to use structure on the target manifold to find tubular neighbourhoods in infinite dimensions.</p>

<p>By “coincidental nature”, we mean that the submanifold is defined by taking those smooth maps with some condition imposed that says that certain “coincidences” happen. That is, that the values of the map at certain points coincide, or are constrained to lie in some submanifold of the target space.</p>

<p>Let us consider, for an example, the simplest case: the inclusion of based loops in <a class="existingWikiWord" href="/nlab/show/smooth+loop+space">smooth loops</a>. So let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> be a smooth finite dimensional manifold, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>L</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">L M</annotation></semantics></math> its smooth <a class="existingWikiWord" href="/nlab/show/free+loop+space">free loop space</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ω</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\Omega M</annotation></semantics></math> its smooth <a class="existingWikiWord" href="/nlab/show/based+loop+space">based loop space</a>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math> be the basepoint of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> the basepoint of the <a class="existingWikiWord" href="/nlab/show/circle">circle</a>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>S</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">S^1</annotation></semantics></math>. To get a tubular neighbourhood of this, we need to start by finding a suitable neighbourhood. To do this, we choose a <a class="existingWikiWord" href="/nlab/show/chart">chart</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo lspace="verythinmathspace">:</mo><msup><mi>ℝ</mi> <mi>n</mi></msup><mo>→</mo><mi>U</mi><mo>⊆</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\phi \colon \mathbb{R}^n \to U \subseteq M</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math> (so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\phi(0) = x_0</annotation></semantics></math>). We define the neighbourhood of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ω</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\Omega M</annotation></semantics></math> to be those loops <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo>∈</mo><mi>L</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\alpha \in L M</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∈</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\alpha(1) \in U</annotation></semantics></math>. To make this a <em>tubular</em> neighbourhood, we need to find a way to project these loops on to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ω</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">\Omega M</annotation></semantics></math>. That is, given a loop <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo lspace="verythinmathspace">:</mo><msup><mi>S</mi> <mn>1</mn></msup><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\alpha \colon S^1 \to M</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∈</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\alpha(1) \in U</annotation></semantics></math> we need to produce a loop <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><msup><mi>S</mi> <mn>1</mn></msup><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\pi(\alpha) \colon S^1 \to M</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi(\alpha)(1) = x_0</annotation></semantics></math>. It is obvious how to move the basepoint: simply scale it to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math> using the scalar multiplication coming from the chart. However, that just moves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(1)</annotation></semantics></math>. We need to move the whole of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> with it - or at least, drag that part of it near <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>. We cannot assume that all of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> lies in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>. The solution is to define a diffeomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ψ</mi></mrow><annotation encoding="application/x-tex">\Psi</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> with the property that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ψ</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\Psi(\alpha(1)) = x_0</annotation></semantics></math>. Then we can define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Ψ</mi><mo>∘</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\pi(\alpha) = \Psi \circ \alpha</annotation></semantics></math>. As we vary <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>, so we also vary <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(1)</annotation></semantics></math>, and thus must vary the diffeomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ψ</mi></mrow><annotation encoding="application/x-tex">\Psi</annotation></semantics></math>. The trick is to choose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ψ</mi></mrow><annotation encoding="application/x-tex">\Psi</annotation></semantics></math> so that it varies smoothly with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(1)</annotation></semantics></math>.</p>

<p>In the above example, this is straightforward because everything happens in the chart, and thus effectively on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℝ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math>. There are more complicated examples. One such is the basic construction in <a class="existingWikiWord" href="/nlab/show/string+topology">string topology</a>. Within <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>L</mi><mi>M</mi><mo>×</mo><mi>L</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">L M \times L M</annotation></semantics></math> we consider those pairs of loops <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><mo>,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\alpha,\beta)</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>β</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(1) = \beta(1)</annotation></semantics></math>. Then for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><mo>,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\alpha,\beta)</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(1)</annotation></semantics></math> <em>near</em> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta(1)</annotation></semantics></math> we want to project the pair <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><mo>,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\alpha,\beta)</annotation></semantics></math> to a pair where these values coincide. Now although the points <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha(1)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>β</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta(1)</annotation></semantics></math> are near (in some vague not-yet-defined sense), they may, as a pair, roam all over the manifold. Thus local solutions are not applicable here. Nonetheless, the question still comes down to the ability to choose diffeomorphisms consistently according to some conditions.</p>

<h2 id="definition">Definition</h2>

<p>One way to choose these diffeomorphisms is to use the notion of a <strong>propagating flow</strong>. The term was coined by <a class="existingWikiWord" href="/nlab/show/Veronique+Godin">Veronique Godin</a> in (<a href="#Godin">Godin, 07</a>) and is based on an idea due to <a class="existingWikiWord" href="/nlab/show/Andrew+Stacey">Andrew Stacey</a> in (<a href="#Stacey">Stacey, 05</a>), though there are probably antecedents. The basic idea is contained in the following definition.</p>

<div class="num_definition" id="propflow">
<h6 id="definition_2">Definition</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\pi \colon E \to M</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/vector+bundle">vector bundle</a> over a <a class="existingWikiWord" href="/nlab/show/smooth+manifold">smooth manifold</a>. Everything here is assumed to be finite dimensional. We consider the space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Diff</mi> <mi>fc</mi></msub><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Diff_{fc}(E)</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/diffeomorphisms">diffeomorphisms</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> which preserve the <a class="existingWikiWord" href="/nlab/show/fibres">fibres</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> and have <a class="existingWikiWord" href="/nlab/show/compact+support">compact support</a>. A <strong>propagating flow</strong> is a <a class="existingWikiWord" href="/nlab/show/smooth+map">smooth map</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><msub><mi>Diff</mi> <mi>fc</mi></msub><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  \phi \colon E \to Diff_{fc}(E)

</annotation></semantics></math></div>
<p>with the property that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>:</mo><mi>v</mi><mo>↦</mo><mi>π</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  \phi(v) : v \mapsto \pi(v)

</annotation></semantics></math></div>
<p>where we identify <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(v)</annotation></semantics></math> with the zero vector in the corresponding fibre of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>.</p>
</div>

<h2 id="construction">Construction</h2>

<p>The original definition of a propagating flow in <a href="#Stacey">Stacey, 05</a> and <a href="#Godin">Godin, 07</a> used the exponentiation map from vector fields to diffeomorphisms to get the actual diffeomorphism. The idea of that was that it is much easier to build a vector field with the required properties than a diffeomorphism because vector fields are more easily manipulated. But the diffeomorphisms used here are simple enough that they can be constructed directly. This makes it easier to generalise to situations where the exponentiation map cannot be assumed to exist.</p>

<p>Let us consider the linear situation first. We start with a vector space, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, and a vector <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v \in V</annotation></semantics></math>. We want to define a diffeomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub><mo lspace="verythinmathspace">:</mo><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\phi_v \colon V \to V</annotation></semantics></math> with the property that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\phi_v(v) = 0</annotation></semantics></math>. This is simple enough:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mo>−</mo><mi>v</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">
\phi_1(w) = w - v.

</annotation></semantics></math></div>
<p>The problem with this is that we do not want just any diffeomorphism. We want one that is the identity “near infinity”. Let us start by fixing the diffeomorphism in the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math>-direction.</p>

<p>Choose a smooth function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo lspace="verythinmathspace">:</mo><mi>ℝ</mi><mo>→</mo><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sigma \colon \mathbb{R} \to [-1,0]</annotation></semantics></math> with the following properties:</p>

<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>{</mo><mrow><mtable displaystyle="false" columnalign="left left"><mtr><mtd><mn>0</mn></mtd> <mtd><mi>t</mi><mo>≤</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>2</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mtd> <mtd><mn>0</mn><mo>≤</mo><mi>t</mi><mo>≤</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>2</mn><mo>≤</mo><mi>t</mi></mtd></mtr></mtable></mrow></mrow></mrow><annotation encoding="application/x-tex">\sigma(t) = \begin{cases} 0 &amp; t \le -2 \\ - 1 &amp; 0 \le t \le 1 \\ 0 &amp; 2 \le t \end{cases}</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>′</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sigma'(t) \gt -1</annotation></semantics></math> (note that this is possible as we have given ourselves an interval of length <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math> to get from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">t = -2</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>.</li>
</ol>

<p>We are actually interested in the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>↦</mo><mi>t</mi><mo>+</mo><mi>h</mi><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \mapsto t + h \sigma(t)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">|</mo><mi>h</mi><mo stretchy="false">|</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|h| \le 1</annotation></semantics></math>. The first property of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> tells us that this agrees with the identity outside <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>2</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2,2]</annotation></semantics></math> and that it is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>↦</mo><mi>t</mi><mo>−</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">t \mapsto t - h</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. The second property tells us that its derivative is strictly bigger than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>−</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">1 - h</annotation></semantics></math> and so, for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>h</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h \le 1</annotation></semantics></math>, is a diffeomorphism.</p>

<p>On <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, we choose a “dual functional” to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math>. That is, we choose some continuous linear functional <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>V</mi><mo>→</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">f \colon V \to \mathbb{R}</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(v) = 1</annotation></semantics></math> (we need to assume that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v \ne 0</annotation></semantics></math> for this part, we shall correct for that later). Then we define a diffeomorphism on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> by:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mo>+</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>+</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>v</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">
\phi_2(w) = w + \sigma(f(w))v =  (w - f(w)v) + (f(w) + \sigma(f(w)))v.

</annotation></semantics></math></div>
<p>The second expression shows that what we have done is used <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> to identify <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ker</mi><mi>f</mi><mo>⊕</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\ker f \oplus \mathbb{R}</annotation></semantics></math> and then applied <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>↦</mo><mi>t</mi><mo>+</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t \mapsto t + \sigma(t)</annotation></semantics></math> on the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>-factor.</p>

<p>This fixes our diffeomorphism in the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math>-direction. To fix it in the other direction, we choose a smooth function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>τ</mi><mo>^</mo></mover><mo lspace="verythinmathspace">:</mo><mi>ker</mi><mi>f</mi><mo>→</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\widehat{\tau} \colon \ker f \to [0,1]</annotation></semantics></math> which is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math> “near infinity” and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>. Then we mix this in to the above as follows:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mn>3</mn></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mo>+</mo><mover><mi>τ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>v</mi><mo stretchy="false">)</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>+</mo><mover><mi>τ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>v</mi><mo stretchy="false">)</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>v</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">
\phi_3(w) = w + \widehat{\tau}(w - f(w)v) \sigma(f(w))v = (w - f(w)v) + (f(w) + \widehat{\tau}(w - f(w)v) \sigma(f(w)) v.

</annotation></semantics></math></div>
<p>As before, the second expression makes it clear that this is a diffeomorphism. When <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>τ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>w</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\widehat{\tau}(w - f(w)v) = 0</annotation></semantics></math> then it is the identity.</p>

<p>This will do, but there are a few too many choices in the above. To simplify these, we assume that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> admits a smooth inner product, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math>. Let us write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math> for the square of the associated norm. Then we can choose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> to be evaluation of the inner product at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math> to be composition of the inner product with a suitable bump function on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>. We shall write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math> for that bump function. To make the final formula cleaner, we assume that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\tau(t) = 1</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">|</mo><mi>t</mi><mo stretchy="false">|</mo><mo>≤</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">|t| \le 2</annotation></semantics></math>. This leads us to:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" columnalign="right left right left right left right left right left" columnspacing="0em"><mtr><mtd><msub><mi>ϕ</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo><mi>w</mi><mo>+</mo><mi>τ</mi><mrow><mo>(</mo><mfrac><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>+</mo><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><mi>σ</mi><mrow><mo>(</mo><mfrac><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><mi>v</mi></mtd> <mtd><mo>=</mo><mi>w</mi><mo>−</mo><mfrac><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mfrac><mi>v</mi><mo>+</mo><mrow><mo>(</mo><mfrac><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mi>τ</mi><mrow><mo>(</mo><mfrac><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><mi>σ</mi><mrow><mo>(</mo><mfrac><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><mo>)</mo></mrow><mi>v</mi><mo>.</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\begin{aligned}
\phi_v(w) &amp;= w + \tau\left(\frac{q(w)}{1 + q(v)}\right) \sigma\left(\frac{g(w,v)}{q(v)}\right) v
&amp;= w - \frac{g(w,v)}{q(v)}v + \left(\frac{g(w,v)}{q(v)} + \tau\left(\frac{q(w)}{q(v)}\right) \sigma\left(\frac{g(w,v)}{q(v)}\right) \right)v.
\end{aligned}

</annotation></semantics></math></div>
<p>As written, this makes sense only for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v \ne 0</annotation></semantics></math>. But it extends to the identity at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v = 0</annotation></semantics></math>. To see that this extension is smooth, we need merely point out that as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v \to 0</annotation></semantics></math>, so <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">q(v) \to 0</annotation></semantics></math> and thus <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mrow><mo>(</mo><mfrac><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\sigma\left(\frac{g(w,v)}{q(v)}\right) \to 0</annotation></semantics></math>. The second expression again shows that, for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">v \ne 0</annotation></semantics></math>, this is a diffeomorphism.</p>

<p>This, then, is our required linear diffeomorphism. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>2</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>q</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(w) \ge 2(1 + q(v))</annotation></semantics></math> it is the identity, and thus will extend “at infinity”, whilst <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\phi_v(v) = 0</annotation></semantics></math>.</p>

<p>The next step is to extend this to a bundle over a manifold. So let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\pi \colon E \to M</annotation></semantics></math> be a smooth vector bundle over a smooth manifold. We wish to extend the above formula so that it is valid for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>. That is, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math> is an arbitrary point in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> and we wish to define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\phi_v \colon E \to E</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mn>0</mn> <mrow><mi>π</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_v(v) = 0_{\pi(v)}</annotation></semantics></math>. So also we must take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math> to be an arbitrary point in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>. And thereby lies the problem: in the formula <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math> interact but they may be in different fibres. The solution is to extend one of them to a vector field. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math> is static in the formula for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\phi_v</annotation></semantics></math>, that is the obvious choice.</p>

<p>We should also note that the explicit formula requires the existence of a smooth <a class="existingWikiWord" href="/nlab/show/orthogonal+structure">orthogonal structure</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math>.</p>

<p>Thus we want to define a smooth function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><mi>Γ</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \colon E \to \Gamma(E)</annotation></semantics></math> with the property that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">X_v(\pi(v)) = v</annotation></semantics></math>. This is easy if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> is trivial, and the condition is convex, so a standard <a class="existingWikiWord" href="/nlab/show/partition+of+unity">partition of unity</a> argument will suffice. Specifically, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>ρ</mi> <mi>λ</mi></msub><mo>:</mo><mi>λ</mi><mo>∈</mo><mi>Λ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\rho_\lambda : \lambda \in \Lambda\}</annotation></semantics></math> be a partition of unity on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> with the property that for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo>∈</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda \in \lambda</annotation></semantics></math> there is an open set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">U_\lambda</annotation></semantics></math> containing the support of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ρ</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">\rho_\lambda</annotation></semantics></math> over which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> is trivial. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>E</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">E_\lambda</annotation></semantics></math> denote the restriction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">U_\lambda</annotation></semantics></math> and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ψ</mi> <mi>λ</mi></msub><mo lspace="verythinmathspace">:</mo><msub><mi>E</mi> <mi>λ</mi></msub><mo>→</mo><msub><mi>U</mi> <mi>λ</mi></msub><mo>×</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\psi_\lambda \colon E_\lambda \to U_\lambda \times V</annotation></semantics></math> be a trivialisation. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub><mo lspace="verythinmathspace">:</mo><msub><mi>E</mi> <mi>λ</mi></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">p_\lambda \colon E_\lambda \to V</annotation></semantics></math> be the composition of this trivialisation with the projection on to the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-factor. We define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>λ</mi></msub><mo lspace="verythinmathspace">:</mo><msub><mi>E</mi> <mi>λ</mi></msub><mo>→</mo><mi>Γ</mi><mo stretchy="false">(</mo><msub><mi>E</mi> <mi>λ</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_\lambda \colon E_\lambda \to \Gamma(E_\lambda)</annotation></semantics></math> by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mrow><mi>λ</mi><mo>,</mo><mi>v</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>ψ</mi> <mi>λ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><msub><mi>p</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">
X_{\lambda,v}(p) = \psi_\lambda^{-1}(p,p_\lambda(v)).

</annotation></semantics></math></div>
<p>Now we define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo lspace="verythinmathspace">:</mo><mi>E</mi><mo>→</mo><mi>Γ</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \colon E \to \Gamma(E)</annotation></semantics></math> by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mi>λ</mi></munder><msub><mi>ρ</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><msub><mi>X</mi> <mrow><mi>λ</mi><mo>,</mo><mi>v</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">
X_v(p) = \sum_\lambda \rho_\lambda(p) X_{\lambda,v}(p).

</annotation></semantics></math></div>
<p>Notice that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">X_v(p) = 0</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math> is “sufficiently far” from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(v)</annotation></semantics></math>.</p>

<p>Thus our diffeomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\phi_v</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math>, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>=</mo><mi>π</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p = \pi(w)</annotation></semantics></math>, is:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>{</mo><mrow><mtable displaystyle="false" columnalign="left left"><mtr><mtd><mi>w</mi><mo>+</mo><mi>τ</mi><mrow><mo>(</mo><mfrac><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>+</mo><mi>q</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><mi>σ</mi><mrow><mo>(</mo><mfrac><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>q</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mtd> <mtd><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≠</mo><mn>0</mn></mtd></mtr> <mtr><mtd><mi>w</mi></mtd> <mtd><msub><mi>X</mi> <mi>v</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mtd></mtr></mtable></mrow></mrow><mo>.</mo></mrow><annotation encoding="application/x-tex">
\phi_v(w) = \begin{cases} w + \tau\left(\frac{q(w)}{1 + q(X_v(p))}\right) \sigma \left(\frac{g(w,X_v(p))}{q(X_v(p))}\right) X_v(p) &amp; X_v(p) \ne 0 \\
w &amp; X_v(p) = 0 \end{cases}.

</annotation></semantics></math></div>
<h2 id="references">References</h2>

<p>The idea goes back to</p>

<ul id="Stacey">
<li><a class="existingWikiWord" href="/nlab/show/Andrew+Stacey">Andrew Stacey</a>, <em>The differential topology of smooth loops</em> (<a href="http://arxiv.org/abs/math/0510097">arXiv:math/0510097</a>)</li>
</ul>

<p>The term <em>propagating flow</em> was coined in</p>

<ul id="Godin">
<li><a class="existingWikiWord" href="/nlab/show/Veronique+Godin">Veronique Godin</a>, <em>Higher string topology operations</em> (2007)(<a href="http://arxiv.org/abs/0711.4859">arXiv:0711.4859</a>)</li>
</ul>

<p>and used for the construction of <a class="existingWikiWord" href="/nlab/show/umkehr+maps">umkehr maps</a> to construct <a class="existingWikiWord" href="/nlab/show/string+topology">string topology</a> operations.</p>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on September 19, 2011 at 15:03:51.
    See the <a href="/nlab/history/propagating+flow" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/propagating+flow" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussions/?CategoryID=0">Discuss</a><span class="backintime"><a href="/nlab/revision/propagating+flow/4" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/propagating+flow" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/propagating+flow" accesskey="S" class="navlink" id="history" rel="nofollow">History (4 revisions)</a>
  <a href="/nlab/show/propagating+flow/cite" style="color: black">Cite</a>
  <a href="/nlab/print/propagating+flow" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/propagating+flow" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
