
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      motivation for sheaves, cohomology and higher stacks in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />


  <link href="/stylesheets/instiki.css?1534097725" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #008B26;
    }
    a:visited.existingWikiWord {
      color: #005c19;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #005000;
}

a.existingWikiWord:visited {
color: #005000;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    
<span id="svg_logo"><svg version="1.1" width="100%" height="100%" viewBox='0 -1 180 198' xmlns='http://www.w3.org/2000/svg'>
      <path id="svg_logo_path" fill="#008B26" stroke-width='0.5' stroke='#000' d='
        M170,60c4,11-1,20-12,25c-9,4-25,3-20,15c5,5,15,0,24,1c11,1,21,11,14,21c-10,15-35,6-48-1c-5-3-27-23-32-10c-1,13,15,10,22,16
        c11,4,24,14,34,20c12,10,7,25-9,23c-11-1-22-9-30-16c-5-5-13-18-21-9c-2,6,2,11,5,14c9,9,22,14,22,31c-2,8-12,8-18,4c-4-3-9-8-11-13
        c-3-6-5-18-12-18c-14-1-5,28-18,30c-9,2-13-9-12-16c1-14,12-24,21-31c5-4,17-13,10-20c-9-10-19,12-23,16c-7,7-17,16-31,15
        c-9-1-18-9-11-17c5-7,14-4,23-6c6-1,15-8,8-15c-5-6-57,2-42-24c7-12,51,4,61,6c6,1,17,4,18-4c2-11-12-7-21-8c-21-2-49-14-49-34
        c0-5,3-11,8-11C31,42,34,65,42,67c6,1,9-3,8-9C49,49,38,40,40,25c1-5,4-15,13-14c10,2,11,18,13,29c1,8,0,24,7,28c15,0,5-22,4-30
        C74,23,78,7,87,1c8-4,14,1,16,9c2,11-8,21-2,30c8,2,11-6,14-12c9-14,36-18,30,5c-3,9-12,19-21,24c-6,4-22,10-23,19c-2,14,15,2,18-2
        c9-9,20-18,33-22C159,52,166,54,170,60' />
    </svg></span>
      <span class="webName">nLab</span><br />
      motivation for sheaves, cohomology and higher stacks
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussions/?CategoryID=0" title="Discuss this page on the nForum. It does not yet have a dedicated thread; feel free to create one, giving it the same name as the title of this page" style="color:black">Discuss this page</a> |
    <a href="/nlab/feeds" title="Subscribe to changes by Atom">Feeds</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="cohomology">Cohomology</h4>

<div class="hide"><p><strong><a class="existingWikiWord" href="/nlab/show/cohomology">cohomology</a></strong></p><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cocycle">cocycle</a>, <a class="existingWikiWord" href="/nlab/show/coboundary">coboundary</a>, <a class="existingWikiWord" href="/nlab/show/coefficient">coefficient</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homology">homology</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/chain">chain</a>, <a class="existingWikiWord" href="/nlab/show/cycle">cycle</a>, <a class="existingWikiWord" href="/nlab/show/boundary">boundary</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/characteristic+class">characteristic class</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/universal+characteristic+class">universal characteristic class</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/secondary+characteristic+class">secondary characteristic class</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/differential+characteristic+class">differential characteristic class</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fiber+sequence">fiber sequence</a>/<a class="existingWikiWord" href="/nlab/show/long+exact+sequence+in+cohomology">long exact sequence in cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fiber+%E2%88%9E-bundle">fiber ∞-bundle</a>, <a class="existingWikiWord" href="/nlab/show/principal+%E2%88%9E-bundle">principal ∞-bundle</a>, <a class="existingWikiWord" href="/nlab/show/associated+%E2%88%9E-bundle">associated ∞-bundle</a>,</p>

<p><a class="existingWikiWord" href="/nlab/show/twisted+%E2%88%9E-bundle">twisted ∞-bundle</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%E2%88%9E-group+extension">∞-group extension</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/obstruction">obstruction</a></p>
</li>
</ul><h3 id="special_and_general_types">Special and general types</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cochain+cohomology">cochain cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/ordinary+cohomology">ordinary cohomology</a>, <a class="existingWikiWord" href="/nlab/show/singular+cohomology">singular cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/group+cohomology">group cohomology</a>, <a class="existingWikiWord" href="/nlab/show/nonabelian+group+cohomology">nonabelian group cohomology</a>, <a class="existingWikiWord" href="/nlab/show/Lie+group+cohomology">Lie group cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Galois+cohomology">Galois cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/groupoid+cohomology">groupoid cohomology</a>, <a class="existingWikiWord" href="/nlab/show/nonabelian+groupoid+cohomology">nonabelian groupoid cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/generalized+%28Eilenberg-Steenrod%29+cohomology">generalized (Eilenberg-Steenrod) cohomology</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cobordism+cohomology+theory">cobordism cohomology theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/integral+cohomology">integral cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/K-theory">K-theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/elliptic+cohomology">elliptic cohomology</a>, <a class="existingWikiWord" href="/nlab/show/tmf">tmf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/taf">taf</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/abelian+sheaf+cohomology">abelian sheaf cohomology</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Deligne+cohomology">Deligne cohomology</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/de+Rham+cohomology">de Rham cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Dolbeault+cohomology">Dolbeault cohomology</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/etale+cohomology">etale cohomology</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/group+of+units">group of units</a>, <a class="existingWikiWord" href="/nlab/show/Picard+group">Picard group</a>, <a class="existingWikiWord" href="/nlab/show/Brauer+group">Brauer group</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/crystalline+cohomology">crystalline cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/syntomic+cohomology">syntomic cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/motivic+cohomology">motivic cohomology</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohomology+of+operads">cohomology of operads</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Hochschild+cohomology">Hochschild cohomology</a>, <a class="existingWikiWord" href="/nlab/show/cyclic+cohomology">cyclic cohomology</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/string+topology">string topology</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/nonabelian+cohomology">nonabelian cohomology</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/principal+%E2%88%9E-bundle">principal ∞-bundle</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/universal+principal+%E2%88%9E-bundle">universal principal ∞-bundle</a>, <a class="existingWikiWord" href="/nlab/show/groupal+model+for+universal+principal+%E2%88%9E-bundles">groupal model for universal principal ∞-bundles</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/principal+bundle">principal bundle</a>, <a class="existingWikiWord" href="/nlab/show/Atiyah+Lie+groupoid">Atiyah Lie groupoid</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/principal+2-bundle">principal 2-bundle</a>/<a class="existingWikiWord" href="/nlab/show/gerbe">gerbe</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/locally+constant+%E2%88%9E-stack">covering ∞-bundle</a>/<a class="existingWikiWord" href="/nlab/show/local+system">local system</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-vector+bundle">(∞,1)-vector bundle</a> / <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2Cn%29-vector+bundle">(∞,n)-vector bundle</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/quantum+anomaly">quantum anomaly</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/orientation">orientation</a>, <a class="existingWikiWord" href="/nlab/show/Spin+structure">Spin structure</a>, <a class="existingWikiWord" href="/nlab/show/Spin%5Ec+structure">Spin^c structure</a>, <a class="existingWikiWord" href="/nlab/show/String+structure">String structure</a>, <a class="existingWikiWord" href="/nlab/show/Fivebrane+structure">Fivebrane structure</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohomology+with+constant+coefficients">cohomology with constant coefficients</a> / <a class="existingWikiWord" href="/nlab/show/cohomology+with+a+local+system+of+coefficients">with a local system of coefficients</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%E2%88%9E-Lie+algebra+cohomology">∞-Lie algebra cohomology</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Lie+algebra+cohomology">Lie algebra cohomology</a>, <a class="existingWikiWord" href="/nlab/show/nonabelian+Lie+algebra+cohomology">nonabelian Lie algebra cohomology</a>, <a class="existingWikiWord" href="/nlab/show/Lie+algebra+extensions">Lie algebra extensions</a>, <a class="existingWikiWord" href="/nlab/show/Gelfand-Fuks+cohomology">Gelfand-Fuks cohomology</a>,</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Gerstenhaber-Schack+cohomology">bialgebra cohomology</a></p>
</li>
</ul><h3 id="special_notions">Special notions</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%3Fech+cohomology">?ech cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hypercohomology">hypercohomology</a></p>
</li>
</ul><h3 id="variants">Variants</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/equivariant+cohomology">equivariant cohomology</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/equivariant+homotopy+theory">equivariant homotopy theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bredon+cohomology">Bredon cohomology</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/twisted+cohomology">twisted cohomology</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/twisted+bundle">twisted bundle</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/twisted+K-theory">twisted K-theory</a>, <a class="existingWikiWord" href="/nlab/show/twisted+spin+structure">twisted spin structure</a>, <a class="existingWikiWord" href="/nlab/show/twisted+spin%5Ec+structure">twisted spin^c structure</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/twisted+differential+c-structures">twisted differential c-structures</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/twisted+differential+string+structure">twisted differential string structure</a>, <a class="existingWikiWord" href="/nlab/show/twisted+differential+fivebrane+structure">twisted differential fivebrane structure</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p>differential cohomology</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/differential+cohomology">differential generalized (Eilenberg-Steenrod) cohomology</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/differential+cobordism+cohomology">differential cobordism cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Deligne+cohomology">Deligne cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/differential+K-theory">differential K-theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/differential+elliptic+cohomology">differential elliptic cohomology</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/schreiber/show/differential+cohomology+in+a+cohesive+topos">differential cohomology in a cohesive topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Chern-Weil+theory">Chern-Weil theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%E2%88%9E-Chern-Weil+theory">∞-Chern-Weil theory</a></p>
</li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relative+cohomology">relative cohomology</a></p>
</li>
</ul><h3 id="extra_structure">Extra structure</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Hodge+structure">Hodge structure</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/orientation">orientation</a>, <a class="existingWikiWord" href="/nlab/show/orientation+in+generalized+cohomology">in generalized cohomology</a></p>
</li>
</ul><h3 id="operations">Operations</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cohomology+operations">cohomology operations</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cup+product">cup product</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/connecting+homomorphism">connecting homomorphism</a>, <a class="existingWikiWord" href="/nlab/show/Bockstein+homomorphism">Bockstein homomorphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fiber+integration">fiber integration</a>, <a class="existingWikiWord" href="/nlab/show/transgression">transgression</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohomology+localization">cohomology localization</a></p>
</li>
</ul><h3 id="theorems">Theorems</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/universal+coefficient+theorem">universal coefficient theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/K%C3%BCnneth+theorem">Künneth theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/de+Rham+theorem">de Rham theorem</a>, <a class="existingWikiWord" href="/nlab/show/Poincare+lemma">Poincare lemma</a>, <a class="existingWikiWord" href="/nlab/show/Stokes+theorem">Stokes theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Hodge+theory">Hodge theory</a>, <a class="existingWikiWord" href="/nlab/show/Hodge+theorem">Hodge theorem</a></p>

<p><a class="existingWikiWord" href="/nlab/show/nonabelian+Hodge+theory">nonabelian Hodge theory</a>, <a class="existingWikiWord" href="/nlab/show/noncommutative+Hodge+theory">noncommutative Hodge theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Brown+representability+theorem">Brown representability theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/abelian+sheaf+cohomology">hypercovering theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Eckmann-Hilton+duality">Eckmann-Hilton-Fuks duality</a></p>
</li>
</ul><div>
<p>
  <a href="/nlab/edit/cohomology+-+contents">Edit this sidebar</a>
</p>
</div></div>

<h4 id="topos_theory"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-Topos Theory</h4>

<div class="hide"><p><strong><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-topos+theory">(∞,1)-topos theory</a></strong></p><h2 id="background">Background</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sheaf+and+topos+theory">sheaf and topos theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-functor">(∞,1)-functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-presheaf">(∞,1)-presheaf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+of+%28%E2%88%9E%2C1%29-presheaves">(∞,1)-category of (∞,1)-presheaves</a></p>
</li>
</ul><h2 id="definitions">Definitions</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/elementary+%28%E2%88%9E%2C1%29-topos">elementary (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-site">(∞,1)-site</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/reflective+sub-%28%E2%88%9E%2C1%29-category">reflective sub-(∞,1)-category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/localization+of+an+%28%E2%88%9E%2C1%29-category">localization of an (∞,1)-category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/topological+localization">topological localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hypercompletion">hypercompletion</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+of+%28%E2%88%9E%2C1%29-sheaves">(∞,1)-category of (∞,1)-sheaves</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-sheaf">(∞,1)-sheaf</a>/<a class="existingWikiWord" href="/nlab/show/%E2%88%9E-stack">∞-stack</a>/<a class="existingWikiWord" href="/nlab/show/derived+stack">derived stack</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-topos">(∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28n%2C1%29-topos">(n,1)-topos</a>, <a class="existingWikiWord" href="/nlab/show/n-topos">n-topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/truncated">n-truncated object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/connected">n-connected object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/topos">(1,1)-topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%282%2C1%29-topos">(2,1)-topos</a>, <a class="existingWikiWord" href="/nlab/show/2-topos">2-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/%282%2C1%29-presheaf">(2,1)-presheaf</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-quasitopos">(∞,1)-quasitopos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/separated+%28%E2%88%9E%2C1%29-presheaf">separated (∞,1)-presheaf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/quasitopos">quasitopos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/separated+presheaf">separated presheaf</a></li>
</ul>
</li>

<li>
<p><span class="newWikiWord">(2,1)-quasitopos<a href="/nlab/new/%282%2C1%29-quasitopos">?</a></span></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/separated+%282%2C1%29-presheaf">separated (2,1)-presheaf</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C2%29-topos">(∞,2)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2Cn%29-topos">(∞,n)-topos</a></p>
</li>
</ul><h2 id="characterization">Characterization</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/universal+colimits">universal colimits</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/object+classifier">object classifier</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/groupoid+object+in+an+%28%E2%88%9E%2C1%29-category">groupoid object in an (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/effective+epimorphism">effective epimorphism</a></li>
</ul>
</li>
</ul><h2 id="morphisms">Morphisms</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-geometric+morphism">(∞,1)-geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29Topos">(∞,1)Topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Lawvere+distribution">Lawvere distribution</a></p>
</li>
</ul><h2 id="extra_stuff_structure_and_property">Extra stuff, structure and property</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/hypercomplete+%28%E2%88%9E%2C1%29-topos">hypercomplete (∞,1)-topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/hypercomplete+object">hypercomplete object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Whitehead+theorem">Whitehead theorem</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/over-%28%E2%88%9E%2C1%29-topos">over-(∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/n-localic+%28%E2%88%9E%2C1%29-topos">n-localic (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/locally+n-connected+%28n%2C1%29-topos">locally n-connected (n,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/structured+%28%E2%88%9E%2C1%29-topos">structured (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/geometry+%28for+structured+%28%E2%88%9E%2C1%29-toposes%29">geometry (for structured (∞,1)-toposes)</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">locally ∞-connected (∞,1)-topos</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">∞-connected (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/local+%28%E2%88%9E%2C1%29-topos">local (∞,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/concrete+%28%E2%88%9E%2C1%29-sheaf">concrete (∞,1)-sheaf</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohesive+%28%E2%88%9E%2C1%29-topos">cohesive (∞,1)-topos</a></p>
</li>
</ul><h2 id="models">Models</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/models+for+%E2%88%9E-stack+%28%E2%88%9E%2C1%29-toposes">models for ∞-stack (∞,1)-toposes</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+category">model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+functors">model structure on functors</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+site">model site</a>/<a class="existingWikiWord" href="/nlab/show/sSet-site">sSet-site</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">model structure on simplicial presheaves</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/descent+for+simplicial+presheaves">descent for simplicial presheaves</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Verity+on+descent+for+strict+omega-groupoid+valued+presheaves">descent for presheaves with values in strict ∞-groupoids</a></p>
</li>
</ul>
</li>
</ul><h2 id="constructions">Constructions</h2><p><strong>structures in a <a class="existingWikiWord" href="/nlab/show/cohesive+%28%E2%88%9E%2C1%29-topos">cohesive (∞,1)-topos</a></strong></p><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/shape+of+an+%28%E2%88%9E%2C1%29-topos">shape</a> / <a class="existingWikiWord" href="/nlab/show/coshape+of+an+%28%E2%88%9E%2C1%29-topos">coshape</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohomology">cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">homotopy</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+in+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">fundamental ∞-groupoid in a locally ∞-connected (∞,1)-topos</a>/<a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+of+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">of a locally ∞-connected (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/categorical+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">categorical</a>/<a class="existingWikiWord" href="/nlab/show/geometric+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">geometric</a> homotopy groups</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Postnikov+tower+in+an+%28%E2%88%9E%2C1%29-category">Postnikov tower</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Whitehead+tower+in+an+%28%E2%88%9E%2C1%29-topos">Whitehead tower</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/rational+homotopy+theory+in+an+%28%E2%88%9E%2C1%29-topos">rational homotopy</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/dimension">dimension</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+dimension">homotopy dimension</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohomological+dimension">cohomological dimension</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/covering+dimension">covering dimension</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Heyting+dimension">Heyting dimension</a></p>
</li>
</ul>
</li>
</ul><div>
<p>
  <a href="/nlab/edit/%28infinity%2C1%29-topos+-+contents">Edit this sidebar</a>
</p>
</div></div>
</div>
</div>

<p>The following is (supposed to be) a pedagogical motivation of the concepts <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a>, <a class="existingWikiWord" href="/nlab/show/stack">stack</a>, <a class="existingWikiWord" href="/nlab/show/infinity-stack">infinity-stack</a> and <a class="existingWikiWord" href="/nlab/show/Higher+Topos+Theory">higher topos theory</a>. It assumes only that the reader has a working knowledge of <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>s and aims to provide from that an intuitive but useful idea of the relevance of the circle of ideas of <a class="existingWikiWord" href="/nlab/show/Categories+and+Sheaves">categories and sheaves</a>, <a class="existingWikiWord" href="/nlab/show/cohomology">cohomology</a>, <a class="existingWikiWord" href="/nlab/show/sheaf+cohomology">sheaf cohomology</a> and a bit of <a class="existingWikiWord" href="/nlab/show/Higher+Topos+Theory">higher topos theory</a>.</p>

<p>Actually, the reader need not even know anything about topological spaces. The only assumption we need is that a space is something that has <em>probes</em> by test spaces (points, say). The reader can jump right to <em><a href="#TheBasicIdeaOfSheaves">The basic idea of sheaves</a></em>.</p>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#MapsBetweenTopologicalSpaces'>Motivation: maps between topological spaces</a></li>
<li><a href='#TheBasicIdeaOfSheaves'>The basic idea of sheaves</a></li>
<li><a href='#sheaves_more_general_than_spaces'>Sheaves more general than spaces</a></li>
<li><a href='#maps_between_generalized_spaces'>Maps between generalized spaces</a></li>
<li><a href='#and_more_a_topos_of_generalized_spaces'>And more: a topos of generalized spaces</a></li>
<li><a href='#higher_sheaves_stacks'>Higher sheaves: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks</a></li>
<li><a href='#generalized_cohomology'>Generalized cohomology</a></li>
<li><a href='#complexes_of_sheaves_abelian_stacks'>Complexes of sheaves: abelian <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks</a></li>
<li><a href='#examples'>Examples</a></li>
<li><a href='#related_entries'>Related entries</a></li>
</ul>
</div>

<h2 id="MapsBetweenTopologicalSpaces">Motivation: maps between topological spaces</h2>

<p>Classes of maps between <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>s encode interesting information.</p>

<p>To pick just one example: there is a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> that goes by the name <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>ℤ</mi><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(\mathbb{Z},2)</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{B}U(1)</annotation></semantics></math> and is called an <a class="existingWikiWord" href="/nlab/show/Eilenberg-Mac+Lane+space">Eilenberg-Mac Lane space</a>. It has the peculiar property that for any other space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, the <a class="existingWikiWord" href="/nlab/show/homotopy">homotopy</a> classes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X, \mathcal{B}U(1)]</annotation></semantics></math> of continuous maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{B}U(1)</annotation></semantics></math> characterize the following:</p>

<ul>
<li>
<p>they correspond to equivalence classes of <a class="existingWikiWord" href="/nlab/show/circle+bundle">circle bundle</a>s over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>: that is, to spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> equipped with a map to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> such that over a contractible open subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">U \subset X</annotation></semantics></math> the space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> looks like the <a class="existingWikiWord" href="/nlab/show/product">product</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> with the circle, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><msub><mo stretchy="false">|</mo> <mi>U</mi></msub><mo>≃</mo><mi>U</mi><mo>×</mo><msup><mi>S</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">P|_U \simeq U \times S^1</annotation></semantics></math> (and such that the identification respects the action of the <a class="existingWikiWord" href="/nlab/show/group">group</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(1)</annotation></semantics></math> on the circle).</p>

<ul>
<li>
<p>Thus, one says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{B}U(1)</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/classifying+space">classifying space</a> for circle <a class="existingWikiWord" href="/nlab/show/bundle">bundle</a>s (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>≃</mo><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">[X, \mathcal{B}U(1)] \simeq \{ </annotation></semantics></math>circle bundles over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">}</mo><mo stretchy="false">/</mo><mo>∼</mo></mrow><annotation encoding="application/x-tex">X \}/{\sim}</annotation></semantics></math>) or that it <a class="existingWikiWord" href="/nlab/show/representable+functor">represents</a> the assignment of circle bundles to spaces – to some extent the topic of sheaves, and cohomology is all about the notion of such <a class="existingWikiWord" href="/nlab/show/representable+functor">representability</a></p>
</li>

<li>
<p>A famous such circle bundle you may have seen is the <a class="existingWikiWord" href="/nlab/show/Hopf+fibration">Hopf fibration</a>, which is a way to map the 3-dimensional sphere <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>S</mi> <mn>3</mn></msup></mrow><annotation encoding="application/x-tex">S^3</annotation></semantics></math> to the familiar 2-dimensional sphere <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>S</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">S^2</annotation></semantics></math>, such that over small parts <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>⊂</mo><msup><mi>S</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">U \subset S^2</annotation></semantics></math> of the 2-sphere the 3-sphere looks like the <a class="existingWikiWord" href="/nlab/show/product">product</a> space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>×</mo><msup><mi>S</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">U \times S^1</annotation></semantics></math>.</p>
</li>

<li>
<p>This particular circle bundle corresponds to a very special class of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>→</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to \mathcal{B}U(1)</annotation></semantics></math>: namely the collection of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>S</mi> <mn>2</mn></msup><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[S^2, \mathcal{B}U(1)]</annotation></semantics></math> happens to have the structure of the abelian group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math> of integers under addition, and the <a class="existingWikiWord" href="/nlab/show/Hopf+fibration">Hopf fibration</a> corresponds to the generating element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> of this group;</p>
</li>

<li>
<p>generally, this abelian group formed by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X, \mathcal{B}U(1)]</annotation></semantics></math> is famous under another name: it is called the second integral <a class="existingWikiWord" href="/nlab/show/cohomology">cohomology</a> group of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^2(X, \mathbb{Z})</annotation></semantics></math>.</p>
</li>
</ul>
</li>

<li>
<p>There is a similar such cohomology group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>H</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H^{n+1}(X,\mathbb{Z})</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> for every natural number <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>: the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math>st <em>integral cohomology group</em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> – and all these groups are naturally realized in terms of homotopy classes of maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> into some topological space – called the <a class="existingWikiWord" href="/nlab/show/Eilenberg-MacLane+space">Eilenberg-MacLane space</a>s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>ℤ</mi><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K(\mathbb{Z}, n+1)</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℬ</mi> <mi>n</mi></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{B}^{n} U(1)</annotation></semantics></math> – and again each element in these groups can be identified with a certain geometric structure living over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, called a circle <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-bundle or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1)</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/gerbe">gerbe</a>: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><msup><mi>ℬ</mi> <mi>n</mi></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">[X, \mathcal{B}^{n} U(1)] = \{ </annotation></semantics></math>circle <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-bundles on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">}</mo><mo stretchy="false">/</mo><mo>∼</mo></mrow><annotation encoding="application/x-tex">X \}/{\sim}</annotation></semantics></math>.</p>
</li>
</ul>

<p>So these cohomology groups encode a lot of interesting information about topological spaces; but there is some useful information about a space, which is not encoded in maps from it to another topological space:</p>

<ul>
<li>
<p>in particular, if the space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in question is not just a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> but carries extra <a class="existingWikiWord" href="/nlab/show/stuff%2C+structure%2C+property">structure</a>, such as being a <em><a class="existingWikiWord" href="/nlab/show/smooth+manifold">smooth manifold</a></em>, then one is interested in <em>smooth</em> circle bundles over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> which are equipped with a <a class="existingWikiWord" href="/nlab/show/connection">connection</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∇</mo></mrow><annotation encoding="application/x-tex">\nabla</annotation></semantics></math>: a good rule which assigns to each smooth path <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>γ</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\gamma : x \to y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> an identification between the two circles over its endpoints;</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>x</mi></mtd> <mtd></mtd> <mtd><mover><mo>↦</mo><mo>∇</mo></mover></mtd> <mtd><msubsup><mi>S</mi> <mi>x</mi> <mn>1</mn></msubsup></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mi>γ</mi></msup></mtd> <mtd></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mrow><mo>∇</mo><mo stretchy="false">(</mo><mi>γ</mi><mo stretchy="false">)</mo></mrow></msup></mtd></mtr> <mtr><mtd><mi>y</mi></mtd> <mtd></mtd> <mtd><mover><mo>↦</mo><mo>∇</mo></mover></mtd> <mtd><msubsup><mi>S</mi> <mi>y</mi> <mn>1</mn></msubsup></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\array{
  x &amp;&amp; \stackrel{\nabla}{\mapsto} &amp; S^1_x
  \\
  \downarrow^\gamma
  &amp;&amp;&amp;
  \downarrow^{\nabla(\gamma)}
  \\
  y &amp;&amp; \stackrel{\nabla}{\mapsto} &amp; S^1_y
}

</annotation></semantics></math></div>
<ul>
<li>
<p>this is the point where these considerations become of interest for <a class="existingWikiWord" href="/nlab/show/physics">physics</a>: there <a class="existingWikiWord" href="/nlab/show/bundles">bundles</a> with <a class="existingWikiWord" href="/nlab/show/connection+on+a+bundle">connection</a>, and then <a class="existingWikiWord" href="/nlab/show/principal+infinity-bundle">n-bundles</a>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1)</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/gerbe">gerbe</a>s, with connection encode <em><a class="existingWikiWord" href="/nlab/show/gauge+fields">gauge fields</a></em> such as the <a class="existingWikiWord" href="/nlab/show/electromagnetic+field">electromagnetic field</a>. See at <em><a class="existingWikiWord" href="/nlab/show/geometry+of+physics">geometry of physics</a></em> for more on this.</p>
</li>

<li>
<p>you might guess that there is a smooth manifold classifying smooth circle bundles with connection – but there is not, not unless one stretches the meaning of <em>manifold</em> and of <em>space</em> in general a bit</p>
</li>

<li>
<p>so maybe we just need a slightly more flexible notion of what “space” should mean.</p>
</li>
</ul>
</li>

<li>
<p>the generalization of the notion of <a class="existingWikiWord" href="/nlab/show/space+and+quantity">space</a> which does accomplish this: the notion of a <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a></p>

<ul>
<li>(there is a very general abstract nonsense way to understand <a class="existingWikiWord" href="/nlab/show/sheaf">sheaves</a> as generalized spaces in the context of a very general abstract <a class="existingWikiWord" href="/nlab/show/duality">duality</a> between the notions of <a class="existingWikiWord" href="/nlab/show/space+and+quantity">space and quantity</a>. The following is an informal way to understand this).</li>
</ul>
</li>
</ul>

<h2 id="TheBasicIdeaOfSheaves">The basic idea of sheaves</h2>

<p>To understand what a <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a> is, recall which aspect of the notion of <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> was relevant in the above examples <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℬ</mi> <mi>n</mi></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{B}^{n} U(1)</annotation></semantics></math>: these spaces were entirely characterized by how one can <em>map</em> other spaces <em>into</em> them:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>↦</mo><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><msup><mi>ℬ</mi> <mi>n</mi></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>.</mo></mrow><annotation encoding="application/x-tex"> X \mapsto [X,\mathcal{B}^{n} U(1)] .</annotation></semantics></math></div>
<p>This is a general strategy that one can adopt: suppose I dream up a space but don’t tell you which one it is, but I give you hints: for each other space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> that you can dream up, I tell you how you can <em>probe</em> my space by mapping your space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> into it.</p>

<ul>
<li>
<dl>
<dt>Let’s now call the space which I dreamed up <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, the generic symbol for spaces. For every space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> that you come up with, I do some secret computation and then present you with the result: I hand you a <a class="existingWikiWord" href="/nlab/show/set">set</a>, let’s call it <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math>, and tell you that this is the set of ways that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> can be mapped into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>:</dt>

<dd>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">X(U) = \{ </annotation></semantics></math>ways to map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> into some hypothetical <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X \}</annotation></semantics></math></p>
</dd>

<dd>
<p>  =: {probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>}.</p>
</dd>
</dl>
</li>

<li>
<p>Will you be able, in general, to guess my space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> from this information <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math>? No. So, to be fair, I should provide a bit more information. To actually get a feeling for what my space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is like, you need to know something about how different ways of probing my space relate to each other.</p>
</li>

<li>
<p>If you give me a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mover><mo>→</mo><mi>f</mi></mover><mi>V</mi></mrow><annotation encoding="application/x-tex">U \stackrel{f}{\to} V</annotation></semantics></math> from one test space to another, then for any element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi></mrow><annotation encoding="application/x-tex">V \stackrel{p}{\to} X</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(V)</annotation></semantics></math>, I can produce an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mover><mo>→</mo><mi>f</mi></mover><mi>V</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi></mrow><annotation encoding="application/x-tex">U \stackrel{f}{\to} V \stackrel{p}{\to} X</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math>. In other words, your map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U \to V</annotation></semantics></math> induces a transformation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>←</mo><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U) \leftarrow X(V)</annotation></semantics></math>. To be fair, I should tell you at least what this transformation is!</p>
</li>

<li>
<p>Well, fine: I’ll do it. If you give me a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mover><mo>→</mo><mi>f</mi></mover><mi>V</mi></mrow><annotation encoding="application/x-tex">U \stackrel{f}{\to} V</annotation></semantics></math> from one test space to another, I’ll give you a map of sets, denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mover><mo>←</mo><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mover><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U) \stackrel{X(f)}{\leftarrow} X(V)</annotation></semantics></math>, that supposedly indicates how <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> turn into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>-probes when you precompose them with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>.</p>
</li>
</ul>

<p>Do you need still more information to guess my space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>? No, you have enough! This somewhat remarkable fact is closely related to a fundamental statement of <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a>: the <a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a> and its implication on <a class="existingWikiWord" href="/nlab/show/representable+functor">representable functor</a>s. These terms will be discussed in a moment…</p>

<p>First, there is a bit more to the game than mentioned so far: you need to be sure that even if I won’t reveal my space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> to you directly, the little information about it which I do provide, that rule <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math>, I should provide honestly and consistently. Some consistency checks to assure that I am not just making things up but am giving you consistent information about my secret space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> are the following:</p>

<ul>
<li>
<p>it must be true that when you hand me the identity map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Id</mi> <mi>U</mi></msub><mo>:</mo><mi>U</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Id_U : U \to U</annotation></semantics></math> on a test space, that then I return you the identity map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Id</mi> <mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow></msub><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Id_{X(U)} : X(U) \to X(U)</annotation></semantics></math> on the set of probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>;</p>
</li>

<li>
<p>also, it must be true that when you first hand me two consecutive maps of test spaces, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">f : U \to V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">g : V \to W</annotation></semantics></math>, and then hand me their composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">g \circ f : U \to W</annotation></semantics></math>, that my reply <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(g \circ f) : X(W) \to X(U)</annotation></semantics></math> to the latter is the result of composing my two replies about the former: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mi>X</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mover><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mover><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(g \circ f) = X(W) \stackrel{X(g)}{\to} X(V) \stackrel{X(f)}{\to} X(U)</annotation></semantics></math>.</p>
</li>
</ul>

<p>Such an assignment <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math> of sets to spaces which satisfies the above two properties is what is called a <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a>: this, in turn, is nothing but what is called a <a class="existingWikiWord" href="/nlab/show/functor">functor</a> on a <a class="existingWikiWord" href="/nlab/show/category">category</a>:</p>

<ul>
<li>
<p>the <a class="existingWikiWord" href="/nlab/show/category">category</a> in question here is the collection of test <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, called <a class="existingWikiWord" href="/nlab/show/object">object</a>s, equipped with continuous maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">f : U \to V</annotation></semantics></math> between them, called <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a>s, which may be composed when their domains and targets match. This composition is associative in the obvious way and on every object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> there is an <a class="existingWikiWord" href="/nlab/show/identity+morphism">identity</a> map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Id</mi> <mi>U</mi></msub><mo>:</mo><mi>U</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Id_U : U \to U</annotation></semantics></math>, composition with which does nothing. This category is known by the name <a class="existingWikiWord" href="/nlab/show/Top">Top</a>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Top</mi><mo>=</mo><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">Top = \{ </annotation></semantics></math>topological spaces and continuous maps between them<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> \}</annotation></semantics></math></p>
</li>

<li>
<p>the other <a class="existingWikiWord" href="/nlab/show/category">category</a> in the game, namely the <a class="existingWikiWord" href="/nlab/show/category">category</a> called <a class="existingWikiWord" href="/nlab/show/Set">Set</a> whose <a class="existingWikiWord" href="/nlab/show/object">object</a>s are <a class="existingWikiWord" href="/nlab/show/set">set</a>s and whose <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a>s are functions between sets: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo>=</mo><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">Set = \{ </annotation></semantics></math>sets and functions between them<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> \}</annotation></semantics></math></p>
</li>

<li>
<p>the probe-game which we are playing can hence be understood as being an assignment of <a class="existingWikiWord" href="/nlab/show/object">object</a>s in <a class="existingWikiWord" href="/nlab/show/Set">Set</a> to <a class="existingWikiWord" href="/nlab/show/object">object</a>s in <a class="existingWikiWord" href="/nlab/show/Top">Top</a> and of <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a>s in <a class="existingWikiWord" href="/nlab/show/Set">Set</a> to <a class="existingWikiWord" href="/nlab/show/morphism">morphism</a>s in <a class="existingWikiWord" href="/nlab/show/Top">Top</a> which satisfies the above consistency conditions: this is called a <a class="existingWikiWord" href="/nlab/show/contravariant+functor">contravariant</a> <a class="existingWikiWord" href="/nlab/show/Set">Set</a>-valued <a class="existingWikiWord" href="/nlab/show/functor">functor</a>, or a <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a>, on <a class="existingWikiWord" href="/nlab/show/Top">Top</a> and it is denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><msup><mi>Top</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">X(-) : Top^{op} \to Set</annotation></semantics></math></p>
</li>
</ul>

<p>We say <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a> instead of just <a class="existingWikiWord" href="/nlab/show/functor">functor</a>, even though taken at face value a presheaf is just a functor, to indicate that there is one further, more nontrivial consistency check on the information about probes of my secret space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> which you should do: it must be true that you can piece together the information which I give for small test spaces to deduce information about probes by bigger test spaces.</p>

<ul>
<li>
<p>More precisely, if I tell you the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> of probes of my secret space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> by the test space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, and if you then chop up <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> into two pieces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_2</annotation></semantics></math> sitting inside <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> by inclusion maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub><mo>:</mo><msub><mi>V</mi> <mi>i</mi></msub><mo>↪</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">p_i : V_i \hookrightarrow U</annotation></semantics></math>, with a bit of overlap <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>V</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_1 \cap V_2</annotation></semantics></math>, then it ought to be true that all the probes by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> can be entirely and exactly be reconstructed from taking probes by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_1</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(V_1)</annotation></semantics></math> and by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_2</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(V_2)</annotation></semantics></math> and see if they match over the overlap <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>V</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_1 \cap V_2</annotation></semantics></math> of the two small probes:</p>
</li>

<li>
<p>in symbols, the collection of pairs in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">\{ </annotation></semantics></math>matching maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_2</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">}</mo><mo>↪</mo><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \} \hookrightarrow X(V_1) \times X(V_2)</annotation></semantics></math> whose elements coincide when restricted to the overlap</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><munderover><mphantom><mi>AAA</mi></mphantom><munder><mo>⟶</mo><mrow><mi>restrict</mi><mspace width="thickmathspace"></mspace><mi>second</mi><mspace width="thickmathspace"></mspace><mi>element</mi></mrow></munder><mover><mo>⟶</mo><mrow><mi>restrict</mi><mspace width="thickmathspace"></mspace><mi>first</mi><mspace width="thickmathspace"></mspace><mi>element</mi></mrow></mover></munderover><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  X(V_1) \times X(V_2) 
    \underoverset
     {\underset{restrict\;second\;element}{\longrightarrow}} 
     {\overset{restrict\;first\;element}{\longrightarrow}}
     {\phantom{AAA}}
  X(V_1 \cap V_2)

</annotation></semantics></math></div>
<p>should be exactly all the possible maps in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math>: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">\{ </annotation></semantics></math>matching probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">}</mo><mo>≃</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_2 \} \simeq X(U)</annotation></semantics></math>.</p>
</li>

<li>
<p>one says that the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo></mrow><annotation encoding="application/x-tex">\{ </annotation></semantics></math>matching probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">V_2 \}</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/equalizer">equalizer</a> of the two <a class="existingWikiWord" href="/nlab/show/parallel+morphisms">parallel morphisms</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><munderover><mphantom><mi>AAA</mi></mphantom><munder><mo>⟶</mo><mrow><mi>restrict</mi><mspace width="thickmathspace"></mspace><mi>second</mi><mspace width="thickmathspace"></mspace><mi>element</mi></mrow></munder><mover><mo>⟶</mo><mrow><mi>restrict</mi><mspace width="thickmathspace"></mspace><mi>first</mi><mspace width="thickmathspace"></mspace><mi>element</mi></mrow></mover></munderover><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> 
  X(V_1) \times X(V_2) 
   \underoverset
     {\underset{restrict\;second\;element}{\longrightarrow}} 
     {\overset{restrict\;first\;element}{\longrightarrow}} 
     {\phantom{AAA}}
  X(V_1 \cap V_2) 

</annotation></semantics></math></div>
<p>the optimal solution to mapping into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mi>X</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(V_1) \times X(V_2)</annotation></semantics></math> such that these two maps become equal;</p>
</li>

<li>
<p>this condition is called a <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a> or <a class="existingWikiWord" href="/nlab/show/descent">descent</a> condition: one thinks of the sheaf of <em>descending</em> from the cover to the base along the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo>⊔</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msub><mi>p</mi> <mn>1</mn></msub><mo>⊔</mo><msub><mi>p</mi> <mn>2</mn></msub></mrow></mover><mi>U</mi></mrow><annotation encoding="application/x-tex">(V_1 \sqcup V_2) \stackrel{p_1 \sqcup p_2}{\to} U</annotation></semantics></math>;</p>
</li>
</ul>

<p>This now is a sensible game to play: I don’t tell you directly which space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> I am thinking of, but I do give you all the information <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math> about its probes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> by test spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, subject to the conditions that</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(-)</annotation></semantics></math> is functorial and hence a <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(-)</annotation></semantics></math> satisfies <a class="existingWikiWord" href="/nlab/show/descent">descent</a> and is therefore a <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a></p>
</li>
</ul>

<h2 id="sheaves_more_general_than_spaces">Sheaves more general than spaces</h2>

<p>So far we have been talking about using topological spaces as probe spaces, hence about presheaves on the category <a class="existingWikiWord" href="/nlab/show/Top">Top</a>. One can use other systems <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> of test spaces as long as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> forms a <a class="existingWikiWord" href="/nlab/show/category">category</a> and such that there is an agreement about how some of its <a class="existingWikiWord" href="/nlab/show/object">object</a>s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, can be <a class="existingWikiWord" href="/nlab/show/cover">cover</a>ed by other <a class="existingWikiWord" href="/nlab/show/object">object</a>s, such as the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_2</annotation></semantics></math> above. Such an agreement of what counts as a <a class="existingWikiWord" href="/nlab/show/cover">cover</a> in a <a class="existingWikiWord" href="/nlab/show/category">category</a> is called a <a class="existingWikiWord" href="/nlab/show/coverage">coverage</a> or a <a class="existingWikiWord" href="/nlab/show/Grothendieck+topology">Grothendieck topology</a>, and a <a class="existingWikiWord" href="/nlab/show/category">category</a> equipped with such an information is called a <a class="existingWikiWord" href="/nlab/show/site">site</a>;</p>

<p>Here are some important examples:</p>

<ul>
<li>
<p>A popular choice is to fix one particular topological space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> and probe all generalized spaces using only open subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>⊂</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">U \subset Z</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>. These open subsets form the <a class="existingWikiWord" href="/nlab/show/category+of+open+subsets">category of open subsets</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>=</mo><mi>Op</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S = Op(Z)</annotation></semantics></math> and the choice of <a class="existingWikiWord" href="/nlab/show/coverage">coverage</a> is the obvious one. <a class="existingWikiWord" href="/nlab/show/sheaf">Sheaves</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(Z)</annotation></semantics></math> are generalized spaces <em>over</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>.</p>
</li>

<li>
<p>Another relevant choice is to use instead of all topological test spaces in the category <a class="existingWikiWord" href="/nlab/show/Top">Top</a> all smooth manifolds as test spaces, in the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">S =</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/Diff">Diff</a>.</p>
</li>

<li>
<p>Or the combination of these: the test spaces in the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(Z)</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> a smooth manifold.</p>
</li>
</ul>

<p>We had motivated this language of sheaves as a reformulation of the familar notion of spaces in a somewhat more indirect form: a rule for how to probe a space. But now something strange happens: it turns out that there are collections of probe information <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><msup><mi>S</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">X(-) : S^{op} \to Set</annotation></semantics></math> which do obey the rules, i.e. do form a sheaf, but for which there is nevertheless <em>no</em> test space in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> that it describes probes into. And in fact, this is the generic case.</p>

<ul>
<li>
<p>On the other hand, maybe this just means that our notion of “ordinary space” was a bit too restrictive: after all, we noticed that all that really matters usually are the ways we can probe a given space by other spaces; and that the information about such probes is useful if only it obeys the rules of being a sheaf.</p>
</li>

<li>
<p>So we have every justification then to regard sheaves in general as perfectly valid <em>generalized spaces</em>; or more precisely: we regard sheaves as rules for how to probe generalized spaces, and we take these generalized spaces to be entirely specified by their <a class="existingWikiWord" href="/nlab/show/sheaf">sheaves</a> of probes.</p>
</li>
</ul>

<p>Examples:</p>

<ul>
<li>
<p>The notion of “generalized” here depends on the perspective of our probes. For the probe category of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>=</mo><mi>Op</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S = Op(Z)</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> a topological space, most sheaves are “generalized spaces” in that they do not describe maps into a space in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, i.e. an open subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>. But every sheaf on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(Z)</annotation></semantics></math> can be shown to correspond to maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> to an ordinary topological space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> which is equipped with a continuous map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">p : E \to Z</annotation></semantics></math> down to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>, such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math> is locally a homeomorphism. Such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math> are called <em><a class="existingWikiWord" href="/nlab/show/etale+space">étale spaces</a></em> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>.</p>
</li>

<li>
<p>A sheaf on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">S = </annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/Diff">Diff</a> is a <a class="existingWikiWord" href="/nlab/show/generalized+smooth+space">generalized smooth space</a>. These may be very different from ordinary manifolds and ordinary topological spaces. There are generalized smooth spaces with a single point and still many curves in them. In fact, the generalized classifying space for smooth circle bundles with connection that we are still after is of this form.</p>
</li>
</ul>

<h2 id="maps_between_generalized_spaces">Maps between generalized spaces</h2>

<p>Since we are thinking of sheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>X</mi></msub><mo>:</mo><msup><mi>S</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">F_X : S^{op} \to Set</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>Y</mi></msub><mo>:</mo><msup><mi>S</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">F_Y : S^{op} \to Set</annotation></semantics></math> as characterizing ‘generalized spaces’ <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, we better have a good notion of maps between sheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>X</mi></msub><mo>→</mo><msub><mi>F</mi> <mi>Y</mi></msub></mrow><annotation encoding="application/x-tex">F_X \to F_Y</annotation></semantics></math> that corresponds to a sensible notion of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math> between generalized spaces.</p>

<p>That’s easy to figure out: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> is supposed to be a map between generalized spaces, whatever these are, then in particular it turns every probe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p \in X(U)</annotation></semantics></math>, of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> which we are thinking of as a probe map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">p : U \to X</annotation></semantics></math>, to a probe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>p</mi><mo>∈</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f \circ p \in Y(U)</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, which we should think of as the composite map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>p</mi><mo>:</mo><mi>U</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi><mover><mo>→</mo><mi>f</mi></mover><mi>Y</mi></mrow><annotation encoding="application/x-tex">f \circ p : U \stackrel{p}{\to} X \stackrel{f}{\to} Y</annotation></semantics></math> that simply maps the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> further to an image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> using the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math>.</p>

<ul>
<li>
<p>nota bene: for the time being there is no space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> such that thinking of probes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p \in X(U)</annotation></semantics></math> as maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">p : U \to X</annotation></semantics></math> of some sort would literally make sense. However, once we impose some consistency conditions on the probe sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> precisely this will make sense. And to motivate these consistency conditions in the first place, it is best to already think of probes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p \in X(U)</annotation></semantics></math> as being maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">p : U \to X</annotation></semantics></math>.</p>
</li>

<li>
<p>so in terms of their collections (sheaves) of probes a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> of generalized spaces should be given for each probe space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> by a map of sets of probes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mi>U</mi></msub><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_U : X(U) \to Y(U)</annotation></semantics></math>, to be thought of as encoding the post-composition map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mi>U</mi></msub><mo>:</mo><mo stretchy="false">(</mo><mi>U</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi><mo stretchy="false">)</mo><mo>↦</mo><mo stretchy="false">(</mo><mi>U</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi><mover><mo>→</mo><mi>f</mi></mover><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_U : (U \stackrel{p}{\to} X) \mapsto (U \stackrel{p}{\to} X \stackrel{f}{\to} Y)</annotation></semantics></math></p>
</li>

<li>
<p>but we can also pre-compose: given a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\phi : U \to V</annotation></semantics></math> of test spaces, we also have the probe transformation map from above, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(\phi) : X(V) \to X(U)</annotation></semantics></math> which is to be thought of as acting by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mi>V</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi><mo stretchy="false">)</mo><mo>↦</mo><mo stretchy="false">(</mo><mi>U</mi><mover><mo>→</mo><mi>ϕ</mi></mover><mi>V</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(\phi) : (V \stackrel{p}{\to} X) \mapsto (U \stackrel{\phi}{\to} V \stackrel{p}{\to} X)</annotation></semantics></math></p>
</li>

<li>
<p>and we can combine both pre- and postcomposition and send <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>V</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi><mo stretchy="false">)</mo><mo>↦</mo><mo stretchy="false">(</mo><mi>U</mi><mover><mo>→</mo><mi>ϕ</mi></mover><mi>V</mi><mover><mo>→</mo><mi>p</mi></mover><mi>X</mi><mover><mo>→</mo><mi>f</mi></mover><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V \stackrel{p}{\to} X) \mapsto (U \stackrel{\phi}{\to} V \stackrel{p}{\to} X \stackrel{f}{\to} Y)</annotation></semantics></math></p>
</li>

<li>
<p>in this notation it is manifestly clear that it must not matter whether we first pre- and then post-compose, or the other way around. But recall that so far writing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">p : V \to X</annotation></semantics></math> for a probe <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p \in X(V)</annotation></semantics></math> is just notation. So we need to enforce the obvious here on our formalism explicitly, lest the interpretation of generalized spaces breaks down.</p>
</li>

<li>
<p>namely this means that the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msub><mi>f</mi> <mi>V</mi></msub></mrow></mover><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msup><mi>ϕ</mi> <mo>*</mo></msup></mrow></mover><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(V) \stackrel{f_V}{\to} Y(V) \stackrel{\phi^*}{\to} Y(U)</annotation></semantics></math> which first turns a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-probe of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> into a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-probe of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> and then turns the result into a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>-probe of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, must coincide with the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msup><mi>ϕ</mi> <mo>*</mo></msup></mrow></mover><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msub><mi>f</mi> <mi>U</mi></msub></mrow></mover><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(V) \stackrel{\phi^*}{\to} X(U) \stackrel{f_U}{\to} Y(U)</annotation></semantics></math> which first turns a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-probe of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> into a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>-probe of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and then turns the result into a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>-probe of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>.</p>
</li>

<li>
<p>Such an equality between two different composite maps is conveniently depicted as a square</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><msub><mi>f</mi> <mi>U</mi></msub></mrow></mover></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↑</mo> <mrow><mi>X</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↑</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow></msup></mtd></mtr> <mtr><mtd><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><msub><mi>f</mi> <mi>V</mi></msub></mrow></mover></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\array{
   X(U)
   &amp;\stackrel{f_U}{\to}&amp;
   Y(U)
   \\
   \uparrow^{X(\phi)}
   &amp;&amp;
   \uparrow^{Y(\phi)}
   \\
   X(V)
   &amp;\stackrel{f_V}{\to}&amp;
   Y(V)
}

</annotation></semantics></math></div>
<p>The fact that the two ways of going from the bottom left to the top right of the square are supposed to be equal is called. “the square commutes”, or “the square is commutative”.</p>
</li>
</ul>

<p>So that then is our definition of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> between generalized spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V \mapsto X(V)</annotation></semantics></math> are the probe-assignments that define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, then the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is defined by probe-transformations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mi>U</mi></msub><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_U : X(U) \to Y(U)</annotation></semantics></math> such that for all maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\phi : U \to V</annotation></semantics></math> the above squares commute.</p>

<ul>
<li>Such a collection of data is called a <a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a> between the probe-assigning <a class="existingWikiWord" href="/nlab/show/functor">functor</a>s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(-)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(-)</annotation></semantics></math>. Clearly, it’s a transformation, and it being “natural” just means that it satisfies the obvious consistency condition we discussed.</li>
</ul>

<p>With this understanding of maps between generalized spaces in hand, we should go back and compare it to the notion of <em>probes</em> of generalized spaces by ordinary spaces.</p>

<ul>
<li>
<p>we had started the discussion with observing that every ordinary topological space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> defines a <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a> of probes by the assignment <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math> := {maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>} =: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Maps</mi><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Maps(U,X)</annotation></semantics></math>.</p>
</li>

<li>
<p>this way every ordinary space is a generalized space, of course;</p>
</li>

<li>
<p>but that should make us nervous: because it means that now there are two <em>different</em> definitions of what a map from a test topological space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> to a topological space should be:</p>

<ul>
<li>
<p>on the one hand, it should be an element in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Top</mi><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U) = Top(U,X)</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Top</mi></mrow><annotation encoding="application/x-tex">Top</annotation></semantics></math> indicates a set of maps of topological spaces;</p>
</li>

<li>
<p>on the other hand, we can regard both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> as generalized spaces and then look at the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sh</mi><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sh(U,X)</annotation></semantics></math> of maps of generalized spaces between them, as just discussed above;</p>
</li>

<li>
<p>if these two notions of maps don’t coincide, then the whole picture of generalized spaces so far runs into inconsistencies!</p>
</li>

<li>
<p>luckily it doesn’t, as one can check. Both notions of maps, while defined differently, happen to be perfectly equivalent. This statement is a simple exercise to prove, and still is the fundamental fact which makes the important idea of generalized spaces work – this fact is called the <a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a>: it says that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" columnalign="right left right left right left right left right left" columnspacing="0em"><mtr><mtd><mi>Top</mi><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo><mi>Sh</mi><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\begin{aligned}
Top(U,X) &amp;=: X(U)
\\ &amp; = Sh(U,X)
\end{aligned}

</annotation></semantics></math></div>
<p>or more formally</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>Hom</mi> <mi>Sheaves</mi></msub><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">
Hom_{Sheaves}(U,X) \simeq X(U)
.
</annotation></semantics></math></div></li>
</ul>
</li>

<li>
<p>as a slogan: <strong>The Yoneda lemma says that the idea of generalized spaces determined by their collections of probes is consistent.</strong></p>
</li>
</ul>

<p>This point is so important that it is worthwhile to build it into our very notation, so that we can’t help but think of the situation in this way.</p>

<ul>
<li>
<p>We agree for any two generalized spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> to write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(Y)</annotation></semantics></math> for the collection of maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>Sh</mi><mo stretchy="false">(</mo><mi>Y</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> X(Y) := Sh(Y,X)</annotation></semantics></math>, the set of maps of generalized spaces from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Y = U</annotation></semantics></math> happens to be an ordinary space, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> consistently and equivalently denotes both: the collection of probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> by the ordinary space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, and the collection of maps of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> regarded as a generalized space itself.</p>
</li>

<li>
<p>(This notation is for instance used in the book <a class="existingWikiWord" href="/nlab/show/Categories+and+Sheaves">Categories and Sheaves</a>, see page 25.)</p>
</li>
</ul>

<h2 id="and_more_a_topos_of_generalized_spaces">And more: a topos of generalized spaces</h2>

<p>It turns out that we can keep going this way. There is not just a natural notion of maps between generalized spaces given by <a class="existingWikiWord" href="/nlab/show/sheaf">sheaves</a>, but every important type of operation on spaces has its analogs as an operation on sheaves: one says that sheaves form a <a class="existingWikiWord" href="/nlab/show/topos">topos</a>: a place where we can go to study generalized <a class="existingWikiWord" href="/nlab/show/homotopy+theory">homotopy theory</a>, more general than the place of <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>s, but where still all the crucial constructions familiar from topological spaces make sense.</p>

<h2 id="higher_sheaves_stacks">Higher sheaves: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks</h2>

<p>Once we are at this point, we should go even a bit further: we have been talking about <em>sets</em> of probes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math>. But of course for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> a true <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>, there is not just a set, but a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">U \to X</annotation></semantics></math> (using the <a class="existingWikiWord" href="/nlab/show/compact-open+topology">compact-open topology</a> on spaces of continuous maps). So we should be looking at sheaves with values in topological spaces: functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><msup><mi>S</mi> <mi>op</mi></msup><mo>→</mo><mi>Top</mi></mrow><annotation encoding="application/x-tex">X(-) : S^{op} \to Top</annotation></semantics></math> satisfying some suitable condition.</p>

<p>There is only one thing we need to take care of, then: since a topological space is a bit more flexible than a plain set, we should be a bit careful about when two sheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math> with values in topological spaces are to be regarded as equal for all practical purposes: recall that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> is to be thought of as the space of all ways of mapping a probe space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> into a space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. It’s not the single points (maps) in this space which matter so much, but they way they hang together.</p>

<ul>
<li>
<p>All “ways of hanging together” in a topological space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> are measured by a collection of groups called the <a class="existingWikiWord" href="/nlab/show/homotopy+group">homotopy group</a>s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(X(U))</annotation></semantics></math>, one for each natural number <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>.</p>
</li>

<li>
<p>So if we are being careful, we should recognize that two sheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>:</mo><msup><mi>S</mi> <mi>op</mi></msup><mo>→</mo><mi>Top</mi></mrow><annotation encoding="application/x-tex">X : S^{op} \to Top</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo>:</mo><msup><mi>S</mi> <mi>op</mi></msup><mo>→</mo><mi>Top</mi></mrow><annotation encoding="application/x-tex">Y : S^{op} \to Top</annotation></semantics></math> must characterize essentially the same generalized space if there is a rule <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> for turning for each test space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> into probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mi>U</mi></msub><mo>:</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_U : X(U) \to Y(U)</annotation></semantics></math>, as before, such that for <em>sufficiently small</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> this comparison map of probe spaces does not change the homotopy groups, i.e. so that all induced homomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>f</mi> <mi>U</mi></msub><mo stretchy="false">)</mo><mo>:</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>π</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>f</mi> <mi>U</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_n(f_U) : \pi_n(X(U), x) \to \pi_n(Y(U), f_U(x))</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/homotopy+group">homotopy group</a>s are isomorphisms of groups. One says that such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mi>U</mi></msub></mrow><annotation encoding="application/x-tex">f_U</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/weak+homotopy+equivalence">weak homotopy equivalence</a>.</p>
</li>

<li>
<p>If a comparison map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> exists with these properties (for small enough <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, recall), then one says that our generalized spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> defined by these sheaves are <em>weakly equivalent</em> or <a class="existingWikiWord" href="/nlab/show/quasi-isomorphism">quasi-isomorphic</a>.</p>
</li>
</ul>

<p>There are several ways to deal with this complication that sheaves with values in topological spaces are very flexible, so flexible that it may require a bit of effort to determine if two of them determine the same generalized space, for all practical purposes.</p>

<p>One nice way to deal with it is to again go back to our attitude that everything should be determined by how we map other things into it: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> is a weak equivalence of sheaves, as above, then we would expect that for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> any other sheaf, the induced map of spaces of probes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Z</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Z</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z(f) : Z(Y) \to Z(X)</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/weak+homotopy+equivalence">weak homotopy equivalence</a>.</p>

<ul>
<li>Recall from the discussion in the above section “maps of generalized spaces” that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z(Y)</annotation></semantics></math> is just another way saying “space of maps of generalized spaces from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>”, and similarly for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z(X)</annotation></semantics></math>.</li>
</ul>

<p>Now, that may fail to be true, simply because we are using an awkward realization of the sheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>. It may be that we have to <em>straighten out</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math> a bit, without really changing it, for the above to be true. Indeed, if things are set up correctly, there should always be a sheaf of topological spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">Z'</annotation></semantics></math> which is equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math>, but for which the above consistency condition is true: the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo>′</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi>Z</mi><mo>′</mo><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Z</mi><mo>′</mo><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z'(f) : Z'(Y) \to Z'(X)</annotation></semantics></math> between spaces of probes of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Z</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">Z'</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> is a homotopy equivalence.</p>

<p>The sheaves with this niceness property are called <a class="existingWikiWord" href="/nlab/show/infinity-stack">infinity-stack</a>s or <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-sheaf">(infinity,1)-sheaves</a>. Recall that despite the fancy terminology, these things are nothing but consistent rules for something that may be probed with test spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, …</p>

<ul>
<li>in applications this means that before we compute the space of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X,A]</annotation></semantics></math> between generalized spaces, we first have to ensure that at least one of them is sufficiently <em>straightened out</em>. One says one picks a <em>resolution</em>. More on that below.</li>
</ul>

<h2 id="generalized_cohomology">Generalized cohomology</h2>

<p>We come back to our original motivation. Recall that we were looking at cohomology groups of spaces <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> by mapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> into other spaces. We noticed that there is in general interesting information about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> which cannot be gained by mapping it into an ordinary topological space. Starting from this we have now arrived at a more general notion of space, called a higher sheaf or an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stack.</p>

<ul>
<li>
<p>So let’s state for the record that we succeeded: we will say now for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> generalized spaces, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks, that the collection of maps</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
H(X,A) := [X,A]

</annotation></semantics></math></div>
<p>from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/cohomology">cohomology</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with coefficients in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>
</li>

<li>
<p>Indeed, one finds that despite their enlarged generality, these <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks behave in all relevant aspects just like ordinary sheaves and ordinary topological spaces do. So one says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks form an <a class="existingWikiWord" href="/nlab/show/infinity-topos">infinity-topos</a> (more precisely: an <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-topos">(infinity,1)-topos</a>): a place where we can go in order to do the familiar <a class="existingWikiWord" href="/nlab/show/homotopy+theory">homotopy theory</a> of topological spaces in a more general context.</p>
</li>
</ul>

<h2 id="complexes_of_sheaves_abelian_stacks">Complexes of sheaves: abelian <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks</h2>

<p>Another term for this <a class="existingWikiWord" href="/nlab/show/cohomology">generalized cohomology</a> theory thus obtained is <a class="existingWikiWord" href="/nlab/show/nonabelian+cohomology">nonabelian cohomology</a>. The reason for that terms is a historic one: before arriving at the full picture of higher topos theory as described here, people had a pretty good guess about some aspects of this story, and this aspect they called <a class="existingWikiWord" href="/nlab/show/abelian+sheaf+cohomology">sheaf cohomology</a>. It turns out that sheaf cohomology is precisely the <em>abelian</em> part of general cohomology. So now general cohomology is sometimes called <a class="existingWikiWord" href="/nlab/show/nonabelian+cohomology">nonabelian cohomology</a> to distinguish it from the more traditional cohomology theory.</p>

<p>Here is what “abelian part of general cohomology” means:</p>

<ul>
<li>
<p>For many sheaves that appear in practice, the topological space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X(U)</annotation></semantics></math> assigned to any test space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> is not just a topological space, but happens to have the structure of an abelian group, too.</p>
</li>

<li>
<p>In this case a cascade of simplifications kicks in: first of all, such topological spaces, by a special case of something called the <a class="existingWikiWord" href="/nlab/show/homotopy+hypothesis">homotopy hypothesis</a> (which is now really a precise theorem) can be identified with simplicial abelian groups.</p>
</li>

<li>
<p>Second, by another theorem called the <a class="existingWikiWord" href="/nlab/show/Dold-Kan+correspondence">Dold-Kan correspondence</a>, simplicial abelian groups are equivalently encoded more simply in the collection of data given by (non-positively graded) chain complexes in abelian groups.</p>
</li>

<li>
<p>{abelian chain complexes} <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≃</mo></mrow><annotation encoding="application/x-tex">\simeq</annotation></semantics></math> {simplicial abelian groups} <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math> {Kan complexes} <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≃</mo></mrow><annotation encoding="application/x-tex">\simeq</annotation></semantics></math> {nice topological spaces}</p>
</li>
</ul>

<p>By an <a class="existingWikiWord" href="/nlab/show/abelian+sheaf">abelian sheaf</a> one means a sheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>↦</mo><mi>X</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \mapsto X(U)</annotation></semantics></math> which takes values in <a class="existingWikiWord" href="/nlab/show/chain+complex">chain complex</a>es of abelian groups (or, more generally, in <a class="existingWikiWord" href="/nlab/show/complex">complex</a>es in another <a class="existingWikiWord" href="/nlab/show/abelian+category">abelian category</a>). Under the above correspondences, we understand this as a special case of a sheaf with values in topological spaces.</p>

<ul>
<li>By <a class="existingWikiWord" href="/nlab/show/abelian+sheaf+cohomology">abelian sheaf cohomology</a> one means nothing but the above general <a class="existingWikiWord" href="/nlab/show/Higher+Topos+Theory">higher topos theoretic</a> notion of cohomology given by the simple idea of collections of maps from one generalized space to another. Only that in the special case of abelian sheaves a wealth of particular computational techniques are used to compute these mapping spaces (such as <a class="existingWikiWord" href="/nlab/show/derived+category">derived categories</a> and</li>
</ul>

<p><a class="existingWikiWord" href="/nlab/show/derived+functor">derived functors</a>) which are not available in the</p>

<p>fully general case. This wealth of computational machinery employed, useful as it is, sometimes hides the simple conceptual reasoning underlying everything.</p>

<p>There is a collection of tools available for <em>computing</em> explicitly the cohomologies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mo stretchy="false">[</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">H(X,A) := [X,A]</annotation></semantics></math> for the case that the coefficient space can be thought of as a complex of abelian groups, or a complex of modules, these tools go by names like</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+category">model category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/derived+category">derived category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/calculus+of+fractions">calculus of fractions</a> / <a class="existingWikiWord" href="/nlab/show/factorization+system">factorization system</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/localization">localization</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/injective+object">injective resolution</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/bar+and+cobar+construction">bar and cobar construction</a></p>
</li>
</ul>
</li>
</ul>

<p>and so forth; historically many concepts in abelian sheaf theory were thought to be <em>defined</em> in terms of these constructions. From a more modern perspective all these are just tools for unraveling an independent reality. This also explains why there are so many different tools which yield the same results. Most notably in the context of <a class="existingWikiWord" href="/nlab/show/abelian+sheaf+cohomology">abelian sheaf cohomology</a> there are two general ways for computing this cohomology called</p>

<ul>
<li>
<p>right derived global section functor</p>
</li>

<li>
<p>Čech cohomology;</p>
</li>
</ul>

<p>these two methods differ in whether one computes using “resolutions” of either the coefficient object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> (this happens in the right derived global section functor approach) or in the domain object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> (this happens in Čech cohomology).</p>

<h2 id="examples">Examples</h2>

<p>Recall that we started the search for a generalized notion of space motivated by the fact that a circle bundle on a space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> may be encoded by a map from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> to some topological space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{B}U(1)</annotation></semantics></math>, but that the same was not true for circle bundles <em>with connection</em>. We had wanted to obtain a generalized notion of space such that this is remedied.</p>

<ul>
<li>
<p>Indeed, this is now the case. There is a famous abelian sheaf, called the second <a class="existingWikiWord" href="/nlab/show/Deligne+cohomology">Deligne complex</a> which we may denote by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[P_1(-), \mathcal{B}U(1)]</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>1</mn></msub><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bar \mathcal{B}_1 U(1)</annotation></semantics></math> (as explained at <a class="existingWikiWord" href="/nlab/show/Deligne+cohomology">Deligne cohomology</a> and at <a class="existingWikiWord" href="/nlab/show/groupoid+of+Lie-algebra+valued+forms">groupoid of Lie-algebra valued forms</a>), which has precisely the property that maps from a manifold <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> into it classify circle bundles with connection on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. Moreover, by varying the two parameters here we get the following cases</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = [P_0(-), \mathcal{B}U(1)] = \mathcal{B}U(1)</annotation></semantics></math>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>H</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(X,A) = H^2(X,A)</annotation></semantics></math> is second integral cohomology – classifies line bundles;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><msub><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>1</mn></msub><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = [P_1(-), \mathcal{B}U(1)] = \bar \mathcal{B}_1 U(1)</annotation></semantics></math>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mover><mi>H</mi><mo stretchy="false">¯</mo></mover> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(X,A) = \bar H^2(X,\mathbb{Z})</annotation></semantics></math> is second differential integral cohomology – classifies line bundles with <a class="existingWikiWord" href="/nlab/show/connection">connection</a>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><mi>ℬ</mi><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><msub><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>2</mn></msub><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = [P_2(-), \mathcal{B}U(1)] = \bar \mathcal{B}_2 U(1)</annotation></semantics></math>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mover><mi>H</mi><mo stretchy="false">¯</mo></mover> <mi>flat</mi> <mn>2</mn></msubsup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H(X,A) = \bar H_{flat}^2(X,\mathbb{Z})</annotation></semantics></math> is second flat differential integral cohomology – classifies smooth line bundles with flat <a class="existingWikiWord" href="/nlab/show/connection">connection</a>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><msup><mi>ℬ</mi> <mn>2</mn></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><msup><mi>ℬ</mi> <mn>2</mn></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = [P_0(-), \mathcal{B}^2U(1)] = \mathcal{B}^2U(1)</annotation></semantics></math>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>H</mi> <mn>3</mn></msup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(X,A) = H^3(X,A)</annotation></semantics></math> is third integral cohomology – classifies line <a class="existingWikiWord" href="/nlab/show/bundle+gerbe">bundle gerbe</a>s;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><msup><mi>ℬ</mi> <mn>2</mn></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><msubsup><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>1</mn> <mn>2</mn></msubsup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = [P_1(-), \mathcal{B}^2U(1)] = \bar \mathcal{B}^2_1 U(1)</annotation></semantics></math> – classifies line <a class="existingWikiWord" href="/nlab/show/bundle+gerbe">bundle gerbe</a>s with connective structure;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><msup><mi>ℬ</mi> <mn>2</mn></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><msubsup><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>2</mn> <mn>2</mn></msubsup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = [P_2(-), \mathcal{B}^2U(1)] = \bar \mathcal{B}^2_2 U(1)</annotation></semantics></math>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mover><mi>H</mi><mo stretchy="false">¯</mo></mover> <mi>flat</mi> <mn>3</mn></msubsup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H(X,A) = \bar H_{flat}^3(X,\mathbb{Z})</annotation></semantics></math> is third differential integral cohomology – classifies smooth line <a class="existingWikiWord" href="/nlab/show/bundle+gerbe">bundle gerbe</a>s with connection;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>P</mi> <mn>3</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><msup><mi>ℬ</mi> <mn>2</mn></msup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><msubsup><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>3</mn> <mn>2</mn></msubsup><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = [P_3(-), \mathcal{B}^2U(1)] = \bar \mathcal{B}^2_3 U(1)</annotation></semantics></math>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mover><mi>H</mi><mo stretchy="false">¯</mo></mover> <mi>flat</mi> <mn>3</mn></msubsup><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>ℤ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> H(X,A) = \bar H_{flat}^3(X,\mathbb{Z})</annotation></semantics></math> is third flat differential integral cohomology – classifies line <a class="existingWikiWord" href="/nlab/show/bundle+gerbe">bundle gerbe</a>s with flat connection;</p>
</li>
</ul>
</li>
</ul>

<p>Notice that all these objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> do indeed behave, and can be treated like, generalized spaces. For instance one can look at paths in these spaces and for instance form their <a class="existingWikiWord" href="/nlab/show/fundamental+groupoid">fundamental groupoid</a>s. One finds results such that for instance</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>2</mn></msub><mi>U</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≃</mo><mi>ℬ</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">\Pi_1(\bar \mathcal{B}_2 U(1)) \simeq \mathcal{B}R</annotation></semantics></math></p>
</li>

<li>
<p>more generally: for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> any Lie group, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Π</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mover><mi>ℬ</mi><mo stretchy="false">¯</mo></mover> <mn>2</mn></msub><mi>G</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>ℬ</mi><mover><mi>G</mi><mo stretchy="false">^</mo></mover></mrow><annotation encoding="application/x-tex">\Pi_1(\bar \mathcal{B}_2 G) \simeq \mathcal{B}\hat G</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>G</mi><mo stretchy="false">^</mo></mover></mrow><annotation encoding="application/x-tex">\hat G</annotation></semantics></math> is the unique simply connected Lie group covering <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p>
</li>
</ul>

<h2 id="related_entries">Related entries</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/geometry+of+physics">geometry of physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fiber+bundles+in+physics">fiber bundles in physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+category+theory+and+physics">higher category theory and physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/string+theory+FAQ">string theory FAQ</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/twisted+smooth+cohomology+in+string+theory">twisted smooth cohomology in string theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/motives+in+physics">motives in physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Hilbert%27s+sixth+problem">Hilbert's sixth problem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+theory+and+physics">model theory and physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/L-infinity+algebras+in+physics">L-infinity algebras in physics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/motivation+for+sheaves%2C+cohomology+and+higher+stacks">motivation for sheaves, cohomology and higher stacks</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/applications+of+%28higher%29+category+theory">applications of (higher) category theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/motivation+for+higher+differential+geometry">motivation for higher differential geometry</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/motivation+for+cohesion">motivation for cohesion</a></p>
</li>
</ul>
<div class="property">category: <a class="category_link" href="/nlab/all_pages/motivation">motivation</a></div></body></html>

</div>

<div class="revisedby">
  <p>
  Last revised on November 11, 2018 at 03:59:18.
  See the <a href="https://ncatlab.org/nlab/history/motivation for sheaves, cohomology and higher stacks" style="color: #005c19">history</a> of this page for a list of all contributions to it.
  </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/motivation+for+sheaves%2C+cohomology+and+higher+stacks" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a> | <a href="/nlab/revision/motivation+for+sheaves%2C+cohomology+and+higher+stacks/33" accesskey="B" class="navlink" id="to_previous_revision" rel="nofollow">Back in time</a> <span class='revisions'>(33 revisions)</span> | <a href="/nlab/show/diff/motivation+for+sheaves%2C+cohomology+and+higher+stacks" accesskey="C" class="navlink" id="see_changes" rel="nofollow">See changes</a> | <a href="/nlab/history/motivation+for+sheaves%2C+cohomology+and+higher+stacks" accesskey="S" class="navlink" id="history" rel="nofollow">History</a>
  | <a href="https://ncatlab.org/nlab/show/motivation for sheaves, cohomology and higher stacks/cite" style="color: black">Cite</a>
  <span class="views">
    | Views:
    <a href="/nlab/print/motivation+for+sheaves%2C+cohomology+and+higher+stacks" accesskey="p" id="view_print" rel="nofollow">Print</a>
    |
    <a href="/nlab/tex/motivation+for+sheaves%2C+cohomology+and+higher+stacks" id="view_tex" rel="nofollow">TeX</a>
    |
    <a href="/nlab/source/motivation+for+sheaves%2C+cohomology+and+higher+stacks" id="view_source" rel="nofollow">Source</a>
  </span>

  


</div>


    <div id="footer">
    <div>This site is running on <a href="http://golem.ph.utexas.edu/instiki/show/HomePage">Instiki 0.19.7(MML+)</a></div>
    <div>Powered by <a href="http://rubyonrails.com/">Ruby on Rails</a>  2.3.18</div>
    </div>

</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
