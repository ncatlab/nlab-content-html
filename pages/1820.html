
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      combinatorial model category in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />


  <link href="/stylesheets/instiki.css?1534097725" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #008B26;
    }
    a:visited.existingWikiWord {
      color: #005c19;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #005000;
}

a.existingWikiWord:visited {
color: #005000;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    
<span id="svg_logo"><svg version="1.1" width="100%" height="100%" viewBox='0 -1 180 198' xmlns='http://www.w3.org/2000/svg'>
      <path id="svg_logo_path" fill="#008B26" stroke-width='0.5' stroke='#000' d='
        M170,60c4,11-1,20-12,25c-9,4-25,3-20,15c5,5,15,0,24,1c11,1,21,11,14,21c-10,15-35,6-48-1c-5-3-27-23-32-10c-1,13,15,10,22,16
        c11,4,24,14,34,20c12,10,7,25-9,23c-11-1-22-9-30-16c-5-5-13-18-21-9c-2,6,2,11,5,14c9,9,22,14,22,31c-2,8-12,8-18,4c-4-3-9-8-11-13
        c-3-6-5-18-12-18c-14-1-5,28-18,30c-9,2-13-9-12-16c1-14,12-24,21-31c5-4,17-13,10-20c-9-10-19,12-23,16c-7,7-17,16-31,15
        c-9-1-18-9-11-17c5-7,14-4,23-6c6-1,15-8,8-15c-5-6-57,2-42-24c7-12,51,4,61,6c6,1,17,4,18-4c2-11-12-7-21-8c-21-2-49-14-49-34
        c0-5,3-11,8-11C31,42,34,65,42,67c6,1,9-3,8-9C49,49,38,40,40,25c1-5,4-15,13-14c10,2,11,18,13,29c1,8,0,24,7,28c15,0,5-22,4-30
        C74,23,78,7,87,1c8-4,14,1,16,9c2,11-8,21-2,30c8,2,11-6,14-12c9-14,36-18,30,5c-3,9-12,19-21,24c-6,4-22,10-23,19c-2,14,15,2,18-2
        c9-9,20-18,33-22C159,52,166,54,170,60' />
    </svg></span>
      <span class="webName">nLab</span><br />
      combinatorial model category
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/404/#Item_11" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
    <a href="/nlab/feeds" title="Subscribe to changes by Atom">Feeds</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="model_category_theory">Model category theory</h4>

<div class="hide"><p><strong><a class="existingWikiWord" href="/nlab/show/model+category">model category</a></strong></p><h2 id="definitions">Definitions</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">category with weak equivalences</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/weak+factorization+system">weak factorization system</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+%28as+an+operation%29">homotopy</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/resolution">resolution</a></p>
</li>
</ul><h2 id="morphisms">Morphisms</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Quillen+adjunction">Quillen adjunction</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a></p>
</li>
</ul>
</li>
</ul><h2 id="universal_constructions">Universal constructions</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+Kan+extension">homotopy Kan extension</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+limit">homotopy limit</a>/<a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bousfield-Kan+map">Bousfield-Kan map</a></p>
</li>
</ul><h2 id="refinements">Refinements</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/monoidal+model+category">monoidal model category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/monoidal+Quillen+adjunction">monoidal Quillen adjunction</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/enriched+model+category">enriched model category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/enriched+Quillen+adjunction">enriched Quillen adjunction</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/simplicial+Quillen+adjunction">simplicial Quillen adjunction</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cofibrantly+generated+model+category">cofibrantly generated model category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/combinatorial+model+category">combinatorial model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cellular+model+category">cellular model category</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/algebraic+model+category">algebraic model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/compactly+generated+model+category">compactly generated model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proper+model+category">proper model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cartesian+closed+model+category">cartesian closed model category</a>, <a class="existingWikiWord" href="/nlab/show/locally+cartesian+closed+model+category">locally cartesian closed model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/stable+model+category">stable model category</a></p>
</li>
</ul><h2 id="producing_new_model_structures">Producing new model structures</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/global+model+structures+on+functor+categories">on functor categories (global)</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Reedy+model+structure">Reedy model structure</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+an+overcategory">on overcategories</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/transferred+model+structure">transferred model structure</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebraic+fibrant+objects">model structure on algebraic fibrant objects</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Grothendieck+construction+for+model+categories">Grothendieck construction for model categories</a></p>
</li>
</ul><h2 id="presentation_of_categories">Presentation of <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_1"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories</h2><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/simplicial+localization">simplicial localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-categorical+hom-space">(∞,1)-categorical hom-space</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/presentable+%28%E2%88%9E%2C1%29-category">presentable (∞,1)-category</a></p>
</li>
</ul><h2 id="model_structures">Model structures</h2><ul>
<li><a class="existingWikiWord" href="/nlab/show/Cisinski+model+structure">Cisinski model structure</a></li>
</ul><h3 id="for_groupoids">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_2"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groupoids</h3><p><a class="existingWikiWord" href="/nlab/show/model+structure+for+%E2%88%9E-groupoids">for ∞-groupoids</a></p><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+topological+spaces">on topological spaces</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Strom+model+structure">Strom model structure</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Thomason+model+structure">Thomason model structure</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+presheaves+over+a+test+category">model structure on presheaves over a test category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+sets">on simplicial sets</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+on+semi-simplicial+sets">on semi-simplicial sets</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/model+structure+for+right+fibrations">for right/left fibrations</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+groupoids">model structure on simplicial groupoids</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+cubical+sets">on cubical sets</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+strict+%E2%88%9E-groupoids">on strict ∞-groupoids</a>, <a class="existingWikiWord" href="/nlab/show/natural+model+structure+on+groupoids">on groupoids</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+chain+complexes">on chain complexes</a>/<a class="existingWikiWord" href="/nlab/show/model+structure+on+cosimplicial+abelian+groups">model structure on cosimplicial abelian groups</a></p>

<p>related by the <a class="existingWikiWord" href="/nlab/show/Dold-Kan+correspondence">Dold-Kan correspondence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+cosimplicial+simplicial+sets">model structure on cosimplicial simplicial sets</a></p>
</li>
</ul><h3 id="for_groupoids_2">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_3"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-groupoids</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+n-groupoids">for n-groupoids</a>/<a class="existingWikiWord" href="/nlab/show/model+structure+for+n-groupoids">for n-types</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+model+structure+on+groupoids">for 1-groupoids</a></p>
</li>
</ul><h3 id="for_groups">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_4"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groups</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+groups">model structure on simplicial groups</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+reduced+simplicial+sets">model structure on reduced simplicial sets</a></p>
</li>
</ul><h3 id="for_algebras">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_5"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-algebras</h3><h4 id="general">general</h4><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+monoids">on monoids</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+T-algebras">on simplicial T-algebras</a>, on <a class="existingWikiWord" href="/nlab/show/homotopy+T-algebra">homotopy T-algebra</a>s</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebras+over+a+monad">on algebas over a monad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebras+over+an+operad">on algebras over an operad</a>,</p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+modules+over+an+algebra+over+an+operad">on modules over an algebra over an operad</a></p>
</li>
</ul><h4 id="specific">specific</h4><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-algebras">model structure on differential-graded commutative algebras</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+differential+graded-commutative+superalgebras">model structure on differential graded-commutative superalgebras</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-algebras+over+an+operad">on dg-algebras over an operad</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-algebras">on dg-algebras</a> and on <a class="existingWikiWord" href="/nlab/show/simplicial+ring">on simplicial rings</a>/<a class="existingWikiWord" href="/nlab/show/model+structure+on+cosimplicial+rings">on cosimplicial rings</a></p>

<p>related by the <a class="existingWikiWord" href="/nlab/show/monoidal+Dold-Kan+correspondence">monoidal Dold-Kan correspondence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+L-%E2%88%9E+algebras">for L-∞ algebras</a>: <a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-Lie+algebras">on dg-Lie algebras</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-coalgebras">on dg-coalgebras</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+Lie+algebras">on simplicial Lie algebras</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-modules">model structure on dg-modules</a></p>
</li>
</ul><h3 id="for_stablespectrum_objects">for stable/spectrum objects</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+spectra">model structure on spectra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+ring+spectra">model structure on ring spectra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+presheaves+of+spectra">model structure on presheaves of spectra</a></p>
</li>
</ul><h3 id="for_categories">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_6"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+categories+with+weak+equivalences">on categories with weak equivalences</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+quasi-categories">Joyal model for quasi-categories</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+sSet-categories">on sSet-categories</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+complete+Segal+spaces">for complete Segal spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+Cartesian+fibrations">for Cartesian fibrations</a></p>
</li>
</ul><h3 id="for_stable_categories">for stable <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_7"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories</h3><ul>
<li><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-categories">on dg-categories</a></li>
</ul><h3 id="for_operads">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_8"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-operads</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+operads">on operads</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+for+Segal+operads">for Segal operads</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebras+over+an+operad">on algebras over an operad</a>,</p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+modules+over+an+algebra+over+an+operad">on modules over an algebra over an operad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dendroidal+sets">on dendroidal sets</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+for+dendroidal+complete+Segal+spaces">for dendroidal complete Segal spaces</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+for+dendroidal+Cartesian+fibrations">for dendroidal Cartesian fibrations</a></p>
</li>
</ul><h3 id="for_categories_2">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_9"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,r)</annotation></semantics></math>-categories</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Theta+space">for (n,r)-categories as ∞-spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+weak+complicial+sets">for weak ∞-categories as weak complicial sets</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+cellular+sets">on cellular sets</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+model+structure">on higher categories in general</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+strict+%E2%88%9E-categories">on strict ∞-categories</a></p>
</li>
</ul><h3 id="for_sheaves__stacks">for <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_10"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-sheaves / <math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline" id="mathml_c7faaf3facb8b8d487de2b81997062b301e5408f_11"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks</h3><ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+homotopical+presheaves">on homotopical presheaves</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">on simplicial presheaves</a></p>

<p><a class="existingWikiWord" href="/nlab/show/global+model+structure+on+simplicial+presheaves">global model structure</a>/<a class="existingWikiWord" href="/nlab/show/Cech+model+structure+on+simplicial+presheaves">Cech model structure</a>/<a class="existingWikiWord" href="/nlab/show/local+model+structure+on+simplicial+presheaves">local model structure</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+sheaves">on simplicial sheaves</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+presheaves+of+simplicial+groupoids">on presheaves of simplicial groupoids</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+sSet-enriched+presheaves">on sSet-enriched presheaves</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+%282%2C1%29-sheaves">model structure for (2,1)-sheaves</a>/for stacks</p>
</li>
</ul><div>
<p>
  <a href="/nlab/edit/model+category+theory+-+contents">Edit this sidebar</a>
</p>
</div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#definition'>Definition</a></li>
<li><a href='#characterization_theorems'>Characterization theorems</a></li>
<ul>
<li><a href='#SmithTheorem'>Smith’s theorem</a></li>
<li><a href='#DuggerTheorem'>Dugger’s theorem</a></li>
<li><a href='#tractable_combinatorial_model_categories'>Tractable combinatorial model categories</a></li>
</ul>
<li><a href='#properties'>Properties</a></li>
<ul>
<li><a href='#hocolims'>Homotopy colimits</a></li>
<li><a href='#bousfield_localization'>Bousfield localization</a></li>
</ul>
<li><a href='#examples'>Examples</a></li>
<ul>
<li><a href='#basic_examples'>Basic examples</a></li>
<li><a href='#cisinski_model_structures'>Cisinski model structures</a></li>
<li><a href='#derived_examples'>Derived examples</a></li>
<li><a href='#from_cofibrantly_generated_model_categories'>From cofibrantly generated model categories</a></li>
<li><a href='#simplicial_combinatorial_model_categories'>Simplicial combinatorial model categories</a></li>
</ul>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>A <em>combinatorial model category</em> is a particularly tractable <a class="existingWikiWord" href="/nlab/show/model+category">model category</a> structure. (Notice however that there is also the, closely related, technical notion of a <a class="existingWikiWord" href="/nlab/show/tractable+model+category">tractable model category</a>).</p>

<p>Being combinatorial means that there is very strong control over the cofibrations in these model structures: there is a <a class="existingWikiWord" href="/nlab/show/set">set</a> (meaning <a class="existingWikiWord" href="/nlab/show/small+set">small set</a>, not a <a class="existingWikiWord" href="/nlab/show/proper+class">proper class</a>) of <a class="existingWikiWord" href="/nlab/show/cofibrantly+generated+model+category">generating (acyclic) cofibrations</a>, and all objects, in particular the domains and codomains of these cofibrations, are <a class="existingWikiWord" href="/nlab/show/small+object">small object</a>s.</p>

<p>So as a slogan we have that</p>

<div class="standout">
<p>A combinatorial model structure is one that is generated from <em>small data</em>: it is generated from a small set of (acyclic) cofibrations between small objects.</p>
</div>

<p>In fact, the combinatoriality condition is a bit stronger than that, as it requires even that <em>every</em> object is small and is the colimit over a small set of generating objects.</p>

<p>There exist large classes of model categories that either are combinatorial or, if not, are <a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalent</a> to ones that are. See the list of examples below.</p>

<p>The relevance of combinatorial model categories is given more abstractly by the result that</p>

<div class="standout">
<p><a class="existingWikiWord" href="/nlab/show/combinatorial+simplicial+model+category">Combinatorial simplicial model categories</a> are precisely those model categories that model <a class="existingWikiWord" href="/nlab/show/presentable+%28%E2%88%9E%2C1%29-category">presentable (∞,1)-categories</a>.</p>
</div>

<p>For more see at <em><a class="existingWikiWord" href="/nlab/show/locally+presentable+categories+-+introduction">locally presentable categories - introduction</a></em>.</p>

<h2 id="definition">Definition</h2>

<div class="num_defn">
<h6 id="definition_2">Definition</h6>

<p><strong>(Jeff Smith)</strong></p>

<p>A <a class="existingWikiWord" href="/nlab/show/model+category">model category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is <strong>combinatorial</strong> if it is</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/locally+presentable+category">locally presentable</a> as a <a class="existingWikiWord" href="/nlab/show/category">category</a></li>
</ul>

<p>and</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/cofibrantly+generated+model+category">cofibrantly generated</a> as a model category.</li>
</ul>
</div>

<div class="num_remark">
<h6 id="remark">Remark</h6>

<p>Recall from the discussion at <a class="existingWikiWord" href="/nlab/show/cofibrantly+generated+model+category">cofibrantly generated model category</a> that this means that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> has a <a class="existingWikiWord" href="/nlab/show/set">set</a> (i.e. a <a class="existingWikiWord" href="/nlab/show/small+set">small set</a>, not a <a class="existingWikiWord" href="/nlab/show/proper+class">proper class</a>) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> of generating <a class="existingWikiWord" href="/nlab/show/cofibrations">cofibrations</a> and a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> of generating trivial cofibrations in that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo>=</mo><mi>llp</mi><mo stretchy="false">(</mo><mi>rlp</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> 
  cof = llp(rlp(I))

</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>fib</mi><mo>=</mo><mi>llp</mi><mo stretchy="false">(</mo><mi>rlp</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  fib = llp(rlp(J))
  \,.

</annotation></semantics></math></div>
<p>Here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fib</mi><mo>,</mo><mi>cof</mi><mo>⊂</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fib, cof \subset Mor(C)</annotation></semantics></math> is the collection of fibrations and cofibration, respectively, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>llp</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>,</mo><mi>rlp</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">llp(S), rlp(S)</annotation></semantics></math> is the collection of morphisms satisfying the left or right, respectively, <a class="existingWikiWord" href="/nlab/show/lifting+property">lifting property</a> with respect to a collection of morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p>
</div>

<p>Jeff Smith’s theorem, <a href="#SmithTheorem">below</a>, gives an equivalent characterization that is usually easier to handle.</p>

<h2 id="characterization_theorems">Characterization theorems</h2>

<p>There are two powerful theorems that characterize combinatorial model categories in terms of data that is often easier to handle:</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Jeff+Smith">Jeff Smith</a>‘s theorem characterizes combinatorial model categories just in terms of weak equivalences and generating cofibrations, hence using only two third of the input data explicitly required. This greatly facilitates identifying combinatorial model category structures. For instance it helps to show that the left <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization</a> of certain combinatorial model categories is again a combinatorial model category.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Dan+Dugger">Dan Dugger</a>‘s theorem shows that <a class="existingWikiWord" href="/nlab/show/combinatorial+model+category">combinatorial model categories</a> are, up to <a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalence</a>, precisely those model categories that have a <em>presentation</em> in that they are <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization</a>s of <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">global model structures on simplicial presheaves</a>. This was used by <a class="existingWikiWord" href="/nlab/show/Jacob+Lurie">Jacob Lurie</a> to show that simplicial combinatorial model categories are precisely the models for <a class="existingWikiWord" href="/nlab/show/presentable+%28%E2%88%9E%2C1%29-category">locally presentable (∞,1)-categories</a>.</p>
</li>
</ul>

<h3 id="SmithTheorem">Smith’s theorem</h3>

<p>A central theorem about combinatorial model categories is <strong><a class="existingWikiWord" href="/nlab/show/Jeff+Smith">Jeff Smith</a>‘s theorem</strong> which establishes the existence of combinatorial model category structures from a small amount of input data.</p>

<div class="num_theorem">
<h6 id="theorem">Theorem</h6>

<p><strong>(Jeff Smith’s theorem)</strong></p>

<p>For</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/locally+presentable+category">locally presentable category</a>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Arr</mi> <mi>W</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>Arr</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr_W(C) \subset Arr(C)</annotation></semantics></math> an accessibly embedded <a class="existingWikiWord" href="/nlab/show/accessible+category">accessible</a> <a class="existingWikiWord" href="/nlab/show/full+subcategory">full subcategory</a> of the <a class="existingWikiWord" href="/nlab/show/arrow+category">arrow category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Arr</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr(C)</annotation></semantics></math> on a <a class="existingWikiWord" href="/nlab/show/class">class</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>⊂</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W \subset Mor(C)</annotation></semantics></math>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I \subset Mor(C)</annotation></semantics></math> a small <a class="existingWikiWord" href="/nlab/show/set">set</a> (not a proper class) of morphisms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></p>
</li>
</ul>

<p>such that</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> satisfies <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">2-out-of-3</a>;</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>inj</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">inj(I) \subset W</annotation></semantics></math></p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">cof(I) \cap W</annotation></semantics></math> is closed under <a class="existingWikiWord" href="/nlab/show/pushout">pushout</a> and <a class="existingWikiWord" href="/nlab/show/transfinite+composition">transfinite composition</a>.</p>
</li>
</ul>

<p>we have that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a combinatorial model category with</p>

<ul>
<li>
<p>weak equivalences <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math>;</p>
</li>

<li>
<p>cofibrations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cof(I)</annotation></semantics></math>.</p>
</li>
</ul>

<p>Moreover, every combinatorial model category arises in this way.</p>
</div>

<p>Here the notation is as described at <a class="existingWikiWord" href="/nlab/show/cofibrantly+generated+model+category">cofibrantly generated model category</a>, so: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>inj</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>=</mo><mi>rlp</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">inj(I) = rlp(I)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>=</mo><mi>llp</mi><mo stretchy="false">(</mo><mi>rlp</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cof(I) = llp(rlp(I))</annotation></semantics></math>.</p>

<p>This statement was announced by <a class="existingWikiWord" href="/nlab/show/Jeff+Smith">Jeff Smith</a> in 1998 at a conference in Barcelona and appararently first appeared in print as (<a href="#Beke">Beke, theorem 1.7</a>). The above formulation follows (<a href="#Barwick">Barwick, prop 1.7</a>).</p>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>To prove the first part of the statement, that the given data encodes a combinatorial model category, it is sufficient to find a small set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> such that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo><mo>=</mo><mi>W</mi><mo>∩</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  cof(J) = W \cap cof(I)
  \,.

</annotation></semantics></math></div>
<p>With that the statement follows using the <a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a> to show the existence of the required factorizations.</p>

<p>To find this small set, we make use of the assumption that the subcategory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Arr</mi> <mi>W</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>Arr</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr_W(C) \subset Arr(C)</annotation></semantics></math> of weak equivalences and commuting squares in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> between them is an <a class="existingWikiWord" href="/nlab/show/accessible+category">accessible</a> subcategory of the <a class="existingWikiWord" href="/nlab/show/arrow+category">arrow category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Arr</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr(C)</annotation></semantics></math>. This means that there is a small set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>W</mi> <mn>0</mn></msub><mo>⊂</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">W_0 \subset W</annotation></semantics></math> such that every element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> is a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/directed+colimit">directed colimit</a> over element in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>W</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">W_0</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Arr</mi> <mi>W</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr_W(C)</annotation></semantics></math>, for some large enough <a class="existingWikiWord" href="/nlab/show/cardinal+number">cardinal number</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>, such that all elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/compact+object">compact</a>.</p>

<p>Using the <a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a> factor every morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P \to Q</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>W</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">W_0</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mover><mo>→</mo><mrow><mo>∈</mo><mi>cell</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow></mover><mi>R</mi><mover><mo>→</mo><mrow><mo>∈</mo><mi>inj</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow></mover><mi>Q</mi></mrow><annotation encoding="application/x-tex">P \stackrel{\in cell(I)}{\to} R \stackrel{\in inj(I)}{\to}Q</annotation></semantics></math>. Note that by <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">2-out-of-3</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>inj</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">inj(I) \subseteq W</annotation></semantics></math>, the cofibration <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P \to R</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> be the set of acyclic cofibratons <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P \to R</annotation></semantics></math> so obtained.</p>

<p>By the choice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>W</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">W_0</annotation></semantics></math> every morphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>K</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>M</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mi>I</mi></mpadded></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>W</mi></mrow></mpadded></msup></mtd></mtr> <mtr><mtd><mi>L</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>N</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    K &amp;\to&amp; M
    \\
    \downarrow^{\mathrlap{I}} &amp;&amp; \downarrow^{\mathrlap{\in W}}
    \\
    L &amp;\to&amp; N
  }

</annotation></semantics></math></div>
<p>in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Arr</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr(C)</annotation></semantics></math> lifts through one of the components in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>W</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">W_0</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> (this mechanism is described in detail at <a class="existingWikiWord" href="/nlab/show/small+object">small object</a>) as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>K</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>P</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>M</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mi>I</mi></mpadded></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><msub><mi>W</mi> <mn>0</mn></msub></mrow></mpadded></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>W</mi></mrow></mpadded></msup></mtd></mtr> <mtr><mtd><mi>L</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Q</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>N</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
    K &amp;\to&amp; P &amp;\to&amp; M
    \\
    \downarrow^{\mathrlap{I}} &amp;&amp; \downarrow^{\mathrlap{\in W_0}} &amp;&amp; \downarrow^{\mathrlap{\in W}}
    \\
    L &amp;\to&amp; Q &amp;\to&amp; N
  }
  \,.

</annotation></semantics></math></div>
<p>In the special case that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">K \to L</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math>, we can refine this to a factoring through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> as follows: by construction using the <a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a> factor the morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P \to Q</annotation></semantics></math> factors as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mover><mo>→</mo><mrow><mo>∈</mo><mi>J</mi></mrow></mover><mi>R</mi><mover><mo>→</mo><mrow><mo>∈</mo><mi>inj</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow></mover><mi>Q</mi></mrow><annotation encoding="application/x-tex">P \stackrel{\in J}{\to} R \stackrel{\in inj(J)}{\to}Q</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>L</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">L \to Q</annotation></semantics></math> lifts to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>L</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \to R</annotation></semantics></math> and we obtain the factorization</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>K</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>P</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>M</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>I</mi></mrow></mpadded></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>J</mi></mrow></mpadded></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>W</mi></mrow></mpadded></msup></mtd></mtr> <mtr><mtd><mi>L</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>R</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>N</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    K &amp;\to&amp; P &amp;\to&amp; M
    \\
    \downarrow^{\mathrlap{\in I}} &amp;&amp; \downarrow^{\mathrlap{\in J}} &amp;&amp; \downarrow^{\mathrlap{\in W}}
    \\
    L &amp;\to&amp; R &amp;\to&amp; N
  }

</annotation></semantics></math></div>
<p>of the original square from an element in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> to an element in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> through an element in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi><mo>=</mo><mi>W</mi><mo>∩</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J = W \cap cof(I)</annotation></semantics></math>. (In <a href="http://arxiv.org/abs/math/0102087">Beke</a>, following <a class="existingWikiWord" href="/nlab/show/Jeff+Smith">Jeff Smith</a>, this is called the <strong>solution set condition</strong>: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>W</mi> <mn>0</mn></msub><mo>∩</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W_0 \cap cof(I)</annotation></semantics></math> is “a solution set for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math>”).</p>

<p>By following now precisely the <a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a> with the only difference that one factors all the squares over which one takes a colimit in that argument through elements in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> as above, it follows now that every morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mover><mo>→</mo><mrow><mo>∈</mo><mi>W</mi></mrow></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">A \stackrel{\in W}{\to} B</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> may be factored as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>A</mi><mover><mo>→</mo><mrow><mo>∈</mo><mi>cell</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow></mover><mi>C</mi><mover><mo>→</mo><mrow><mo>∈</mo><mi>inj</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow></mover><mi>B</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  A \stackrel{\in cell(J)}{\to} C \stackrel{\in inj(I)}{\to} B
  \,.

</annotation></semantics></math></div>
<p>This we use to show that every morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f \in cof(I) \cap W</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cof(J)</annotation></semantics></math>:</p>

<p>since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">f \in W</annotation></semantics></math> we may factor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> as above and since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f \in cof(I)</annotation></semantics></math> we obtain a lift <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> in</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>A</mi></mtd> <mtd><mover><mo>→</mo><mrow><mo>∈</mo><mi>cell</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>C</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mi>f</mi></msup></mtd> <mtd><msup><mrow></mrow> <mi>σ</mi></msup><mo>↗</mo></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>inj</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow></mpadded></msup></mtd></mtr> <mtr><mtd><mi>B</mi></mtd> <mtd><mover><mo>→</mo><mo>=</mo></mover></mtd> <mtd><mi>B</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
    A &amp;\stackrel{\in cell(J)}{\to}&amp; C
    \\
    \downarrow^{f} &amp;{}^\sigma \nearrow&amp;
    \downarrow^{\mathrlap{\in inj(I)}}
    \\
    B &amp;\stackrel{=}{\to}&amp; B
  }
  \,.

</annotation></semantics></math></div>
<p>Rearranging this it becomes a <a class="existingWikiWord" href="/nlab/show/retract">retract</a> diagram in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Arr</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr(C)</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>A</mi></mtd> <mtd><mover><mo>→</mo><mo>=</mo></mover></mtd> <mtd><mi>A</mi></mtd> <mtd><mover><mo>→</mo><mo>=</mo></mover></mtd> <mtd><mi>A</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mi>f</mi></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>cell</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow></mpadded></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mi>f</mi></msup></mtd></mtr> <mtr><mtd><mi>B</mi></mtd> <mtd><mover><mo>→</mo><mi>σ</mi></mover></mtd> <mtd><mi>C</mi></mtd> <mtd><mover><mo>→</mo><mrow><mo>∈</mo><mi>inj</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>B</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    A &amp;\stackrel{=}{\to}&amp; A &amp;\stackrel{=}{\to}&amp; A
    \\
    \downarrow^f &amp;&amp; \downarrow^{\mathrlap{\in cell(J)}}
    &amp;&amp; \downarrow^f
    \\
    B &amp;\stackrel{\sigma}{\to}&amp;
    C
    &amp;
    \stackrel{\in inj(I)}{\to}
    &amp;
    B
  }

</annotation></semantics></math></div>
<p>which shows that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a retract of an element in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cell</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cell(J) \subset cof(J)</annotation></semantics></math>, hence itself in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cof(J)</annotation></semantics></math>.</p>

<p>And the converse statement is immediate: by definition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi><mo>⊂</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">J \subset cof(I) \cap W</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cof(J)</annotation></semantics></math> is the saturation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> under the operation of forming retracts of transfinite compositions of pushouts of elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math>, under which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">cof(I) \cap W</annotation></semantics></math> is assumed to be closed.</p>

<p>In total we have indeed <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>cof</mi><mo stretchy="false">(</mo><mi>J</mi><mo stretchy="false">)</mo><mo>=</mo><mi>cof</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">cof(J) = cof(I) \cap W</annotation></semantics></math> which shows that the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> given determine a combinatorial model category.</p>

<p>To see the converse, that every combinatorial model structure arises this way, it is sufficient to show that for every combinatorial model category the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Arr</mi> <mi>W</mi></msub><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>Arr</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Arr_W(C) \subset Arr(C)</annotation></semantics></math> is an <a class="existingWikiWord" href="/nlab/show/accessible+category">accessible category</a>.</p>
</div>

<p>For applications of this theorem, the following auxiliary statements are useful.</p>

<div class="num_prop">
<h6 id="proposition">Proposition</h6>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a combinatorial model category, the full subcategory inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><msub><mo stretchy="false">)</mo> <mi>W</mi></msub><mo>↪</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  Mor(C)_W \hookrightarrow Mor(C)

</annotation></semantics></math></div>
<p>of the <a class="existingWikiWord" href="/nlab/show/arrow+category">arrow category</a> on the weak equivalences is an <a class="existingWikiWord" href="/nlab/show/accessible+functor">accessible inclusion</a> of an <a class="existingWikiWord" href="/nlab/show/accessible+category">accessible category</a>.</p>
</div>

<p>This is due to Smith. A proof appears as (<a href="#Dugger01">Dugger 01, 7.4</a>). See also (<a href="#Barwick">Barwick, prop. 1.10</a>).</p>

<div class="num_prop">
<h6 id="proposition_2">Proposition</h6>

<p>Let</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  F : Mor(A) \to Mor(B)

</annotation></semantics></math></div>
<p>be an <a class="existingWikiWord" href="/nlab/show/accessible+functor">accessible functor</a> between <a class="existingWikiWord" href="/nlab/show/arrow+categories">arrow categories</a>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> be equipped with <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">weak equivalences</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> such that the <a class="existingWikiWord" href="/nlab/show/full+subcategory">full subcategory</a> inclusion</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Mor</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>↪</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  Mor(W) \hookrightarrow Mor(B)

</annotation></semantics></math></div>
<p>on the weak equivalences is an <a class="existingWikiWord" href="/nlab/show/accessible+functor">accessible embedding</a> of an <a class="existingWikiWord" href="/nlab/show/accessible+category">accessible category</a>. Then so is the full subcategory of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mor</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Mor(A)</annotation></semantics></math> on the pre-images <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>F</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F^{-1}(W)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>
</div>

<p>(<a href="#Beke">Beke, prop. 1.18</a>).</p>

<div class="proof">
<h6 id="proof_2">Proof</h6>

<p>By general properties of <a class="existingWikiWord" href="/nlab/show/accessible+categories">accessible categories</a> (see there) the full inverse image along an accessible functor of a full accessible subcategory is again accessible.</p>
</div>

<h3 id="DuggerTheorem">Dugger’s theorem</h3>

<p>The following theorem is precisely the model-category theory version of the statement that every <a class="existingWikiWord" href="/nlab/show/locally+presentable+%28%E2%88%9E%2C1%29-category">locally presentable (∞,1)-category</a> arises as the <a class="existingWikiWord" href="/nlab/show/localization+of+an+%28%E2%88%9E%2C1%29-category">localization</a> of an <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+of+%28%E2%88%9E%2C1%29-presheaves">(∞,1)-category of (∞,1)-presheaves</a>.</p>

<div class="num_theorem">
<h6 id="theorem_2">Theorem</h6>

<p><strong>(<a class="existingWikiWord" href="/nlab/show/Dugger%27s+theorem">Dugger's theorem</a>)</strong></p>

<p>Every combinatorial model category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalent</a> to a left <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>S</mi></msub><mi>SPSh</mi><mo stretchy="false">(</mo><mi>K</mi><msub><mo stretchy="false">)</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">L_S SPSh(K)_{proj}</annotation></semantics></math> of the global projective <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">model structure on simplicial presheaves</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SPSh</mi><mo stretchy="false">(</mo><mi>K</mi><msub><mo stretchy="false">)</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">SPSh(K)_{proj}</annotation></semantics></math> on a <a class="existingWikiWord" href="/nlab/show/small+category">small category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>S</mi></msub><mi>SPSh</mi><mo stretchy="false">(</mo><mi>K</mi><msub><mo stretchy="false">)</mo> <mi>proj</mi></msub><mover><mo>→</mo><mrow><msub><mo>≃</mo> <mi>Quillen</mi></msub></mrow></mover><mi>C</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  L_S SPSh(K)_{proj} \stackrel{\simeq_{Quillen}}{\to}
  C
  \,.

</annotation></semantics></math></div></div>

<p>This is (<a href="#Dugger01">Dugger 01, theorem 1.1</a>) building on results in (<a href="#DuggerUniversalHomotopy">DuggerUniversalHomotopy</a>).</p>

<div class="proof">
<h6 id="proof_3">Proof</h6>

<p>The proof proceeds (the way Dugger presents it, at least) in roughly three steps:</p>

<ol>
<li>
<p>Use that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">[C^{op}, sSet_{Quillen}]_{proj}</annotation></semantics></math> is in some precise sense the <em>homotopy-</em> <a class="existingWikiWord" href="/nlab/show/free+cocompletion">free cocompletion</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. This means that every functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>γ</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\gamma : C \to B</annotation></semantics></math> from a plain category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> to a model category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> factors in an essentially unique way through the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>:</mo><mi>C</mi><mo>→</mo><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j : C \to [C^{op},sSet]</annotation></semantics></math> by a <a class="existingWikiWord" href="/nlab/show/Quillen+adjunction">Quillen adjunction</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mover><mi>γ</mi><mo stretchy="false">^</mo></mover><mo>⊣</mo><mi>R</mi><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi><mover><munder><mo>→</mo><mi>R</mi></munder><mover><mo>←</mo><mover><mi>γ</mi><mo stretchy="false">^</mo></mover></mover></mover><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  (\hat \gamma \dashv R) : 
  B
  \stackrel{\overset{\hat \gamma}{\leftarrow}}
   {\underset{R}{\to}}
  [C^{op}, sSet_{Quillen}]_{proj}  
  \,.

</annotation></semantics></math></div>
<p>The detailed definitions and detailed proof of this are discussed at <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+of+%28%E2%88%9E%2C1%29-presheaves">(∞,1)-category of (∞,1)-presheaves</a>.</p>
</li>

<li>
<p>For a given combinatorial model category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, choose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>:</mo><mo>=</mo><msubsup><mi>B</mi> <mi>λ</mi> <mi>cof</mi></msubsup></mrow><annotation encoding="application/x-tex">C := B_\lambda^{cof}</annotation></semantics></math> the full <a class="existingWikiWord" href="/nlab/show/subcategory">subcategory</a> on a <a class="existingWikiWord" href="/nlab/show/small+set">small set</a> (guaranteed to exist since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/locally+presentable+category">locally presentable</a>) of cofibrant <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/compact+object">compact object</a>s, for some <a class="existingWikiWord" href="/nlab/show/regular+cardinal">regular cardinal</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>, and show that the induced Quillen adjunction</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>B</mi><mover><munder><mo>↪</mo><mi>R</mi></munder><mover><mo>←</mo><mover><mi>i</mi><mo stretchy="false">^</mo></mover></mover></mover><mo stretchy="false">[</mo><mo stretchy="false">(</mo><msubsup><mi>B</mi> <mi>λ</mi> <mi>cof</mi></msubsup><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">
  B \stackrel{\overset{\hat i}{\leftarrow}}{\underset{R}{\hookrightarrow}}
  [(B_\lambda^{cof})^{op}, sSet]_{proj} 

</annotation></semantics></math></div>
<p>induced by the above statement from the inclusion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><msubsup><mi>B</mi> <mi>λ</mi> <mi>cof</mi></msubsup><mo>↪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i : B_\lambda^{cof} \hookrightarrow B</annotation></semantics></math> exhibits <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> as a homotopy-<a class="existingWikiWord" href="/nlab/show/reflective+subcategory">reflective subcategory</a> in that the <a class="existingWikiWord" href="/nlab/show/derived+functor">derived</a> counit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>i</mi><mo stretchy="false">^</mo></mover><mo>∘</mo><mi>Q</mi><mo>∘</mo><mi>R</mi><mover><mo>→</mo><mo>≃</mo></mover><mi>Id</mi></mrow><annotation encoding="application/x-tex"> \hat i \circ Q \circ R \stackrel{\simeq}{\to} Id</annotation></semantics></math> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math> some cofibrant replacement functor) is a <a class="existingWikiWord" href="/nlab/show/natural+transformation">natural</a> weak equivalence on fibrant objects (recall from <a class="existingWikiWord" href="/nlab/show/adjoint+functor">adjoint functor</a> the characterization of adjoints to full and faithful functors).</p>
</li>

<li>
<p>Define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> to be the set of morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><msubsup><mi>C</mi> <mi>λ</mi> <mi>cof</mi></msubsup><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[(C_\lambda^{cof})^{op}, sSet]</annotation></semantics></math> that the left <a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>i</mi><mo stretchy="false">^</mo></mover><mo>∘</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\hat i \circ Q</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>i</mi><mo stretchy="false">^</mo></mover></mrow><annotation encoding="application/x-tex">\hat i</annotation></semantics></math> (here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math> is some cofibrant replacement functor) sends to weak equivalences in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. Then form the left <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>S</mi></msub><mo stretchy="false">[</mo><mo stretchy="false">(</mo><msubsup><mi>C</mi> <mi>λ</mi> <mi>cof</mi></msubsup><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">L_S [(C_\lambda^{cof})^{op},sSet]_{proj}</annotation></semantics></math> with respect to this set of morphisms and prove that this is <a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalent</a> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.</p>
</li>
</ol>

<p>Carrying this program through requires the following intermediate results.</p>

<p>First recall from the discussion at <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+of+%28%E2%88%9E%2C1%29-presheaves">(∞,1)-category of (∞,1)-presheaves</a> that to produce the Quilen adjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mover><mi>i</mi><mo stretchy="false">^</mo></mover><mo>⊣</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\hat i \dashv R)</annotation></semantics></math> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>, we are to choose a <a class="existingWikiWord" href="/nlab/show/cofibrant+resolution">cofibrant resolution</a> functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>I</mi><mo>:</mo><mi>C</mi><mo>→</mo><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><mi>B</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
  I : C \to [\Delta,B]

</annotation></semantics></math></div>
<p>of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>C</mi><mo>=</mo><msubsup><mi>B</mi> <mi>λ</mi> <mi>cof</mi></msubsup><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i : C= B_\lambda^{cof} \to B</annotation></semantics></math>.</p>

<p>The <a class="existingWikiWord" href="/nlab/show/adjunct">adjunct</a> of this is a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>I</mi><mo stretchy="false">˜</mo></mover><mo>:</mo><mi>C</mi><mo>×</mo><mi>Δ</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\tilde I : C \times \Delta \to B</annotation></semantics></math>. For each object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b \in B</annotation></semantics></math> write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mi>Δ</mi><mo stretchy="false">↓</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C \times \Delta \downarrow b)</annotation></semantics></math> for the <a class="existingWikiWord" href="/nlab/show/slice+category">slice category</a> induced by this functor.</p>

<p><strong>Lemma</strong> (Dugger, prop. 4.2)</p>

<p>For every fibrant object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b \in B</annotation></semantics></math> we have that the <a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mi>Δ</mi><mo stretchy="false">↓</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hocolim (C \times \Delta \downarrow b) \to B)</annotation></semantics></math> is weakly equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>i</mi><mo stretchy="false">^</mo></mover><mo>∘</mo><mi>Q</mi><mo>∘</mo><mi>R</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat i \circ Q\circ R (b)</annotation></semantics></math>.</p>

<p><strong>Corollary</strong> (Dugger, cor. 4.4) The induced Quillen adjunction</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>B</mi><mover><mo>→</mo><mo>←</mo></mover><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
  B \stackrel{\leftarrow}{\to}
  [C^{op}, sSet]

</annotation></semantics></math></div>
<p>is a homotopy-reflective embedding precisely if the canonical morphisms</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mi>Δ</mi><mo stretchy="false">↓</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">
  hocolim (C \times \Delta \downarrow b) \to b

</annotation></semantics></math></div>
<p>are weak equivalences for every fibrant object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b \in B</annotation></semantics></math>.</p>

<p>…</p>
</div>

<p>Notice that the theorem just mentions plain combinatorial model categories, not <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model categories</a>. But of course by basic facts of <a class="existingWikiWord" href="/nlab/show/enriched+category+theory">enriched category theory</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Funct</mi><mo stretchy="false">(</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>SSet</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Funct(C^{op}, SSet)</annotation></semantics></math> is an <a class="existingWikiWord" href="/nlab/show/SSet">SSet</a>-<a class="existingWikiWord" href="/nlab/show/enriched+category">enriched category</a> and its projective <a class="existingWikiWord" href="/nlab/show/global+model+structure+on+functors">global model structure on functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Func</mi><mo stretchy="false">(</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>SSet</mi><msub><mo stretchy="false">)</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">Func(C^{op}, SSet)_{proj}</annotation></semantics></math> is compatibly a <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a>, as are all its <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localizations</a>. (See <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">model structure on simplicial presheaves</a> for more details.) Therefore an immediate but very useful corollary of the above statement is</p>

<div class="num_corollary">
<h6 id="corollary">Corollary</h6>

<p>Every combinatorial model category is <a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalent</a> to one which is</p>

<ul>
<li>
<p>a <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a></p>
</li>

<li>
<p>a left <a class="existingWikiWord" href="/nlab/show/proper+model+category">proper model category</a>.</p>
</li>
</ul>
</div>

<h3 id="tractable_combinatorial_model_categories">Tractable combinatorial model categories</h3>

<p>A combinatorial model category is a <a class="existingWikiWord" href="/nlab/show/tractable+model+category">tractable model category</a> precisely if the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> of generating cofibrations can be chosen such that all elements have a cofibrant object as domain.</p>

<p>A <a class="existingWikiWord" href="/nlab/show/proper+model+category">left proper</a> combinatorial model category precisely if the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math> of generating trivial cofibrations can be chosen with cofibrant domain.</p>

<p>This are corollaries 2.7 and 2..8 in <a href="http://www.math.harvard.edu/~clarkbar/complete.pdf">Bar</a>.</p>

<h2 id="properties">Properties</h2>

<h3 id="hocolims">Homotopy colimits</h3>

<div class="num_prop" id="CharacterizationOfFilteredHomotopyColimits">
<h6 id="proposition_3">Proposition</h6>

<p>In a combinatorial model category, for every sufficiently large regular <a class="existingWikiWord" href="/nlab/show/cardinal+number">cardinal</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math> the following holds:</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/filtered+colimits">filtered colimits</a> preserve weak equivalences;</p>
</li>

<li>
<p>hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/filtered+colimits">filtered colimits</a> are already <a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a>s.</p>
</li>
</ul>
</div>

<p>See also at <em><a class="existingWikiWord" href="/nlab/show/filtered+homotopy+colimit">filtered homotopy colimit</a></em>.</p>

<div class="proof">
<h6 id="proof_4">Proof</h6>

<p>This appears as proposition 7.3 in <a href="http://arxiv.org/abs/math/0007068">Dug00</a>, reproduced for instance as prop. 2.5 in <a href="http://www.math.harvard.edu/~clarkbar/complete.pdf">Bar</a>.</p>

<p>The point is to choose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math> such that all domains and codomains of the generating cofibrations are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/compact+object">compact object</a>. This is possible since by assumption that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/locally+presentable+category">locally presentable category</a> all its objects are <a class="existingWikiWord" href="/nlab/show/small+object">small object</a>s, hence each a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/compact+object">compact object</a> for some cardinal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>. Take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math> to be the maximum of these.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>,</mo><mi>G</mi><mo>:</mo><mi>J</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F, G : J \to C</annotation></semantics></math> be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-filtered diagrams in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \to G</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a> that is degreewise a weak equivalence. Using the functorial factorization provided by the <a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a> this may be factored as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>H</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \to H \to G</annotation></semantics></math> where the first transformation is objectwise an acyclic cofibration and the second objectwise an acyclic fibration, and by functoriality of the factorization this sits over a factorization</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mi>lim</mi> <mo>→</mo></munder><mi>F</mi><mover><mo>↪</mo><mo>≃</mo></mover><munder><mi>lim</mi> <mo>→</mo></munder><mi>H</mi><mover><mo>→</mo><mrow></mrow></mover><munder><mi>lim</mi> <mo>→</mo></munder><mi>G</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \lim_\to F \stackrel{\simeq}{\hookrightarrow} \lim_\to H \stackrel{}{\to}\lim_\to G
  \,.

</annotation></semantics></math></div>
<p>It remains to show that the second morphism is a weak equivalence. But by our factorization and by <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">2-out-of-3</a> applied to our componentwise weak equivalences, we have that all its components <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>→</mo><mi>G</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(j) \to G(j)</annotation></semantics></math> are acyclic fibrations.</p>

<p>At <a class="existingWikiWord" href="/nlab/show/small+object">small object</a> it is described in detail how <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-smallness of an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> implies that morphisms from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> into a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-filtered colimit lift to some component of the colimit</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>⋯</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>H</mi><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>H</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>H</mi><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>⋯</mi></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd></mtd> <mtd><msup><mrow></mrow> <mpadded width="0" lspace="-100%width"><mrow><mo>∃</mo><mover><mi>f</mi><mo stretchy="false">^</mo></mover></mrow></mpadded></msup><mo>↗</mo></mtd> <mtd><mo stretchy="false">↓</mo></mtd> <mtd><mo>↙</mo></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mi>X</mi></mtd> <mtd><mover><mo>→</mo><mrow><mo>∀</mo><mi>f</mi></mrow></mover></mtd> <mtd><munder><mi>lim</mi> <mo>→</mo></munder><mi>H</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
    \cdots&amp;\to&amp;H(j-1) &amp;\to&amp; H(j) &amp;\to&amp; H(j+1) &amp;\to&amp; \cdots
    \\
    &amp;&amp;&amp;{}^{\mathllap{\exists \hat f}}\nearrow&amp;\downarrow &amp; \swarrow
    \\
    &amp;&amp;X&amp; \stackrel{\forall f}{\to} &amp;\lim_\to H
  }
  \,.

</annotation></semantics></math></div>
<p>So given a diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>X</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><munder><mi>lim</mi> <mo>→</mo></munder><mi>H</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>I</mi></mrow></mpadded></msup></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Y</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><munder><mi>lim</mi> <mo>→</mo></munder><mi>G</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    X &amp;\to&amp; \lim_\to H
    \\
    \downarrow^{\mathrlap{\in I}} &amp;&amp; \downarrow
    \\
    Y &amp;\to&amp; \lim_\to G 
  }

</annotation></semantics></math></div>
<p>we are guaranteed, by the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/small+object">smallness</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> that we established above, a lift</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>X</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>H</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><munder><mi>lim</mi> <mo>→</mo></munder><mi>H</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>I</mi></mrow></mpadded></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mrow><mo>∈</mo><mpadded width="0"><mrow><mo>∈</mo><mi>rlp</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow></mpadded></mrow></msup></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Y</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>G</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><munder><mi>lim</mi> <mo>→</mo></munder><mi>G</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    X &amp;\to&amp; H(j) &amp;\to&amp; \lim_\to H
    \\
    \downarrow^{\mathrlap{\in I}} &amp;&amp; \downarrow^{\in \mathrlap{\in rlp(I)}}
    &amp;&amp;
    \downarrow
    \\
    Y &amp;\to&amp; G(j) &amp;\to&amp; \lim_\to G
  }

</annotation></semantics></math></div>
<p>into some component at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>∈</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">j \in J</annotation></semantics></math> and hence a lift</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>X</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>H</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><munder><mi>lim</mi> <mo>→</mo></munder><mi>H</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>I</mi></mrow></mpadded></msup></mtd> <mtd><mo>↗</mo></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mrow><mo>∈</mo><mpadded width="0"><mrow><mo>∈</mo><mi>rlp</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo></mrow></mpadded></mrow></msup></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Y</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>G</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><munder><mi>lim</mi> <mo>→</mo></munder><mi>G</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
    X &amp;\to&amp; H(j) &amp;\to&amp; \lim_\to H
    \\
    \downarrow^{\mathrlap{\in I}} &amp;
    \nearrow
    &amp; \downarrow^{\in \mathrlap{\in rlp(I)}}
    &amp;&amp;
    \downarrow
    \\
    Y &amp;\to&amp; G(j) &amp;\to&amp; \lim_\to G
  }
  \,.

</annotation></semantics></math></div>
<p>Thereby <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>lim</mi> <mo>→</mo></msub><mi>H</mi><mo>→</mo><msub><mi>lim</mi> <mo>→</mo></msub><mi>G</mi></mrow><annotation encoding="application/x-tex">\lim_\to H \to \lim_\to G</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>rlp</mi><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo>⊂</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">rlp(I) \subset W</annotation></semantics></math>.</p>
</div>

<h3 id="bousfield_localization">Bousfield localization</h3>

<p>Combinatorial model categories, like <a class="existingWikiWord" href="/nlab/show/cellular+model+category">cellular model categories</a> have a good theory of <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localizations</a>, at least if in addition they are left <a class="existingWikiWord" href="/nlab/show/proper+model+category">proper</a>. See <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization of model categories</a> for more on this.</p>

<h2 id="examples">Examples</h2>

<h3 id="basic_examples">Basic examples</h3>

<p>Basic examples are</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sSet">sSet</a> with its standard <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+sets">model structure on simplicial sets</a>;</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/sSet">sSet</a> with the Joyal-<a class="existingWikiWord" href="/nlab/show/model+structure+for+quasi-categories">model structure for quasi-categories</a>;</p>

<p>notice that this is not directly a <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a>, but is enriched over itself. A Quillen equivalent combinatorial simplicial model category is</p>

<ul>
<li>the <a class="existingWikiWord" href="/nlab/show/model+structure+for+Cartesian+fibrations">model structure for Cartesian fibrations</a> over the point.</li>
</ul>
</li>

<li>
<p>the category of <a class="existingWikiWord" href="/nlab/show/dendroidal+set">dendroidal set</a>s with its <a class="existingWikiWord" href="/nlab/show/model+structure+on+dendroidal+sets">model structure on dendroidal sets</a>.</p>
</li>

<li>
<p>the categories of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,r)</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/Theta+space">Theta space</a>s.</p>
</li>
</ul>

<h3 id="cisinski_model_structures">Cisinski model structures</h3>

<p>More generally, every <em><a class="existingWikiWord" href="/nlab/show/Cisinski+model+structure">Cisinski model structure</a></em> is combinatorial.</p>

<h3 id="derived_examples">Derived examples</h3>

<p>Further classes of examples are obtained from such basic examples by localizing presheaf categories with values in these:</p>

<ul>
<li>
<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> a combinatorial model category and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/small+category">small category</a> the injective and projective <a class="existingWikiWord" href="/nlab/show/model+structure+on+functors">model structure on functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Funct</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>V</mi><msub><mo stretchy="false">)</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">Funct(C,V)_{inj}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Funct</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>V</mi><msub><mo stretchy="false">)</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">Funct(C,V)_{proj}</annotation></semantics></math> are again combinatorial model categories. See there for details.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> is a left or right <a class="existingWikiWord" href="/nlab/show/proper+model+category">proper model category</a> then so is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Funct</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>V</mi><msub><mo stretchy="false">)</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">Funct(C,V)_{inj}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Funct</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>V</mi><msub><mo stretchy="false">)</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">Funct(C,V)_{proj}</annotation></semantics></math> and hence the standard results of the theory of <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization of model categories</a> applies, which ensures that all left Bousfield localizations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>L</mi> <mi>S</mi></msub><mi>Funct</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_S Funct(C,V)</annotation></semantics></math> are again combinatorial model categories. Such local <a class="existingWikiWord" href="/nlab/show/model+structure+on+homotopical+presheaves">local model structures on homotopical presheaves</a> includes notably the local <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">model structure on simplicial presheaves</a>.</p>
</li>
</ul>

<h3 id="from_cofibrantly_generated_model_categories">From cofibrantly generated model categories</h3>

<p>Not every <a class="existingWikiWord" href="/nlab/show/cofibrantly+generated+model+category">cofibrantly generated model category</a> is also a combinatorial model category.</p>

<p>For instance:</p>

<div class="num_example">
<h6 id="counterexample">(Counter)example</h6>

<p><a class="existingWikiWord" href="/nlab/show/Top">Top</a> with the standard <a class="existingWikiWord" href="/nlab/show/model+structure+on+topological+spaces">model structure on topological spaces</a> is cofibrantly generated, but not combinatorial. But it is <a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalent</a> to a combinatorial model structure, namely to the standard <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+sets">model structure on simplicial sets</a> (see <a class="existingWikiWord" href="/nlab/show/homotopy+hypothesis">homotopy hypothesis</a>).</p>
</div>

<p>One might therefore ask which cofibrantly generated model categories are Quillen equivalent to combinatorial ones. It turns out that if one assumes the large-cardinal hypothesis <a class="existingWikiWord" href="/nlab/show/Vopenka%27s+principle">Vop?nka's principle</a>, then <em>every</em> cofibrantly generated model category is Quillen equivalent to a combinatorial one. In fact, if we slightly generalize the notion of “cofibrantly generated,” this statement is equivalent to Vopěnka’s principle. For a discussion of this see</p>

<ul>
<li>J. Rosicky, <em>Are all cofibrantly generated model categories combinatorial?</em> (<a href="http://www.math.muni.cz/~rosicky/papers/cof1.ps">ps</a>)</li>
</ul>

<p>Although Vopěnka’s principle cannot be proven from <a class="existingWikiWord" href="/nlab/show/ZFC">ZFC</a>, and in fact is fairly strong as <a class="existingWikiWord" href="/nlab/show/large+cardinal">large cardinal</a> hypotheses go, this means that looking for cofibrantly generated model categories that are not Quillen equivalent to combinatorial ones is probably a waste of time. Certainly, all known cofibrantly generated model categories <em>are</em> Quillen equivalent to simplicial ones, usually in a fairly natural way.</p>

<h3 id="simplicial_combinatorial_model_categories">Simplicial combinatorial model categories</h3>

<p>Those combinatorial model categories that are at the same time <a class="existingWikiWord" href="/nlab/show/simplicial+model+categories">simplicial model categories</a> are precisely those that present <a class="existingWikiWord" href="/nlab/show/presentable+%28%E2%88%9E%2C1%29-categories">presentable (∞,1)-categories</a>. See <a class="existingWikiWord" href="/nlab/show/combinatorial+simplicial+model+category">combinatorial simplicial model category</a>.</p>

<h2 id="related_concepts">Related concepts</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Ho%28CombModCat%29">Ho(CombModCat)</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Cisinski+model+structure">Cisinski model structure</a></p>
</li>
</ul>
<p><strong>Locally presentable categories:</strong> <a class="existingWikiWord" href="/nlab/show/cocomplete+category">Cocomplete</a> possibly-<a class="existingWikiWord" href="/nlab/show/large+categories">large categories</a> generated under <a class="existingWikiWord" href="/nlab/show/filtered+colimits">filtered colimits</a> by <a class="existingWikiWord" href="/nlab/show/small+object">small</a> <a class="existingWikiWord" href="/nlab/show/generators">generators</a> under <a class="existingWikiWord" href="/nlab/show/small+colimit">small</a> <a class="existingWikiWord" href="/nlab/show/relations">relations</a>. Equivalently, <a class="existingWikiWord" href="/nlab/show/accessible+functor">accessible</a> <a class="existingWikiWord" href="/nlab/show/reflective+localizations">reflective localizations</a> of <a class="existingWikiWord" href="/nlab/show/free+cocompletions">free cocompletions</a>. Accessible categories omit the cocompleteness requirement; toposes add the requirement of a <a class="existingWikiWord" href="/nlab/show/left+exact+functor">left exact</a> localization.</p><table><thead><tr><th><math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline"><semantics><mrow><mphantom><mi>A</mi></mphantom></mrow><annotation encoding="application/x-tex">\phantom{A}</annotation></semantics></math><a class="existingWikiWord" href="/nlab/show/%28n%2Cr%29-categories">(n,r)-categories</a><math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline"><semantics><mrow><mphantom><mi>A</mi></mphantom></mrow><annotation encoding="application/x-tex">\phantom{A}</annotation></semantics></math></th><th><math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline"><semantics><mrow><mphantom><mi>A</mi></mphantom></mrow><annotation encoding="application/x-tex">\phantom{A}</annotation></semantics></math><a class="existingWikiWord" href="/nlab/show/toposes">toposes</a><math xmlns="http://www.w3.org/1998/Math/MathML" class="maruku-mathml" display="inline"><semantics><mrow><mphantom><mi>A</mi></mphantom></mrow><annotation encoding="application/x-tex">\phantom{A}</annotation></semantics></math></th><th>locally presentable</th><th>loc finitely pres</th><th>localization theorem</th><th><a class="existingWikiWord" href="/nlab/show/free+cocompletion">free cocompletion</a></th><th>accessible</th></tr></thead><tbody><tr><td style="text-align: left;"><strong><a class="existingWikiWord" href="/nlab/show/%280%2C1%29-category+theory">(0,1)-category theory</a></strong></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/locales">locales</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/suplattice">suplattice</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/algebraic+lattices">algebraic lattices</a></td><td style="text-align: left;"><a href="algebraic+lattice#RelationToLocallyFinitelyPresentableCategories">Porst’s theorem</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/powerset">powerset</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/poset">poset</a></td></tr>
<tr><td style="text-align: left;"><strong><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></strong></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Grothendieck+topos">toposes</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/locally+presentable+categories">locally presentable categories</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/locally+finitely+presentable+categories">locally finitely presentable categories</a></td><td style="text-align: left;"><a href="locally+presentable+category#AsLocalizationsOfPresheafCategories">Adámek-Rosický‘s theorem</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/presheaf+category">presheaf category</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/accessible+categories">accessible categories</a></td></tr>
<tr><td style="text-align: left;"><strong><a class="existingWikiWord" href="/nlab/show/model+category">model category theory</a></strong></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/model+toposes">model toposes</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/combinatorial+model+categories">combinatorial model categories</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/Dugger%27s+theorem">Dugger's theorem</a></td><td style="text-align: left;">global <a class="existingWikiWord" href="/nlab/show/model+structures+on+simplicial+presheaves">model structures on simplicial presheaves</a></td><td style="text-align: left;">n/a</td></tr>
<tr><td style="text-align: left;"><strong><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+theory">(∞,1)-category theory</a></strong></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-toposes">(∞,1)-toposes</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/locally+presentable+%28%E2%88%9E%2C1%29-categories">locally presentable (∞,1)-categories</a></td><td style="text-align: left;"></td><td style="text-align: left;"><a href="locally+presentable+infinity-category#Definition">Simpson’s theorem</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-presheaf+%28%E2%88%9E%2C1%29-categories">(∞,1)-presheaf (∞,1)-categories</a></td><td style="text-align: left;"><a class="existingWikiWord" href="/nlab/show/accessible+%28%E2%88%9E%2C1%29-categories">accessible (∞,1)-categories</a></td></tr>
</tbody></table>
<h2 id="references">References</h2>

<p>Much of the theory of combinatorial model categories goes back to <a class="existingWikiWord" href="/nlab/show/Jeff+Smith">Jeff Smith</a>. Apparently Smith will eventually present a book on this subject. To date, however, his ideas and results appear reproduced in articles of other authors.</p>

<p>After <a class="existingWikiWord" href="/nlab/show/Jeff+Smith">Jeff Smith</a> presented his recognition theorem at a conference in Barcelona, its first appearance in a publication is apparently lemma 1.8 in</p>

<ul>
<li id="Beke"><a class="existingWikiWord" href="/nlab/show/Tibor+Beke">Tibor Beke</a>, <em>Sheafifiable homotopy model categories</em> , Math. Proc. Cambr. Phil. Soc. 129 (2000), 447–475;<a href="http://arxiv.org/abs/math/0102087">arXiv:math/0102087</a></li>
</ul>

<p>The very definition of combinatorial model categories appears also for instance as definition A.2.6.1 in</p>

<ul>
<li id="Lurie"><a class="existingWikiWord" href="/nlab/show/Jacob+Lurie">Jacob Lurie</a>, <em><a class="existingWikiWord" href="/nlab/show/Higher+Topos+Theory">Higher Topos Theory</a></em>;</li>
</ul>

<p>or definition 1.3 in</p>

<ul>
<li id="Barwick"><a class="existingWikiWord" href="/nlab/show/Clark+Barwick">Clark Barwick</a>, <em>On (enriched) left Bousfield localization of model categories</em> (<a href="http://arxiv.org/abs/0708.2067">arXiv:0708.2067</a>)</li>
</ul>

<p>Smith’s theorem appears as proposition (<a href="#Lurie">Lurie, A.2.6.8</a>) and as (<a href="#Barwick">Barwick, prop. 1.7</a>).</p>

<p>Dugger’s theorem is due to</p>

<ul>
<li id="Dugger01"><a class="existingWikiWord" href="/nlab/show/Daniel+Dugger">Daniel Dugger</a>, <em><a class="existingWikiWord" href="/nlab/show/Combinatorial+model+categories+have+presentations">Combinatorial model categories have presentations</a></em> Adv. Math. 164 (2001), no. 1, 177-201 (<a href="http://arxiv.org/abs/math/0007068">arXiv:math/0007068</a>)</li>
</ul>

<p>based on results in</p>

<ul>
<li id="DuggerUniversalHomotopy"><a class="existingWikiWord" href="/nlab/show/Dan+Dugger">Dan Dugger</a>, <em><a class="existingWikiWord" href="/nlab/show/Universal+homotopy+theories">Universal homotopy theories</a></em></li>
</ul>

<p>The <a class="existingWikiWord" href="/nlab/show/localization+of+a+2-category">homotopy 2-category</a> of combinatorial model categories at the <a class="existingWikiWord" href="/nlab/show/Quillen+equivalences">Quillen equivalences</a> is discussed in</p>

<ul>
<li>Olivier Renaudin, <em>Theories homotopiques de Quillen combinatoires et derivateurs de Grothendieck</em> (<a href="https://arxiv.org/abs/math/0603339">arXiv:0603339</a>)</li>
</ul>

<p>See also</p>

<ul>
<li id="Low14"><a class="existingWikiWord" href="/nlab/show/Zhen+Lin+Low">Zhen Lin Low</a>, <em>The heart of a combinatorial model category</em>, Theory and Applications of Categories, Vol. 31, 2016, No. 2, pp 31-62 (<a href="http://arxiv.org/abs/1402.6659">arXiv:1402.6659</a>)</li>
</ul>
</body></html>

</div>

<div class="revisedby">
  <p>
  Last revised on November  5, 2018 at 13:59:27.
  See the <a href="https://ncatlab.org/nlab/history/combinatorial model category" style="color: #005c19">history</a> of this page for a list of all contributions to it.
  </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/combinatorial+model+category" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a> | <a href="/nlab/revision/combinatorial+model+category/58" accesskey="B" class="navlink" id="to_previous_revision" rel="nofollow">Back in time</a> <span class='revisions'>(58 revisions)</span> | <a href="/nlab/show/diff/combinatorial+model+category" accesskey="C" class="navlink" id="see_changes" rel="nofollow">See changes</a> | <a href="/nlab/history/combinatorial+model+category" accesskey="S" class="navlink" id="history" rel="nofollow">History</a>
  | <a href="https://ncatlab.org/nlab/show/combinatorial model category/cite" style="color: black">Cite</a>
  <span class="views">
    | Views:
    <a href="/nlab/print/combinatorial+model+category" accesskey="p" id="view_print" rel="nofollow">Print</a>
    |
    <a href="/nlab/tex/combinatorial+model+category" id="view_tex" rel="nofollow">TeX</a>
    |
    <a href="/nlab/source/combinatorial+model+category" id="view_source" rel="nofollow">Source</a>
  </span>

  


</div>


    <div id="footer">
    <div>This site is running on <a href="http://golem.ph.utexas.edu/instiki/show/HomePage">Instiki 0.19.7(MML+)</a></div>
    <div>Powered by <a href="http://rubyonrails.com/">Ruby on Rails</a>  2.3.18</div>
    </div>

</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
