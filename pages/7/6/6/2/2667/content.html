
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      Schur functor in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      Schur functor
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/13040/#Item_2" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="representation_theory">Representation theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/representation+theory">representation theory</a></strong></p>

<p><strong><a class="existingWikiWord" href="/nlab/show/geometric+representation+theory">geometric representation theory</a></strong></p>

<h2 id="ingredients">Ingredients</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/linear+algebra">linear algebra</a>, <a class="existingWikiWord" href="/nlab/show/algebra">algebra</a>, <a class="existingWikiWord" href="/nlab/show/higher+algebra">higher algebra</a></li>
</ul>

<h2 id="definitions">Definitions</h2>

<p><a class="existingWikiWord" href="/nlab/show/representation">representation</a>, <a class="existingWikiWord" href="/nlab/show/2-representation">2-representation</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-representation">∞-representation</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/group">group</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-group">∞-group</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/group+algebra">group algebra</a>, <a class="existingWikiWord" href="/nlab/show/algebraic+group">algebraic group</a>, <a class="existingWikiWord" href="/nlab/show/Lie+algebra">Lie algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/vector+space">vector space</a>, <a class="existingWikiWord" href="/nlab/show/n-vector+space">n-vector space</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/affine+space">affine space</a>, <a class="existingWikiWord" href="/nlab/show/symplectic+vector+space">symplectic vector space</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/action">action</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-action">∞-action</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/module">module</a>, <a class="existingWikiWord" href="/nlab/show/equivariant+object">equivariant object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/bimodule">bimodule</a>, <a class="existingWikiWord" href="/nlab/show/Morita+equivalence">Morita equivalence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/induced+representation">induced representation</a>, <a class="existingWikiWord" href="/nlab/show/Frobenius+reciprocity">Frobenius reciprocity</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Hilbert+space">Hilbert space</a>, <a class="existingWikiWord" href="/nlab/show/Banach+space">Banach space</a>, <a class="existingWikiWord" href="/nlab/show/Fourier+transform">Fourier transform</a>, <a class="existingWikiWord" href="/nlab/show/functional+analysis">functional analysis</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/orbit">orbit</a>, <a class="existingWikiWord" href="/nlab/show/coadjoint+orbit">coadjoint orbit</a>, <a class="existingWikiWord" href="/nlab/show/Killing+form">Killing form</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/unitary+representation">unitary representation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+quantization">geometric quantization</a>, <a class="existingWikiWord" href="/nlab/show/coherent+state">coherent state</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/socle">socle</a>, <a class="existingWikiWord" href="/nlab/show/quiver">quiver</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/module+algebra">module algebra</a>, <a class="existingWikiWord" href="/nlab/show/comodule+algebra">comodule algebra</a>, <a class="existingWikiWord" href="/nlab/show/Hopf+action">Hopf action</a>, <a class="existingWikiWord" href="/nlab/show/measuring">measuring</a></p>
</li>
</ul>

<h2 id="geometric_representation_theory">Geometric representation theory</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/D-module">D-module</a>, <a class="existingWikiWord" href="/nlab/show/perverse+sheaf">perverse sheaf</a>,</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Grothendieck+group">Grothendieck group</a>, <a class="existingWikiWord" href="/nlab/show/lambda-ring">lambda-ring</a>, <a class="existingWikiWord" href="/nlab/show/symmetric+function">symmetric function</a>, <a class="existingWikiWord" href="/nlab/show/formal+group">formal group</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/principal+bundle">principal bundle</a>, <a class="existingWikiWord" href="/nlab/show/torsor">torsor</a>, <a class="existingWikiWord" href="/nlab/show/vector+bundle">vector bundle</a>, <a class="existingWikiWord" href="/nlab/show/Atiyah+Lie+algebroid">Atiyah Lie algebroid</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+function+theory">geometric function theory</a>, <a class="existingWikiWord" href="/nlab/show/groupoidification">groupoidification</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Eilenberg-Moore+category">Eilenberg-Moore category</a>, <a class="existingWikiWord" href="/nlab/show/algebra+over+an+operad">algebra over an operad</a>, <a class="existingWikiWord" href="/nlab/show/actegory">actegory</a>, <a class="existingWikiWord" href="/nlab/show/crossed+module">crossed module</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/reconstruction+theorems">reconstruction theorems</a></p>
</li>
</ul>

<h2 id="theorems">Theorems</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Borel-Weil-Bott+theorem">Borel-Weil-Bott theorem</a></p>
</li>

<li>
<p><span class="newWikiWord">Be?linson-Bernstein localization<a href="/nlab/new/Be%3Flinson-Bernstein+localization">?</a></span></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kazhdan-Lusztig+theory">Kazhdan-Lusztig theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/BBDG+decomposition+theorem">BBDG decomposition theorem</a></p>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/representation+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea_and_definition'>Idea and definition</a></li>
<li><a href='#the_category_of_schur_functors'>The category of Schur functors</a></li>
<li><a href='#schur_functors_on_more_general_categories'>Schur functors on more general categories</a></li>
<ul>
<li><a href='#change_of_base'>Change of base</a></li>
<li><a href='#the_action_of_young_symmetrizers'>The action of Young symmetrizers</a></li>
<li><a href='#constructing_schur_functors'>Constructing Schur functors</a></li>
<li><a href='#schur_functors_are_natural'>Schur functors are “natural”</a></li>
</ul>
<li><a href='#conceptual_description_of_schur_functors'>Conceptual description of Schur functors</a></li>
<li><a href='#representability'>Representability</a></li>
<ul>
<li><a href='#structure_of_the_representing_object'>Structure of the representing object</a></li>
</ul>
<li><a href='#composition_of_schur_functors'>Composition of Schur functors</a></li>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#references'>References</a></li>
<li><a href='#old_stuff'>Old Stuff</a></li>
<ul>
<li><a href='#modules_over_a_bimonoid'>Modules over a bimonoid</a></li>
</ul>
</ul>
</div>

<h2 id="idea_and_definition">Idea and definition</h2>

<p>Classically, a ‘Schur functor’ is a specific sort of <a class="existingWikiWord" href="/nlab/show/functor">functor</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">S: FinVect \to FinVect</annotation></semantics></math></div>
<p>where <a class="existingWikiWord" href="/nlab/show/FinVect">FinVect</a> is the category of <a class="existingWikiWord" href="/nlab/show/finite+dimensional+vector+spaces">finite dimensional vector spaces</a> over the <a class="existingWikiWord" href="/nlab/show/complex+numbers">complex numbers</a>. Namely, it is a functor where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(X)</annotation></semantics></math> is obtained by taking the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>th <a class="existingWikiWord" href="/nlab/show/tensor+power">tensor power</a> of the vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and then picking out a subspace that transforms in a certain way with respect to the <a class="existingWikiWord" href="/nlab/show/symmetric+group">symmetric group</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>. In fact, Schur functors can be defined on a large class of <a class="existingWikiWord" href="/nlab/show/categories">categories</a> resembling <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">FinVect</annotation></semantics></math>: for example, <a class="existingWikiWord" href="/nlab/show/categories+of+representations">categories of representations</a> of a <a class="existingWikiWord" href="/nlab/show/group">group</a>, or <a class="existingWikiWord" href="/nlab/show/vector+bundles">vector bundles</a>, or <a class="existingWikiWord" href="/nlab/show/coherent+sheaves">coherent sheaves</a>. After an elementary introduction to Schur functors, this article will give a conceptual approach based on the fact that these functors are precisely those that can be ‘<a class="existingWikiWord" href="/nlab/show/natural+transformation">naturally</a>’ — or more precisely, ‘<a class="existingWikiWord" href="/nlab/show/pseudonatural+transformation">pseudonaturally</a>’ defined on all <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric monoidal</a> <a class="existingWikiWord" href="/nlab/show/linear+category">linear</a> <a class="existingWikiWord" href="/nlab/show/Cauchy+complete+categories">Cauchy complete categories</a>.</p>

<p>The most famous examples of Schur functors are these:</p>

<ul>
<li>
<p>For each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \geq 0</annotation></semantics></math>, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/symmetric+power">symmetric power</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>↦</mo><msup><mi>S</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \mapsto S^n(X)</annotation></semantics></math> is a Schur functor.</p>
</li>

<li>
<p>For each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \geq 0</annotation></semantics></math>, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/alternating+power">alternating power</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>↦</mo><msup><mi>Λ</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \mapsto \Lambda^n(X)</annotation></semantics></math> is a Schur functor.</p>
</li>
</ul>

<p>More generally, complex <a class="existingWikiWord" href="/nlab/show/irreducible+representation">irreducible representation</a>s of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> correspond to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-box <a class="existingWikiWord" href="/nlab/show/Young+diagram">Young diagrams</a>, so Schur functors are usually described with the help of these. An <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-box Young diagram is simply a pictorial way of writing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> as a sum of natural numbers listed in decreasing order. For example, this 17-box Young diagram:</p>

<div id="Young" style="text-align:center"><svg xmlns="http://www.w3.org/2000/svg" xmlns:se="http://svg-edit.googlecode.com" xmlns:xlink="http://www.w3.org/1999/xlink" width="120" height="140" se:nonce="39384">
 <!-- Created with SVG-edit - http://svg-edit.googlecode.com/ -->
 <desc>Young diagram (5,4,4,2,1,1)</desc>
 <g>
  <title>Layer 1</title>
  <rect x="10" y="10" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_1"></rect>
  <rect x="30" y="10" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_2"></rect>
  <rect x="50" y="10" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_3"></rect>
  <rect x="70" y="10" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_4"></rect>
  <rect x="90" y="10" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_5"></rect>
  <rect x="10" y="30" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_6"></rect>
  <rect x="30" y="30" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_7"></rect>
  <rect x="50" y="30" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_8"></rect>
  <rect x="70" y="30" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_9"></rect>
  <rect x="10" y="50" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_10"></rect>
  <rect x="30" y="50" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_11"></rect>
  <rect x="50" y="50" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_12"></rect>
  <rect x="70" y="50" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_13"></rect>
  <rect x="10" y="70" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_14"></rect>
  <rect x="30" y="70" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_15"></rect>
  <rect x="10" y="90" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_16"></rect>
  <rect x="10" y="110" width="20" height="20" fill="#ffdddd" stroke="#000000" stroke-width="2" id="svg_39384_17"></rect>
 </g>
</svg></div>

<p>describes the partition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>17</mn></mrow><annotation encoding="application/x-tex">17</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>5</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">5 + 4 + 4 + 2 + 1 + 1</annotation></semantics></math>. However, it also can be used to construct an irreducible complex representation of the permutation group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mn>17</mn></msub></mrow><annotation encoding="application/x-tex">S_{17}</annotation></semantics></math>, and thus a Schur functor.</p>

<p>In general, here is the recipe for constructing the Schur functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">S_\lambda</annotation></semantics></math> associated to an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-box Young diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>. For now we only say what this functor does to objects (that is, <a class="existingWikiWord" href="/nlab/show/finite-dimensional+vector+spaces">finite-dimensional vector spaces</a>):</p>

<ul>
<li>
<p>Given an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-box Young diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> and a vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, we first form the <a class="existingWikiWord" href="/nlab/show/tensor+power">tensor power</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math>. We think of each factor in this tensor power as corresponding to a specific box of the Young diagram.</p>
</li>

<li>
<p>Then we pick out the subspace of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math> consisting of tensors that are <em>unchanged</em> by any permutation that interchanges two boxes in the same <em>row</em>.</p>
</li>

<li>
<p>Then we project this subspace onto the space of tensors that <em>change sign</em> under any permutation that interchanges two boxes in the same <em>column</em>. The result is called <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_\lambda(X)</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">S_\lambda</annotation></semantics></math> is the Schur functor corresponding to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</p>
</li>
</ul>

<p>It is easy to see from this description that:</p>

<ul>
<li>
<p>The tall skinny Young diagrams with one column and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> rows give the Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Λ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Lambda^n</annotation></semantics></math>.</p>
</li>

<li>
<p>The short fat Young diagrams with one row and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> columns give the Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>S</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">S^n</annotation></semantics></math>.</p>
</li>
</ul>

<p>We can also think of this relation between Young diagrams and Schur functors in a slightly more abstract way using the <a class="existingWikiWord" href="/nlab/show/group+algebra">group algebra</a> of the symmetric group, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}[S_n]</annotation></semantics></math>. Suppose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-box Young diagram. Then we can think of the operation ‘symmetrize with respect to permutations of the boxes in each row’ as an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>p</mi> <mi>λ</mi> <mi>S</mi></msubsup><mo>∈</mo><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p^S_\lambda \in \mathbb{C}[S_n]</annotation></semantics></math>. Similarly, we can think of the operation ‘antisymmetrize with respect to permutations of the boxes in each column’ as an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>p</mi> <mi>λ</mi> <mi>A</mi></msubsup><mo>∈</mo><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p^A_\lambda \in \mathbb{C}[S_n]</annotation></semantics></math>. By construction, each of these elements is <a class="existingWikiWord" href="/nlab/show/idempotent">idempotent</a>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msubsup><mi>p</mi> <mi>λ</mi> <mi>A</mi></msubsup><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>=</mo><msubsup><mi>p</mi> <mi>λ</mi> <mi>A</mi></msubsup><mspace width="thinmathspace"></mspace><mo>,</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mo stretchy="false">(</mo><msubsup><mi>p</mi> <mi>λ</mi> <mi>S</mi></msubsup><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>=</mo><msubsup><mi>p</mi> <mi>λ</mi> <mi>S</mi></msubsup></mrow><annotation encoding="application/x-tex"> (p^A_\lambda)^2 = p^A_\lambda \, , \; \; (p^S_\lambda)^2 = p^S_\lambda  </annotation></semantics></math></div>
<p>Now, it is easy to see that the product of commuting idempotents is idempotent. The elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>p</mi> <mi>λ</mi> <mi>S</mi></msubsup></mrow><annotation encoding="application/x-tex">p^S_\lambda</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msubsup><mi>p</mi> <mi>λ</mi> <mi>A</mi></msubsup></mrow><annotation encoding="application/x-tex">p^A_\lambda</annotation></semantics></math> do not commute, but amazingly, their product</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub><mo>=</mo><msubsup><mi>p</mi> <mi>λ</mi> <mi>A</mi></msubsup><msubsup><mi>p</mi> <mi>λ</mi> <mi>S</mi></msubsup></mrow><annotation encoding="application/x-tex"> p_\lambda = p^A_\lambda p^S_\lambda </annotation></semantics></math></div>
<p>is idempotent up to a scalar multiple!</p>

<p>This element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub><mo>∈</mo><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p_\lambda \in \mathbb{C}[S_n]</annotation></semantics></math> is called the <strong>Young symmetrizer</strong> corresponding to the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-box Young diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>. There is a functor, called a <strong>Schur functor</strong>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">  S_\lambda : FinVect \to FinVect </annotation></semantics></math></div>
<p>defined on any finite-dimensional vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> as follows:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>p</mi> <mi>λ</mi></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">  S_\lambda(X) = p_\lambda X^{\otimes n} </annotation></semantics></math></div>
<p>Here we are using the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>, and thus its group algebra, acts on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math>. Thus, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">p_\lambda</annotation></semantics></math> acts as an idempotent operator on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_\lambda(X)</annotation></semantics></math> as defined above is the range of this operator.</p>

<p>An even deeper approach to Schur functors is based on the relation between Young diagrams and representations of the symmetric groups. The subspace</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>λ</mi></msub><mo>=</mo><msub><mi>p</mi> <mi>λ</mi></msub><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊆</mo><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">   V_\lambda = p_\lambda \mathbb{C}[S_n] \subseteq \mathbb{C}[S_n] </annotation></semantics></math></div>
<p>has an obvious right action of the algebra <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}[S_n]</annotation></semantics></math>, and thus becomes a representation of the group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>. In fact, it is an irreducible representation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>, and every irreducible representation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> is isomorphic to one of this form. Even better, this recipe sets up a one-to-one correspondence between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-box Young diagrams and isomorphism classes of irreducible representations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>.</p>

<p>(Strictly speaking, to think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">p_\lambda</annotation></semantics></math> as an element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{C}[S_n]</annotation></semantics></math>, we must choose a way to label the boxes of the Young diagram with numbers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1, \dots, n</annotation></semantics></math>. Such an identification is called a <strong>Young tableau</strong>. For our purposes it will cause no harm to randomly choose a Young tableau for each Young diagram, since different choices give isomorphic representations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">V_\lambda</annotation></semantics></math>. In other contexts, the difference between various choices of Young tableaux can be extremely important.)</p>

<p>This description of irreducible representations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> paves the way towards an important generalization of Schur functors. First, note that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>≅</mo><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">   X^{\otimes n} \cong \mathbb{C}[S_n] \otimes_{\mathbb{C}[S_n]} X^{\otimes n} </annotation></semantics></math></div>
<p>It follows that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>p</mi> <mi>λ</mi></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><msub><mi>p</mi> <mi>λ</mi></msub><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><msub><mi>V</mi> <mi>λ</mi></msub><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> \array{ S_\lambda(X) &amp;=&amp; p_\lambda X^{\otimes n} \\
&amp;\cong&amp; p_\lambda \mathbb{C}[S_n] \otimes_{\mathbb{C}[S_n]} X^{\otimes n} \\
&amp;\cong&amp; V_\lambda \otimes_{\mathbb{C}[S_n]} X^{\otimes n} 
}

</annotation></semantics></math></div>
<p>These isomorphisms here are natural, so there is no harm in <em>defining</em> the Schur functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">S_\lambda</annotation></semantics></math> by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>V</mi> <mi>λ</mi></msub><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">   S_\lambda(-) = V_\lambda \otimes_{\mathbb{C}[S_n]} (-)^{\otimes n} </annotation></semantics></math></div>
<p>This formula defines the Schur functor not only on objects but also on morphisms. Even better, we can use the same formula to define a functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">  S_R : FinVect \to FinVect </annotation></semantics></math></div>
<p>for <em>any</em> representation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>, as follows:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>=</mo><mi>R</mi><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">   S_R(-) = R \otimes_{\mathbb{C}[S_n]} (-)^{\otimes n} \, . </annotation></semantics></math></div>
<p>These more general functors are still called ‘Schur functors’.</p>

<p>Even more generally, any finite direct sum of the Schur functors just described may also be called a Schur functor. In other words, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>R</mi> <mi>n</mi></msub><msub><mo stretchy="false">}</mo> <mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R = \{R_n\}_{n \ge 0}</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math> is a finite-dimensional representation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>, and only finitely many of these representations are nonzero, then we define the <strong>Schur functor</strong></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></munder><msub><mi>R</mi> <mi>n</mi></msub><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">   S_R(-) = \bigoplus_{n \ge 0} R_n \otimes_{\mathbb{C}[S_n]} (-)^{\otimes n} \, . </annotation></semantics></math></div>
<ul>
<li>
<p>For each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \geq 0</annotation></semantics></math>, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/tensor+power">tensor power</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>↦</mo><msup><mi>V</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V \mapsto V^{\otimes n}</annotation></semantics></math> is a Schur functor.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> are Schur functors, the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>↦</mo><mi>F</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>⊕</mo><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V \mapsto F(V) \oplus G(V)</annotation></semantics></math> is a Schur functor.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> are Schur functors, the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>↦</mo><mi>F</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V \mapsto F(V) \otimes G(V)</annotation></semantics></math> is also a Schur functor.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> are Schur functors, the composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>↦</mo><mi>F</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V \mapsto F(G(V))</annotation></semantics></math> is a Schur functor. This way of constructing Schur functors is known as <a class="existingWikiWord" href="/nlab/show/plethysm">plethysm</a>.</p>
</li>
</ul>

<h2 id="the_category_of_schur_functors">The category of Schur functors</h2>

<p>There is a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> with</p>

<ul>
<li>
<p>Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">S_R : FinVect \to FinVect</annotation></semantics></math> as objects. Here</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></munder><msub><mi>R</mi> <mi>n</mi></msub><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mspace width="thinmathspace"></mspace></mrow><annotation encoding="application/x-tex">   S_R(-) = \bigoplus_{n \ge 0} R_n \otimes_{\mathbb{C}[S_n]} (-)^{\otimes n} \, </annotation></semantics></math></div>
<p>each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">R_n</annotation></semantics></math> is a finite-dimensional representation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>, and only finitely many of these representations are nonzero.</p>
</li>

<li>
<p>natural transformations between such functors as morphisms.</p>
</li>
</ul>

<p>In the rest of this article, we would like to give a conceptual explanation of this category.</p>

<p>As a warm-up, let us note that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">Schur</mo></mrow><annotation encoding="application/x-tex">\Schur</annotation></semantics></math> has has a nice description in terms of groupoid of finite sets and bijections. This groupoid is the <a class="existingWikiWord" href="/nlab/show/core">core</a> of the category <a class="existingWikiWord" href="/nlab/show/FinSet">FinSet</a>, so it is denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>core</mi><mo stretchy="false">(</mo><mi>FinSet</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">core(FinSet)</annotation></semantics></math>. What is the relation between Schur functors and this groupoid. Every Schur functor is a finite direct sum of Schur functors coming from irreducible representations of symmetric groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> for various <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. But what sort of entity is a <em>direct sum of representations of symmetric groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> for various <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>?</em> It is nothing but a representation of the <a class="existingWikiWord" href="/nlab/show/permutation+groupoid">permutation groupoid</a>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨆</mo> <mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></munder><msub><mi>S</mi> <mi>n</mi></msub><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex"> \mathbb{P} = \bigsqcup_{n \ge 0} S_n \, , </annotation></semantics></math></div>
<p>where objects are natural numbers, all morphisms are automorphisms, and the automorphisms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> form the group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>. In other words, it is a functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>:</mo><mi>ℙ</mi><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">R : \mathbb{P} \to Vect </annotation></semantics></math></div>
<p>But conceptually, the importance of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math> is that it is a <a class="existingWikiWord" href="/nlab/show/skeleton">skeleton</a> of the groupoid of finite sets and bijections. So,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi><mo>≃</mo><mi>core</mi><mo stretchy="false">(</mo><mi>FinSet</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex"> \mathbb{P} \simeq core(FinSet) \, .</annotation></semantics></math></div>
<p>As a result, any Schur functor gives a functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>:</mo><mi>core</mi><mo stretchy="false">(</mo><mi>FinSet</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">    R : core(FinSet) \to Vect </annotation></semantics></math></div>
<p>Following <a class="existingWikiWord" href="/nlab/show/Andre+Joyal">Joyal</a>‘s work on combinatorics, such functors are known as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>-valued <a class="existingWikiWord" href="/nlab/show/species">species</a>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>-valued <a class="existingWikiWord" href="/nlab/show/structure+type">structure types</a>. The idea here is that just as an ordinary Set-valued species</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>T</mi><mo>:</mo><mi>core</mi><mo stretchy="false">(</mo><mi>FinSet</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">    T : core(FinSet) \to Set </annotation></semantics></math></div>
<p>assigns to any finite set a <em>set</em> of structures of some type, a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>-valued species assigns to any finite set a <em>vector space</em> of structures of some type, Thanks to the ‘free vector space on a set’ functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>Set</mi><mo>→</mo><mi>Vect</mi><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">F: Set \to Vect \, ,</annotation></semantics></math></div>
<p>we can linearize any ordinary species <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math> and obtain a linear species <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">F \circ T</annotation></semantics></math>. This process is extremely important in the work of <a class="existingWikiWord" href="/nlab/show/Marcelo+Aguiar">Marcelo Aguiar</a> and <a class="existingWikiWord" href="/nlab/show/Swapneel+Mahajan">Swapneel Mahajan</a>:</p>

<ul>
<li id="AMbook"><a class="existingWikiWord" href="/nlab/show/Marcelo+Aguiar">Marcelo Aguiar</a> and <a class="existingWikiWord" href="/nlab/show/Swapneel+Mahajan">Swapneel Mahajan</a>, <a class="existingWikiWord" href="/nlab/show/Monoidal+Functors%2C+Species+and+Hopf+Algebras">Monoidal Functors, Species and Hopf Algebras</a>, 2010.</li>
</ul>

<p>However, not all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>-valued species corresond to Schur functors, because we have defined Schur functors to arise from <em>finite</em> direct sums of irreducible representations of permutation groups. So, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> is equivalent to the category where:</p>

<ul>
<li>
<p>objects are <strong>polynomial species</strong>: that is, functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>:</mo><mi>core</mi><mo stretchy="false">(</mo><mi>Fin</mi><mo lspace="0em" rspace="thinmathspace">Set</mo><mo stretchy="false">)</mo><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">R: core(Fin\Set) \to FinVect</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R(n) = \{0\}</annotation></semantics></math> for all sufficiently large finite sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>;</p>
</li>

<li>
<p>morphisms are natural transformations.</p>
</li>
</ul>

<p>We call this the <strong>category of polynomial species</strong>. The reason for the term ‘polynomial’ is that any functor of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></munder><msub><mi>R</mi> <mi>n</mi></msub><msub><mo>⊗</mo> <mrow><mi>ℂ</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">   S_R(X) = \bigoplus_{n \ge 0} R_n \otimes_{\mathbb{C}[S_n]} X^{\otimes n} </annotation></semantics></math></div>
<p>gives rise to a formal power series called its <strong>generating function</strong>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></munder><mfrac><mrow><mi>dim</mi><mo stretchy="false">(</mo><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><msup><mi>x</mi> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">      \sum_{n \ge 0} \frac{dim(R_n) \, x^n}{n!}  \, , </annotation></semantics></math></div>
<p>and this power series is a polynomial precisely when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is a polynomial species.</p>

<p>The category of representations of any groupoid has many nice features. For example, it is a <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric monoidal</a> <a class="existingWikiWord" href="/nlab/show/abelian+category">abelian category</a>, by which we mean a symmetric monoidal category that is also abelian, where tensoring with any object is right exact. So, the category of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>-valued species is symmetric monoidal abelian — and it is easy to check that the subcategory of polynomial species inherits this structure. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> is equivalent to the category of polynomial species, it too is symmetric monoidal abelian.</p>

<p>In particular, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> has two monoidal structures, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>, defined by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo>⊕</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>⊕</mo><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (F \oplus G)(V) = F(V) \oplus G(V) </annotation></semantics></math></div>
<p>and</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo>⊗</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> (F \otimes G)(V) = F(V) \otimes G(V) </annotation></semantics></math></div>
<p>Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> distributes over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math>, these make <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> into a <a class="existingWikiWord" href="/nlab/show/rig+category">rig category</a>.</p>

<p>In the literature on species, the operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math> is often called <strong>addition</strong>, since adding species this way corresponds to adding their generating functions. <a href="#AMbook">Aguiar and Mahajan</a> call <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> the <em>Hadamard product</em> (see section 8.1.2).</p>

<p>But the category of representations of a groupoid has even more nice features when the groupoid itself has a <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal structure</a>: then the representation category acquires a monoidal structure thanks to <a class="existingWikiWord" href="/nlab/show/Day+convolution">Day convolution</a>. The groupoid <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math> has, in fact, <em>two</em> important monoidal structures, coming from the product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math> and disjoint union <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math> of finite sets. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math> distributes over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math>, these make <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math> into a <a class="existingWikiWord" href="/nlab/show/rig+category">rig category</a>. Thanks to Day convolution, these give the category of representations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math> two more monoidal structures, making it into a rig category in another way. The same is true for the subcategory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math>.</p>

<p>In the literature on species, the monoidal structure coming from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math> is often called <strong>multiplication</strong>, since multiplying species in this way corresponds to multiplying their generating functions. Aguiar and Mahajan call this monoidal structure the <em>Cauchy product</em>. The monoidal structure coming from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math> has no commonly used name, but it deserves to be called the <strong>Dirichlet product</strong>.</p>

<p>Aguiar and Mahajan point out that some of the relationships between the “pointwise” products (addition and Hadamard) and the “Day” products (Cauchy and Dirichlet) can be described in terms of <a class="existingWikiWord" href="/nlab/show/duoidal+categories">duoidal categories</a>. Specifically, the Hadamard and Cauchy products form duoidal structures in both orders.</p>

<p>On top of all this, the composite of Schur functors is again a Schur functor. This gives <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> a fifth monoidal structure: the <strong>plethystic tensor product</strong>. Unlike the four previous monoidal structures, this one is not symmetric.</p>

<p>Mathematicians often work with a decategorified version of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math>: its <a class="existingWikiWord" href="/nlab/show/Grothendieck+group">Grothendieck group</a>, also known as the ring of <a class="existingWikiWord" href="/nlab/show/symmetric+functions">symmetric functions</a>. The various structures that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> possesses endow this ring with corresponding structures. Among other things, it is the free <a class="existingWikiWord" href="/nlab/show/lambda-ring">lambda-ring</a> on one generator. As we shall see, this corresponds to the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> is the free <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric monoidal</a> <a class="existingWikiWord" href="/nlab/show/Cauchy+complete+category">Cauchy complete</a> <a class="existingWikiWord" href="/nlab/show/linear+category">linear category</a> on one object.</p>

<h2 id="schur_functors_on_more_general_categories">Schur functors on more general categories</h2>

<p>We have described Schur functors as special functors</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">  F: FinVect \to FinVect  </annotation></semantics></math></div>
<p>But in fact, functors such as the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> alternating power, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> symmetric power, etc. make sense in much wider contexts. For starters, we can replace the complex numbers by any field <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> of characteristic zero, and everything in our discussion still works. More importantly, Schur functors can be applied to any <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric monoidal</a> <a class="existingWikiWord" href="/nlab/show/Cauchy+complete+category">Cauchy complete</a> <a class="existingWikiWord" href="/nlab/show/linear+category">linear category</a> (“<a class="existingWikiWord" href="/nlab/show/tensor+category">tensor category</a>”). Here by <strong>linear category</strong> we mean a category <a class="existingWikiWord" href="/nlab/show/enriched+category">enriched</a> over <a class="existingWikiWord" href="/nlab/show/Vect">Vect</a>, the category of vector spaces over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>. Such a category is <strong>Cauchy complete</strong> when:</p>

<ul>
<li>
<p>it has <a class="existingWikiWord" href="/nlab/show/biproducts">biproducts</a>, also known as <a class="existingWikiWord" href="/nlab/show/direct+sums">direct sums</a>, and</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/idempotent">idempotents</a><a class="existingWikiWord" href="/nlab/show/split+idempotent">split</a>.</p>
</li>
</ul>

<p>To illustrate the full breadth of this generalization, here are a few examples:</p>

<ul>
<li>
<p>the category <a class="existingWikiWord" href="/nlab/show/Vect">Vect</a>, consisting of vector spaces over any field <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/characteristic+zero">characteristic zero</a></p>
</li>

<li>
<p>the category <a class="existingWikiWord" href="/nlab/show/FinVect">FinVect</a>, consisting of <a class="existingWikiWord" href="/nlab/show/finite-dimensional+vector+spaces">finite-dimensional vector spaces</a> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></p>
</li>

<li>
<p>the <a class="existingWikiWord" href="/nlab/show/category+of+representations">category of representations</a> of any <a class="existingWikiWord" href="/nlab/show/group">group</a> on vector spaces (or <a class="existingWikiWord" href="/nlab/show/finite-dimensional+vector+spaces">finite-dimensional vector spaces</a>) over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></p>
</li>

<li>
<p>the category of <a class="existingWikiWord" href="/nlab/show/super+vector+spaces">super vector spaces</a>, <a class="existingWikiWord" href="/nlab/show/graded+vector+space">graded vector spaces</a> or <a class="existingWikiWord" href="/nlab/show/chain+complexes">chain complexes</a> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></p>
</li>

<li>
<p>for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>=</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">k = \mathbb{R}</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, the category of finite-dimensional real or complex <a class="existingWikiWord" href="/nlab/show/vector+bundle">vector bundles</a> over any <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>, or smooth vector bundles over any smooth <a class="existingWikiWord" href="/nlab/show/manifold">manifold</a></p>
</li>

<li>
<p>the category of algebraic vector bundles over any <a class="existingWikiWord" href="/nlab/show/algebraic+variety">algebraic variety</a> (or more generally, <a class="existingWikiWord" href="/nlab/show/scheme">scheme</a> or <a class="existingWikiWord" href="/nlab/show/algebraic+stack">algebraic stack</a>) over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></p>
</li>

<li>
<p>the category of <a class="existingWikiWord" href="/nlab/show/coherent+sheaves">coherent sheaves</a> of vector spaces over any algebraic variety (or scheme or algebraic stack) over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></p>
</li>
</ul>

<p>These examples can be hybridized, and thus they multiply indefinitely: for example, we could take coherent sheaves of chain complexes, or vector bundles equipped with a group action, and so on.</p>

<p>In the following subsections, we explain how to define Schur functors on any category of this sort. A somewhat novel feature of our treatment is that we <em>do not require the theory of Young diagrams</em> to define and study Schur functors.</p>

<p>Our strategy is as follows. We fix a symmetric monoidal Cauchy complete linear category, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. The group algebra <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> begins life as a <a class="existingWikiWord" href="/nlab/show/monoid">monoid</a> in the symmetric monoidal category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">FinVect</annotation></semantics></math>. However, we shall explain how interpret it as living in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> by a “change of base” functor going from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">FinVect</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. This will let us use the Young symmetrizers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">p_\lambda</annotation></semantics></math> to construct idempotents on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>V</mi> <mrow><mo>⊗</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V^{\otimes k}</annotation></semantics></math> for any object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">V \in C</annotation></semantics></math>. Splitting these idempotents, we obtain the Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S_\lambda : C \to C</annotation></semantics></math>.</p>

<h3 id="change_of_base">Change of base</h3>

<p>To achieve the desired change of base, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mat</mi></mrow><annotation encoding="application/x-tex">Mat</annotation></semantics></math> be the linear category whose objects are integers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m \geq 0</annotation></semantics></math> and whose morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \to n</annotation></semantics></math> are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math> matrices with entries in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>. Because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is Cauchy complete and in particular has finite biproducts (direct sums), there is an evident linear functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Mat</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">Mat \to C</annotation></semantics></math></div>
<p>which takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>I</mi> <mi>m</mi></msup></mrow><annotation encoding="application/x-tex">I^m</annotation></semantics></math>, the direct sum of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> copies of the tensor unit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math>. It is the unique linear functor taking <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math>, up to unique linear isomorphism. In the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">C = FinVect</annotation></semantics></math>, the linear functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Mat</mi><mo>→</mo><mi>FinVect</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">Mat \to FinVect,</annotation></semantics></math></div>
<p>taking <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>, is a linear equivalence (exhibiting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Mat</mi></mrow><annotation encoding="application/x-tex">Mat</annotation></semantics></math> as a <a class="existingWikiWord" href="/nlab/show/skeleton">skeleton</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>). Because of this equivalence, we could equally well say that there is a linear functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">i: FinVect \to C</annotation></semantics></math></div>
<p>which, up to unique linear isomorphism, is the unique linear functor taking <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math>. Notice that a <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+functor">symmetric monoidal functor</a> of this form must take the tensor unit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math> (up to coherent isomorphism, as always), and in fact <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> is symmetric monoidal, because there is a canonical isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>I</mi> <mi>m</mi></msup><mo>⊗</mo><msup><mi>I</mi> <mi>n</mi></msup><mo>≅</mo><msup><mi>I</mi> <mrow><mi>m</mi><mi>n</mi></mrow></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">I^m \otimes I^n \cong I^{m n},</annotation></semantics></math></div>
<p>using the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> preserves direct sums in each argument, and the fact that there is a canonical isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>I</mi><mo>⊗</mo><mi>I</mi><mo>≅</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">I \otimes I \cong I</annotation></semantics></math>.</p>

<p>In summary, we have the following proposition.</p>

<div class="num_prop">
<h6 id="proposition">Proposition</h6>

<p>There is exactly one symmetric monoidal linear functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">i: FinVect \to C</annotation></semantics></math>, up to symmetric monoidal linear isomorphism.</p>
</div>

<h3 id="the_action_of_young_symmetrizers">The action of Young symmetrizers</h3>

<p>Next we explain how given an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X \in C</annotation></semantics></math>, any Young symmetrizer in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> acts as an idempotent on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math>.</p>

<p>For this we only need to know a little bit about the group algebra <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math>, which we recall here. By <a class="existingWikiWord" href="/nlab/show/Maschke%27s+theorem">Maschke's theorem</a>, for any finite group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>, the <a class="existingWikiWord" href="/nlab/show/group+algebra">group algebra</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[G]</annotation></semantics></math> decomposes as a direct sum of matrix algebras</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mi>λ</mi></munder><mi>hom</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mi>λ</mi></msub><mo>,</mo><msub><mi>V</mi> <mi>λ</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bigoplus_{\lambda} hom(V_\lambda, V_\lambda)</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> ranges over isomorphism classes of irreducible representations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>. The identity elements of these matrix algebras <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mi>λ</mi></msub><mo>,</mo><msub><mi>V</mi> <mi>λ</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hom(V_\lambda, V_\lambda)</annotation></semantics></math> thus correspond to certain special elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub><mo>∈</mo><mi>k</mi><mo stretchy="false">[</mo><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p_\lambda \in k[G]</annotation></semantics></math>. Clearly these elements are <a class="existingWikiWord" href="/nlab/show/idempotent">idempotent</a>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msubsup><mi>p</mi> <mi>λ</mi> <mn>2</mn></msubsup><mo>=</mo><msub><mi>p</mi> <mi>λ</mi></msub><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex"> p_\lambda^2 = p_\lambda \, . </annotation></semantics></math></div>
<p>We are particularly interested in the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>=</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G = S_n</annotation></semantics></math>. In this case, we call the idempotents <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">p_\lambda</annotation></semantics></math> are ‘Young symmetrizers’. However, we will not need the formula for these idempotents.</p>

<p>The key step is to apply base change to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math>. Here we exploit the fact that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow></munder><mi>k</mi></mrow><annotation encoding="application/x-tex">   k[S_n] = \bigoplus_{\sigma \in S_n}  k </annotation></semantics></math></div>
<p>is a <a class="existingWikiWord" href="/nlab/show/monoid">monoid</a> in the monoidal category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">FinVect</annotation></semantics></math>. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>FinVect</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">i : FinVect \to C</annotation></semantics></math> is a monoidal functor, it follows that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> carries <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> to a monoid in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, which we again call <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> by abuse of notation. As an object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, we have</p>
<div class="maruku-equation" id="eq:sum"><span class="maruku-eq-number">(1)</span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>≅</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow></munder><mi>I</mi></mrow><annotation encoding="application/x-tex">  k[S_n] \cong \bigoplus_{\sigma \in S_n}  I   </annotation></semantics></math></div>
<p>There is a general concept of what it means for a monoid in a monoidal category to <a class="existingWikiWord" href="/nlab/show/action">act</a> on an object in that category. In particular, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is an object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, the monoid <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> acts on the tensor power <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math>. To see this, note that for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sigma \in S_n</annotation></semantics></math>, there is a corresponding symmetry isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> \sigma : X^{\otimes n} \to X^{\otimes n} </annotation></semantics></math></div>
<p>Putting these together with the help of <a class="maruku-eqref" href="#eq:sum">(1)</a> we obtain a morphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k[S_n] \otimes X^{\otimes n} \to X^{\otimes n}</annotation></semantics></math></div>
<p>which is the desired action.</p>

<p>Finally, we would like to describe how each Young symmetrizer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub><mo>∈</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p_\lambda \in k[S_n]</annotation></semantics></math> acts on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math>. Quite generally, any element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x \in k[S_n]</annotation></semantics></math> gives a linear map from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math>, namely the unique map sending <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>. Applying the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> to this, we obtain a morphism which by abuse of language we call</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex"> x : I \to k[S_n]</annotation></semantics></math></div>
<p>This then yields an endomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mover><mi>x</mi><mo>˜</mo></mover><mo>:</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> \widetilde{x}: X^{\otimes n} \to X^{\otimes n }</annotation></semantics></math></div>
<p>given as the composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mover><mo>⟶</mo><mo>≅</mo></mover><mi>I</mi><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mover><mo>⟶</mo><mrow><mi>x</mi><mo>⊗</mo><mn>1</mn></mrow></mover><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>⟶</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> X^{\otimes n} \stackrel{\cong}{\longrightarrow} I \otimes X^{\otimes n} \stackrel{x \otimes 1}{\longrightarrow} k[S_n] \otimes X^{\otimes n} \longrightarrow X^{\otimes n} </annotation></semantics></math></div>
<p>It is easy to check that for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>∈</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x,y \in k[S_n]</annotation></semantics></math>,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>x</mi><mi>y</mi></mrow><mo>˜</mo></mover><mo>=</mo><mover><mi>x</mi><mo>˜</mo></mover><mover><mi>y</mi><mo>˜</mo></mover></mrow><annotation encoding="application/x-tex"> \widetilde{x y} = \widetilde{x} \widetilde{y} </annotation></semantics></math></div>
<p>Thus for any Young symmetrizer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">p_\lambda</annotation></semantics></math>, the morphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mover><mi>p</mi><mo>˜</mo></mover> <mi>λ</mi></msub><mo>:</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> \widetilde{p}_\lambda : X^{\otimes n} \to X^{\otimes n} </annotation></semantics></math></div>
<p>is idempotent, because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">p_\lambda</annotation></semantics></math> is.</p>

<h3 id="constructing_schur_functors">Constructing Schur functors</h3>

<p>By construction, the morphisms</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mover><mi>p</mi><mo>˜</mo></mover> <mi>λ</mi></msub><mo>:</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> \widetilde{p}_\lambda : X^{\otimes n} \to X^{\otimes n} </annotation></semantics></math></div>
<p>are the components of a natural transformation from the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>↦</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X \mapsto X^{\otimes n}</annotation></semantics></math> to itself. Since idempotents split in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, we can form the cokernel of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>−</mo><msub><mover><mi>p</mi><mo>˜</mo></mover> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">1 - \widetilde{p}_\lambda</annotation></semantics></math>, or in other words, the coequalizer of the pair</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mover><munder><mo>⇉</mo><mn>1</mn></munder><mrow><msub><mover><mi>p</mi><mo>˜</mo></mover> <mi>λ</mi></msub></mrow></mover><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> X^{\otimes n} \stackrel{\widetilde{p}_\lambda}{\underset{1}{\rightrightarrows}} X^{\otimes n} </annotation></semantics></math></div>
<div class="num_defn">
<h6 id="definition">Definition</h6>

<p>For any Young diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>, the <strong>Schur functor</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S_\lambda: C \to C</annotation></semantics></math> is defined as follows. Given an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_\lambda(X)</annotation></semantics></math> be the cokernel of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mover><mi>p</mi><mo>˜</mo></mover> <mi>λ</mi></msub><mo stretchy="false">)</mo><mo>:</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(1 - \widetilde{p}_\lambda) : X^{\otimes n} \to X^{\otimes n}</annotation></semantics></math>. Given a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f: X \to Y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_\lambda(f)</annotation></semantics></math> be the unique map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_\lambda(X) \to S_\lambda(Y)</annotation></semantics></math> such that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mtd> <mtd><mo>→</mo></mtd> <mtd><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msup><mi>f</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo stretchy="false">↓</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msup><mi>Y</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mtd> <mtd><mo>→</mo></mtd> <mtd><msub><mi>S</mi> <mi>ν</mi></msub><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
X^{\otimes n} &amp; \to &amp; S_\lambda(X) \\
f^{\otimes n} \downarrow \; \; &amp; &amp; \downarrow S_\lambda(f) \\
Y^{\otimes n} &amp; \to &amp; S_\nu(Y)
}
</annotation></semantics></math></div>
<p>commutes, where the horizontal arrows are the cokernel maps.</p>
</div>

<p>More generally we can define a <strong>Schur functor</strong></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">  S_R : C \to C  </annotation></semantics></math></div>
<p>for any finite-dimensional representation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>, as follows. We can write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> as a finite direct sum of irreducible representations:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>R</mi><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mi>i</mi></munder><msub><mi>V</mi> <mrow><msub><mi>λ</mi> <mi>i</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">  R = \bigoplus_i V_{\lambda_i}  </annotation></semantics></math></div>
<p>and then define</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mi>i</mi></munder><msub><mi>S</mi> <mrow><msub><mi>λ</mi> <mi>i</mi></msub></mrow></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">  S_R(-) = \bigoplus_i S_{\lambda_i}(-) \, .</annotation></semantics></math></div>
<h3 id="schur_functors_are_natural">Schur functors are “natural”</h3>

<p>Suppose now that we have a symmetric monoidal linear functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">G: C \to D</annotation></semantics></math>. We can think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> as a “change of base category”, and Schur functors are “natural” with respect to change of base.</p>

<p>That is to say: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> is a symmetric monoidal linear functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C \to D</annotation></semantics></math>, then by definition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> preserves tensor products (at least up to coherent natural isomorphism), and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> will automatically preserve both direct sums (by linearity) as well as splittings of idempotents (as all functors do). Therefore, for a Schur functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>λ</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>V</mi> <mi>λ</mi></msub><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S_\lambda(X) = V_\lambda \otimes_{S_n} X^{\otimes n}</annotation></semantics></math>, we have natural isomorphisms</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>S</mi> <mrow><mi>λ</mi><mo>,</mo><mi>D</mi></mrow></msub><mo stretchy="false">(</mo><mi>G</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>V</mi> <mrow><mi>λ</mi><mo>,</mo><mi>D</mi></mrow></msub><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>G</mi><mi>X</mi><msup><mo stretchy="false">)</mo> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mtd> <mtd><mo>≅</mo></mtd> <mtd><msub><mi>V</mi> <mrow><mi>λ</mi><mo>,</mo><mi>D</mi></mrow></msub><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow></msub><mi>G</mi><mo stretchy="false">(</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><mi>G</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mrow><mi>λ</mi><mo>,</mo><mi>C</mi></mrow></msub><mo stretchy="false">)</mo><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow></msub><mi>G</mi><mo stretchy="false">(</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><mi>G</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mrow><mi>λ</mi><mo>,</mo><mi>C</mi></mrow></msub><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><mi>G</mi><mo stretchy="false">(</mo><msub><mi>S</mi> <mrow><mi>λ</mi><mo>,</mo><mi>C</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
S_{\lambda, D} (G X) = V_{\lambda, D} \otimes_{S_n} (G X)^{\otimes n} &amp; \cong &amp; V_{\lambda, D} \otimes_{S_n} G(X^{\otimes n}) \\
 &amp; \cong &amp; G(V_{\lambda, C}) \otimes_{S_n} G(X^{\otimes n}) \\
 &amp; \cong &amp; G(V_{\lambda, C} \otimes_{S_n} X^{\otimes n}) \\
 &amp; \cong &amp; G(S_{\lambda, C}(X))
}
</annotation></semantics></math></div>
<p>where the first isomorphism uses the symmetric monoidal structure of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>; the second uses the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mrow><mi>λ</mi><mo>,</mo><mi>D</mi></mrow></msub><mo>≅</mo><mi>G</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mrow><mi>λ</mi><mo>,</mo><mi>C</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_{\lambda, D} \cong G(V_{\lambda, C})</annotation></semantics></math> because there is, up to isomorphism, only one symmetric monoidal linear functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FinVect</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">FinVect \to D</annotation></semantics></math>; the third uses the symmetric monoidal structure again and preservation of idempotent splittings.</p>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> is any representation, then by writing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> as a direct sum of irreducible representations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">V_\lambda</annotation></semantics></math> and using the fact that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> preserves direct sums, we have more generally</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mrow><mi>R</mi><mo>,</mo><mi>D</mi></mrow></msub><mo>∘</mo><mi>G</mi><mo>≅</mo><mi>G</mi><mo>∘</mo><msub><mi>S</mi> <mrow><mi>R</mi><mo>,</mo><mi>C</mi></mrow></msub><mo>.</mo></mrow><annotation encoding="application/x-tex">S_{R, D} \circ G \cong G \circ S_{R, C}.</annotation></semantics></math></div>
<p>In summary, Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">S_R</annotation></semantics></math> transfer “naturally” across change of base functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">G: C \to D</annotation></semantics></math>.</p>

<h2 id="conceptual_description_of_schur_functors">Conceptual description of Schur functors</h2>

<p>As we have seen, Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">S_R</annotation></semantics></math> are definable under fairly mild hypotheses: working over a field of characteristic zero, they can be defined on any symmetric monoidal linear category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> which is Cauchy complete. So, for such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> we can define a Schur functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S_R: C \to C</annotation></semantics></math></div>
<p>and moreover, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">G: C \to D</annotation></semantics></math> is a symmetric monoidal linear functor, the Schur functors on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> are “naturally” compatible, in the sense that the diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>C</mi></mtd> <mtd><mover><mo>→</mo><mi>G</mi></mover></mtd> <mtd><mi>D</mi></mtd></mtr> <mtr><mtd><msub><mi>S</mi> <mrow><mi>R</mi><mo>,</mo><mi>C</mi></mrow></msub><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><msub><mi>S</mi> <mrow><mi>R</mi><mo>,</mo><mi>D</mi></mrow></msub></mtd></mtr> <mtr><mtd><mi>C</mi></mtd> <mtd><munder><mo>→</mo><mi>G</mi></munder></mtd> <mtd><mi>D</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
C &amp; \stackrel{G}{\to} &amp; D \\
S_{R, C} \downarrow &amp; &amp; \downarrow S_{R, D} \\
C &amp; \underset{G}{\to} &amp; D
}
</annotation></semantics></math></div>
<p>commutes up to a canonical isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>G</mi></msub><mo>:</mo><msub><mi>S</mi> <mrow><mi>R</mi><mo>,</mo><mi>D</mi></mrow></msub><mo>∘</mo><mi>G</mi><mo>≅</mo><mi>G</mi><mo>∘</mo><msub><mi>S</mi> <mrow><mi>R</mi><mo>,</mo><mi>C</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\phi_G: S_{R, D} \circ G \cong G \circ S_{R, C}</annotation></semantics></math>, and moreover these <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>G</mi></msub></mrow><annotation encoding="application/x-tex">\phi_G</annotation></semantics></math> fit together sensibly when we compose symmetric monoidal linear functors.</p>

<p>In this abstract framework, it may be wondered what significant role is played by the representations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> of the symmetric group. The natural isomorphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>G</mi></msub></mrow><annotation encoding="application/x-tex">\phi_G</annotation></semantics></math> which relate the Schur functors across change of base <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">G: C \to D</annotation></semantics></math> are pleasant to observe, but surely this is just some piddling general nonsense in the larger story of Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">S_R</annotation></semantics></math>, which are after all deeply studied and incredibly rich classical constructions?</p>

<p>Let us put the question another way. We have seen the Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">S_R</annotation></semantics></math> are constructed in a uniform (or “polymorphic”) way across all symmetric monoidal Cauchy complete linear categories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, and this construction is natural with respect to symmetric monoidal change of base functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">G: C \to D</annotation></semantics></math>. Or rather: not natural in a strict sense, but <em>pseudonatural</em> in the sense that naturality squares commute up to isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ϕ</mi> <mi>G</mi></msub></mrow><annotation encoding="application/x-tex">\phi_G</annotation></semantics></math>. Now pseudonaturality is a very general phenomenon in 2-category theory. So the question is: among all such pseudonatural transformations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, what is special about the Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">S_R</annotation></semantics></math>? What extra properties pick out exactly the Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">S_R</annotation></semantics></math> from the class of all pseudonatural transformations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>?</p>

<p>The perhaps surprising answer is: no extra properties! That is, the Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>R</mi></msub></mrow><annotation encoding="application/x-tex">S_R</annotation></semantics></math> are <em>precisely</em> those functors that are defined on all symmetric monoidal Cauchy complete linear <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and that are pseudonatural with respect to change of base <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">G: C \to D</annotation></semantics></math>!</p>

<p>Let us now make this precise. Schur functors are defined on certain symmetric monoidal linear categories, but they respect neither the symmetric monoidal structure nor the linear structure. So, we have to forget some of the structure of the objects on which Schur functors are defined. This focuses our attention on the ‘forgetful’ 2-functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>SymMonLinCauch</mi><mo>→</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">U: SymMonLinCauch \to Cat</annotation></semantics></math></div>
<p>where:</p>

<div class="num_defn">
<h6 id="definition_2">Definition</h6>

<p><strong>SymMonLinCauch</strong> is the 2-category with</p>

<ul>
<li>
<p>small symmetric monoidal Cauchy complete linear categories as objects,</p>
</li>

<li>
<p>symmetric monoidal linear functors as morphisms,</p>
</li>

<li>
<p>symmetric monoidal linear natural transformations as 2-morphisms.</p>
</li>
</ul>
</div>

<p>As we shall see, Schur functors correspond to <a class="existingWikiWord" href="/nlab/show/pseudonatural+transformations">pseudonatural transformations</a> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> to itself, and morphisms between Schur functors correspond to <a class="existingWikiWord" href="/nlab/show/modifications">modifications</a> between these pseudonatural transformations. For the reader unaccustomed to these 2-categorical concepts, we recall:</p>

<div class="num_defn">
<h6 id="definition_3">Definition</h6>

<p>Given two 2-functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>,</mo><mi>V</mi><mo>:</mo><mi>S</mi><mover><mo>→</mo><mo>→</mo></mover><mi>C</mi></mrow><annotation encoding="application/x-tex">U, V: S \stackrel{\to}{\to} C</annotation></semantics></math> between 2-categories, a <strong>pseudonatural transformation</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\phi: U \to V</annotation></semantics></math> is a rule that assigns to each 0-cell <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> a 1-cell <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>:</mo><mi>U</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(s): U(s) \to V(s)</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, and to each 1-cell <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>r</mi><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">f: r \to s</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> an invertible 2-cell <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(f)</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>U</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>U</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">↓</mo></mtd> <mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>⇙</mo></mtd> <mtd><mo stretchy="false">↓</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>V</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><munder><mo>→</mo><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></munder></mtd> <mtd><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
U(r) &amp; \stackrel{U(f)}{\to} &amp; U(s) \\
\phi(r) \downarrow &amp; \phi(f) \swArrow &amp; \downarrow \phi(s) \\
V(r) &amp; \underset{V(f)}{\to} &amp; V(s)
}
</annotation></semantics></math></div>
<p>such that the following pasting diagram equalities hold:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>U</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>U</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>U</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd> <mtd></mtd> <mtd><mi>U</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>g</mi><mi>f</mi><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>U</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd> <mtd></mtd> <mtd></mtd></mtr> <mtr><mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">↓</mo></mtd> <mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>⇙</mo></mtd> <mtd><mo stretchy="false">↓</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mtd> <mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>⇙</mo></mtd> <mtd><mo stretchy="false">↓</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">↓</mo></mtd> <mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>g</mi><mi>f</mi><mo stretchy="false">)</mo><mo>⇙</mo></mtd> <mtd><mo stretchy="false">↓</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd> <mtd></mtd> <mtd></mtd> <mtd></mtd></mtr> <mtr><mtd><mi>V</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><munder><mo>→</mo><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></munder></mtd> <mtd><mi>V</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mtd> <mtd><munder><mo>→</mo><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></munder></mtd> <mtd><mi>V</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd> <mtd></mtd> <mtd><mi>V</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><munder><mo>→</mo><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>g</mi><mi>f</mi><mo stretchy="false">)</mo></mrow></munder></mtd> <mtd><mi>V</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd> <mtd></mtd> <mtd></mtd> <mtd></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
U(r) &amp; \stackrel{U(f)}{\to} &amp; U(s) &amp; \stackrel{U(g)}{\to} &amp; U(t) &amp; &amp; U(r) &amp; \stackrel{U(g f)}{\to} &amp; U(t) &amp; &amp; \\
\phi(r) \downarrow &amp; \phi(f) \swArrow &amp; \downarrow \phi(s) &amp; \phi(g) \swArrow &amp; \downarrow \phi(t) &amp; = &amp; \phi(r) \downarrow &amp; \phi(g f) \swArrow &amp; \downarrow \phi(t) &amp; &amp; &amp; \\
V(r) &amp; \underset{V(f)}{\to} &amp; V(s) &amp; \underset{V(g)}{\to} &amp; V(t) &amp; &amp; V(r) &amp; \underset{V(g f)}{\to} &amp; V(t) &amp; &amp; &amp; 
}
</annotation></semantics></math></div>
<p>and</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>U</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><mover><mo>→</mo><mrow><mi>U</mi><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>r</mi></msub><mo stretchy="false">)</mo></mrow></mover></mtd> <mtd><mi>U</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd></mtd> <mtd></mtd></mtr> <mtr><mtd><mi>ϕ</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">↓</mo></mtd> <mtd><mi>ϕ</mi><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>r</mi></msub><mo stretchy="false">)</mo><mo>⇙</mo></mtd> <mtd><mo stretchy="false">↓</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mn>1</mn> <mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msub></mtd></mtr> <mtr><mtd><mi>V</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd><munder><mo>→</mo><mrow><mi>V</mi><mo stretchy="false">(</mo><msub><mn>1</mn> <mi>r</mi></msub><mo stretchy="false">)</mo></mrow></munder></mtd> <mtd><mi>V</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mtd> <mtd></mtd> <mtd></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
 U(r) &amp; \stackrel{U(1_r)}{\to} &amp; U(r) &amp; &amp; \\
\phi(r) \downarrow &amp; \phi(1_r) \swArrow &amp; \downarrow \phi(r) &amp; = &amp; 1_{\phi(r)} \\
V(r) &amp; \underset{V(1_r)}{\to} &amp; V(r) &amp; &amp; 
}
</annotation></semantics></math></div>
<p>There is also a requirement that the assignation f \mapsto \phi(f) should be natural as f varies along a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-cell \alpha: f \Rightarrow g. That is, \phi(g).U\alpha =V\alpha.\phi(f).</p>
</div>

<div class="num_defn">
<h6 id="definition_4">Definition</h6>

<p>With notation as above, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ϕ</mi><mo>,</mo><mi>ψ</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\phi, \psi: U \to V</annotation></semantics></math> be two pseudonatural transformations. A <strong>modification</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>:</mo><mi>ϕ</mi><mo>→</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">x: \phi \to \psi</annotation></semantics></math> is a rule which associates to each 0-cell <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> a 2-cell <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>:</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x(s): \phi(s) \to \psi(t)</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, such that the following compatibility condition holds:</p>
</div>

<div style="text-align:center">
<p><img src="/nlab/files/tincan.png" alt="tin can diagram for modification between psuedo natural transformations, drawn by John Baez" /></p>
</div>

<p>We now propose our conceptual definition of Schur functor:</p>

<div class="num_defn">
<h6 id="definition_5">Definition</h6>

<p>An (abstract) <strong>Schur functor</strong> is a pseudonatural transformation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">S: U \to U</annotation></semantics></math>, where</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>SymMonLinCauch</mi><mo>→</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">U: SymMonLinCauch \to Cat</annotation></semantics></math></div>
<p>is the forgetful 2-functor. A <strong>morphism</strong> of Schur functors is a modification between such pseudonatural transformations.</p>
</div>

<p>What this proposed definition makes manifestly obvious is that <em>Schur functors are closed under composition</em>. This provides a satisfying conceptual explanation of <em>plethysm</em>, as we will explore in the next two sections. However, we should first check that this proposed definition gives a category of Schur functors equivalent to the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> defined earlier!</p>

<p>Before launching into the proof, it is worth pondering an easier problem where we replace categories by sets, and symmetric monoidal linear Cauchy-complete categories by commutative rings.<br />So, instead of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math> let us consider <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>, and instead of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SymMonLinCauch</mi></mrow><annotation encoding="application/x-tex">SymMonLinCauch</annotation></semantics></math> let us consider <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>CommRing</mi></mrow><annotation encoding="application/x-tex">CommRing</annotation></semantics></math>. There is a forgetful functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>CommRing</mi><mo>→</mo><mi>Set</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex"> U : CommRing \to Set \, . </annotation></semantics></math></div>
<p>What are the natural transformations from this functor to itself? Any polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>∈</mo><mi>ℤ</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P \in \mathbb{Z}[x]</annotation></semantics></math> defines such a natural transformation, since for any commutative ring <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> there is a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>P</mi> <mi>R</mi></msub><mo>:</mo><mi>U</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>→</mo><mi>U</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_R: U(R) \to U(R)</annotation></semantics></math> given by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>P</mi> <mi>R</mi></msub><mo>:</mo><mi>x</mi><mo>↦</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> P_R : x \mapsto P(x) </annotation></semantics></math></div>
<p>and this is clearly natural in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>. But in fact, the set of natural transformations from this functor turns out to be <em>precisely</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}[x]</annotation></semantics></math>. And the reason is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}[x]</annotation></semantics></math> is the free commutative ring on one generator!</p>

<p>To see this, note that the forgetful functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>CommRing</mi><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex"> U : CommRing \to Set  </annotation></semantics></math></div>
<p>has a left adjoint, the ‘free commutative ring’ functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>Set</mi><mo>→</mo><mi>CommRing</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex"> F : Set \to CommRing \, . </annotation></semantics></math></div>
<p>The free commutative ring on a 1-element set is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>≅</mo><mi>ℤ</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex"> F(1) \cong \mathbb{Z}[x] </annotation></semantics></math></div>
<p>and homomorphisms from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(1)</annotation></semantics></math> to any commutative ring <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math> are in one-to-one correspondence with elements of the underlying set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math>, since</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>hom</mi><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>U</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>R</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex"> U(R) \cong hom(1, U(R)) \cong hom(F(1), R) \, . </annotation></semantics></math></div>
<p>So, we say <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(1)</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/representable+functor">represents</a> the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math>. This makes it easy to show that the set of natural transformations from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> to itself is isomorphic to the underlying set of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbb{Z}[x]</annotation></semantics></math>, namely <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(F(1))</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>U</mi><mo>,</mo><mi>U</mi><mo stretchy="false">]</mo><mo>≅</mo><mo stretchy="false">[</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>,</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>≅</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≃</mo><mi>U</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[U,U] \cong [hom(F(1), -), hom(F(1), -)] \cong hom(F(1), F(1)) \simeq U(F(1))</annotation></semantics></math></div>
<p>In the first step here we use the representability <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>≅</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U \cong hom(F(1), -)</annotation></semantics></math>; in the second we use the <a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a>, and in the third we use the adjointness between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>.</p>

<p>We shall carry out a categorified version of this argument to prove that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> is the category of endomorphisms of the 2-functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>SymMonLinCauch</mi><mo>→</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">U: SymMonLinCauch \to Cat</annotation></semantics></math></div>
<p>The key is that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> is the free symmetric monoidal linear Cauchy-complete category on one generator.</p>

<div class="query">
<p><a class="existingWikiWord" href="/nlab/show/John+Baez">John Baez</a>: I added explanatory remarks above. Okay?</p>
</div>

<h2 id="representability">Representability</h2>

<p>To build a bridge from abstract Schur functors as pseudonatural transformations to the more classical descriptions, we start with the following key result. In what follows we use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">k \mathbb{P}</annotation></semantics></math> to denote the ‘linearization’ of the permutation groupoid: that is, the linear category formed by replacing the homsets in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math> by the free vector spaces on those homsets. We use <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math> to denote the Cauchy completion of the linearization of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math>. As we shall see, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math> is equivalent to the category of Schur functors. But first:</p>

<div class="num_theorem">
<h6 id="theorem">Theorem</h6>

<p>The underlying 2-functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>SymMonLinCauch</mi><mo>→</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">U: SymMonLinCauch \to Cat</annotation></semantics></math></div>
<p>is represented by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math>. In other words:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>≃</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">   U(-) \simeq hom(-, \widebar{k \mathbb{P}}) </annotation></semantics></math></div></div>

<div class="proof">
<h6 id="proof_sketch">Proof (Sketch)</h6>

<p>It is well-known that the permutation category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math>, whose objects are integers <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m \geq 0</annotation></semantics></math> and whose morphisms are precisely automorphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m \to m</annotation></semantics></math> given by permutation groups <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>m</mi></msub></mrow><annotation encoding="application/x-tex">S_m</annotation></semantics></math>, is the representing object for the underlying 2-functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>0</mn></msub><mo>:</mo><mi>SymMonCat</mi><mo>→</mo><mi>Cat</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">U_0: SymMonCat \to Cat \, .</annotation></semantics></math></div>
<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SymMonLin</mi></mrow><annotation encoding="application/x-tex">SymMonLin</annotation></semantics></math> denote the 2-category of small symmetric monoidal linear (but not necessarily Cauchy complete) categories, and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Lin</mi></mrow><annotation encoding="application/x-tex">Lin</annotation></semantics></math> denote the 2-category of small linear categories. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>Cat</mi><mo>→</mo><mi>Lin</mi></mrow><annotation encoding="application/x-tex">k(-): Cat \to Lin</annotation></semantics></math> denote linearization, given by change of base</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>⋅</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>:</mo><mi>Set</mi><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">k \cdot - : Set \to Vect</annotation></semantics></math></div>
<p>applied to a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>-enriched category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>,</mo><mi>hom</mi><mo>:</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>→</mo><mi>Set</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C_0, hom: C_0 \times C_0 \to Set)</annotation></semantics></math> to yield a linear category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>→</mo><mi>Vect</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C_0, C_0 \times C_0 \to Vect)</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>Cat</mi><mo>→</mo><mi>Lin</mi></mrow><annotation encoding="application/x-tex">k(-): Cat \to Lin</annotation></semantics></math> is left 2-adjoint to the underlying 2-functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>0</mn></msub><mo>:</mo><mi>Lin</mi><mo>→</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">U_0: Lin \to Cat</annotation></semantics></math>. For this, we use the fact that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> is a nice closed category (here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>) – in particular cocomplete – then the lax monoidal functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>I</mi><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>V</mi><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">\hom(I, -): V \to Set</annotation></semantics></math> has a left adjoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⋅</mo><mi>I</mi><mo>:</mo><mi>Set</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">- \cdot I: Set \to V</annotation></semantics></math> (here linearization) which is strong (symmetric) monoidal. This induces a 2-functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo>=</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">Cat = Set</annotation></semantics></math>-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Cat \to V</annotation></semantics></math>-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math> which is strong 2-symmetric monoidal. It therefore sends symmetric pseudomonoids in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math> to symmetric pseudomonoids in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math>. In other words, it sends symmetric monoidal categories to symmetric monoidal linear categories. Therefore, the 2-adjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>⊣</mo><msub><mi>U</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">k(-) \dashv U_0</annotation></semantics></math> between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>LinCat</mi></mrow><annotation encoding="application/x-tex">LinCat</annotation></semantics></math> lifts to one between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SymMonCat</mi></mrow><annotation encoding="application/x-tex">SymMonCat</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SymMonLinCat</mi></mrow><annotation encoding="application/x-tex">SymMonLinCat</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>SymMonCat</mi><mo>→</mo><mi>SymMonLin</mi><mo stretchy="false">)</mo><mo>⊣</mo><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo>:</mo><mi>SymMonLin</mi><mo>→</mo><mi>SymMonCat</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k(-): SymMonCat \to SymMonLin) \dashv (U_1: SymMonLin \to SymMonCat)</annotation></semantics></math></div>
<p>Finally, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>LinCauch</mi></mrow><annotation encoding="application/x-tex">LinCauch</annotation></semantics></math> denote the 2-category of small Cauchy complete linear categories. The linear Cauchy completion gives a 2-reflector <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><mo>¯</mo></mover><mo>:</mo><mi>Lin</mi><mo>→</mo><mi>LinCat</mi></mrow><annotation encoding="application/x-tex">\widebar{(-)}: Lin \to LinCat</annotation></semantics></math> which is left 2-adjoint to the 2-embedding <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>LinCauch</mi><mo>→</mo><mi>Lin</mi></mrow><annotation encoding="application/x-tex">i: LinCauch \to Lin</annotation></semantics></math>, and again the 2-adjunction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><mo>¯</mo></mover><mo>⊣</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\widebar{(-)} \dashv i</annotation></semantics></math> lifts to the level of symmetric monoidal structure to give a 2-adjunction</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mover><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><mo>¯</mo></mover><mo>:</mo><mi>SymMonLin</mi><mo>→</mo><mi>SymMonLinCauch</mi><mo stretchy="false">)</mo><mo>⊣</mo><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo>:</mo><mi>SymMonLinCauch</mi><mo>→</mo><mi>SymMonLin</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\widebar{(-)}: SymMonLin \to SymMonLinCauch) \dashv (U_2: SymMonLinCauch \to SymMonLin)</annotation></semantics></math></div>
<p>For this, the key fact is that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \otimes B</annotation></semantics></math> denotes the tensor product of two <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-enriched categories, then there is a canonical enriched functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>A</mi><mo>¯</mo></mover><mo>⊗</mo><mover><mi>B</mi><mo>¯</mo></mover><mo>≃</mo><mover><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A} \otimes \overline{B} \simeq \overline{A \otimes B}</annotation></semantics></math> making Cauchy completion into a lax 2-monoidal functor on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math>. Even better, it is lax 2-symmetric monoidal. So, it sends symmetric pseudomonoids to symmetric pseudomonoids. In this case, then, it sends symmetric monoidal linear categories to symmetric monoidal linear Cauchy-complete categories.</p>

<p>Putting this all together, the underlying functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>SymMonLinCauch</mi><mo>→</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">U: SymMonLinCauch \to Cat</annotation></semantics></math> is the evident composite</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>SymMonLinCauch</mi><mover><mo>→</mo><mrow><msub><mi>U</mi> <mn>2</mn></msub></mrow></mover><mi>SymMonLin</mi><mover><mo>→</mo><mrow><msub><mi>U</mi> <mn>1</mn></msub></mrow></mover><mi>SymMonCat</mi><mover><mo>→</mo><mrow><msub><mi>U</mi> <mn>0</mn></msub></mrow></mover><mi>Cat</mi></mrow><annotation encoding="application/x-tex">SymMonLinCauch \stackrel{U_2}{\to} SymMonLin \stackrel{U_1}{\to} SymMonCat \stackrel{U_0}{\to} Cat</annotation></semantics></math></div>
<p>and therefore we have pseudonatural equivalences</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>SymMonLinCauch</mi><mo stretchy="false">(</mo><mover><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>ℙ</mi><mo stretchy="false">)</mo></mrow><mo>¯</mo></mover><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mtd> <mtd><mo>≅</mo></mtd> <mtd><mi>SymMonLin</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">(</mo><mi>ℙ</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>U</mi> <mn>2</mn></msub><mo>−</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><mi>SymMonCat</mi><mo stretchy="false">(</mo><mi>ℙ</mi><mo>,</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mi>U</mi> <mn>2</mn></msub><mo>−</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><msub><mi>U</mi> <mn>0</mn></msub><msub><mi>U</mi> <mn>1</mn></msub><msub><mi>U</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≅</mo></mtd> <mtd><mi>U</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{
SymMonLinCauch(\widebar{k(\mathbb{P})}, -) &amp; \cong &amp; SymMonLin(k(\mathbb{P}), U_2 -) \\
 &amp; \cong &amp; SymMonCat(\mathbb{P}, U_1 U_2 -) \\
 &amp; \cong &amp; U_0 U_1 U_2 \\
 &amp; \cong &amp; U
}
</annotation></semantics></math></div>
<p>so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math> is the representing object.</p>
</div>

<div class="query">
<p><a class="existingWikiWord" href="/nlab/show/John+Baez">John Baez</a>: I took remarks from the query box here and used them to improve the proof above. However, it could still use more improvement. Could you polish it up a bit, Todd?</p>
</div>

<h3 id="structure_of_the_representing_object">Structure of the representing object</h3>

<p>Let us now calculate <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math>. In general, the linear Cauchy completion of a linear category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> consists of the full subcategory of linear presheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">C^{op} \to Vect</annotation></semantics></math> that are obtained as retracts of finite direct sums of representables <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">C(-, c): C^{op} \to Vect</annotation></semantics></math>. In the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><mi>k</mi><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">C = k\mathbb{P}</annotation></semantics></math>, these are the functors</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><msup><mi>ℙ</mi> <mi>op</mi></msup><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">F: \mathbb{P}^{op} \to FinVect</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(n) = 0</annotation></semantics></math> for large enough <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. For it is clear that this category contains the representables and is closed under finite direct sums and retracts. On the other hand, every polynomial <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is a sum of monomials <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>⊕</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⊕</mo><mi>⋯</mi><mo>⊕</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(0) \oplus F(1) \oplus \cdots \oplus F(n)</annotation></semantics></math>, and by Maschke’s theorem, each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">S_j</annotation></semantics></math>-module <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(j)</annotation></semantics></math> is the retract of a finite sum of copies of the group algebra <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>j</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_j]</annotation></semantics></math> which corresponds to the representable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mi>ℙ</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k\mathbb{P}(-, j)</annotation></semantics></math>.</p>

<p>So, inspired by Joyal’s work on <a class="existingWikiWord" href="/nlab/show/combinatorial+species">combinatorial species</a>, we make the following definition:</p>

<div class="num_defn">
<h6 id="definition_6">Definition</h6>

<p>A <strong>polynomial species</strong> is a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><msup><mi>ℙ</mi> <mi>op</mi></msup><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">F: \mathbb{P}^{op} \to FinVect</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(n) = 0</annotation></semantics></math> for all sufficiently large <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. A morphism of polynomial species is a natural transformation between such functors.</p>
</div>

<p>As we have mentioned, the category of polynomial species inherits two monoidal structures from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math> via <a class="existingWikiWord" href="/nlab/show/Day+convolution">Day convolution</a>. Most important is the one coming from the <em>additive</em> monoidal structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}</annotation></semantics></math>, which is given on the level of objects by adding natural numbers, and on the morphism level given by group homomorphisms</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>m</mi></msub><mo>×</mo><msub><mi>S</mi> <mi>n</mi></msub><mo>→</mo><msub><mi>S</mi> <mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_m \times S_n \to S_{m+n}</annotation></semantics></math></div>
<p>which juxtapose permutations. This can be linearized to give algebra maps</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>m</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>→</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_m] \otimes k[S_n] \to k[S_{m+n}]</annotation></semantics></math></div>
<p>which give the monoidal category structure of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">k\mathbb{P}</annotation></semantics></math>. This monoidal structure uniquely extends via <a class="existingWikiWord" href="/nlab/show/Day+convolution">Day convolution</a> to the Cauchy completion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k\mathbb{P}}</annotation></semantics></math>, which is intermediate between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">k\mathbb{P}</annotation></semantics></math> and the category of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>-valued presheaves on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mi>ℙ</mi></mrow><annotation encoding="application/x-tex">k\mathbb{P}</annotation></semantics></math>. The general formula for the Day convolution product applied to presheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>,</mo><mi>G</mi><mo>:</mo><msup><mi>ℙ</mi> <mi>op</mi></msup><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">F, G: \mathbb{P}^{op} \to Vect</annotation></semantics></math> is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>G</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>j</mi></msub><mo>×</mo><msub><mi>S</mi> <mi>k</mi></msub></mrow></msub><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(F G)(n) = \sum_{j+k = n} (F(j) \otimes G(k)) \otimes_{S_j \times S_k} k[S_n]</annotation></semantics></math></div>
<div class="query">
<p><a class="existingWikiWord" href="/nlab/show/John+Baez">John Baez</a>: Todd had written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> where I have put <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> here. Okay?</p>
</div>

<p>or, in other notation,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>n</mi></mrow></munder><msubsup><mi>Ind</mi> <mrow><msub><mi>S</mi> <mi>j</mi></msub><mo>×</mo><msub><mi>S</mi> <mi>k</mi></msub></mrow> <mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow></msubsup><mi>F</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>G</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F G)(n) = \sum_{j+k = n} Ind_{S_j \times S_k}^{S_n} F(j) \otimes G(k)</annotation></semantics></math></div>
<p>and by restriction this formula gives a tensor product on polynomial species. This tensor product is a kind of categorification of the usual definition of product of ordinary polynomials, where given</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>M</mi></mrow></munder><mfrac><mrow><msub><mi>f</mi> <mi>j</mi></msub><msup><mi>x</mi> <mi>j</mi></msup></mrow><mrow><mi>j</mi><mo>!</mo></mrow></mfrac><mspace width="2em"></mspace><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>N</mi></mrow></munder><mfrac><mrow><msub><mi>g</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mrow><mrow><mi>k</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">F(x) = \sum_{0 \leq j \leq M} \frac{f_j x^j}{j!} \qquad G(x) = \sum_{0 \leq k \leq N} \frac{g_k x^k}{k!}</annotation></semantics></math></div>
<p>the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>n</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">n^{th}</annotation></semantics></math> Taylor coefficient of the product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x)G(x)</annotation></semantics></math> is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>n</mi></mrow></munder><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><mi>j</mi><mo>!</mo><mi>k</mi><mo>!</mo></mrow></mfrac><msub><mi>f</mi> <mi>j</mi></msub><msub><mi>g</mi> <mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{j+k = n} \frac{n!}{j! k!} f_j g_k</annotation></semantics></math></div>
<p>So in summary:</p>

<div class="num_theorem">
<h6 id="theorem_2">Theorem</h6>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math> is equivalent to the symmetric monoidal category of polynomial species.</p>
</div>

<p>Now, having defined Schur functors abstractly as pseudonatural transformations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">U \to U</annotation></semantics></math>, the representability theorem together with the 2-categorical Yoneda lemma means that the category of Schur functors is equivalent to the category of symmetric monoidal linear functors on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math>. Accordingly, we calculate</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>U</mi><mo>,</mo><mi>U</mi><mo stretchy="false">]</mo><mo>≅</mo><mi>SymMonLinCauch</mi><mo stretchy="false">(</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>,</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo stretchy="false">)</mo><mo>≅</mo><mi>U</mi><mo stretchy="false">(</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[U, U] \cong SymMonLinCauch(\widebar{k\mathbb{P}}, \widebar{k\mathbb{P}}) \cong U(\widebar{k\mathbb{P}})</annotation></semantics></math></div>
<p>In other words,</p>

<div class="num_theorem">
<h6 id="theorem_3">Theorem</h6>

<p>The category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> is equivalent to the category of polynomial species <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℙ</mi> <mi>op</mi></msup><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}^{op} \to FinVect</annotation></semantics></math>.</p>
</div>

<p>NB: This theorem refers only to the underlying category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(\overline{k\mathbb{P}})</annotation></semantics></math>. In other words, this category certainly has linear tensor category structure as well, but this structure is not respected by Schur functor composition which we consider next.</p>

<h2 id="composition_of_schur_functors">Composition of Schur functors</h2>

<p>Now we consider composition of Schur functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">U \to U</annotation></semantics></math>, or equivalently symmetric monoidal linear functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>→</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k\mathbb{P}} \to \widebar{k \mathbb{P}}</annotation></semantics></math>. Composition endows <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>U</mi><mo>,</mo><mi>U</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[U, U]</annotation></semantics></math> with a monoidal structure, and this monoidal structure transfers across the equivalence of the preceding theorem to a monoidal structure on the underlying category of Schur functors, or equivalently, polynomial species <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℙ</mi> <mi>op</mi></msup><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}^{op} \to FinVect</annotation></semantics></math>. We proceed to analyze this monoidal structure.</p>

<p>It may be easier to do this in reverse. Any Schur functor may regarded as a functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mn>1</mn><mover><mo>→</mo><mi>F</mi></mover><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">1 \stackrel{F}{\to} \overline{k\mathbb{P}}  \, .</annotation></semantics></math></div>
<p>This induces a symmetric monoidal functor, unique up to (unique) symmetric monoidal isomorphism:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi><mover><mo>→</mo><mrow><msup><mi>F</mi> <mo>∼</mo></msup></mrow></mover><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>:</mo><mi>m</mi><mo>↦</mo><msup><mi>F</mi> <mrow><mo>⊗</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbb{P} \stackrel{F^\sim}{\to}\overline{k\mathbb{P}}: m \mapsto F^{\otimes m}</annotation></semantics></math></div>
<p>Here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>F</mi> <mrow><mo>⊗</mo><mi>m</mi></mrow></msup></mrow><annotation encoding="application/x-tex">F^{\otimes m}</annotation></semantics></math> is a Day convolution product of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> copies of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>. Finally, the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>F</mi> <mo>∼</mo></msup></mrow><annotation encoding="application/x-tex">F^\sim</annotation></semantics></math> is linearized and extended (uniquely) to the linear Cauchy completion, to give a symmetric monoidal linear functor on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\widebar{k \mathbb{P}}</annotation></semantics></math>. The efficient tensor product description is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><msub><mo>⊗</mo> <mi>ℙ</mi></msub><msup><mi>F</mi> <mo>∼</mo></msup><mo>:</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>→</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">- \otimes_{\mathbb{P}} F^\sim: \overline{k\mathbb{P}} \to \overline{k\mathbb{P}}</annotation></semantics></math></div>
<p>as this manifestly preserves colimits in the blank argument and therefore all colimits needed for the Cauchy completion. (And since the extension to the Cauchy completion is unique, this formula must be correct! The only question is whether this functor is valued in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{k\mathbb{P}}</annotation></semantics></math>.)</p>

<p>In the language of species, this construction is called the <em>substitution product</em>, and is denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \circ F</annotation></semantics></math>. This is morally correct because it is indeed an appropriate categorification of polynomial composition. However, to avoid overloading the symbol <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math> in ways that might be confusing, we will rename it <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>⊠</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \boxtimes F</annotation></semantics></math>. Thus,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>⊠</mo><mi>F</mi><mo>=</mo><mi>G</mi><msub><mo>⊗</mo> <mi>ℙ</mi></msub><msup><mi>F</mi> <mo>∼</mo></msup></mrow><annotation encoding="application/x-tex">G \boxtimes F = G \otimes_{\mathbb{P}} F^\sim</annotation></semantics></math></div>
<p>In notation which looks slightly less abstract, this is the Schur object given by the formula</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo>⊠</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></munder><mi>G</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>k</mi></msub></mrow></msub><msup><mi>F</mi> <mrow><mo>⊗</mo><mi>k</mi></mrow></msup><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G \boxtimes F)(n) = \sum_{k \geq 0} G(k) \otimes_{S_k} F^{\otimes k}(n)</annotation></semantics></math></div>
<p>It should be noted that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo>⊠</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G \boxtimes F)(n)</annotation></semantics></math> is indeed <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mo stretchy="false">(</mo><mi>deg</mi><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>deg</mi><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n \gt (deg G)(deg F)</annotation></semantics></math>, so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>⊠</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \boxtimes F</annotation></semantics></math> is indeed a polynomial species. It is just the polynomial special case of the substitution product which is defined on general <strong>linear species</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>,</mo><mi>G</mi><mo>:</mo><msup><mi>ℙ</mi> <mi>op</mi></msup><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">F, G: \mathbb{P}^{op} \to Vect</annotation></semantics></math>.</p>

<div class="num_prop">
<h6 id="proposition_2">Proposition</h6>

<p>The product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊠</mo></mrow><annotation encoding="application/x-tex">\boxtimes</annotation></semantics></math> makes the category of polynomial species into a monoidal category. The unit for this product is polynomial species <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> given by the representable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℙ</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>:</mo><msup><mi>ℙ</mi> <mi>op</mi></msup><mo>→</mo><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">\mathbb{P}(-, 1): \mathbb{P}^{op} \to FinVect</annotation></semantics></math>.</p>
</div>

<div class="proof">
<h6 id="proof_sketch_2">Proof (Sketch)</h6>

<p>The following proof is adapted from a similar argument due to Max Kelly [ref]: we exhibit an associativity isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo>:</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⊠</mo><mi>G</mi><mo>→</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mo stretchy="false">(</mo><mi>F</mi><mo>⊠</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha: (- \boxtimes F) \boxtimes G \to - \boxtimes (F \boxtimes G)</annotation></semantics></math> on the basis of universal properties. The point is that by the universal property of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{k\mathbb{P}}</annotation></semantics></math>, the category of functors</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mn>1</mn><mo>→</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">F: 1 \to \overline{k\mathbb{P}}</annotation></semantics></math></div>
<p>is equivalent to the category of symmetric monoidal linear functors</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo>:</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>→</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">H: \overline{k\mathbb{P}} \to \overline{k\mathbb{P}}</annotation></semantics></math></div>
<p>The correspondence in one direction takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> to the symmetric monoidal functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">H = - \boxtimes F</annotation></semantics></math>, and in the other direction takes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F = H(X)</annotation></semantics></math>. By the equivalence, we have a unit isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>⊠</mo><mi>F</mi><mo>≅</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">X \boxtimes F \cong F</annotation></semantics></math>. Also by this equivalence, symmetric monoidal linear transformations between symmetric monoidal linear functors of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⊠</mo><mi>G</mi><mo>→</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mo stretchy="false">(</mo><mi>F</mi><mo>⊠</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(- \boxtimes F) \boxtimes G \to - \boxtimes (F \boxtimes G)</annotation></semantics></math></div>
<p>are in natural bijection with morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>⊠</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⊠</mo><mi>G</mi><mo>→</mo><mi>X</mi><mo>⊠</mo><mo stretchy="false">(</mo><mi>F</mi><mo>⊠</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \boxtimes F) \boxtimes G \to X \boxtimes (F \boxtimes G)</annotation></semantics></math>, which by the unit isomorphism reduce to morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>⊠</mo><mi>G</mi><mo>→</mo><mi>F</mi><mo>⊠</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \boxtimes G \to F \boxtimes G</annotation></semantics></math>. Thus, corresponding to the identity on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>⊠</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \boxtimes G</annotation></semantics></math> we obtain an associativity map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi><mo>:</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⊠</mo><mi>G</mi><mo>→</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mo stretchy="false">(</mo><mi>F</mi><mo>⊠</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha: (- \boxtimes F) \boxtimes G \to - \boxtimes (F \boxtimes G)</annotation></semantics></math>. By similar arguments that appeal to the universal property of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{k \mathbb{P}}</annotation></semantics></math>, we get all the required axioms: the invertibility of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>, the pentagon, etc.</p>
</div>

<p>To summarize: we have equivalences between</p>

<ul>
<li>
<p>The category of pseudonatural transformations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>→</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">U \to U</annotation></semantics></math>;</p>
</li>

<li>
<p>The category of symmetric monoidal linear functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>→</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{k\mathbb{P}} \to \overline{k \mathbb{P}}</annotation></semantics></math>;</p>
</li>

<li>
<p>The category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi><mo>=</mo><mi>U</mi><mo stretchy="false">(</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Schur = U(\overline{k\mathbb{P}})</annotation></semantics></math>.</p>
</li>
</ul>

<p>The equivalence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi><mo>→</mo><mi>SymMonLinCauch</mi><mo stretchy="false">(</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>,</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Schur \to SymMonLinCauch(\overline{k \mathbb{P}}, \overline{k \mathbb{P}})</annotation></semantics></math> takes a polynomial species <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">- \boxtimes F</annotation></semantics></math>. Moreover, the associativity isomorphism is precisely a structure</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mi>G</mi><mo stretchy="false">)</mo><mo>∘</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mi>F</mi><mo stretchy="false">)</mo><mo>→</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>⊠</mo><mo stretchy="false">(</mo><mi>F</mi><mo>⊠</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(- \boxtimes G) \circ (- \boxtimes F) \to - \boxtimes (F \boxtimes G)</annotation></semantics></math></div>
<p>of strong monoidal equivalence from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Schur</mi><mo>,</mo><mo>⊠</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Schur, \boxtimes)</annotation></semantics></math> to the monoidal category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SymMonLinCauch</mi><mo stretchy="false">(</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo>,</mo><mover><mrow><mi>k</mi><mi>ℙ</mi></mrow><mo>¯</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SymMonLinCauch(\overline{k\mathbb{P}}, \overline{k\mathbb{P}})</annotation></semantics></math> under endofunctor composition. (The hexagonal coherence condition for a monoidal functor follows from the pentagon; one side of the hexagon is an identity since endofunctor composition is a strict monoidal product.)</p>

<p>The tensor product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊠</mo></mrow><annotation encoding="application/x-tex">\boxtimes</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Schur</mi></mrow><annotation encoding="application/x-tex">Schur</annotation></semantics></math> goes by another name: it is the <strong>plethystic tensor product</strong>.</p>

<h2 id="related_concepts">Related concepts</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/plethory">plethory</a></li>

<li><a class="existingWikiWord" href="/nlab/show/Specht+module">Specht module</a></li>
</ul>

<h2 id="references">References</h2>

<p>A nice introduction to Schur functors can be found here:</p>

<ul>
<li>William Fulton and Joe Harris, <em>Representation Theory: a First Course</em>, Springer, Berlin, 1991.</li>
</ul>

<p>For a quick online introduction to <a class="existingWikiWord" href="/nlab/show/Young+tableaux">Young tableaux</a> and representations of the <a class="existingWikiWord" href="/nlab/show/symmetric+groups">symmetric groups</a>, try:</p>

<ul>
<li>Yufei Zhao, Young tableaux and the representations of the symmetric group, MIT. (<a href="http://www.thehcmr.org/issue2_2/tableaux.pdf">web</a>)</li>
</ul>

<p>For more details on these topics, see:</p>

<ul>
<li>
<p>William Fulton, <em>Young Tableaux, with Applications to Representation Theory and Geometry</em>, Cambridge U. Press, 1997.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bruce+E.+Sagan">Bruce E. Sagan</a>, <em>The Symmetric Group: Representations, Combinatorial Algorithms, and Symmetric Functions</em>, Springer, Berlin, 2001.</p>
</li>
</ul>

<p>A treatment of the category of Schur functors as the free 2-rig on one generator is in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/John+Baez">John Baez</a>, <a class="existingWikiWord" href="/nlab/show/Joe+Moeller">Joe Moeller</a>, <a class="existingWikiWord" href="/nlab/show/Todd+Trimble">Todd Trimble</a>, <em>Schur functors and categorified plethysm</em>, (<a href="https://arxiv.org/abs/2106.00190">arXiv:2106.00190</a>)</li>
</ul>

<p><a class="existingWikiWord" href="/nlab/show/species">Species</a> were invented here:</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Andr%C3%A9+Joyal">André Joyal</a>, Une théorie combinatoire des séries formelles, <em>Adv. Math</em> <strong>42</strong> (1981), 1–82.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Andr%C3%A9+Joyal">André Joyal</a>: Foncteurs analytiques et espèces des structures, in <em>Combinatoire Énumérative</em>, Lecture Notes in Mathematics <strong>1234</strong>, Springer, Berlin, 1986, pp. 126–159.</p>
</li>
</ul>

<p>A standard reference on species is:</p>

<ul>
<li>François Bergeron, Gilbert Labelle, Pierre Leroux, <em>Combinatorial Species and Tree-like Structures</em>, Cambridge University Press, Cambridge 1998.</li>
</ul>

<p>Here is an important new book on combinatorics which emphasizes the use of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>-valued species:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Marcelo+Aguiar">Marcelo Aguiar</a> and <a class="existingWikiWord" href="/nlab/show/Swapneel+Mahajan">Swapneel Mahajan</a>, <em>Monoidal Functors, Species and Hopf Algebras</em>, to be published by Cambridge U. Press. (<a href="http://www.math.tamu.edu/~maguiar/a.pdf">web</a>)</li>

<li>Kaan Akin, David A Buchsbaum, Jerzy Weyman, <em>Schur functors and Schur complexes</em>, Adv. Math. <strong>44</strong>:3 (1982) 207-278</li>

<li>Marcin Chałupnik, <em>Extensions of Weyl and Schur functors</em>, Homology, Homotopy and Applications 11(2), s. 27-48, 2009.</li>
</ul>

<p>See also</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Martin+Brandenburg">Martin Brandenburg</a>, <em>Operations on categories of modules are given by Schur functors</em> (<a href="https://arxiv.org/abs/1610.02180">arXiv:1610.02180</a>)</li>
</ul>

<h2 id="old_stuff">Old Stuff</h2>

<p><a class="existingWikiWord" href="/nlab/show/John+Baez">John Baez</a>: this stuff should go somewhere, perhaps:</p>

<div class="query">
<p>The first thing that should be understood from the beginning is that a general Schur functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is <em>nonlinear</em>: the action on <a class="existingWikiWord" href="/nlab/show/hom-set">hom-sets</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>W</mi><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hom(V, W) \to hom(F(V), F(W))</annotation></semantics></math></div>
<p>is not assumed to respect the linear structure. In fact, linear Schur functors are rather uninteresting: because every finite-dimensional space is a finite <a class="existingWikiWord" href="/nlab/show/direct+sum">direct sum</a> of copies of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>-dimensional space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℂ</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math>, and because <a class="existingWikiWord" href="/nlab/show/linear+functor">linear functors</a> preserve finite direct sums (that is, <a class="existingWikiWord" href="/nlab/show/biproduct">biproducts</a>, it turns out that every linear Schur functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/representable+functor">representable</a> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hom(X, -)</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>ℂ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X = F(\mathbb{C})</annotation></semantics></math>. So, the category of linear Schur functors is equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FinVect</mi></mrow><annotation encoding="application/x-tex">FinVect</annotation></semantics></math>.</p>
</div>

<p><a class="existingWikiWord" href="/nlab/show/John+Baez">John Baez</a>: This stuff should get worked into the discussion near the end of how Schur functors are like polynomials…</p>

<div class="query">
<h3 id="modules_over_a_bimonoid">Modules over a bimonoid</h3>

<p>Next we exploit the fact that, just like any <a class="existingWikiWord" href="/nlab/show/group+algebra">group algebra</a>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/bialgebra">bialgebra</a> — or in fancier language, a <a class="existingWikiWord" href="/nlab/show/bimonoid">bimonoid</a> in the <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+category">symmetric monoidal category</a> <a class="existingWikiWord" href="/nlab/show/FinVect">FinVect</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mrow></mrow> <mi>k</mi></msub></mrow><annotation encoding="application/x-tex">{}_k</annotation></semantics></math>. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo lspace="verythinmathspace">:</mo><msub><mi>FinVect</mi> <mi>k</mi></msub><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">i \colon FinVect_k \to C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+functor">symmetric monoidal functor</a>, this means that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> carries <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> to a bimonoid in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. As noted above, we call this bimonoid by the same name, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math>.</p>

<p>The <a class="existingWikiWord" href="/nlab/show/category+of+modules">category of modules</a> over a <a class="existingWikiWord" href="/nlab/show/bimonoid">bimonoid</a> is a <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal category</a>. More explicitly, in the case of the bimonoid <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> with comultiplication</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>→</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">\delta: k[S_n] \to k[S_n] \otimes k[S_n] \,,</annotation></semantics></math></div>
<p>the tensor product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">V \otimes W</annotation></semantics></math> of two <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math>-modules in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> carries a module structure where the action is defined by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><mi>V</mi><mo>⊗</mo><mi>W</mi><mover><mo>→</mo><mrow><mi>δ</mi><mo>⊗</mo><msub><mn>1</mn> <mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow></msub></mrow></mover><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><mi>V</mi><mo>⊗</mo><mi>W</mi><mover><mo>→</mo><mrow><mn>1</mn><mo>⊗</mo><mi>σ</mi><mo>⊗</mo><mn>1</mn></mrow></mover><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><mi>V</mi><mo>⊗</mo><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><mi>W</mi><mover><mo>→</mo><mrow><msub><mi>α</mi> <mi>V</mi></msub><mo>⊗</mo><msub><mi>α</mi> <mi>W</mi></msub></mrow></mover><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">k[S_n] \otimes V \otimes W \stackrel{\delta \otimes 1_{V \otimes W}}{\to} k[S_n] \otimes k[S_n] \otimes V \otimes W \stackrel{1 \otimes \sigma \otimes 1}{\to} k[S_n] \otimes V \otimes k[S_n] \otimes W \stackrel{\alpha_V \otimes \alpha_W}{\to} V \otimes W</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is a symmetry isomorphism and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>α</mi> <mi>V</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_V</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>α</mi> <mi>W</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_W</annotation></semantics></math> are the actions on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math>.</p>

<p>Now we consider a particular case of tensor product representations. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is an object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, the symmetric group <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math> has a representation on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n}</annotation></semantics></math>. (Indeed, for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sigma \in S_n</annotation></semantics></math>, there is a corresponding symmetry isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{\otimes n} \to X^{\otimes n}</annotation></semantics></math>. From this one may construct an action</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>≅</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨁</mo> <mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow></munder><mi>I</mi><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">k[S_n] \otimes X^{\otimes n} \cong \bigoplus_{\sigma \in S_n} I \otimes X^{\otimes n} \to X^{\otimes n}</annotation></semantics></math></div>
<p>which is the required representation.) So, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>ν</mi></msub></mrow><annotation encoding="application/x-tex">V_\nu</annotation></semantics></math> is a Young tableau representation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, we obtain a tensor product representation</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V_\nu \otimes X^{\otimes n}</annotation></semantics></math></div>
<p>of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>S</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[S_n]</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>Consider next the <strong>averaging operator</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msub><mo lspace="thinmathspace" rspace="thinmathspace">∑</mo> <mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow></msub><mi>σ</mi></mrow><annotation encoding="application/x-tex">e = \frac1{n!} \sum_{\sigma \in S_n} \sigma</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>:</mo><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e: V_\nu \otimes X^{\otimes n} \to V_\nu \otimes X^{\otimes n}</annotation></semantics></math></div>
<p>This operator makes sense since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> has characteristic zero, and crucially, this operator is <em>idempotent</em> (because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>=</mo><mi>σ</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">e = \sigma e</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sigma \in S_n</annotation></semantics></math>). Because we assume idempotents split in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, we have a (split) coequalizer</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mover><munder><mo>→</mo><mn>1</mn></munder><mover><mo>→</mo><mi>e</mi></mover></mover><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo>→</mo><msub><mi>V</mi> <mi>ν</mi></msub><msub><mo>⊗</mo> <mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow></msub><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V_\nu \otimes X^{\otimes n} \stackrel{\overset{e}{\to}}{\underset{1}{\to}} V_\nu \otimes X^{\otimes n} \to V_\nu \otimes_{S_n} X^{\otimes n}</annotation></semantics></math></div>
<p>This <a class="existingWikiWord" href="/nlab/show/coequalizer">coequalizer</a> is indeed the object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S_n</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/coinvariants">coinvariants</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V_\nu \otimes X^{\otimes n}</annotation></semantics></math>, i.e., the joint coequalizer of the diagram consisting of all arrows</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mover><mo>→</mo><mrow><mi>σ</mi><mo>⋅</mo><mo lspace="verythinmathspace" rspace="0em">−</mo></mrow></mover><msub><mi>V</mi> <mi>ν</mi></msub><mo>⊗</mo><msup><mi>X</mi> <mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V_\nu \otimes X^{\otimes n} \stackrel{\sigma \cdot-}{\to} V_\nu \otimes X^{\otimes n}</annotation></semantics></math></div>
<p>ranging over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>∈</mo><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\sigma \in S_n</annotation></semantics></math> (it is the joint coequalizer because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>e</mi><mo>=</mo><mi>σ</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">e = \sigma e</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>).</p>

<p>We may now define the Schur functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>ν</mi></msub></mrow><annotation encoding="application/x-tex">S_\nu</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> attached to a Young tableau <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ν</mi></mrow><annotation encoding="application/x-tex">\nu</annotation></semantics></math>.</p>
</div>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on February  5, 2023 at 08:26:09.
    See the <a href="/nlab/history/Schur+functor" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/Schur+functor" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/13040/#Item_2">Discuss</a><span class="backintime"><a href="/nlab/revision/Schur+functor/98" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/Schur+functor" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/Schur+functor" accesskey="S" class="navlink" id="history" rel="nofollow">History (98 revisions)</a>
  <a href="/nlab/show/Schur+functor/cite" style="color: black">Cite</a>
  <a href="/nlab/print/Schur+functor" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/Schur+functor" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
