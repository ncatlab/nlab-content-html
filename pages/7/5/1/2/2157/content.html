
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      affine space in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      affine space
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/1245/#Item_16" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#definitions'>Definitions</a></li>
<ul>
<li><a href='#summary'>Summary</a></li>
<li><a href='#details_and_comparisons'>Details and comparisons</a></li>
<ul>
<li><a href='#vectorvalued_differences'>Vector-valued differences</a></li>
<li><a href='#two_ternary_operations'>Two ternary operations</a></li>
<li><a href='#one_quaternary_operation'>One quaternary operation</a></li>
<li><a href='#one_ternary_operation'>One ternary operation</a></li>
<li><a href='#unbiased_definition'>Unbiased definition</a></li>
<li><a href='#slice_of_'>Slice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math></a></li>
</ul>
<li><a href='#ClosedMonoidal'>Closed monoidal structure</a></li>
</ul>
<li><a href='#further_remarks'>Further Remarks</a></li>
<li><a href='#affine_spaces_as_model_spaces'>Affine spaces as model spaces</a></li>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>An <strong>affine space</strong> or <strong>affine linear space</strong> is a <a class="existingWikiWord" href="/nlab/show/vector+space">vector space</a> that has forgotten its origin. An <strong>affine linear map</strong> (a morphism of affine spaces) is a linear map (a morphism of vector spaces) that need not preserve the origin.</p>

<p>Note that the ‘linear functions’ of elementary algebra —the total functions whose graphs are lines— are in fact (precisely) <em>affine</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>-linear maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math> to itself. (Similarly, the ‘linear relations’ —the relations whose graphs are lines— are precisely the <em><a class="existingWikiWord" href="/nlab/show/projective+space">projective</a></em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>-linear maps.)</p>

<p>Alternatively, in <a class="existingWikiWord" href="/nlab/show/algebraic+geometry">algebraic geometry</a>, the terminology “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional affine space” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>𝔸</mi> <mi>n</mi></msup><mi>k</mi></mrow><annotation encoding="application/x-tex">\mathbb{A}^n k</annotation></semantics></math> (affine line, affine plane, etc.) over a <a class="existingWikiWord" href="/nlab/show/field">field</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> refers to, depending on context, the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>k</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k^n</annotation></semantics></math>, or the set of maximal ideals of the <a class="existingWikiWord" href="/nlab/show/polynomial+algebra">polynomial algebra</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[x_1, \ldots, x_n]</annotation></semantics></math> – these definitions coinciding if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is an <a class="existingWikiWord" href="/nlab/show/algebraically+closed+field">algebraically closed field</a> – and typically considered as equipped with relevant extra structure such as a <a class="existingWikiWord" href="/nlab/show/Zariski+topology">Zariski topology</a> or, going even further, the <a class="existingWikiWord" href="/nlab/show/locally+ringed+space">locally ringed space</a> structure adhering to the <a class="existingWikiWord" href="/nlab/show/affine+variety">affine variety</a> or <a class="existingWikiWord" href="/nlab/show/affine+scheme">affine scheme</a> corresponding to the polynomial algebra <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[x_1, \ldots, x_n]</annotation></semantics></math>. Whatever the precise sense chosen, the idea is that an affine space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>𝔸</mi> <mi>n</mi></msup><mi>k</mi></mrow><annotation encoding="application/x-tex">\mathbb{A}^n k</annotation></semantics></math> is a setting in which the study of loci of polynomial equations, i.e. definable sets in the theory of <a class="existingWikiWord" href="/nlab/show/commutative+algebras">commutative algebras</a> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>, is carried out.</p>

<p>Most of this article concerns affine spaces in the sense of vector spaces that have forgotten their origins or identities; the algebraic geometry sense is very briefly touched upon in the section <em>Affine spaces as model spaces</em>.</p>

<h2 id="definitions">Definitions</h2>

<h3 id="summary">Summary</h3>

<p>The definition of affine space can be made precise in various (equivalent) ways. We give a name to some of the definitions for later reference.</p>

<ol>
<li>
<p>An affine space is simply a vector space, but with different morphisms; an affine linear map is a function that is the difference between a linear map and a <a class="existingWikiWord" href="/nlab/show/constant+function">constant function</a>.</p>
</li>

<li>
<p>An affine space is a <a class="existingWikiWord" href="/nlab/show/set">set</a> equipped with an equivalence class of vector space structures, where two vector space structures are considered equivalent if the <a class="existingWikiWord" href="/nlab/show/identity+function">identity function</a> is affine linear as a map from one structure to the other; whether a map between affine spaces is affine linear is independent of the representative vector space structures.</p>
</li>

<li>
<p>An affine space is a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with a vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> and an <a class="existingWikiWord" href="/nlab/show/action">action</a> of (the additive group or <em><a class="existingWikiWord" href="/nlab/show/translation+group">translation group</a></em> of) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> that makes <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> into a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/torsor">torsor</a> (over the point); an affine linear map is a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-equivariant map. For this point of view, see also <a class="existingWikiWord" href="/zoranskoda/show/affine+space">affine space</a>.</p>
</li>

<li>
<p>An affine space is a <a class="existingWikiWord" href="/nlab/show/heap">heap</a> whose <a class="existingWikiWord" href="/nlab/show/automorphism+group">automorphism group</a> is equipped with structure making it the additive group of a vector space; an affine linear map is a heap morphism.</p>
</li>

<li>
<p>An affine space is an <a class="existingWikiWord" href="/nlab/show/inhabited+set">inhabited set</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with a vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> and a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\Lambda\colon A \times A \to V</annotation></semantics></math> (thought of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>≔</mo><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\Lambda(x,y) \coloneqq x - y</annotation></semantics></math>) that satisfies some equations; an affine linear map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">A \to A'</annotation></semantics></math> is a function equipped with a linear map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">V \to V'</annotation></semantics></math> relative to which it preserves subtraction (the “vector-valued difference” definition).</p>
</li>

<li>
<p>An affine space over the <a class="existingWikiWord" href="/nlab/show/ground+field">ground field</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is an <a class="existingWikiWord" href="/nlab/show/inhabited+set">inhabited set</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with functions <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mu\colon A \times A \times A \to A</annotation></semantics></math> (thought of as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>≔</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\mu(x,y,z) \coloneqq x - y + z</annotation></semantics></math>) and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mo>*</mo></msub><mo lspace="verythinmathspace">:</mo><mi>k</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Lambda_*\colon k \times A \times A \to A</annotation></semantics></math> (thought of as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>≔</mo><mi>x</mi><mo>−</mo><mi>r</mi><mi>x</mi><mo>+</mo><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\Lambda_r(x,y) \coloneqq x - r x + r y</annotation></semantics></math>) that satisfy some equations; an affine linear map is a function that preserves these operations (the “two ternary operations” definition).</p>
</li>

<li>
<p>An affine space over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is an inhabited set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>μ</mi> <mo>*</mo></msub><mo lspace="verythinmathspace">:</mo><mi>k</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mu_*\colon k\times A\times A\times A\to A</annotation></semantics></math> (thought of as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>μ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>≔</mo><mi>r</mi><mi>x</mi><mo>−</mo><mi>r</mi><mi>y</mi><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\mu_r(x,y,z) \coloneqq r x - r y + z</annotation></semantics></math>) that satisfies some equations; an affine linear map is a function that preserves this operation (the “one quaternary operation”) definition.</p>
</li>

<li>
<p>Assuming that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math> is invertible in the field <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> (i.e. the <a class="existingWikiWord" href="/nlab/show/characteristic">characteristic</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is not <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>), an affine space over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is an inhabited set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mo>*</mo></msub><mo lspace="verythinmathspace">:</mo><mi>k</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Lambda_*\colon k \times A \times A \to A</annotation></semantics></math> that satisfies some equations; an affine linear map is a function that preserves this operation (the “one ternary operation” definition).</p>
</li>

<li>
<p>An affine space over the field <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is an inhabited set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with, for every <a class="existingWikiWord" href="/nlab/show/natural+number">natural number</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \geq 0</annotation></semantics></math> and every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math>-tuple <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_0,\dots,r_n)</annotation></semantics></math> of elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_0 + \dots + r_n = 1</annotation></semantics></math>, a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>γ</mi> <mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub></mrow></msub><mo lspace="verythinmathspace">:</mo><msup><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\gamma_{r_0,\ldots,r_n}\colon A^{n+1}\to A</annotation></semantics></math> (thought of as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>γ</mi> <mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>≔</mo><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\gamma_{r_0,\ldots,r_n}(x_0,\ldots,x_n) \coloneqq r_0 x_0 + \cdots + r_n x_n</annotation></semantics></math>), satisfying some equations; an affine linear map is a function that preserves these operations (the “<a class="existingWikiWord" href="/nlab/show/unbiased">unbiased</a>” definition).</p>
</li>

<li>
<p>An affine space over the field <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is a vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">A'</annotation></semantics></math> together with a surjective linear map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\pi:A'\to k</annotation></semantics></math> (the “slice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>” definition). The affine space itself (the set being regarded as equipped with affine-space structure) is the fiber <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi^{-1}(1)</annotation></semantics></math>.</p>
</li>
</ol>

<div class="query">
<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: I think there should also be a definition of the form “an affine space is a <a class="existingWikiWord" href="/nlab/show/projective+space">projective space</a>” with a distinguished line called “infinity”, which should also be equivalent to a “synthetic” description involving points and lines and incidence axioms. This definition would not fix the field <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> at the outset, but rather recover it synthetically using cross-ratios. Accordingly, it ought to define an equivalent groupoid to the groupoid of pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k,A)</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is a field and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is an affine space over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. I don’t know how one could recover the non-invertible affine transformations from it directly.</p>
</div>

<div class="query">
<p>There should be another characterisation, which I don't quite see how to phrase, at least when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi><mo>=</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">k = \mathbb{R}</annotation></semantics></math>, which is that an affine space is a manifold (perhaps Riemannian) that is sufficiently flat and unbounded in some sense. —Toby</p>

<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: It’d have to be at least Riemannian, otherwise you don’t have enough structure. I don’t suppose it’s enough to say that a (finitely generated) affine space is a Riemannian manifold isometric to some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℝ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math>?</p>

<p><em>Toby</em>: I intended ‘that is [] in some sense’ to include the possibility of structure that should be preserved by the morphisms. Note that a Riemannian manifold is <em>too much</em> structure, although it allows a definition like the first one above. (A Riemannian manifold isometric to some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℝ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math> is precisely a <a class="existingWikiWord" href="/nlab/show/Euclidean+space">Euclidean space</a>.) But really, I'm hoping for some phrasing such that ‹isomorphic to some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℝ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math>› actually becomes a (not too obvious) <em>theorem</em>. I'll keep thinking about it.</p>

<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: Shouldn’t a Riemannian manifold isometric to some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℝ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math> be a “Euclidean affine space” (a torsor over a Euclidean space)? Seems that a Euclidean space would be a Riemannian manifold <em>equipped with</em> an isometry to some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℝ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math>. It does seem like there should be a natural way to say this, but I don’t know what it is.</p>

<p><em>Toby</em>: I guess that this depends on what you think ‘Euclidean space’ means; I've known people to define it to <em>be</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>ℝ</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^n</annotation></semantics></math>, but that seems quite ahistorical to me; I like that Urs calls such a thing <a class="existingWikiWord" href="/nlab/show/Cartesian+space">Cartesian space</a> instead. Euclid did not have coordinates; he did not even have an origin, so a Euclidean space should be a heap rather than a group. For my comment above, I would define a <a class="existingWikiWord" href="/nlab/show/Euclidean+space">Euclidean space</a> to be an affine inner product space; FWIW <a href="https://secure.wikimedia.org/wikipedia/en/affine_space">Wikipedia agrees</a>. (However, Wikipedia doesn't go as far as I do when I claim that the inner product should be valued in an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>-line rather than in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math> itself; then again, I ignored that subtlety myself in my previous comment.)</p>
</div>

<p>Clearly every vector space has an underlying affine space (and every linear map is affine linear), giving a <a class="existingWikiWord" href="/nlab/show/forgetful+functor">forgetful functor</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo>:</mo><mi>Vect</mi><mo>→</mo><mi>Aff</mi></mrow><annotation encoding="application/x-tex">U:Vect \to Aff</annotation></semantics></math>. Conversely, any affine space gives rise to a canonical vector space, sometimes called its space of <em>displacements</em>. This is obvious from the definitions that involve a vector space as part of the structure, but a vector space can also be reconstructed from the other definitions as well, analogously to how a group can be reconstructed from a <a class="existingWikiWord" href="/nlab/show/heap">heap</a>. This gives a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>:</mo><mi>Aff</mi><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">D:Aff\to Vect</annotation></semantics></math> in the other direction. One can verify that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">D(U(V))\cong V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>≅</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">U(D(A))\cong A</annotation></semantics></math>; the first isomorphism is <a class="existingWikiWord" href="/nlab/show/natural+isomorphism">natural</a>, but the second is not (otherwise <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math> would be <a class="existingWikiWord" href="/nlab/show/equivalent+categories">equivalent categories</a>, which they are not).</p>

<p>The category of affine spaces is almost a <a class="existingWikiWord" href="/nlab/show/variety+of+algebras">variety of algebras</a>, as can be seen from the last few definitions, except for the requirement that an affine space be inhabited. To rectify this, sometimes one allows the <a class="existingWikiWord" href="/nlab/show/empty+set">empty set</a> to be an affine space, although it does not have any particular vector space of displacements. (See <a href="heap#empty">heap#empty</a> for discussion.)</p>

<p>Note that there are a few different ways to think about the operations involved in the final three definitions (those not explicitly involving a vector space). The operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo lspace="verythinmathspace">:</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>↦</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\mu\colon x,y,z \mapsto x - y + z</annotation></semantics></math> is the same as the <a class="existingWikiWord" href="/nlab/show/Mal%27cev+operation">Mal'cev operation</a> (i.e. <a class="existingWikiWord" href="/nlab/show/heap">heap</a> structure) of the <a class="existingWikiWord" href="/nlab/show/translation+group">additive group</a> of a vector space. It can be viewed as the point completing a parallelogram with given vertices <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,y,z</annotation></semantics></math>, or equivalently as the result of adding <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math>, relative to a choice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> as the origin. The operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mo>*</mo></msub><mo lspace="verythinmathspace">:</mo><mi>r</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>↦</mo><mi>x</mi><mo>−</mo><mi>r</mi><mi>x</mi><mo>+</mo><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\Lambda_*\colon r,x,y \mapsto x - r x + r y</annotation></semantics></math> can be viewed as either a weighted average of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> (i.e. as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">(1-r)x + r y</annotation></semantics></math>) or as the result of multiplying the “displacement vector” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y-x</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math>, relative to the origin <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> (i.e. as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>+</mo><mi>r</mi><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x + r(y-x)</annotation></semantics></math>).</p>

<h3 id="details_and_comparisons">Details and comparisons</h3>

<p>The first few definitions, which explicitly involve a vector space, make no especial use of the fact that the vector space is a vector space rather than merely an abelian <a class="existingWikiWord" href="/nlab/show/group">group</a>. Thus, they are valid (and equivalent) in the more general context of <a class="existingWikiWord" href="/nlab/show/torsors">torsors</a> and <a class="existingWikiWord" href="/nlab/show/heaps">heaps</a>. They are also mostly complete as stated, except for the final one.</p>

<h4 id="vectorvalued_differences">Vector-valued differences</h4>

<p>In this definition, an affine space over a vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> is a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with a “subtraction” function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\Lambda\colon A\times A\to V</annotation></semantics></math>, written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo lspace="verythinmathspace">:</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>↦</mo><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\Lambda\colon x,y \mapsto x-y</annotation></semantics></math>, such that:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\Lambda(x,x) = 0</annotation></semantics></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>−</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x-x = 0</annotation></semantics></math>, for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>Λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lambda(x,y) + \Lambda(y,z) = \Lambda(x,z)</annotation></semantics></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x-y) + (y-z) = (x-z)</annotation></semantics></math>, for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,y,z</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</li>

<li>For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> there exists a unique <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">\Lambda(y,x) = v</annotation></semantics></math>, or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>−</mo><mi>x</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">y - x = v</annotation></semantics></math>.</li>
</ul>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>−</mo><mi>x</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">y - x = v</annotation></semantics></math>, then we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">y = x + v</annotation></semantics></math>, which we can regard as an operation on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math> by the third axiom. Hence we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>v</mi><mo stretchy="false">)</mo><mo>−</mo><mi>x</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">(x + v) - x = v</annotation></semantics></math> and (by uniqueness) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x + (y - x) = y</annotation></semantics></math>, and also <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>+</mo><mn>0</mn><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x + 0 = x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo>=</mo><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x + v) + w = x + (v + w)</annotation></semantics></math> by the first two axioms. Thus, these axioms suffice to make <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> into a <a class="existingWikiWord" href="/nlab/show/torsor">torsor</a> over the additive group of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> with the action <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math>, which is one of the previous definitions given.</p>

<p>Note again that this would makes sense if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> is any group, not just the additive group of a vector space.</p>

<h4 id="two_ternary_operations">Two ternary operations</h4>

<p>This definition is an affine version of the usual definition of a vector space in terms of addition and scalar multiplication. However, in each case the affine operation needs to take an extra parameter. In reading the following axioms it helps to think of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu(x,y,z)</annotation></semantics></math> as “the sum of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math> relative to the basepoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math>” and likewise <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lambda_r(x,y)</annotation></semantics></math> as “the product <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>⋅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">r\cdot y</annotation></semantics></math> relative to the basepoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>”.</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\mu(x,x,y) = y</annotation></semantics></math> (identity for addition)</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>z</mi><mo>,</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>,</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu(x,y,\mu(z,w,v)) = \mu(\mu(x,y,z),w,v)</annotation></semantics></math> (associativity of addition)</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>z</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu(x,y,z) = \mu(z,y,x)</annotation></semantics></math> (commutativity of addition)</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mrow><mi>r</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><msub><mi>Λ</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lambda_{r s}(x,y) = \Lambda_r(x, \Lambda_s(x,y))</annotation></semantics></math> (associativity of scalar multiplication)</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\Lambda_1(x,y) = y</annotation></semantics></math> (identity for scalar multiplication)</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\Lambda_0(x,y) = x</annotation></semantics></math> (left zero for scalar multiplication)</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mrow><mi>r</mi><mo>+</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>μ</mi><mo stretchy="false">(</mo><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>x</mi><mo>,</mo><msub><mi>Λ</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lambda_{r+s}(x,y) = \mu(\Lambda_r(x,y), x, \Lambda_s(x,y))</annotation></semantics></math> (left distributivity of scalar multiplication)</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>μ</mi><mo stretchy="false">(</mo><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lambda_r(w, \mu(x,y,z)) = \mu(\Lambda_r(w,x), \Lambda_r(w,y), \Lambda_r(w,z))</annotation></semantics></math> (right distributivity of scalar multiplication)</li>
</ul>

<div class="query">
<p><em>Joost</em>: Could it be that there is an axiom missing here ? One can go from Vector spaces to the 2 ternary operations definition and back, but I can’t see that by starting with the two ternary operations definition, going to vectorspaces and back, you get the same <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math>. I guess you need an extra axiom as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu(x,y,\Lambda_r(y,z))=\Lambda_r(x,\mu(x,y,z))</annotation></semantics></math>.</p>

<p><em>Toby</em>: Conceptually, there is something missing, which I've inserted as the left zero property of scalar multiplication. (The right zero property <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\Lambda_r(x,x) = x</annotation></semantics></math> follows from this using associativity of scalar multiplication with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">s = 0</annotation></semantics></math>, same as with vector spaces.) But I have to leave, and I haven't yet derived your axiom, even with this aid.</p>
</div>

<h4 id="one_quaternary_operation">One quaternary operation</h4>

<p>This definition is an affine version of the less standard definition of a vector space in terms of a single operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>↦</mo><mi>r</mi><mo>⋅</mo><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">r,x,y\mapsto r\cdot x + y</annotation></semantics></math>. Here an affine space over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with a single operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo lspace="verythinmathspace">:</mo><mi>k</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mu\colon k\times A\times A\times A\to A</annotation></semantics></math>, written as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>↦</mo><msub><mi>μ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r,x,y,z)\mapsto \mu_r(x,y,z)</annotation></semantics></math> and thought of as the sum “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>⋅</mo><mi>x</mi><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">r\cdot x + z</annotation></semantics></math> relative to the basepoint <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math>,” such that:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>μ</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\mu_1(x,y,y) = x</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>μ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\mu_r(x,x,y) = y</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>μ</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>μ</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu_1(x,y,z) = \mu_1(z,y,x)</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>μ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><msub><mi>μ</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>,</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>μ</mi> <mrow><mi>r</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><msub><mi>μ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo>,</mo><mi>w</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu_r(\mu_s(x,y,z),w,v) = \mu_{r s}(x,y,\mu_r(z,w,v))</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>μ</mi> <mrow><mi>r</mi><mo>+</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>μ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><msub><mi>μ</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu_{r+s}(x,y,z) = \mu_r(x,y,\mu_s(x,y,z))</annotation></semantics></math></li>
</ul>

<h4 id="one_ternary_operation">One ternary operation</h4>

<p>In the affine case (in contrast to the vector space case), it turns out that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math> is invertible the “addition” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>↦</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">(x,y,z)\mapsto x-y+z</annotation></semantics></math> can be recovered from the “scalar multiplication” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>↦</mo><mi>r</mi><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">(r,x,y)\mapsto r x + (1-r)y</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Λ</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><msub><mi>Λ</mi> <mrow><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu(x,y,z) = \Lambda_2(y,\Lambda_{1/2}(x,z))</annotation></semantics></math>. Thus, in this case we can define an affine space over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> to be a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> together with a single operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Λ</mi><mo lspace="verythinmathspace">:</mo><mi>k</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Lambda\colon k\times A\times A\to A</annotation></semantics></math> such that the axioms for the two-ternary-operations definition are satisfied with this definition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math>.</p>

<p>However, we can also simplify the requisite axioms in this presentation. The following axioms are easier to state if we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Λ</mi> <mi>r</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Lambda_r(x,y)</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">(1-r) x + r y</annotation></semantics></math>, or equivalently as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mi>x</mi><mo>+</mo><mi>s</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">r x + s y</annotation></semantics></math>, where we require <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+s=1</annotation></semantics></math> for the expression to be defined.</p>

<ul>
<li>Idempotence: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mi>x</mi><mo>+</mo><mi>s</mi><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">r x + s x = x</annotation></semantics></math> whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+s=1</annotation></semantics></math>.</li>

<li>Commutativity: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mi>x</mi><mo>+</mo><mi>s</mi><mi>y</mi><mo>=</mo><mi>s</mi><mi>y</mi><mo>+</mo><mi>r</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">r x + s y = s y + r x</annotation></semantics></math> whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+s=1</annotation></semantics></math>.</li>

<li>Associativity: whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+s+t=1</annotation></semantics></math>, whichever of the following three expressions are defined are equal:<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>r</mi><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo><mrow><mo>(</mo><mfrac><mi>s</mi><mrow><mn>1</mn><mo>−</mo><mi>r</mi></mrow></mfrac><mi>y</mi><mo>+</mo><mfrac><mi>t</mi><mrow><mn>1</mn><mo>−</mo><mi>r</mi></mrow></mfrac><mi>z</mi><mo>)</mo></mrow></mtd></mtr> <mtr><mtd><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>s</mi><mo stretchy="false">)</mo><mrow><mo>(</mo><mfrac><mi>r</mi><mrow><mn>1</mn><mo>−</mo><mi>s</mi></mrow></mfrac><mi>x</mi><mo>+</mo><mfrac><mi>t</mi><mrow><mn>1</mn><mo>−</mo><mi>s</mi></mrow></mfrac><mi>z</mi><mo>)</mo></mrow><mo>+</mo><mi>s</mi><mi>y</mi></mtd></mtr> <mtr><mtd><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo><mrow><mo>(</mo><mfrac><mi>r</mi><mrow><mn>1</mn><mo>−</mo><mi>t</mi></mrow></mfrac><mi>x</mi><mo>+</mo><mfrac><mi>s</mi><mrow><mn>1</mn><mo>−</mo><mi>t</mi></mrow></mfrac><mi>y</mi><mo>)</mo></mrow><mo>+</mo><mi>t</mi><mi>z</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\array{
r x + (1-r)\left(\frac{s}{1-r} y + \frac{t}{1-r} z\right)\\
(1-s)\left(\frac{r}{1-s} x + \frac{t}{1-s} z\right) + s y\\
(1-t)\left(\frac{r}{1-t} x + \frac{s}{1-t} y\right) + t z
}

</annotation></semantics></math></div>
<p>The first is defined whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r\neq 1</annotation></semantics></math>, the second whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s\neq 1</annotation></semantics></math>, and the third whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t\neq 1</annotation></semantics></math>. Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> has characteristic <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>≠</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\neq 2</annotation></semantics></math>, we cannot have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>=</mo><mi>s</mi><mo>=</mo><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r=s=t=1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>+</mo><mi>s</mi><mo>+</mo><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+s+t=1</annotation></semantics></math> at the same time, so at least one of these expressions is always defined. We write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mi>x</mi><mo>+</mo><mi>s</mi><mi>y</mi><mo>+</mo><mi>t</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">r x + s y + t z</annotation></semantics></math> for the common value of whichever of them are defined.</p>
</li>

<li>Cancellation: for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">r\in k</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x,y\in A</annotation></semantics></math>, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>+</mo><mi>r</mi><mi>y</mi><mo>−</mo><mi>r</mi><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x + r y - r y = x</annotation></semantics></math>.</li>
</ul>

<h4 id="unbiased_definition">Unbiased definition</h4>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>vect</mi></msub></mrow><annotation encoding="application/x-tex">Th_{vect}</annotation></semantics></math> denote the <a class="existingWikiWord" href="/nlab/show/Lawvere+theory">Lawvere theory</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>-vector spaces. For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, its <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-ary operations are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-tuples <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>k</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">(r_1,\dots,r_n)\in k^n</annotation></semantics></math> representing the <a class="existingWikiWord" href="/nlab/show/linear+combination">linear combination</a> operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>↦</mo><msub><mi>r</mi> <mn>1</mn></msub><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">(x_1,\dots,x_n)\mapsto r_1 x_1 +\dots+ r_n x_n</annotation></semantics></math>. Composition of operations is by substitution in the obvious way, and the identity operation is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1)</annotation></semantics></math>. A model of this theory is simply a vector space. With this ‘unbiased’ definition, a vector space comes equipped with, for every integer <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n\ge 0</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-tuple <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_1,\dots,r_n)</annotation></semantics></math> of elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>, a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>V</mi> <mi>n</mi></msup><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">V^n\to V</annotation></semantics></math> (thought of as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>v</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>↦</mo><msub><mi>r</mi> <mn>1</mn></msub><msub><mi>v</mi> <mn>1</mn></msub><mo>+</mo><mi>…</mi><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>v</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">(v_1,\dots,v_n)\mapsto r_1 v_1+\dots r_n v_n</annotation></semantics></math>), satisfying some axioms.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>aff</mi></msub></mrow><annotation encoding="application/x-tex">Th_{aff}</annotation></semantics></math> denote the subtheory of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>vect</mi></msub></mrow><annotation encoding="application/x-tex">Th_{vect}</annotation></semantics></math> containing only those operations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_1,\dots,r_n)</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>1</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_1+\dots+r_n=1</annotation></semantics></math>; an <strong>affine space</strong> is a nonempty model of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>aff</mi></msub></mrow><annotation encoding="application/x-tex">Th_{aff}</annotation></semantics></math>. (We have to observe that these are closed under the theory operations and thus define a subtheory. Note that this excludes all zero-ary operations, so an affine space has no distinguished constants, and it also excludes all nonidentity unary operations.) The basic operations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">r_0x_0+\dots+r_n x_n</annotation></semantics></math>, when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_0+\dots+r_n=1</annotation></semantics></math>, are called <strong>affine (linear) combinations</strong> of elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p>

<p>The axioms for the unbiased definition are most straightforward to see by writing out the operations of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>aff</mi></msub></mrow><annotation encoding="application/x-tex">Th_{aff}</annotation></semantics></math>. In particular, this includes “substitution” axioms of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>s</mi> <mn>00</mn></msub><msub><mi>x</mi> <mn>00</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>s</mi> <mrow><mn>0</mn><msub><mi>m</mi> <mn>0</mn></msub></mrow></msub><msub><mi>x</mi> <mrow><mn>0</mn><msub><mi>m</mi> <mn>0</mn></msub></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>s</mi> <mrow><mi>n</mi><mn>0</mn></mrow></msub><msub><mi>x</mi> <mrow><mi>n</mi><mn>0</mn></mrow></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>s</mi> <mrow><mi>n</mi><msub><mi>m</mi> <mi>n</mi></msub></mrow></msub><msub><mi>x</mi> <mrow><mi>n</mi><msub><mi>m</mi> <mi>n</mi></msub></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>s</mi> <mn>00</mn></msub><msub><mi>x</mi> <mn>00</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>s</mi> <mrow><mi>n</mi><msub><mi>m</mi> <mi>n</mi></msub></mrow></msub><msub><mi>x</mi> <mrow><mi>n</mi><msub><mi>m</mi> <mi>n</mi></msub></mrow></msub><mo>.</mo></mrow><annotation encoding="application/x-tex">
r_0(s_{00} x_{00} + \dots + s_{0m_0} x_{0m_0}) + \dots + r_n (s_{n0} x_{n0} + \dots + s_{n m_n} x_{n m_n}) = r_0 s_{00} x_{00} + \dots + r_n s_{n m_n} x_{n m_n}.

</annotation></semantics></math></div>
<p>However, it also includes “permutation” axioms of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>x</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>r</mi> <mrow><mi>σ</mi><mn>0</mn></mrow></msub><msub><mi>x</mi> <mrow><mi>σ</mi><mn>0</mn></mrow></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mrow><mi>σ</mi><mi>n</mi></mrow></msub><msub><mi>x</mi> <mrow><mi>σ</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
r_0 x_0 + \dots + r_n x_n = r_{\sigma 0} x_{\sigma 0} + \dots + r_{\sigma n} x_{\sigma n}

</annotation></semantics></math></div>
<p>and also “duplication” and “omission” axioms. This Lawvere theory can be defined concisely as follows. The Lawvere theory of vector spaces is the opposite of the category of finite-dimensional vector spaces; its operations are all <a class="existingWikiWord" href="/nlab/show/linear+combinations">linear combinations</a>. The Lawvere theory for affine spaces is the sub-theory of this consisting of only the affine combinations. (The Lawvere theory of vector spaces also has other interesting sub-theories, such as that consisting of <em><a class="existingWikiWord" href="/nlab/show/convex+combinations">convex combinations</a></em> whose algebras are abstract <a class="existingWikiWord" href="/nlab/show/convex+space">convex space</a>s in one sense of the term.) Note that the empty set is a model (algebra) of this Lawvere theory; an affine space is an <em>inhabited</em> model.</p>

<p>Given the unbiased definition in terms of a Lawvere theory, the previous three “biased” vector-space-free definitions can then be recovered by finding particular generating operations for the theory. In particular, this Lawvere theory is generated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-ary operations if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>char</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>≠</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">char(k)\neq 2</annotation></semantics></math>, and by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math>-ary ones if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>char</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">char(k)=2</annotation></semantics></math>. To wit, suppose given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi> <mn>0</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>k</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(r_0,\dots,r_n)\in k^{n+1}</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n\ge 3</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_0+\dots+r_n=1</annotation></semantics></math>. Suppose for the moment that the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math> are not all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>, and WLOG suppose that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_0\neq 1</annotation></semantics></math>. (Note that here we use the invariance under permutations.) Then we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>x</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>r</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mrow><mo>(</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><msub><mi>r</mi> <mn>0</mn></msub></mrow></mfrac><msub><mi>r</mi> <mn>1</mn></msub><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><msub><mi>r</mi> <mn>0</mn></msub></mrow></mfrac><msub><mi>r</mi> <mi>n</mi></msub><msub><mi>x</mi> <mi>n</mi></msub><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">
r_0 x_0 + \dots + r_n x_n = r_0 x_0 + (1-r_0)\left(\frac{1}{1-r_0} r_1 x_1 + \dots + \frac{1}{1-r_0}r_n x_n\right)

</annotation></semantics></math></div>
<p>so we have expressed the given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math>-ary operation in terms of a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-ary one and an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-ary one. By induction, in this way we can express any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math>-ary operation in terms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-ary ones (note that there is only one <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>-ary operation, namely the identity, and no <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>-ary ones) — as long as we never hit a tuple where every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_i=1</annotation></semantics></math>. But since we always have the requirement <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>r</mi> <mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r_0+\dots+r_n=1</annotation></semantics></math>, this badness can only happen if the characteristic of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. Moreover, we still have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>−</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
x_0 + \dots + x_n = x_0 - x_1 + (2x_1 + x_2 + \dots + x_n)

</annotation></semantics></math></div>
<p>so we can still write this <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math>-ary operation in terms of a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math>-ary one and an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-ary one. So only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n+1=3</annotation></semantics></math> (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mi>char</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=char(k)=2</annotation></semantics></math>) are we prevented from getting down to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-ary operations only, and in this case we can still get down to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math>-ary ones. Finally, we observe that any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math>-ary operation can be written in terms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-ary ones and the particular <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math>-ary operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>−</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_0 - x_1 + x_2</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>r</mi> <mn>1</mn></msub><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>r</mi> <mn>2</mn></msub><msub><mi>x</mi> <mn>2</mn></msub><mo>=</mo><mo maxsize="1.2em" minsize="1.2em">(</mo><msub><mi>r</mi> <mn>0</mn></msub><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>r</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><msub><mi>x</mi> <mn>2</mn></msub><mo maxsize="1.2em" minsize="1.2em">)</mo><mo>−</mo><msub><mi>x</mi> <mn>2</mn></msub><mo>+</mo><mo maxsize="1.2em" minsize="1.2em">(</mo><msub><mi>r</mi> <mn>1</mn></msub><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>r</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mi>x</mi> <mn>2</mn></msub><mo maxsize="1.2em" minsize="1.2em">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex">
r_0 x_0 + r_1 x_1 + r_2 x_2 = \big(r_0 x_0 + (1-r_0) x_2\big) - x_2 + \big(r_1 x_1 + (1-r_1) x_2\big).

</annotation></semantics></math></div>
<h4 id="slice_of_">Slice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math></h4>

<p>(This gives definition 10.)</p>

<p>Given an affine space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> (with any other definition but number 10), the corresponding <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\pi:A'\to k</annotation></semantics></math> is constructed as follows. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>′</mo><mo>=</mo><mn>1</mn><mo>⊔</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A' = 1 \sqcup A</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math> is the coproduct in affine spaces (akin to a simplicial <a class="existingWikiWord" href="/nlab/show/join">join</a>), <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal</a> affine space, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is the composite of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>⊔</mo><mo>!</mo><mo>:</mo><mn>1</mn><mo>⊔</mo><mi>A</mi><mo>→</mo><mn>1</mn><mo>⊔</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \sqcup !: 1 \sqcup A \to 1 \sqcup 1</annotation></semantics></math> with a natural identification <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo>:</mo><mn>1</mn><mo>⊔</mo><mn>1</mn><mo>≅</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\mu: 1 \sqcup 1 \cong k</annotation></semantics></math>. Both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>⊔</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">1 \sqcup !</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math> which are morphisms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math> may be regarded as morphisms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo stretchy="false">↓</mo><mi>Aff</mi><mo>≃</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">1 \downarrow Aff \simeq Vect</annotation></semantics></math> (pointed affine spaces are vector spaces) if we let the first inclusion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>i</mi> <mn>0</mn></msub><mo>:</mo><mn>1</mn><mo>→</mo><mn>1</mn><mo>⊔</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">i_0: 1 \to 1 \sqcup A</annotation></semantics></math> be the pointing of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>⊔</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">1 \sqcup A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>:</mo><mn>1</mn><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">0: 1 \to k</annotation></semantics></math> the pointing of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> and define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo>∘</mo><msub><mi>i</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mu \circ i_0 = 0</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi><mo>∘</mo><msub><mi>i</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu \circ i_1 = 1</annotation></semantics></math> (the element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>∈</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">1 \in k</annotation></semantics></math>). (So <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math> is like two ends of a meter stick used to set up coordinates on the line <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>.)</p>

<p>Conversely, given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\pi:A'\to k</annotation></semantics></math>, the fiber <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi^{-1}(1)</annotation></semantics></math> naturally acquires a “vector-valued difference” affine space structure by simple subtraction in the vector space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">A'</annotation></semantics></math>, where the vector space of displacements is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>=</mo><msup><mi>π</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V = \pi^{-1}(0)</annotation></semantics></math>.</p>

<p>Note that this definition embeds the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math> of (inhabited) affine spaces fully-faithfully in the <a class="existingWikiWord" href="/nlab/show/slice+category">slice category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Vect/k</annotation></semantics></math>. The objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Vect/k</annotation></semantics></math> not in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math> are those of the form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>:</mo><mi>V</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">0:V\to k</annotation></semantics></math>, which form a category equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math> itself. Moreover, there are no morphisms from objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math> to objects not in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math>; while by the above construction, a morphism from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn><mo>:</mo><mi>V</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">0:V\to k</annotation></semantics></math> to an affine space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo>:</mo><mi>A</mi><mo>′</mo><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\pi:A'\to k</annotation></semantics></math> is just a map from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> to the vector space of displacements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. Hence, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Vect/k</annotation></semantics></math> is equivalent to the (dual) <a class="existingWikiWord" href="/nlab/show/cograph+of+a+functor">cograph</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>:</mo><mi>Aff</mi><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">D:Aff\to Vect</annotation></semantics></math>.</p>

<h3 id="ClosedMonoidal">Closed monoidal structure</h3>

<p>If we allow affine spaces to be empty, then they are the models of an <a class="existingWikiWord" href="/nlab/show/algebraic+theory">algebraic theory</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>Aff</mi></msub></mrow><annotation encoding="application/x-tex">Th_{Aff}</annotation></semantics></math>. Moreover, like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>Vect</mi></msub></mrow><annotation encoding="application/x-tex">Th_{Vect}</annotation></semantics></math>, the theory <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Th</mi> <mi>Aff</mi></msub></mrow><annotation encoding="application/x-tex">Th_{Aff}</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/commutative+theory">commutative theory</a>. It follows that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A, B</annotation></semantics></math> are affine spaces, then the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(A, B)</annotation></semantics></math> is closed under all affine space operations pointwise defined on the set of all functions from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. This gives <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/closed+category">closed category</a> structure; on general grounds, it is in fact a <a class="existingWikiWord" href="/nlab/show/symmetric+monoidal+closed+category">symmetric monoidal closed category</a>. The unit of this structure is the terminal or one-pointed affine space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math>, via the natural isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\hom(1, B) \cong B</annotation></semantics></math>. Thus <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi></mrow><annotation encoding="application/x-tex">Aff</annotation></semantics></math> is a closed <a class="existingWikiWord" href="/nlab/show/semicartesian+monoidal+category">semicartesian monoidal category</a>.</p>

<p>Analogous to the case of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>, every affine space is a coproduct of copies of the monoidal unit: an affine space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> of dimension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> admits an affine basis, which amounts to an isomorphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>⊔</mo><mn>1</mn><mo>⊔</mo><mi>…</mi><mo>⊔</mo><mn>1</mn><mo>≅</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">1 \sqcup 1 \sqcup \ldots \sqcup 1 \cong A</annotation></semantics></math>, represented by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> [sic] points of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. Such basis representations allow one to coordinatize spaces of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≅</mo><msup><mi>B</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\hom(A, B) \cong B^{n+1}</annotation></semantics></math>, with dimension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>dim</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)\dim(B)</annotation></semantics></math>. If one uses the first of the affine basis elements to give a pointing of the affine space (equivalent to a vector space structure), then the remaining affine basis elements provide a vector space basis, and in those coordinates every element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>hom</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f \in \hom(A, B)</annotation></semantics></math> may be written in matrix-vector form <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x) = M x + b</annotation></semantics></math>, where again the space of such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(M, b)</annotation></semantics></math> has dimension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mi>n</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m n + m</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> is the dimension of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. (There are also more ‘unbiased’ coordinate descriptions, not biased in favor of the first basis element playing the role of the origin.)</p>

<p>Similarly, we can coordinatize affine tensor products <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \otimes B</annotation></semantics></math>: the tensor distributes over coproducts (as it does in any symmetric monoidal closed category) and so</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨆</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></munder><mn>1</mn><mo stretchy="false">)</mo><mo>⊗</mo><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨆</mo> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></munder><mn>1</mn><mo stretchy="false">)</mo><mo>≅</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨆</mo> <mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></munder><mn>1</mn><mo>⊗</mo><mn>1</mn><mo>≅</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⨆</mo> <mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></munder><mn>1</mn></mrow><annotation encoding="application/x-tex">(\bigsqcup_{n+1} 1) \otimes (\bigsqcup_{m+1} 1) \cong \bigsqcup_{(m+1)(n+1)} 1 \otimes 1 \cong \bigsqcup_{(m+1)(n+1)} 1</annotation></semantics></math></div>
<p>with dimension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m n + m + n</annotation></semantics></math>. In other words, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>a</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_1, \ldots, a_{n+1}</annotation></semantics></math> is an affine basis of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>b</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>b</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">b_1, \ldots, b_{m+1}</annotation></semantics></math> a basis of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>-dimensional <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \otimes B</annotation></semantics></math> has an affine basis consisting of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m n + m + n + 1</annotation></semantics></math> many elements <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>a</mi> <mi>i</mi></msub><mo>⊗</mo><msub><mi>b</mi> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i \otimes b_j</annotation></semantics></math>.</p>

<p>The embedding <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi><mo>→</mo><mi>Vect</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Aff \to Vect/k</annotation></semantics></math> described in the previous subsection, sending <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>1</mn><mo>⊔</mo><mo>!</mo><mo>:</mo><mn>1</mn><mo>⊔</mo><mi>A</mi><mo>→</mo><mn>1</mn><mo>⊔</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \sqcup !: 1 \sqcup A \to 1 \sqcup 1</annotation></semantics></math>, is a <a class="existingWikiWord" href="/nlab/show/strong+monoidal+functor">strong monoidal functor</a> (preserves the tensor product up to coherent isomorphism) if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Vect/k</annotation></semantics></math> is endowed with the obvious tensor product acquired from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math>. Note that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Vect/k</annotation></semantics></math> is the coreflection of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Vect</annotation></semantics></math> from monoidal categories to <a class="existingWikiWord" href="/nlab/show/semicartesian+monoidal+categories">semicartesian monoidal categories</a>; the embedding <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi><mo>→</mo><mi>Vect</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">Aff \to Vect/k</annotation></semantics></math> was in fact discovered by one of us in conjunction with this fact, and is the same as the functor induced by universality from the strong monoidal functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Aff</mi><mo>→</mo><mi>Vect</mi></mrow><annotation encoding="application/x-tex">Aff \to Vect</annotation></semantics></math> given by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>↦</mo><mn>1</mn><mo>⊔</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \mapsto 1 \sqcup A</annotation></semantics></math>.</p>

<h2 id="further_remarks">Further Remarks</h2>

<p>Every finitely-generated affine space is isomorphic to the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-fold <a class="existingWikiWord" href="/nlab/show/direct+sum">direct sum</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>k</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k^n</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/base+field">base field</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/natural+number">natural number</a> (possibly <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math>). In <a class="existingWikiWord" href="/nlab/show/algebraic+geometry">algebraic geometry</a>, an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional affine space is often denoted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>𝔸</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb{A}^n</annotation></semantics></math> and identified with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>k</mi> <mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k^n</annotation></semantics></math>. If one accepts the empty set as an affine space, then this is considered to have dimension <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math> by convention (so <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>k</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">k^{-1} = \empty</annotation></semantics></math>).</p>

<p>The notion of affine space may be generalised to <strong>affine module</strong> by replacing the vector space above by a <a class="existingWikiWord" href="/nlab/show/module">module</a> and the base field <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> by a <a class="existingWikiWord" href="/nlab/show/commutative+ring">commutative ring</a>. Then an affine module over the ring <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/integer">integer</a>s is precisely a commutative <a class="existingWikiWord" href="/nlab/show/heap">heap</a>, just like a module over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math> is an <a class="existingWikiWord" href="/nlab/show/abelian+group">abelian group</a>. Note that the definition involving only one “scalar multiplication” operation works if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math> is invertible in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>; it's not enough that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">2 \ne 0</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>.</p>

<div class="query">
<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: I haven’t thought much about affine modules, but it seems likely to me that the “biased” module-free definitions won’t be right any more, since the Lawvere theory needn’t be generated by 2-ary or 3-ary operations (as far as I can see). More explicitly, I don’t immediately see how to write an operation like</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>2</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>3</mn></msub><mo stretchy="false">)</mo><mo>↦</mo><mn>4</mn><msub><mi>x</mi> <mn>0</mn></msub><mo>−</mo><mn>6</mn><msub><mi>x</mi> <mn>1</mn></msub><mo>−</mo><mn>2</mn><msub><mi>x</mi> <mn>2</mn></msub><mo>+</mo><mn>5</mn><msub><mi>x</mi> <mn>3</mn></msub></mrow><annotation encoding="application/x-tex">(x_0,x_1,x_2,x_3) \mapsto 4x_0 - 6x_1 - 2x_2 + 5x_3</annotation></semantics></math></div>
<p>in terms of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>A</mi> <mn>3</mn></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A^3\to A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi><mo>×</mo><msup><mi>A</mi> <mn>2</mn></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}\times A^2\to A</annotation></semantics></math>, but it seems to me that this operation should still exist in an affine <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math>-module.</p>

<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: Well that’s rubbish isn’t it. The operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>A</mi> <mn>3</mn></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A^3\to A</annotation></semantics></math> is enough to give you a heap, hence an additive group, and then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℤ</mi><mo>×</mo><msup><mi>A</mi> <mn>2</mn></msup><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}\times A^2\to A</annotation></semantics></math> gives you the scalar multiplication. And so</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mn>4</mn><msub><mi>x</mi> <mn>0</mn></msub><mo>−</mo><mn>6</mn><msub><mi>x</mi> <mn>1</mn></msub><mo>−</mo><mn>2</mn><msub><mi>x</mi> <mn>2</mn></msub><mo>+</mo><mn>5</mn><msub><mi>x</mi> <mn>3</mn></msub><mo>=</mo><mo maxsize="1.2em" minsize="1.2em">(</mo><mo stretchy="false">(</mo><mn>4</mn><msub><mi>x</mi> <mn>0</mn></msub><mo>−</mo><mn>3</mn><mi>y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo>+</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>6</mn><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mn>7</mn><mi>y</mi><mo stretchy="false">)</mo><mo maxsize="1.2em" minsize="1.2em">)</mo><mo>−</mo><mi>y</mi><mo>+</mo><mo maxsize="1.2em" minsize="1.2em">(</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>2</mn><msub><mi>x</mi> <mn>2</mn></msub><mo>+</mo><mn>3</mn><mi>y</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo>+</mo><mo stretchy="false">(</mo><mn>5</mn><msub><mi>x</mi> <mn>3</mn></msub><mo>−</mo><mn>4</mn><mi>y</mi><mo stretchy="false">)</mo><mo maxsize="1.2em" minsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">4x_0 - 6x_1 - 2x_2 + 5x_3 = \big((4x_0 - 3y) - y + (-6x_1+7y)\big) - y + \big((-2x_2+3y) - y + (5x_3 - 4y)\big)</annotation></semantics></math></div>
<p>for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> at all.</p>

<p><em>Toby</em>: Right. But I find an affine module of a <em>rig</em> to be a trickier concept.</p>

<p><a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>: Quite so. Perhaps first one should look for a version of a <a class="existingWikiWord" href="/nlab/show/heap">heap</a> corresponding to a <a class="existingWikiWord" href="/nlab/show/monoid">monoid</a>?</p>

<p><em>Toby</em>: Yes, that would be an affine <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math>-module.</p>
</div>

<h2 id="affine_spaces_as_model_spaces">Affine spaces as model spaces</h2>

<p>Affine spaces typically serve as local models for more general kinds of spaces.</p>

<p>For instance a <a class="existingWikiWord" href="/nlab/show/manifold">manifold</a> is a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> that is locally isomorphic to an affine space over the <a class="existingWikiWord" href="/nlab/show/real+numbers">real numbers</a>.</p>

<p>Similarly, in <a class="existingWikiWord" href="/nlab/show/algebraic+geometry">algebraic geometry</a> a <a class="existingWikiWord" href="/nlab/show/scheme">scheme</a> is locally isomorphic to an <a class="existingWikiWord" href="/nlab/show/affine+scheme">affine scheme</a>.</p>

<p>Therefore there are attempts to axiomatize properties of categories of affine spaces for the purpose of using these as model spaces for more complicated geometries. One such axiomatization is the notion of <a class="existingWikiWord" href="/nlab/show/geometry+%28for+structured+%28%E2%88%9E%2C1%29-toposes%29">geometry (for structured (∞,1)-toposes)</a>. and in particular that of <a href="/nlab/show/geometry+(for+structured+(infinity%2C1%29-toposes%29#Pregeometry">pregeometry</a>.</p>

<h2 id="related_concepts">Related concepts</h2>

<ul>
<li>
<p>the <a class="existingWikiWord" href="/nlab/show/automorphism+group">automorphism group</a> of an affine space is an <em><a class="existingWikiWord" href="/nlab/show/affine+group">affine group</a></em></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Cartesian+space">Cartesian space</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/polydisk">polydisk</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/projective+space">projective space</a>, <a class="existingWikiWord" href="/nlab/show/conical+space">conical space</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relative+affine+n-space">relative affine n-space</a></p>
</li>
</ul>

<h2 id="references">References</h2>

<p>Textbook accounts:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Igor+R.+Shafarevich">Igor R. Shafarevich</a>, <a class="existingWikiWord" href="/nlab/show/Alexey+O.+Remizov">Alexey O. Remizov</a>: §8 in: <em>Linear Algebra and Geometry</em> (2012) &lbrack;<a href="https://doi.org/10.1007/978-3-642-30994-6">doi:10.1007/978-3-642-30994-6</a>, <a href="https://maa.org/press/maa-reviews/linear-algebra-and-geometry">MAA-review</a>&rbrack;</li>
</ul>

<p>See also:</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Aurelio+Carboni">Aurelio Carboni</a>, <em>Categories of Affine Spaces</em> , JPAA <strong>61</strong> (1989) pp.243-250.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Aurelio+Carboni">Aurelio Carboni</a>, <a class="existingWikiWord" href="/nlab/show/George+Janelidze">George Janelidze</a>, <em>Modularity and Descent</em> , JPAA <strong>99</strong> (1995) pp.255-265.</p>
</li>

<li>
<p>Michel Thiébaud, <em>Modular Categories</em> , pp.386-400 in <em>Proc. Como conference - Category Theory</em> , LNM <strong>1488</strong> Springer Heidelberg 1991.</p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on July 25, 2024 at 15:40:49.
    See the <a href="/nlab/history/affine+space" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/affine+space" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/1245/#Item_16">Discuss</a><span class="backintime"><a href="/nlab/revision/affine+space/36" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/affine+space" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/affine+space" accesskey="S" class="navlink" id="history" rel="nofollow">History (36 revisions)</a>
  <a href="/nlab/show/affine+space/cite" style="color: black">Cite</a>
  <a href="/nlab/print/affine+space" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/affine+space" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
