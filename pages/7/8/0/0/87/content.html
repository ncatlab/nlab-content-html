
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      anafunctor in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      anafunctor
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/8834/#Item_8" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Anafunctors</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="category_theory">Category theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></strong></p>

<h2 id="concepts">Concepts</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category">category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/functor">functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Cat">Cat</a></p>
</li>
</ul>

<h2 id="universal_constructions">Universal constructions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/universal+construction">universal construction</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/representable+functor">representable functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+functor">adjoint functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/limit">limit</a>/<a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/end">end</a>/<a class="existingWikiWord" href="/nlab/show/coend">coend</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kan+extension">Kan extension</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="theorems">Theorems</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Isbell+duality">Isbell duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Grothendieck+construction">Grothendieck construction</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+functor+theorem">adjoint functor theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monadicity+theorem">monadicity theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+lifting+theorem">adjoint lifting theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Tannaka+duality">Tannaka duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Gabriel-Ulmer+duality">Gabriel-Ulmer duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Freyd-Mitchell+embedding+theorem">Freyd-Mitchell embedding theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a></p>
</li>
</ul>

<h2 id="extensions">Extensions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sheaf+and+topos+theory">sheaf and topos theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/enriched+category+theory">enriched category theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+category+theory">higher category theory</a></p>
</li>
</ul>

<h2 id="applications">Applications</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/applications+of+%28higher%29+category+theory">applications of (higher) category theory</a></li>
</ul>
<div>
<p>
  <a href="/nlab/edit/category+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>

<h4 id="homotopy_theory">Homotopy theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+theory">homotopy theory</a>, <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+theory">(∞,1)-category theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></strong></p>

<p>flavors: <a class="existingWikiWord" href="/nlab/show/stable+homotopy+theory">stable</a>, <a class="existingWikiWord" href="/nlab/show/equivariant+homotopy+theory">equivariant</a>, <a class="existingWikiWord" href="/nlab/show/rational+homotopy+theory">rational</a>, <a class="existingWikiWord" href="/nlab/show/p-adic+homotopy+theory">p-adic</a>, <a class="existingWikiWord" href="/nlab/show/proper+homotopy+theory">proper</a>, <a class="existingWikiWord" href="/nlab/show/geometric+homotopy+theory">geometric</a>, <a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+theory">cohesive</a>, <a class="existingWikiWord" href="/nlab/show/directed+homotopy+theory">directed</a>…</p>

<p>models: <a class="existingWikiWord" href="/nlab/show/topological+homotopy+theory">topological</a>, <a class="existingWikiWord" href="/nlab/show/simplicial+homotopy+theory">simplicial</a>, <a class="existingWikiWord" href="/nlab/show/localic+homotopy+theory">localic</a>, …</p>

<p>see also <strong><a class="existingWikiWord" href="/nlab/show/algebraic+topology">algebraic topology</a></strong></p>

<p><strong>Introductions</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Introduction+to+Topology+--+2">Introduction to Basic Homotopy Theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Introduction+to+Homotopy+Theory">Introduction to Abstract Homotopy Theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometry+of+physics+--+homotopy+types">geometry of physics – homotopy types</a></p>
</li>
</ul>

<p><strong>Definitions</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy">homotopy</a>, <a class="existingWikiWord" href="/nlab/show/higher+homotopy">higher homotopy</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Pi-algebra">Pi-algebra</a>, <a class="existingWikiWord" href="/nlab/show/spherical+object+and+Pi%28A%29-algebra">spherical object and Pi(A)-algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+coherent+category+theory">homotopy coherent category theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopical+category">homotopical category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+category">model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/category+of+fibrant+objects">category of fibrant objects</a>, <a class="existingWikiWord" href="/nlab/show/cofibration+category">cofibration category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Waldhausen+category">Waldhausen category</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Ho%28Top%29">Ho(Top)</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/homotopy+category+of+an+%28%E2%88%9E%2C1%29-category">homotopy category of an (∞,1)-category</a></li>
</ul>
</li>
</ul>

<p><strong>Paths and cylinders</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/left+homotopy">left homotopy</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cylinder+object">cylinder object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cone">mapping cone</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/right+homotopy">right homotopy</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/path+object">path object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cocone">mapping cocone</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/generalized+universal+bundle">universal bundle</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/interval+object">interval object</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+localization">homotopy localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/infinitesimal+interval+object">infinitesimal interval object</a></p>
</li>
</ul>
</li>
</ul>

<p><strong>Homotopy groups</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+group">homotopy group</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+group">fundamental group</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+group+of+a+topos">fundamental group of a topos</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Brown-Grossman+homotopy+group">Brown-Grossman homotopy group</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/categorical+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">categorical homotopy groups in an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">geometric homotopy groups in an (∞,1)-topos</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid">fundamental ∞-groupoid</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+groupoid">fundamental groupoid</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/path+groupoid">path groupoid</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+in+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">fundamental ∞-groupoid in a locally ∞-connected (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+of+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">fundamental ∞-groupoid of a locally ∞-connected (∞,1)-topos</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%28%E2%88%9E%2C1%29-category">fundamental (∞,1)-category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+category">fundamental category</a></li>
</ul>
</li>
</ul>

<p><strong>Basic facts</strong></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+group+of+the+circle+is+the+integers">fundamental group of the circle is the integers</a></li>
</ul>

<p><strong>Theorems</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+theorem+of+covering+spaces">fundamental theorem of covering spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Freudenthal+suspension+theorem">Freudenthal suspension theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Blakers-Massey+theorem">Blakers-Massey theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+homotopy+van+Kampen+theorem">higher homotopy van Kampen theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/nerve+theorem">nerve theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Whitehead%27s+theorem">Whitehead's theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Hurewicz+theorem">Hurewicz theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Galois+theory">Galois theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+hypothesis">homotopy hypothesis</a>-theorem</p>
</li>
</ul>
</div></div>
</div>
</div>

<h1 id="anafunctors">Anafunctors</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<ul>
<li><a href='#FoundationalMotivation'>Foundational motivation</a></li>
<li><a href='#InternalCatMotivation'>Motivation from internal categories</a></li>
<li><a href='#HomotopicalMotivation'>Homotopical motivation</a></li>
</ul>
<li><a href='#definitions'>Definitions</a></li>
<ul>
<li><a href='#SetDef'>Explicit set-theoretic definition</a></li>
<li><a href='#internal_definition_using_covers'>Internal definition using covers</a></li>
<li><a href='#as_an_operation_on_2categories'>As an operation on 2-categories</a></li>
<li><a href='#homotopytheoretic_interpretation'>Homotopy-theoretic interpretation</a></li>
</ul>
<li><a href='#examples'>Examples</a></li>
<ul>
<li><a href='#product_anafunctor'>Product anafunctor</a></li>
<li><a href='#anafunctor_from_functor'>Anafunctor from functor</a></li>
<li><a href='#inverses_of_anafunctors'>Inverses of anafunctors</a></li>
</ul>
<li><a href='#SizeQuestions'>Questions of size</a></li>
<li><a href='#anafunctors_in_homotopy_type_theory'>Anafunctors in homotopy type theory</a></li>
<li><a href='#related_concepts'>Related concepts</a></li>
<ul>
<li><a href='#anafunctors_versus_representable_profunctors'>Anafunctors versus representable profunctors</a></li>
</ul>
<li><a href='#generalizations'>Generalizations</a></li>
<ul>
<li><a href='#higher_versions'>Higher versions</a></li>
<li><a href='#lower_version'>Lower version</a></li>
<li><a href='#additive_version'>Additive version</a></li>
</ul>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>An <em>anafunctor</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F\colon C \to D</annotation></semantics></math> is a generalized <a class="existingWikiWord" href="/nlab/show/functor">functor</a>.</p>

<p>A basic fact in ordinary <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a> is that a <a class="existingWikiWord" href="/nlab/show/functor">functor</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">f\colon C \to D</annotation></semantics></math> is an <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalence of categories</a> – in that there is a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo lspace="verythinmathspace">:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">g\colon D \to C</annotation></semantics></math> and natural isomorphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi><mo>≃</mo><msub><mi>Id</mi> <mi>D</mi></msub></mrow><annotation encoding="application/x-tex">f \circ g \simeq Id_D</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi><mo>≃</mo><msub><mi>Id</mi> <mi>C</mi></msub></mrow><annotation encoding="application/x-tex">g \circ f \simeq Id_C</annotation></semantics></math> – if and only if it is <a class="existingWikiWord" href="/nlab/show/essentially+surjective+functor">essentially surjective</a> and <a class="existingWikiWord" href="/nlab/show/full+and+faithful+functor">fully faithful</a>. However, the “if” part of this statement depends crucially on the <a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a>: the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> is obtained by <em>choosing</em> for each <a class="existingWikiWord" href="/nlab/show/object">object</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">d \in D</annotation></semantics></math> an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">c \in C</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">f(c) \simeq d</annotation></semantics></math>. In fact, the statement that “every fully faithful and essentially surjective functor is an equivalence of categories” is equivalent to the axiom of choice.</p>

<p>The notion of <em>anafunctor</em> is a generalization of the usual notion of <em>functor</em>, which enables us to recover a version of this statement without the axiom of choice. It was first studied in detail (<a href="#Makkai">Makkai</a>) with <a class="existingWikiWord" href="/nlab/show/foundations">foundational concerns</a> in mind, although it also appears unnamed in (<a href="#Kelly">Kelly</a>). Later, they were applied by <a class="existingWikiWord" href="/nlab/show/Toby+Bartels">Toby Bartels</a> to <a class="existingWikiWord" href="/nlab/show/internal+category">internal categories</a>, where the axiom of choice is simply not an option. These “internal anafunctors” actually turned out to be known already (at least up to equivalence) in some contexts, in particular as <a class="existingWikiWord" href="/nlab/show/Hilsum-Skandalis+morphism">Hilsum-Skandalis morphism</a>s between <a class="existingWikiWord" href="/nlab/show/Lie+groupoid">Lie groupoid</a>s.</p>

<p>We present three motivations and applications of anafunctors:</p>

<ul>
<li>
<p><a href="#FoundationalMotivation">Anafunctors as a tool for handling foundational issues</a></p>
</li>

<li>
<p><a href="#InternalCatMotivation">Anafunctors as morphisms in internal categories</a></p>
</li>

<li>
<p><a href="#HomotopicalMotivation">Anafunctors as morphisms in a homotopy category</a></p>
</li>
</ul>

<h3 id="FoundationalMotivation">Foundational motivation</h3>

<p>There is a sense in which the construction of inverse equivalences is not a “real” use of the axiom of choice, because the choice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math> is determined up to unique isomorphism. Note that in ordinary set theory, the axiom of choice is not necessary to make choices that are uniquely defined; this is sometimes called the “axiom of non-choice” or the “function comprehension principle.” Since in category theory, an object can only be expected to be determined up to unique isomorphism, it is natural to regard the above statement as really being a “<a class="existingWikiWord" href="/nlab/show/functor+comprehension+principle">functor comprehension principle</a>” or an “axiom of non-choice for categories.” The fact that the full axiom of choice is required to make such choices is then an artifact of the usual <a class="existingWikiWord" href="/nlab/show/foundation">foundation</a>al choice to define categories as having a <a class="existingWikiWord" href="/nlab/show/set">set</a> of objects.</p>

<p>In fact, however, we can recover the functor comprehension principle while maintaining the definition of categories in set theory if we modify the notion of <em>functor</em>. This results in the notion of <em>anafunctor</em>, which is essentially “a functor which determines its values on objects only up to isomorphism.” In particular, an anafunctor is an <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalence of categories</a> (in the sense of having an inverse <em>anafunctor</em>) precisely if it is essentially surjective and full and faithful. From this point of view, an anafunctor is not necessarily a fundamental notion, but rather an artifact that makes it possible to approximate the “natural” theory of categories, which doesn’t need choice but has a functor comprehension principle, while still working in a set-theoretic foundation lacking choice.</p>

<p>Every functor may be interpreted as an anafunctor; that every anafunctor is equivalent to a functor is equivalent to the <a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a>, in which case the inclusion of functors into anafunctors is in fact an <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalence of categories</a>. But if you ignore functors and deal only with anafunctors (or saturated anafunctors), then the theory becomes entirely <a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive</a> (without using the axiom of choice or even <a class="existingWikiWord" href="/nlab/show/excluded+middle">excluded middle</a>). Thus, anafunctors (or even saturated anafunctors) are the correct notion to use if you are doing <a class="existingWikiWord" href="/nlab/show/constructive+mathematics">constructive mathematics</a> and you still want to <a class="existingWikiWord" href="/nlab/show/foundations">found</a> mathematics on some sort of <a class="existingWikiWord" href="/nlab/show/set+theory">set theory</a>.</p>

<h3 id="InternalCatMotivation">Motivation from internal categories</h3>

<p>Since questions concerning the axiom of choice tend to look a bit esoteric to those not actively interested in questions of <a class="existingWikiWord" href="/nlab/show/foundations">foundations</a>, it is helpful (and useful!) to think of this more generally in terms of <a class="existingWikiWord" href="/nlab/show/internal+category">internal category</a> theory, where the concept is of independent use, and in fact well known by other names than “anafunctor”.</p>

<p>Consider some ambient category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℰ</mi></mrow><annotation encoding="application/x-tex">\mathcal{E}</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/internalization">internal</a> to which we want to do category theory. A good example to keep in mind is the category <a class="existingWikiWord" href="/nlab/show/Top">Top</a> of <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>s. We observe that “the axiom of choice fails in <a class="existingWikiWord" href="/nlab/show/Top">Top</a>”, but that this is a very non-esoteric and obvious statement: it just means that not every continuous <a class="existingWikiWord" href="/nlab/show/epimorphism">epimorphism</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">P \to X</annotation></semantics></math> between topological spaces has a <em>continuous</em> <a class="existingWikiWord" href="/nlab/show/section">section</a>.</p>

<p>Then it may easily happen that an internal functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">f\colon C \to D</annotation></semantics></math> between <a class="existingWikiWord" href="/nlab/show/internal+category">internal categories</a> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℰ</mi></mrow><annotation encoding="application/x-tex">\mathcal{E}</annotation></semantics></math> (for instance between topological categories) is fully faithful, in the “internal” sense that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>C</mi> <mn>1</mn></msub></mtd> <mtd><mover><mo>→</mo><mrow></mrow></mover></mtd> <mtd><msub><mi>D</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><msub><mi>C</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>C</mi> <mn>0</mn></msub></mtd> <mtd><munder><mo>→</mo><mrow></mrow></munder></mtd> <mtd><msub><mi>D</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>D</mi> <mn>0</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{C_1 &amp; \overset{}{\to} &amp; D_1\\
  \downarrow &amp;&amp; \downarrow\\
  C_0 \times C_0 &amp; \underset{}{\to} &amp; D_0\times D_0}
</annotation></semantics></math></div>
<p>is a <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a>, and essentially surjective, in the “internal” sense that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mn>0</mn></msub><msub><mo>×</mo> <mrow><msub><mi>D</mi> <mn>0</mn></msub></mrow></msub><mi>Iso</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>D</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0 \times_{D_0} Iso(D) \to D_0</annotation></semantics></math> is surjective (or even a quotient map, i.e. a <a class="existingWikiWord" href="/nlab/show/regular+epimorphism">regular epimorphism</a>), but for which there still does not exist a weak inverse in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>ℰ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(\mathcal{E})</annotation></semantics></math>.</p>

<p>For example, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> be a topological space and consider the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">C(U) \to X</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is regarded as an internal category in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Top</mi></mrow><annotation encoding="application/x-tex">Top</annotation></semantics></math> which is <a class="existingWikiWord" href="/nlab/show/discrete+category">discrete</a> in the categorical sense, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(U)</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/Cech+nerve">Cech groupoid</a> associated to an open <a class="existingWikiWord" href="/nlab/show/cover">cover</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">⋃</mo> <mi>i</mi></msub><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X = \bigcup_i U_i</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. That means that the space of objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(U)</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></msub><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\coprod_i U_i</annotation></semantics></math>, and its space of morphisms is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\coprod_{i,j} (U_i\cap U_j)</annotation></semantics></math>. Then the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">C(U)\to X</annotation></semantics></math> is fully faithful (essentially by definition of the morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(U)</annotation></semantics></math>) and essentially surjective (since the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math> are a cover of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>) in the senses above. However, in general it does not admit a weak inverse, since the continuous function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></msub><msub><mi>U</mi> <mi>i</mi></msub><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\coprod_i U_i \to X</annotation></semantics></math> does not have a continuous section if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is connected unless one of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math> is already equal to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>.</p>

<p>Note that the foundational point of view also fits in this picture; we can simply take <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℰ</mi><mo>=</mo><msub><mi>Set</mi> <mrow><mo>¬</mo><mi>AC</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{E} = Set_{\not AC}</annotation></semantics></math> to be the category <a class="existingWikiWord" href="/nlab/show/Set">Set</a> of <a class="existingWikiWord" href="/nlab/show/set">set</a>s in a model of set theory that need not satisfy the <a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a>. Here the same thing may happen: not every fully faithful and essentially surjective functor has a weak inverse.</p>

<h3 id="HomotopicalMotivation">Homotopical motivation</h3>

<p>There is a standard way to deal with such situations where we are faced with a category – here the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>ℰ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(\mathcal{E})</annotation></semantics></math> of categories internal to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℰ</mi></mrow><annotation encoding="application/x-tex">\mathcal{E}</annotation></semantics></math> – some of whose morphisms look like they ought to have inverses, but do not: we call these would-be invertible morphisms <em>weak equivalences</em> such that our category becomes a <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">category with weak equivalences</a> or a <a class="existingWikiWord" href="/nlab/show/homotopical+category">homotopical category</a>. Then we pass to the corresponding <a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a>: the universal “improvement” of our category such that all the would-be invertible morphisms do become invertible.</p>

<p>Here we take the weak equivalences in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>ℰ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(\mathcal{E})</annotation></semantics></math> to be the internal functors that are internally fully faithful and essentially surjective. It turns out that this choice of weak equivalences is particularly well-behaved in that it actually forms a <a class="existingWikiWord" href="/nlab/show/calculus+of+fractions">calculus of fractions</a>. Due to the early work on abstract <a class="existingWikiWord" href="/nlab/show/homotopy+theory">homotopy theory</a> by Gabriel and Zisman, there is simple explicit construction of the corresponding <a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ho</mi><mo stretchy="false">(</mo><mi>Cat</mi><mo stretchy="false">(</mo><mi>ℰ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ho(Cat(\mathcal{E}))</annotation></semantics></math> in this case: the objects are the same as those of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(E)</annotation></semantics></math> – hence <a class="existingWikiWord" href="/nlab/show/internal+category">categories internal to</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℰ</mi></mrow><annotation encoding="application/x-tex">\mathcal{E}</annotation></semantics></math> for us – and the morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">f\colon C \to D</annotation></semantics></math> are <a class="existingWikiWord" href="/nlab/show/span">span</a>s of morphism in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>ℰ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(\mathcal{E})</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mover><mi>C</mi><mo stretchy="false">^</mo></mover></mtd> <mtd><mover><mo>→</mo><mover><mi>f</mi><mo stretchy="false">^</mo></mover></mover></mtd> <mtd><mi>D</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mrow><mo>∈</mo><mi>W</mi></mrow></mpadded></msup></mtd></mtr> <mtr><mtd><mi>C</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \array{
    \hat C &amp;\stackrel{\hat f}{\to}&amp; D
    \\
    \downarrow^{\mathrlap{\in W}}
    \\
    C
  }
  \,,

</annotation></semantics></math></div>
<p>where the left leg is a weak equivalence, hence for us: where the left leg is an internal functor that is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>-surjective for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>. (This is the beginning of the construction of the <a class="existingWikiWord" href="/nlab/show/Dwyer-Kan+localization">Dwyer-Kan localization</a> at our chosen weak equivalences.)</p>

<p>For the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℰ</mi><mo>=</mo><mi>Top</mi></mrow><annotation encoding="application/x-tex">\mathcal{E} = Top</annotation></semantics></math> such a span is a morphism out of a <em>Cech cover</em>. For instance for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">C = X</annotation></semantics></math> a topological space regarded as a topological category, for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/topological+group">topological group</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>=</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">D = \mathbf{B}G</annotation></semantics></math> its <a class="existingWikiWord" href="/nlab/show/delooping">delooping</a> one-object topological groupoid, such a span is a <a class="existingWikiWord" href="/nlab/show/Cech+cohomology">Cech cocycle</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with values in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p>

<p>And finally: for the case that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ℰ</mi><mo>=</mo><msub><mi>Set</mi> <mrow><mo>¬</mo><mi>C</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{E} = Set_{\not C}</annotation></semantics></math> is the category of sets without the axiom of choice, such a span is an <strong>anafunctor</strong>: a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>C</mi><mo stretchy="false">^</mo></mover><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\hat C \to C</annotation></semantics></math> that is surjective on objects and <a class="existingWikiWord" href="/nlab/show/full+and+faithful+functor">full and faithful</a>, together with a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>C</mi><mo stretchy="false">^</mo></mover><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\hat C \to D</annotation></semantics></math> out of the “resolution” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>So one can understand ordinary anafunctors as follows:</p>

<ol>
<li>
<p>first we consider that the <a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a> may fail, which makes previously invertible functors non-invertible;</p>
</li>

<li>
<p>then we universally <em>force</em> the now non-invertible functors to become invertible after all, by throwing in formal inverses for them.</p>
</li>
</ol>

<p>More generally, in any <a class="existingWikiWord" href="/nlab/show/category+of+fibrant+objects">category of fibrant objects</a> the morphisms in the <a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a> are represented by <a class="existingWikiWord" href="/nlab/show/span">span</a>s of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mover><mi>X</mi><mo stretchy="false">^</mo></mover></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Y</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mpadded width="0"><mo>≃</mo></mpadded></msup></mtd></mtr> <mtr><mtd><mi>X</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    \hat X &amp;\to &amp; Y
    \\
    \downarrow^{\mathrlap{\simeq}}
    \\
    X 
  }

</annotation></semantics></math></div>
<p>with the left leg being an acyclic fibration. (This is a special case of the general statements of <a class="existingWikiWord" href="/nlab/show/simplicial+localization">simplicial localization</a>).</p>

<h2 id="definitions">Definitions</h2>

<p>Given categories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>, an <strong>anafunctor</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F\colon C \to D</annotation></semantics></math> may be rather slickly defined as a <a class="existingWikiWord" href="/nlab/show/span">span</a> of ordinary (<a class="existingWikiWord" href="/nlab/show/strict+functor">strict</a>) <a class="existingWikiWord" href="/nlab/show/functors">functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mover><mo>←</mo><mi>σ</mi></mover><mover><mi>F</mi><mo>¯</mo></mover><mover><mo>→</mo><mi>τ</mi></mover><mi>D</mi></mrow><annotation encoding="application/x-tex">C \overset{\sigma}\leftarrow \overline{F} \overset{\tau}\rightarrow D</annotation></semantics></math> (where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> is some category), with the property that the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo lspace="verythinmathspace">:</mo><mover><mi>F</mi><mo>¯</mo></mover><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\sigma\colon {\overline{F}} \to C</annotation></semantics></math> is both <a class="existingWikiWord" href="/nlab/show/faithful+functor">faithful</a> and (strictly!) surjective on both objects and morphisms (therefore both <a class="existingWikiWord" href="/nlab/show/full+functor">full</a> and <a class="existingWikiWord" href="/nlab/show/essentially+surjective+functor">essentially surjective on objects</a>). It is also possible to define an anafunctor as a span in which <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is merely a <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">weak equivalence</a> (that is, faithful, full, and essentially surjective on objects), although that is slightly more complicated to work with.</p>

<h3 id="SetDef">Explicit set-theoretic definition</h3>

<p>In more explicit detail, an <strong>anafunctor</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F\colon C \to D</annotation></semantics></math> consists of:</p>

<ul>
<li>a set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">{|F|}</annotation></semantics></math> of <strong>specifications</strong> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> (which corresponds to the set of objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math>);</li>

<li>maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo lspace="verythinmathspace">:</mo><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\sigma\colon {|F|} \to C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi><mo lspace="verythinmathspace">:</mo><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\tau\colon {|F|} \to D</annotation></semantics></math> (taking values in objects). Given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">x\colon C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo lspace="verythinmathspace">:</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">y\colon D</annotation></semantics></math>, we say that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> is a <strong>specified value</strong> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> if, for some <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo lspace="verythinmathspace">:</mo><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">s\colon {|F|}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x = \sigma(s)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>=</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y = \tau(s)</annotation></semantics></math>; in this case, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> <strong>specifies</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> as a value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, and we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F_s(x) = y</annotation></semantics></math>. That is,<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≔</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex"> F_s(x) \coloneqq \tau(s) .</annotation></semantics></math></div>
<p>We say that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> is a <strong>value</strong> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> is isomorphic (in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>) to some specified value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>; we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F(x) \cong y</annotation></semantics></math>. (There is no notion of <em>the</em> value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, except in the up-to-isomorphism sense of the <a class="existingWikiWord" href="/nlab/show/generalised+the">generalised the</a>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F(x) = y</annotation></semantics></math> is a meaningless statement.);</p>
</li>

<li>for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>,</mo><mi>t</mi><mo lspace="verythinmathspace">:</mo><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">s, t\colon {|F|}</annotation></semantics></math> and morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f\colon \sigma(s) \to \sigma(t)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, a morphism<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><msub><mi>F</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>F</mi> <mi>t</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> F_{s,t}(f)\colon F_s(x) \to F_t(y) </annotation></semantics></math></div>
<p>in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≔</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \coloneqq \sigma(s)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>≔</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \coloneqq \sigma(t)</annotation></semantics></math>. Similarly to the above, we can define whether a given morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> is a <strong>specified value</strong> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at a given morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> or whether <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math> is (merely) a <strong>value</strong> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>. (Again, there is no notion of <em>the</em> value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>.);</p>
</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/surjective+function">surjective function</a>. Thus, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> has <em>some</em> value at any given object or morphism of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. (In the <a class="existingWikiWord" href="/nlab/show/internalization">internalized</a> case, this requirement can become quite complicated; for example, internal to <a class="existingWikiWord" href="/nlab/show/Diff">Diff</a>, one requires a <a class="existingWikiWord" href="/nlab/show/surjective+submersion">surjective submersion</a>.);</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> preserves <a class="existingWikiWord" href="/nlab/show/identity+morphism">identities</a>. That is, given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo lspace="verythinmathspace">:</mo><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">s\colon {|F|}</annotation></semantics></math>, the value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> specified by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> at the identity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(s)</annotation></semantics></math> is the identity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau(s)</annotation></semantics></math>, or (in symbols) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mo lspace="0em" rspace="thinmathspace">id</mo> <mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mo lspace="0em" rspace="thinmathspace">id</mo> <mrow><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">F_{s,s}(\id_{\sigma(s)}) = \id_{\tau(s)}</annotation></semantics></math>, or (whenever this makes sense)<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mo lspace="0em" rspace="thinmathspace">id</mo> <mi>x</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mo lspace="0em" rspace="thinmathspace">id</mo> <mrow><msub><mi>F</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mo>;</mo></mrow><annotation encoding="application/x-tex"> F_{s,s}(\id_x) = \id_{F_s(x)} ;</annotation></semantics></math></div></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> preserves <a class="existingWikiWord" href="/nlab/show/composition">composition</a>. That is, given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>u</mi><mo lspace="verythinmathspace">:</mo><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">s, t, u\colon {|F|}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f\colon \sigma(s) \to \sigma(t)</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo lspace="verythinmathspace">:</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>→</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g\colon \sigma(t) \to \sigma(u)</annotation></semantics></math>,<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>u</mi></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo>;</mo><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>;</mo><msub><mi>F</mi> <mrow><mi>t</mi><mo>,</mo><mi>u</mi></mrow></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding="application/x-tex"> F_{s,u}(f;g) = F_{s,t}(f);F_{t,u}(g) .</annotation></semantics></math></div>
<p>(Here the semicolon indicates composition in the anti-Leibniz order.).</p>
</li>
</ul>

<p>From the above explicit data, the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> is constructed as follows: the objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> are the elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">{|F|}</annotation></semantics></math>, while a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s \to t</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> is simply a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(s) \to \sigma(t)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> extends to a surjective faithful functor from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> (acting as the identity on morphisms), and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math> extends to a functor from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> (mapping the morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo lspace="verythinmathspace">:</mo><mi>s</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">f\colon s \to t</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo lspace="verythinmathspace">:</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_{s,t}(f)\colon \tau(s) \to \tau(t)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>).</p>

<p>An anafunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is <strong>saturated</strong> if, whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F(x) \cong y</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F_s(x) = y</annotation></semantics></math> for some unique specification <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math>, where the unicity of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> depends not only on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> but also on how <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> is a value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>. To be precise: if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo lspace="verythinmathspace">:</mo><mi>y</mi><mo>′</mo><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">g\colon y' \to y</annotation></semantics></math> is an isomorphism in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>′</mo></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">F_{s'}(x) = y'</annotation></semantics></math> for some specification <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">s'</annotation></semantics></math>, then there is a unique specification <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>′</mo><mo>,</mo><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msub><mo lspace="0em" rspace="thinmathspace">id</mo> <mi>x</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">F_{s',s}(\id_x) = g</annotation></semantics></math> (where in particular, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\sigma(s) = x</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>s</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">F_s(x) = y</annotation></semantics></math>). Every anafunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo lspace="verythinmathspace">:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F\colon C \to D</annotation></semantics></math> has a <em>saturation</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math>; <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\overline{F}</annotation></semantics></math> is a saturated anafunctor and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>≅</mo><mover><mi>F</mi><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">F \cong \overline{F}</annotation></semantics></math> in the category of anafunctors from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>. In fact, the inclusion of the saturated anafunctors into the anafunctors (as a full subcategory) is an equivalence of categories (given fixed <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>).</p>

<p>The usual notions of <a class="existingWikiWord" href="/nlab/show/full+functors">full functors</a> and <a class="existingWikiWord" href="/nlab/show/faithful+functors">faithful functors</a> can be generalized to anafunctors. An anafunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is <strong>full</strong> if the maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>:</mo><mi>Hom</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>,</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mi>Hom</mi><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>,</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_{s, t}: Hom(\sigma(s), \sigma(t)) \to Hom(\tau(s), \tau(t))</annotation></semantics></math> are all surjective, and it is <strong>faithful</strong> if the maps are injective.</p>

<p>Anafunctors can be composed via pullback. Given anafunctors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F: C \to D</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">G: D \to E</annotation></semantics></math>, we can form the pullback</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mo stretchy="false">|</mo><mi>GF</mi><mo stretchy="false">|</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mo stretchy="false">|</mo><mi>G</mi><mo stretchy="false">|</mo></mtd> <mtd><mover><mo>→</mo><mrow><msub><mi>τ</mi> <mi>G</mi></msub></mrow></mover><mi>E</mi></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo><mpadded width="0"><mrow><msub><mi>σ</mi> <mi>G</mi></msub></mrow></mpadded></mtd></mtr> <mtr><mtd><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mtd> <mtd><munder><mo>→</mo><mrow><msub><mi>τ</mi> <mi>F</mi></msub></mrow></munder></mtd> <mtd><mi>D</mi></mtd></mtr> <mtr><mtd><mpadded width="0" lspace="-100%width"><mrow><msub><mi>σ</mi> <mi>F</mi></msub></mrow></mpadded><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>C</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\array{
  |GF|                &amp; \to                 &amp; |G|        &amp; \overset{\tau_G}\to E\\
  \downarrow          &amp;                     &amp; \downarrow\mathrlap{\sigma_G}\\
  |F|                 &amp; \underset{\tau_F}\to &amp; D\\
  \mathllap{\sigma_F}\downarrow\\
  C
}

</annotation></semantics></math></div>
<p>More explicitly, the specifications are given by pairs <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo><mo>×</mo><mo stretchy="false">|</mo><mi>G</mi><mo stretchy="false">|</mo></mrow><annotation encoding="application/x-tex">(s, t) \in |F| \times |G|</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>τ</mi> <mi>F</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi> <mi>G</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau_F(s) = \sigma_G(t)</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>σ</mi> <mrow><mi>G</mi><mi>F</mi></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>σ</mi> <mi>F</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{G F}(s, t) = \sigma_F(s)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>τ</mi> <mrow><mi>G</mi><mi>F</mi></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>τ</mi> <mi>G</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tau_{G F}(s, t) = \tau_G(t)</annotation></semantics></math>. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mi>s</mi><mo>′</mo><mo>,</mo><mi>t</mi><mo>′</mo><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">|</mo><mi>GF</mi><mo stretchy="false">|</mo></mrow><annotation encoding="application/x-tex">(s, t), (s', t') \in |GF|</annotation></semantics></math> and an arrow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><msub><mi>σ</mi> <mi>F</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>σ</mi> <mi>F</mi></msub><mo stretchy="false">(</mo><mi>s</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f: \sigma_F(s) \to \sigma_F(s')</annotation></semantics></math>, we obtain an arrow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>s</mi><mo>′</mo></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>s</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_{s, s'}(f): \tau(s) \to \tau(s')</annotation></semantics></math>. This is also an arrow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>σ</mi> <mi>G</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>σ</mi> <mi>G</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_G(t) \to \sigma_G(t')</annotation></semantics></math>, so we can lift this map to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>G</mi> <mrow><mi>t</mi><mo>,</mo><mi>t</mi><mo>′</mo></mrow></msub><msub><mi>F</mi> <mrow><mi>s</mi><mo>,</mo><mi>s</mi><mo>′</mo></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>→</mo><mi>τ</mi><mo stretchy="false">(</mo><mi>t</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_{t, t'}F_{s, s'}(f): \tau(t) \to \tau(t')</annotation></semantics></math>, and this completes the description of the anafunctor. The other axioms can be verified straightforwardly.</p>

<p>Categories, anafunctors, and a suitably defined notion of <a class="existingWikiWord" href="/nlab/show/ananatural+transformation">ananatural transformation</a> between them form a <a class="existingWikiWord" href="/nlab/show/bicategory">bicategory</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math>; an internal <a class="existingWikiWord" href="/nlab/show/equivalence">equivalence</a> in this 2-category is called an <strong>anaequivalence</strong>. Every functor may be interpreted as an anafunctor, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo></mrow></mrow><annotation encoding="application/x-tex">{|F|}</annotation></semantics></math> always taken to be (the set of objects in) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> itself and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> the <a class="existingWikiWord" href="/nlab/show/identity+functor">identity functor</a>. Indeed, there is a <a class="existingWikiWord" href="/nlab/show/2-functor">2-functor</a> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math> from the <a class="existingWikiWord" href="/nlab/show/strict+2-category">strict 2-category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Str</mi><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Str Cat</annotation></semantics></math> of categories, functors and natural transformations; this functor is an <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalence</a> if and only if the <a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a> holds. Thus, most mathematicians will identify <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Str</mi><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Str Cat</annotation></semantics></math> as simply <a class="existingWikiWord" href="/nlab/show/Cat">Cat</a>, the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-category of categories; however, mathematicians who doubt the axiom of choice will distinguish them. While anafunctors exist in any case, there is an ideological statement that may be implied by their use: that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math> is <em>really</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math> rather than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Str</mi><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Str Cat</annotation></semantics></math>.</p>

<p>In any case, (modulo “size issues” which one may want to impose) the inclusion of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Str</mi><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Str Cat</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math> has a right adjoint, described using <a class="existingWikiWord" href="/nlab/show/clique">clique</a>s. Accordingly, we can instead define anafunctors by means of clique categories, taking an anafunctor from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> to be a genuine functor from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Clique</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Clique(D)</annotation></semantics></math> (and the 2-category of anafunctors as the <a class="existingWikiWord" href="/nlab/show/Kleisli+category">Kleisli category</a> for the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Clique</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Clique(-)</annotation></semantics></math> 2-monad (in particular, natural transformations between anafunctors into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> are simply natural transformations of the corresponding genuine functors into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Clique</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Clique(D)</annotation></semantics></math>)).</p>

<h3 id="internal_definition_using_covers">Internal definition using covers</h3>

<p>We generalise the slick definition of anafunctors as spans rather than the detailed definition involving specified values.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> be a category containing a collection of morphisms called “covers” such that</p>

<ul>
<li>every <a class="existingWikiWord" href="/nlab/show/isomorphism">isomorphism</a> is a cover,</li>

<li>covers are closed under composition,</li>

<li>any <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of a cover exists and is a cover (<a class="existingWikiWord" href="/nlab/show/pullback+stability">pullback stability</a>),</li>

<li>every cover is the <a class="existingWikiWord" href="/nlab/show/quotient+object">quotient object</a> of its <a class="existingWikiWord" href="/nlab/show/kernel+pair">kernel pair</a>, i.e. is an <a class="existingWikiWord" href="/nlab/show/effective+epimorphism">effective epimorphism</a>. (Since all pullbacks of covers exist, this is equivalent to saying that every cover is a <a class="existingWikiWord" href="/nlab/show/regular+epimorphism">regular epimorphism</a>.)</li>
</ul>

<p>Note that these are precisely the axioms saying that the singleton families <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>p</mi><mo lspace="verythinmathspace">:</mo><mi>V</mi><mo>→</mo><mi>U</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{p\colon V\to U\}</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math> is a cover form a <a class="existingWikiWord" href="/nlab/show/subcanonical+coverage">subcanonical</a> <a class="existingWikiWord" href="/nlab/show/Grothendieck+pretopology">Grothendieck pretopology</a>. One important class of examples is when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/regular+category">regular category</a> and the covers are the <a class="existingWikiWord" href="/nlab/show/regular+epimorphisms">regular epimorphisms</a>. Another is when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> is the category of smooth manifolds and the covers are the surjective submersions.</p>

<p>In such a situation, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> are <a class="existingWikiWord" href="/nlab/show/internal+category">internal categories</a> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>, we define an <strong>anafunctor</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\to D</annotation></semantics></math> to consist of a span <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>←</mo><mi>F</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\leftarrow F \to D</annotation></semantics></math> of internal functors such that:</p>

<ol>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mn>0</mn></msub><mo>→</mo><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0\to C_0</annotation></semantics></math> (the map of objects) is a cover.</p>
</li>

<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F\to C</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/ff+morphism">fully-faithful</a>, in the internal sense that the following is a pullback square:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>F</mi> <mn>1</mn></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><msub><mi>C</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><msub><mi>F</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>F</mi> <mn>0</mn></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><msub><mi>C</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>C</mi> <mn>0</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{F_1 &amp; \to &amp; C_1 \\ \downarrow &amp;&amp; \downarrow \\ F_0\times F_0&amp;   \to &amp; C_0\times C_0}</annotation></semantics></math></div></li>
</ol>

<p>Note that assuming <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mn>0</mn></msub><mo>→</mo><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0\to C_0</annotation></semantics></math> is a cover, so is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>F</mi> <mn>0</mn></msub><mo>→</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0\times F_0\to C_0\times C_0</annotation></semantics></math> (it is a composition of pullbacks of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mn>0</mn></msub><mo>→</mo><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0\to C_0</annotation></semantics></math>); thus the above pullback always exists.</p>

<p>By the remarks above, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/Set">Set</a> and “cover” means “<a class="existingWikiWord" href="/nlab/show/surjection">surjection</a>” (an example where the covers are the regular epimorphisms), then we recover the original external notion of (<a class="existingWikiWord" href="/nlab/show/small+category">small</a>) anafunctor. An anafunctor, defined in this way, is saturated just when the map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>core</mi><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>→</mo><mi>core</mi><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">core(F) \to core(C\times D)</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/cores">cores</a> is an <a class="existingWikiWord" href="/nlab/show/isofibration">isofibration</a>, so we need an internal notion of core to define saturated anafunctors internally. An anafunctor is an anaequivalence when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F\to D</annotation></semantics></math> is fully faithful and <a class="existingWikiWord" href="/nlab/show/essentially+surjective+functor">essentially surjective</a>, meaning the canonical map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mn>0</mn></msub><msub><mo>×</mo> <mrow><msub><mi>C</mi> <mn>0</mn></msub></mrow></msub><msub><mi>C</mi> <mn>1</mn></msub><mo>→</mo><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0\times_{C_0}C_1 \to C_0</annotation></semantics></math> has splits over a cover of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0</annotation></semantics></math>. For <a class="existingWikiWord" href="/nlab/show/Lie+groupoids">Lie groupoids</a>, these are the <a class="existingWikiWord" href="/nlab/show/Morita+equivalences">Morita equivalences</a>.</p>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>←</mo><mi>F</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\leftarrow F \to D</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>←</mo><mi>G</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\leftarrow G \to D</annotation></semantics></math> are internal anafunctors, we define an <strong><a class="existingWikiWord" href="/nlab/show/ananatural+transformation">ananatural transformation</a></strong> between them (or simply a <em>natural transformation</em>, given the context) to be a <a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a> between the two induced internal functors <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><msub><mo>×</mo> <mi>C</mi></msub><mi>G</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F\times_C G \to D</annotation></semantics></math>. We can then prove that internal categories, anafunctors, and natural transformations form a <a class="existingWikiWord" href="/nlab/show/bicategory">bicategory</a>. (Interestingly, you may need the axiom of choice in the <span class="newWikiWord">metalogic<a href="/nlab/new/metalogic">?</a></span> to conclude this, depending on whether there is a natural way to choose the necessary pullbacks; else you get an <a class="existingWikiWord" href="/nlab/show/anabicategory">anabicategory</a>, in which the composition functors are anafunctors.)</p>

<p>The role of the assumptions about covers is:</p>

<ul>
<li>Identity maps must be covers in order to have identity anafunctors (and more generally, for every functor to give rise to an anafunctor).</li>

<li>To compose anafunctors by pullback, the pullbacks of covers must exist and be covers, and covers must be closed under composition.</li>

<li>To define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><msub><mo>×</mo> <mi>C</mi></msub><mi>G</mi></mrow><annotation encoding="application/x-tex">F \times_C G</annotation></semantics></math> and obtain a notion of natural transformation, we again need covers to have pullbacks.</li>

<li>To define composition of natural transformations between anafunctors, we need covers to be effective; see diagram (118) in <a href="#HGT1">HGT1</a>.</li>
</ul>

<p>Note: in Section 1.1.5 of <a href="#HGT1">HGT1</a>, the following additional axiom was assumed on the class of covers:</p>

<ul>
<li>every <a class="existingWikiWord" href="/nlab/show/congruence">congruence</a> involving a cover has a quotient object which is a cover.</li>
</ul>

<p>This is not needed for anafunctors but is used to relate descent to bundles (and then to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math>-bundles).</p>

<h3 id="as_an_operation_on_2categories">As an operation on 2-categories</h3>

<p><em>This section is work in progress by <a class="existingWikiWord" href="/nlab/show/David+Roberts">me</a></em></p>

<p>While internal anafunctors seem to require a lot of baggage, they can be defined very elegantly by working with the 2-category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(S)</annotation></semantics></math> (or some sub-2-category thereof) as a 2-category. One first makes the observation:</p>

<ul>
<li>functors internal to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> which are fully faithful and whose object component belongs to a singleton Grothendieck pretopology themselves form a (strict) singleton pretopology on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(S)</annotation></semantics></math>. Thus one can consider anafunctors as spans in a 2-category where the source leg belongs to a strict, subcanonical singleton Grothendieck pretopology, all of whose covers are <a class="existingWikiWord" href="/nlab/show/ff+morphism">ff</a>.</li>
</ul>

<h3 id="homotopytheoretic_interpretation">Homotopy-theoretic interpretation</h3>

<p>Observe that the surjective-on-objects equivalences are precisely the <a class="existingWikiWord" href="/nlab/show/model+category">acyclic fibrations</a> for the <a class="existingWikiWord" href="/nlab/show/canonical+model+structure">canonical model structure</a> on <a class="existingWikiWord" href="/nlab/show/Cat">Cat</a>. Therefore, anafunctors can be identified with the “one-step generalized morphisms” in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi></mrow><annotation encoding="application/x-tex">Cat</annotation></semantics></math> whose first leg is not just a <a class="existingWikiWord" href="/nlab/show/weak+equivalence">weak equivalence</a> but an acyclic fibration. However, it appears that the canonical model structure on Cat only exists (with its weak equivalences being the fully faithful and essentially surjective maps) under the assumption of some choice—though full AC is not needed, <a class="existingWikiWord" href="/nlab/show/COSHEP">COSHEP</a> suffices.</p>

<p>More generally, it is proven in <a href="#EKV">EKV</a> that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> has a Grothendieck coverage, then under suitable additional conditions on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> (and, of course, the axiom of choice assumed external to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>), there is a <a class="existingWikiWord" href="/nlab/show/model+category">model structure</a> on the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Cat</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cat(S)</annotation></semantics></math> of internal categories in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> relative to that coverage. The internal anafunctors relative to the given coverage, as defined above, can then once again be identified with the spans whose first leg is an acyclic fibration.</p>

<p>Since all objects in the canonical model structure on Cat are fibrant, according to Kenneth Brown’s theorem in <a class="existingWikiWord" href="/nlab/show/homotopical+cohomology+theory">homotopical cohomology theory</a> it follows that one-step generalized morphisms already realize the full localization, i.e. they represent all morphisms in the <a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ho</mi><mo stretchy="false">(</mo><mi>Cat</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ho(Cat)</annotation></semantics></math>.</p>

<p>If we specialize to groupoids, with their canonical model structure by <a class="existingWikiWord" href="/nlab/show/Ronnie+Brown">Brown</a>–<a class="existingWikiWord" href="/nlab/show/Marek+Golasi%C5%84ski">Golasiński</a>, then by the general idea of <a class="existingWikiWord" href="/nlab/show/homotopical+cohomology+theory">homotopical cohomology theory</a> this means that anafunctors between groupoids represent <a class="existingWikiWord" href="/nlab/show/nonabelian+cocycle">nonabelian cocycle</a>s on groupoids with values in groupoids. By the notion of <a class="existingWikiWord" href="/nlab/show/descent">codescent</a> such homotopical cocycles are related to <a class="existingWikiWord" href="/nlab/show/descent">descent data</a> that enters the definition of <a class="existingWikiWord" href="/nlab/show/sheaf">sheaves</a> and <a class="existingWikiWord" href="/nlab/show/stack">stack</a>s.</p>

<h2 id="examples">Examples</h2>

<p>We will use the <a href="/nlab/show/anafunctor#SetDef">explicit set-theoretic definition</a> in this section.</p>

<h3 id="product_anafunctor">Product anafunctor</h3>

<p>Given a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> with <a class="existingWikiWord" href="/nlab/show/cartesian+product">binary products</a>, we can form a product functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo>:</mo><mi>C</mi><mo>×</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">P: C \times C \to C</annotation></semantics></math> that sends a pair of objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, B)</annotation></semantics></math> to a product of them. This requires picking a product for each pair, and hence requires the <a class="existingWikiWord" href="/nlab/show/axiom+of+choice">axiom of choice</a>.</p>

<p>However, we can form the product anafunctor without using choice. The specifications are given by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">|</mo><mi>P</mi><mo stretchy="false">|</mo><mo>=</mo><mtext>product diagrams in </mtext><mspace width="thickmathspace"></mspace><mi>C</mi></mrow><annotation encoding="application/x-tex">|P| = \text{product diagrams in }\;C</annotation></semantics></math>, and the maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><mo stretchy="false">|</mo><mi>P</mi><mo stretchy="false">|</mo><mo>→</mo><mi>C</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\sigma: |P| \to C \times C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi><mo>:</mo><mo stretchy="false">|</mo><mi>P</mi><mo stretchy="false">|</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\tau: |P| \to C</annotation></semantics></math> are given by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>A</mi><mo>←</mo><mi>D</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>,</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mi>τ</mi><mo stretchy="false">(</mo><mi>A</mi><mo>←</mo><mi>D</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \sigma(A \leftarrow D \rightarrow B) = (A, B),\;\; \tau(A \leftarrow D \rightarrow B) = D.

</annotation></semantics></math></div>
<p>Given product diagrams <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>←</mo><mi>D</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \leftarrow D \rightarrow B</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>′</mo><mo>←</mo><mi>D</mi><mo>′</mo><mo>→</mo><mi>B</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">A' \leftarrow D' \rightarrow B'</annotation></semantics></math>, and a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>A</mi><mo>′</mo><mo>,</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f, g): (A, B) \to (A', C')</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">C \times C</annotation></semantics></math>, we obtain <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false">)</mo><mo>:</mo><mi>D</mi><mo>→</mo><mi>D</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">P(f, g): D \to D'</annotation></semantics></math> by the universal property of the product. The compatibility conditions are easy to check.</p>

<h3 id="anafunctor_from_functor">Anafunctor from functor</h3>

<p>Suppose we have a usual functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F: C \to D</annotation></semantics></math>. Then we can obtain an anafunctor as the span</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>C</mi></mtd> <mtd><mover><mo>→</mo><mi>F</mi></mover></mtd> <mtd><mi>D</mi></mtd></mtr> <mtr><mtd><mpadded width="0" lspace="-100%width"><mrow><msub><mi>id</mi> <mi>C</mi></msub></mrow></mpadded><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>C</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\array{
  C &amp; \overset{F}\to &amp; D\\
  \mathllap{id_C} \downarrow \\
  C
}

</annotation></semantics></math></div>
<p>The composition of anafunctors agree with the composition of functors.</p>

<h3 id="inverses_of_anafunctors">Inverses of anafunctors</h3>

<p>Given an anafunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F: C \to D</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\sigma: |F| \to C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi><mo>:</mo><mo stretchy="false">|</mo><mi>F</mi><mo stretchy="false">|</mo><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\tau: |F| \to D</annotation></semantics></math>, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> (ie. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math>) is essentially surjective, then its saturation is strictly surjective.</p>

<p>Then given a saturated full and faithfull essentially surjective anafunctor, we can obtain an inverse anafunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>F</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F^{-1}: D \to C</annotation></semantics></math> by swapping <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> around. The conditions of being full and faithful and essentially surjective guarantees the axioms are still satisfied.</p>

<h2 id="SizeQuestions">Questions of size</h2>

<p>Even if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> are <a class="existingWikiWord" href="/nlab/show/small+categories">small categories</a>, then the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ana</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ana(C,D)</annotation></semantics></math> of anafunctors from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> is not necessarily even essentially small, and thus the 2-category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math> of categories and anafunctors is not <a class="existingWikiWord" href="/nlab/show/cartesian+closed+category">cartesian closed</a>. Some models in which this fails to be true are sketched in <a href="#HenryMO">this MO discussion</a>.</p>

<p>This is true, however, under the assumption of <a class="existingWikiWord" href="/nlab/show/COSHEP">COSHEP</a>, since in that case (as above) anafunctors represent maps in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ho</mi><mo stretchy="false">(</mo><mi>Cat</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ho(Cat)</annotation></semantics></math>, which is locally small by general model category theory. More specifically, under COSHEP every anafunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>←</mo><mi>F</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\leftarrow F \to D</annotation></semantics></math> is equivalent to one where the set of objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mn>0</mn></msub><mo>′</mo></mrow><annotation encoding="application/x-tex">C_0'</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mn>0</mn></msub><mo>′</mo><mo>→</mo><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0'\to C_0</annotation></semantics></math> is a projective cover of the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0</annotation></semantics></math> of objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>COSHEP is actually stronger than necessary for this; all that is really needed is <a class="existingWikiWord" href="/nlab/show/WISC">WISC</a>, i.e. for any set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, the full subcategory of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi><mo stretchy="false">/</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Set/X</annotation></semantics></math> consisting of surjections has a <a class="existingWikiWord" href="/nlab/show/weakly+initial+set">weakly initial set</a>. For in that case, any anafunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>←</mo><mi>F</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\leftarrow F \to D</annotation></semantics></math> is equivalent to one where the set of objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>, equipped with its surjection to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mn>0</mn></msub></mrow><annotation encoding="application/x-tex">C_0</annotation></semantics></math>, belongs to the weakly initial set. Note that COSHEP implies WISC, as do the <a class="existingWikiWord" href="/nlab/show/axiom+of+multiple+choice">axiom of multiple choice</a> and the axiom of <a class="existingWikiWord" href="/nlab/show/small+violations+of+choice">small violations of choice</a> (SVC).</p>

<p>In <a href="#Makkai">Makkai’s paper</a>, he proves that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ana</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ana(C,D)</annotation></semantics></math> is essentially small under the assumption of his <a class="existingWikiWord" href="/nlab/show/small+cardinality+selection+axiom">small cardinality selection axiom</a> (SCSA), which also follows from SVC. Although SCSA and WISC carry the same feel that “choice is violated only in a small way,” Makkai’s proof from SCSA is an “injective” approach, in that the set of possibilities for the objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is constructed mainly from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>, rather than purely from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> as in the “projective” approach above using COSHEP or WISC.</p>

<p>Another axiom ensuring that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ana</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ana(C,D)</annotation></semantics></math> is essentially small is the <a class="existingWikiWord" href="/nlab/show/axiom+of+stack+completions">axiom of stack completions</a> (ASC), since if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>→</mo><mover><mi>D</mi><mo stretchy="false">^</mo></mover></mrow><annotation encoding="application/x-tex">D\to \hat{D}</annotation></semantics></math> is an intrinsic stack completion we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ana</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mi>D</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>Fun</mi><mo stretchy="false">(</mo><mi>C</mi><mo>,</mo><mover><mi>D</mi><mo stretchy="false">^</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ana(C,D) \simeq Fun(C,\hat{D})</annotation></semantics></math>.</p>

<p>In particular, the bicategory of categories and anafunctors is locally essentially small and cartesian closed in the internal logic of any <a class="existingWikiWord" href="/nlab/show/Grothendieck+topos">Grothendieck topos</a>, because the latter satisfies WISC, SCSA, and ASC.</p>

<h2 id="anafunctors_in_homotopy_type_theory">Anafunctors in homotopy type theory</h2>

<p>Anafunctors are unnecessary when using “saturated/univalent” categories in <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> (see Def. 9.1.3 of <a class="existingWikiWord" href="/nlab/show/the+HoTT+book">the HoTT book</a>, and Chap. 9 notes), because of their <a class="existingWikiWord" href="/nlab/show/functor+comprehension+principle">functor comprehension principle</a>. An anafunctor is a span whose first leg is a surjective and fully faithful functor, but for saturated categories any such functor is an equivalence (in the strong sense of having an inverse), so any anafunctor is equivalent to a functor.</p>

<h2 id="related_concepts">Related concepts</h2>

<h3 id="anafunctors_versus_representable_profunctors">Anafunctors versus representable profunctors</h3>

<p>A different way of describing “a functor whose values are determined only up to isomorphism” is with a representable <a class="existingWikiWord" href="/nlab/show/profunctor">profunctor</a> (a.k.a. distributor). A profunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mi>⇸</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A &amp;#8696; B</annotation></semantics></math> is a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi><mo>→</mo><mo stretchy="false">[</mo><msup><mi>B</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F\colon A \to [B^{op},Set]</annotation></semantics></math>, and we call it <em>representable</em> if each <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(a)</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/representable+functor">representable</a>.</p>

<p>In the presence of <a class="existingWikiWord" href="/nlab/show/axiom+of+choice">AC</a>, one can then choose a representing object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>a</mi></msub><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">F_a\in B</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and thereby define a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\to B</annotation></semantics></math>, but without choice this is generally not possible. However, one can define an anafunctor from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, whose specifications at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> are “representations” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(a)</annotation></semantics></math>.</p>

<p>Conversely, given an anafunctor represented by a span <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mover><mo>←</mo><mi>g</mi></mover><mi>P</mi><mover><mo>→</mo><mi>f</mi></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">A \xleftarrow{g} P \xrightarrow{f} B</annotation></semantics></math>, one can define a profunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mi>⇸</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A &amp;#8696; B</annotation></semantics></math> as the composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mo>*</mo></msub><mo>∘</mo><msup><mi>g</mi> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">f_* \circ g^*</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>f</mi> <mo>*</mo></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mo stretchy="false">(</mo><mi>b</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_*(p)(b) = B(b,f(p))</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>g</mi> <mo>*</mo></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_*(a)(p) = A(g(p),a)</annotation></semantics></math>, and this profunctor will be representable. This defines a bijective-on-objects <a class="existingWikiWord" href="/nlab/show/equivalence+of+2-categories">equivalence of 2-categories</a> between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Prof</mi> <mi>rep</mi></msub></mrow><annotation encoding="application/x-tex">Prof_{rep}</annotation></semantics></math>, the <a class="existingWikiWord" href="/nlab/show/locally+full+sub-2-category">locally full sub-2-category</a> of <a class="existingWikiWord" href="/nlab/show/Prof">Prof</a> determined by the representable profunctors. (This appears to have been written down first <a href="http://permalink.gmane.org/gmane.science.mathematics.categories/6485">here</a> by <a class="existingWikiWord" href="/nlab/show/Jean+Benabou">Jean Benabou</a>).</p>

<p>Anafunctors and representable profunctors each have advantages. For purposes which require only the 2-category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub><mo>≃</mo><msub><mi>Prof</mi> <mi>rep</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}\simeq Prof_{rep}</annotation></semantics></math>, either one is of course sufficient. For instance, a non-<a class="existingWikiWord" href="/nlab/show/cleavage">cloven</a> <a class="existingWikiWord" href="/nlab/show/Grothendieck+fibration">Grothendieck fibration</a> can equally well be turned into a <a class="existingWikiWord" href="/nlab/show/pseudofunctor">pseudofunctor</a> valued in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana}</annotation></semantics></math> or in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Prof</mi> <mi>rep</mi></msub></mrow><annotation encoding="application/x-tex">Prof_{rep}</annotation></semantics></math>. However, in this case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Prof</mi> <mi>rep</mi></msub></mrow><annotation encoding="application/x-tex">Prof_{rep}</annotation></semantics></math> is arguably more natural, since an arbitrary functor (not necessarily a fibration) <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math> can be turned into a normal <a class="existingWikiWord" href="/nlab/show/lax+2-functor">lax 2-functor</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>B</mi> <mi>op</mi></msup><mo>→</mo><mi>Prof</mi></mrow><annotation encoding="application/x-tex">B^{op}\to Prof</annotation></semantics></math>, which is a pseudofunctor landing in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Prof</mi> <mi>rep</mi></msub></mrow><annotation encoding="application/x-tex">Prof_{rep}</annotation></semantics></math> exactly when the given functor was a fibration. (It is a pseudofunctor landing in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Prof</mi> <mi>corep</mi></msub></mrow><annotation encoding="application/x-tex">Prof_{corep}</annotation></semantics></math> iff the functor was an opfibration, and it is a pseudofunctor iff the functor was <a class="existingWikiWord" href="/nlab/show/exponentiable+functor">exponentiable</a>.) More generally, one good point about using representable profunctors is that they fit in immediately with the general notion of profunctor.</p>

<p>On the other hand, sometimes it requires a little contortion to put something in the form of a representable distributor. For instance, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> has binary <a class="existingWikiWord" href="/nlab/show/products">products</a>, then there is obviously a product-assigning representable distributor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi><mo>×</mo><mi>A</mi><mi>⇸</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">P\colon A \times A  &amp;#8696; A</annotation></semantics></math> defined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>a</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>a</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Hom</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><msub><mi>a</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><msub><mi>Hom</mi> <mi>A</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><msub><mi>a</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(a_1,a_2)(a) = Hom_A(a,a_1) \times Hom_A(a,a_2)</annotation></semantics></math>. But if A has binary <a class="existingWikiWord" href="/nlab/show/coproducts">coproducts</a>, then in order to define a coproduct-assigning representable distributor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo lspace="verythinmathspace">:</mo><mi>A</mi><mo>×</mo><mi>A</mi><mi>⇸</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">C\colon  A \times A  &amp;#8696; A</annotation></semantics></math>, one needs to say something like</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>a</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">C(a_1,a_2)(a)=</annotation></semantics></math> the set of triples <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi> <mn>3</mn></msub><mo>,</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>p</mi> <mn>2</mn></msub><mo>,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_3,p_1,p_2,f)</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub><mo lspace="verythinmathspace">:</mo><msub><mi>a</mi> <mi>i</mi></msub><mo>→</mo><msub><mi>a</mi> <mn>3</mn></msub></mrow><annotation encoding="application/x-tex">p_i\colon a_i \to a_3</annotation></semantics></math> are the injections into a coproduct and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math> is a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi><mo>→</mo><msub><mi>a</mi> <mn>3</mn></msub></mrow><annotation encoding="application/x-tex">a \to a_3</annotation></semantics></math>, modulo an equivalence relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi> <mn>3</mn></msub><mo>,</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>p</mi> <mn>2</mn></msub><mo>,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>∼</mo><mo stretchy="false">(</mo><msub><mi>a</mi> <mn>3</mn></msub><mo>′</mo><mo>,</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>′</mo><mo>,</mo><msub><mi>p</mi> <mn>2</mn></msub><mo>′</mo><mo>,</mo><mi>f</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_3,p_1,p_2,f) \sim (a_3',p_1',p_2',f')</annotation></semantics></math> if there exists a (necessarily unique iso)morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo lspace="verythinmathspace">:</mo><msub><mi>a</mi> <mn>3</mn></msub><mo>→</mo><msub><mi>a</mi> <mn>3</mn></msub><mo>′</mo></mrow><annotation encoding="application/x-tex">g\colon a_3 \to a_3'</annotation></semantics></math> commuting with all the structure maps.</li>
</ul>

<p>(This is essentially making explicit the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Cat</mi> <mi>ana</mi></msub><mo>→</mo><msub><mi>Prof</mi> <mi>rep</mi></msub></mrow><annotation encoding="application/x-tex">Cat_{ana} \to Prof_{rep}</annotation></semantics></math> defined above.) Of course, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is more easily defined as a <em><a class="existingWikiWord" href="/nlab/show/corepresentable+functor">corepresentable</a></em> distributor. But if we want to define a functor that involves both limits and colimits, like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>↦</mo><mi>a</mi><mo>×</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b,c) \mapsto a \times (b + c)</annotation></semantics></math>, then it is not “naturally” represented as either a representable or a corepresentable profunctor. However, with anafunctors, all of these functors can be represented “naturally” in analogous ways. In the first case, we consider the span <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>A</mi><mo>←</mo><mi>P</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A\times A \leftarrow P \to A</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math> is the category of binary product diagrams in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. In the second case, we consider the span <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>A</mi><mo>←</mo><mi>C</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A\times A \leftarrow C \to A</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is the category of binary coproduct diagrams. And in the third case, we consider the span <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>←</mo><mi>D</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A\times A\times A \leftarrow D \to A</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> is the category of binary coproduct diagrams together with a product diagram one of whose factors is the vertex of the coproduct diagram.</p>

<p>Roughly speaking, anafunctors are formulated exactly in order to describe “functors defined up to isomorphism,” while representable distributors describe “functors valued in representable presheaves.” “Objects defined up to isomorphism” and “representable presheaves” are <em>formally</em> equivalent (without invoking AC), but not every “naturally occurring” object-defined-up-to-isomorphism is “given in nature” by the presheaf it represents. Some are given by the <a class="existingWikiWord" href="/nlab/show/copresheaf">copresheaf</a> they corepresent; others aren’t given directly in either of those ways. One can also think of an anafunctor as a particularly convenient “presentation” of a representable distributor.</p>

<p>A further reason that the notion of anafunctor is useful is that when working with <a class="existingWikiWord" href="/nlab/show/internal+categories">internal categories</a>, the quotienting operations necessary to define the composite of internal profunctors may not exist, whereas internal anafunctors can always be composed. Thus, when working with (for instance) <a class="existingWikiWord" href="/nlab/show/smooth+manifold">smooth</a> categories or groupoids, profunctors are not so much an option, but anafunctors are well-behaved (see the papers by Bartels and Roberts referenced below).</p>

<h2 id="generalizations">Generalizations</h2>

<h3 id="higher_versions">Higher versions</h3>

<p>see <a class="existingWikiWord" href="/nlab/show/infinity-anafunctor">infinity-anafunctor</a></p>

<h3 id="lower_version">Lower version</h3>

<p>see <a class="existingWikiWord" href="/nlab/show/anafunction">anafunction</a></p>

<h3 id="additive_version">Additive version</h3>

<p>The notion of abelian <a class="existingWikiWord" href="/nlab/show/butterfly">butterfly</a> introduced by Behrang Noohi <a href="http://arxiv.org/abs/math.CT/0506313">Weak maps of 2-groups</a> is the additive version of the notion of (saturated) anafunctor: the equivalence between, on the one hand, internal groupoids and internal functors and, on the other hand, arrows and commutative squares in an abelian category extends to an equivalence between saturated anafunctors and butterflies.</p>

<h2 id="references">References</h2>

<p>The term “anafunctor” was introduced by Michael Makkai in</p>

<ul>
<li id="Makkai"><a class="existingWikiWord" href="/nlab/show/Michael+Makkai">Michael Makkai</a>, <em>Avoiding the axiom of choice in general category theory</em>, Journal of Pure and Applied Algebra <strong>108</strong> isse 2 (1996) pp 109-173, doi:<a href="https://doi.org/10.1016/0022-4049%2895%2900029-1">10.1016/0022-4049(95)00029-1</a>, (<a href="http://www.math.mcgill.ca/makkai/anafun/">author’s page</a>)</li>
</ul>

<p>motivated in part to complete the analogy prophase:anaphase::profunctor:??.</p>

<p>The concept also appears, unnamed, in the article</p>

<p id="Kelly"><a class="existingWikiWord" href="/nlab/show/Max+Kelly">Max Kelly</a>, <em>Complete functors in homology I</em> (1963)</p>

<p>on <a class="existingWikiWord" href="/nlab/show/homological+algebra">homological algebra</a>.</p>

<p>The popularity of the term was notably pushed by <a class="existingWikiWord" href="/nlab/show/Toby+Bartels">Toby Bartels</a>, who considered <a class="existingWikiWord" href="/nlab/show/internalization">internalization</a>s of Makkai’s definition in</p>

<ul id="HGT1">
<li><a class="existingWikiWord" href="/nlab/show/Toby+Bartels">Toby Bartels</a>, <em>Higher Gauge Theory I: 2-Bundles</em> (<a href="http://arxiv.org/abs/math.CT/0410328">arXiv:math.CT/0410328</a>)</li>
</ul>

<p>A development and exposition of the general setup taking Makkai’s and Bartels’ motivations and the theory of <a class="existingWikiWord" href="/nlab/show/homotopical+category">homotopical categories</a> into account is</p>

<ul>
<li id="Roberts12"><a class="existingWikiWord" href="/nlab/show/David+Roberts">David Roberts</a>, <em>Internal categories, anafunctors and localisations</em>, <a class="existingWikiWord" href="/nlab/show/Theory+and+Applications+of+Categories">Theory and Applications of Categories</a>, Vol. 26, 2012, No. 29, pp 788-829, <a href="http://www.tac.mta.ca/tac/volumes/26/29/26-29abs.html">journal version</a>, <a href="http://arxiv.org/abs/1101.2363">arXiv:1101.2363</a></li>
</ul>

<p>and a purely formal construction using 2-categories appears in the notes</p>

<ul>
<li id="Roberts18"><a class="existingWikiWord" href="/nlab/show/David+Roberts">David Roberts</a>, <em>The construction of formal anafunctors</em> (2018) arXiv:<a href="https://arxiv.org/abs/1808.04552">1808.04552</a>, doi:<a href="https://doi.org/10.25909/5b6cfd1a73e55">10.25909/5b6cfd1a73e55</a></li>
</ul>

<p>See also</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Erik+Palmgren">Erik Palmgren</a>, <em>Locally cartesian closed categories without chosen constructions</em>, <a href="http://www.tac.mta.ca/tac/volumes/20/1/20-01abs.html">TAC</a>.</li>
</ul>

<p>Since anafunctors are a special case of a more general concept, they, or the general theory applying to them, has been considered under different terms elsewhere.</p>

<p>The general question of <a class="existingWikiWord" href="/nlab/show/model+category">model category</a> structures on categories of <a class="existingWikiWord" href="/nlab/show/internal+category">internal categories</a> is discussed in</p>

<ul id="EKV">
<li>T. Everaert, R.W. Kieboom and T. Van der Linden , <em>Model structures for homotopy of internal categories</em> TAC, Vol. 15, CT2004, No. 3, pp 66-94. (<a href="http://www.tac.mta.ca/tac/volumes/15/3/15-03abs.html">web</a> (<a href="http://www.tac.mta.ca/tac/volumes/15/3/15-03.pdf">pdf</a>))</li>
</ul>

<p>Closely related, still a bit more general, are the considerations in</p>

<ul>
<li>Jardine, <em>Cocycle categories</em> K-theory 0782 (<a href="http://www.math.uiuc.edu/K-theory/0782/">web</a>) (<a href="http://www.math.uiuc.edu/K-theory/0782/coc-cat3.pdf">pdf</a>)</li>
</ul>

<p>Some models of set theory in which the bicategory of anafunctors fails to be small are sketched in the answers to</p>

<ul>
<li id="HenryMO">Simon Henry, <em>Non smallness of the set of anafunctors without AC?</em>, URL (version: 2017-03-16): <a href="https://mathoverflow.net/q/264585">https://mathoverflow.net/q/264585</a></li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on June 17, 2023 at 13:52:17.
    See the <a href="/nlab/history/anafunctor" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/anafunctor" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/8834/#Item_8">Discuss</a><span class="backintime"><a href="/nlab/revision/anafunctor/110" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/anafunctor" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/anafunctor" accesskey="S" class="navlink" id="history" rel="nofollow">History (110 revisions)</a>
  <a href="/nlab/show/anafunctor/cite" style="color: black">Cite</a>
  <a href="/nlab/print/anafunctor" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/anafunctor" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
