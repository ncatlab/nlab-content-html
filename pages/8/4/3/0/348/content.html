
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      sieve in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1660229990" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1676280126" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "A(Hover to reveal, click to "hold")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
}

  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/effects.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/controls.js?1660229990" type="text/javascript"></script>
<script src="/javascripts/application.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1660229990" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1660229990" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span>
      sieve
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/2534/#Item_11" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="category_theory">Category Theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></strong></p>

<h2 id="concepts">Concepts</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category">category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/functor">functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Cat">Cat</a></p>
</li>
</ul>

<h2 id="universal_constructions">Universal constructions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/universal+construction">universal construction</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/representable+functor">representable functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+functor">adjoint functor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/limit">limit</a>/<a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/end">end</a>/<a class="existingWikiWord" href="/nlab/show/coend">coend</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kan+extension">Kan extension</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="theorems">Theorems</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Isbell+duality">Isbell duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Grothendieck+construction">Grothendieck construction</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+functor+theorem">adjoint functor theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/monadicity+theorem">monadicity theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/adjoint+lifting+theorem">adjoint lifting theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Tannaka+duality">Tannaka duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Gabriel-Ulmer+duality">Gabriel-Ulmer duality</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Freyd-Mitchell+embedding+theorem">Freyd-Mitchell embedding theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/relation+between+type+theory+and+category+theory">relation between type theory and category theory</a></p>
</li>
</ul>

<h2 id="extensions">Extensions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sheaf+and+topos+theory">sheaf and topos theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/enriched+category+theory">enriched category theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+category+theory">higher category theory</a></p>
</li>
</ul>

<h2 id="applications">Applications</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/applications+of+%28higher%29+category+theory">applications of (higher) category theory</a></li>
</ul>
<div>
<p>
  <a href="/nlab/edit/category+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>

<h4 id="topos_theory">Topos Theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/topos+theory">topos theory</a></strong></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Toposes">Toposes</a></li>
</ul>

<h2 id="background">Background</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category">category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/functor">functor</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="toposes">Toposes</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%280%2C1%29-topos">(0,1)-topos</a>, <a class="existingWikiWord" href="/nlab/show/Heyting+algebra">Heyting algebra</a>, <a class="existingWikiWord" href="/nlab/show/locale">locale</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/pretopos">pretopos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/topos">topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Grothendieck+topos">Grothendieck topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category+of+presheaves">category of presheaves</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/representable+functor">representable presheaf</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/category+of+sheaves">category of sheaves</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/site">site</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/sieve">sieve</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/coverage">coverage</a>, <a class="existingWikiWord" href="/nlab/show/Grothendieck+pretopology">pretopology</a>, <a class="existingWikiWord" href="/nlab/show/Grothendieck+topology">topology</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/sheafification">sheafification</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/quasitopos">quasitopos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/base+topos">base topos</a>, <a class="existingWikiWord" href="/nlab/show/indexed+topos">indexed topos</a></p>
</li>
</ul>

<h2 id="internal_logic">Internal Logic</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/categorical+semantics">categorical semantics</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/internal+logic">internal logic</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/subobject+classifier">subobject classifier</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/natural+numbers+object">natural numbers object</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="topos_morphisms">Topos morphisms</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/logical+morphism">logical morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+morphism">geometric morphism</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/direct+image">direct image</a>/<a class="existingWikiWord" href="/nlab/show/inverse+image">inverse image</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/global+section">global sections</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+embedding">geometric embedding</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/surjective+geometric+morphism">surjective geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/essential+geometric+morphism">essential geometric morphism</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/locally+connected+geometric+morphism">locally connected geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/connected+geometric+morphism">connected geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/totally+connected+geometric+morphism">totally connected geometric morphism</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%C3%A9tale+geometric+morphism">étale geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/open+geometric+morphism">open geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proper+geometric+morphism">proper geometric morphism</a>, <a class="existingWikiWord" href="/nlab/show/compact+topos">compact topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/separated+geometric+morphism">separated geometric morphism</a>, <a class="existingWikiWord" href="/nlab/show/Hausdorff+topos">Hausdorff topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/local+geometric+morphism">local geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/bounded+geometric+morphism">bounded geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/base+change">base change</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/localic+geometric+morphism">localic geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/hyperconnected+geometric+morphism">hyperconnected geometric morphism</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/atomic+geometric+morphism">atomic geometric morphism</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="extra_stuff_structure_properties">Extra stuff, structure, properties</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/topological+locale">topological locale</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/localic+topos">localic topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/petit+topos">petit topos/gros topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/locally+connected+topos">locally connected topos</a>, <a class="existingWikiWord" href="/nlab/show/connected+topos">connected topos</a>, <a class="existingWikiWord" href="/nlab/show/totally+connected+topos">totally connected topos</a>, <a class="existingWikiWord" href="/nlab/show/strongly+connected+topos">strongly connected topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/local+topos">local topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cohesive+topos">cohesive topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/classifying+topos">classifying topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/smooth+topos">smooth topos</a></p>
</li>
</ul>

<h2 id="cohomology_and_homotopy">Cohomology and homotopy</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cohomology">cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+groups+in+an+%28infinity%2C1%29-topos">homotopy</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/abelian+sheaf+cohomology">abelian sheaf cohomology</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">model structure on simplicial presheaves</a></p>
</li>
</ul>

<h2 id="in_higher_category_theory">In higher category theory</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+topos+theory">higher topos theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%280%2C1%29-topos">(0,1)-topos</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/%280%2C1%29-site">(0,1)-site</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-topos">2-topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/2-site">2-site</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-sheaf">2-sheaf</a>, <a class="existingWikiWord" href="/nlab/show/stack">stack</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-topos">(∞,1)-topos</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-site">(∞,1)-site</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-sheaf">(∞,1)-sheaf</a>, <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-stack">∞-stack</a>, <a class="existingWikiWord" href="/nlab/show/derived+stack">derived stack</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="theorems">Theorems</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Diaconescu%27s+theorem">Diaconescu's theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Barr%27s+theorem">Barr's theorem</a></p>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/topos+theory+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#Idea'>Idea</a></li>
<li><a href='#definition'>Definition</a></li>
<li><a href='#properties'>Properties</a></li>
<ul>
<li><a href='#relation_to_fibrations'>Relation to fibrations</a></li>
<li><a href='#relation_to_subfunctors'>Relation to subfunctors</a></li>
<li><a href='#sieves_as_covers'>Sieves as covers</a></li>
<ul>
<li><a href='#introduction_and_overview'>Introduction and overview</a></li>
<li><a href='#the_sheaf_condition_from_morphisms_out_of_a_sieve'>The sheaf condition from morphisms out of a sieve</a></li>
</ul>
</ul>
<li><a href='#examples'>Examples</a></li>
<li><a href='#references'>References</a></li>
</ul>
</div>

<h2 id="Idea">Idea</h2>

<p>The notion of <em>sieve</em> is a generalization of that of (right) <em><a class="existingWikiWord" href="/nlab/show/ideal+in+a+monoid">ideal in a monoid</a></em> from <a class="existingWikiWord" href="/nlab/show/monoids">monoids</a> to <a class="existingWikiWord" href="/nlab/show/categories">categories</a>: a <strong>sieve on</strong> an <a class="existingWikiWord" href="/nlab/show/object">object</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in a <a class="existingWikiWord" href="/nlab/show/category">category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> is a collection of <a class="existingWikiWord" href="/nlab/show/morphisms">morphisms</a> with <a class="existingWikiWord" href="/nlab/show/codomain">codomain</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> that are closed under <a class="existingWikiWord" href="/nlab/show/composition">precomposition</a> with morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math>.</p>

<p>Sometimes one says that a <strong>sieve in</strong> a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/full+subcategory">full subcategory</a> closed under precomposition with morphisms in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathcal{C}</annotation></semantics></math> (<a href="#Lurie">Lurie, def. 6.2.2.1</a>). If so, then a <em>sieve on</em> an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is a <em>sieve in</em> the <a class="existingWikiWord" href="/nlab/show/slice+category">slice category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>𝒞</mi> <mrow><mo stretchy="false">/</mo><mi>X</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{C}_{/X}</annotation></semantics></math>. But a <em>sieve in</em> a category is also naturally taken to be a collection of <em>sieves on</em> various objects. On the other hand, most authors speak just about <em>sieves on</em> an object anyway.</p>

<p><em>Sieves on</em> objects are an equivalent way to talk about <a class="existingWikiWord" href="/nlab/show/subobjects">subobjects</a> of <a class="existingWikiWord" href="/nlab/show/representable+functors">representable functors</a> in a <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a> category in terms of the total sets of <em>elements</em> of such a <a class="existingWikiWord" href="/nlab/show/subfunctor">subfunctor</a>.</p>

<p id="Attitude"> In this sense “sieve” is a <a class="existingWikiWord" href="/nlab/show/concept+with+an+attitude">concept with an attitude</a>: One refers to a <a class="existingWikiWord" href="/nlab/show/subobject">subobject</a> of a <a class="existingWikiWord" href="/nlab/show/representable+functor">representable functor</a> as a <em>sieve</em> to indicate that one is interested in regarding it as a <a class="existingWikiWord" href="/nlab/show/cover">cover</a> of a (sifted) <a class="existingWikiWord" href="/nlab/show/coverage">coverage</a>: the singled out subobjects then correspond to <em>covering sieves</em>.</p>

<p>Accordingly, the classical examples of <em>sieves on</em> an object are <a class="existingWikiWord" href="/nlab/show/Grothendieck+topologies">Grothendieck topologies</a>, used to present the <a class="existingWikiWord" href="/nlab/show/presheaves">presheaves</a> that behave like <a class="existingWikiWord" href="/nlab/show/coverings">coverings</a>. They are used to say which <a class="existingWikiWord" href="/nlab/show/presheaves">presheaves</a> are actually <a class="existingWikiWord" href="/nlab/show/sheaves">sheaves</a> with respect to a given <a class="existingWikiWord" href="/nlab/show/coverage">coverage</a> or <a class="existingWikiWord" href="/nlab/show/Grothendieck+topology">Grothendieck topology</a>.</p>

<p>A choice of collections of morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">d \to c</annotation></semantics></math> into an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">c \in C</annotation></semantics></math> for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">d \in C</annotation></semantics></math> reminds one of the <a class="existingWikiWord" href="/nlab/show/representable+functor">representable functor</a> <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><msub><mi>hom</mi> <mi>C</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>:</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">Y(c) := \hom_C(-, c): C^{op} \to Set</annotation></semantics></math> which assigns to each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">d \in C</annotation></semantics></math> the set of <em>all</em> morphisms from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>. Every choice of covers of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> is therefore for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">d \in C</annotation></semantics></math> a subset of the value of this functor evaluated at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math>. This begins to look like an <a class="existingWikiWord" href="/nlab/show/monomorphism">monic</a> <a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a> into this functor. Indeed, it turns out that one can assume without restriction of generality that the assignment of covers of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> can always be extended to such a monic natural transformation, and hence one formalizes the notion of “collection of covers” of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> as a <a class="existingWikiWord" href="/nlab/show/subobject">subobject</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>F</mi><mo>↪</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i: F \hookrightarrow \hom(-, c)</annotation></semantics></math> of the functor represented by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>: a <em>sieve</em> at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>.</p>

<p>A dual notion is a <a class="existingWikiWord" href="/nlab/show/cosieve">cosieve</a>.</p>

<h2 id="definition">Definition</h2>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/small+category">small category</a>.</p>

<div class="num_defn">
<h6 id="definition_2">Definition</h6>

<p>A <em>sieve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></em> is a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>↪</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S \hookrightarrow C</annotation></semantics></math> that is both <a class="existingWikiWord" href="/nlab/show/fully+faithful">fully faithful</a> and a <a class="existingWikiWord" href="/nlab/show/discrete+fibration">discrete fibration</a>.</p>

<p>A <em>sieve on an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">c \in C</annotation></semantics></math></em> is a sieve in the <a class="existingWikiWord" href="/nlab/show/slice+category">slice category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo stretchy="false">/</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">C/c</annotation></semantics></math>.</p>
</div>

<p>Spelling this out, we arrive at the traditional definition of a sieve on an object:</p>

<div class="num_defn">
<h6 id="definition_3">Definition</h6>

<p>A <em>sieve</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> on an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">c \in C</annotation></semantics></math> is a subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi><mo>⊂</mo><mi>Ob</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">/</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S \subset Ob(C/c)</annotation></semantics></math> of the set of objects of the <a class="existingWikiWord" href="/nlab/show/over+category">over category</a> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> which is <em>closed under precomposition</em>: it has the property that whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>→</mo><mi>c</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">(d \to c) \in S</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>e</mi><mo>→</mo><mi>d</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(e \to d) \in Mor(C)</annotation></semantics></math> then the composition <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>e</mi><mo>→</mo><mi>d</mi><mo>→</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(e \to d \to c)</annotation></semantics></math> is in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p>
</div>

<div class="num_remark">
<h6 id="remark">Remark</h6>

<p>This is probably called a <em>sieve</em> because it “sifts out” the ‘special’ maps into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> from the set of <em>all</em> maps into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>. (Note that ‘sieve’ is the noun, while ‘sift’ is the verb.)</p>

<p>The French term for a sieve is <em>crible</em>.</p>
</div>

<div class="num_remark">
<h6 id="remark_2">Remark</h6>

<p>Sometimes the condition of a sieve being closed under the operation of precomposing with an arbitrary morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mi>e</mi><mo>→</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">g: e \to d</annotation></semantics></math> is called a “saturation condition”. Given any collection of morphisms targeted at <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>, one can always close it up, or <em>saturate</em> it, to obtain a sieve on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>.</p>
</div>

<h2 id="properties">Properties</h2>

<h3 id="relation_to_fibrations">Relation to fibrations</h3>

<p>Just as a <a class="existingWikiWord" href="/nlab/show/Grothendieck+fibration">Grothendieck fibration</a> is equivalent to a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">C^{op} \to Cat</annotation></semantics></math> and a <a class="existingWikiWord" href="/nlab/show/discrete+fibration">discrete fibration</a> is equivalent to a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Set</mi></mrow><annotation encoding="application/x-tex">C^{op} \to Set</annotation></semantics></math>, a sieve in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is equivalent to a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>C</mi> <mi>op</mi></msup><mo>→</mo><mi>Ω</mi></mrow><annotation encoding="application/x-tex">C^{op} \to \Omega</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math> is the preordered category of <a class="existingWikiWord" href="/nlab/show/truth+values">truth values</a>. This makes it obvious that a sieve picks out a subset of the objects in a way that is “downward closed”. This is a form of <a class="existingWikiWord" href="/nlab/show/negative+thinking">negative thinking</a>, as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ω</mi><mo>,</mo><mi>Set</mi><mo>,</mo><mi>Cat</mi></mrow><annotation encoding="application/x-tex">\Omega, Set, Cat</annotation></semantics></math> are the categories of all <a class="existingWikiWord" href="/nlab/show/%28-1%29-categories">(-1)-categories</a>, <a class="existingWikiWord" href="/nlab/show/0-categories">0-categories</a> and <a class="existingWikiWord" href="/nlab/show/1-categories">1-categories</a> respectively.</p>

<h3 id="relation_to_subfunctors">Relation to subfunctors</h3>

<p>There is a canonical way to create subfunctors from sieves and sieves from subfunctors.</p>

<p>A <a class="existingWikiWord" href="/nlab/show/subfunctor">subfunctor</a> is a <a class="existingWikiWord" href="/nlab/show/subobject">subobject</a> in a <a class="existingWikiWord" href="/nlab/show/functor+category">functor category</a>. Here, specifically, one is interested in <a class="existingWikiWord" href="/nlab/show/subobjects">subobjects</a> in a <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a> category of <a class="existingWikiWord" href="/nlab/show/representable+functors">representable functors</a>. It’s these subfunctors of representable functors that are in bijection with sieves.</p>

<div class="num_defn">
<h6 id="definition_4">Definition</h6>

<p>Given a sieve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>, the <strong>subfunctor</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>S</mi></msub><mo>↪</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_S \hookrightarrow Y(c)</annotation></semantics></math> <strong>defined by the sieve</strong> is the <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a></p>

<ul>
<li>
<p>that assigns to each object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">d \in C</annotation></semantics></math> the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>S</mi></msub><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>d</mi><mo>→</mo><mi>c</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F_S(d) = \{(d \to c) \in S\}</annotation></semantics></math>;</p>
</li>

<li>
<p>that assigns to each morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>→</mo><mi>d</mi><mo>′</mo><mo stretchy="false">)</mo><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">(d \to d') \in C</annotation></semantics></math> the function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>S</mi></msub><mo stretchy="false">(</mo><mi>d</mi><mo>′</mo><mo stretchy="false">)</mo><mo>→</mo><msub><mi>F</mi> <mi>S</mi></msub><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_S(d') \to F_S(d)</annotation></semantics></math> induced on elements by precomposition with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi><mo>→</mo><mi>d</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">d \to d'</annotation></semantics></math>.</p>
</li>
</ul>
</div>

<div class="num_defn">
<h6 id="definition_5">Definition</h6>

<p>Given a subfunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>↪</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F \hookrightarrow Y(c)</annotation></semantics></math>, the <strong>sieve defined by the subfunctor</strong> is given by</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>F</mi></msub><mo>≔</mo><mo stretchy="false">{</mo><mi>g</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>c</mi><mo>∈</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mover><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S_F \coloneqq \{g: d \to c \in Mor(C) | (Y(d) \stackrel{Y(g)}\to Y(c)) = (Y(d)  \to F \to Y(c)) \}</annotation></semantics></math></li>
</ul>

<p>or equivalently</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>F</mi></msub><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>d</mi><mo>∈</mo><mi>Obj</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow></msub><mi>F</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_F = \coprod_{d \in Obj(C)}F(d)</annotation></semantics></math>.</li>
</ul>
</div>

<div class="num_lemma">
<h6 id="lemma">Lemma</h6>

<p>These two definitions establish a bijection between sieves on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> and subobjects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(c)</annotation></semantics></math>.</p>

<p>For every sieve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mrow><msub><mi>F</mi> <mi>S</mi></msub></mrow></msub><mo>=</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">
  S_{F_S} = S

</annotation></semantics></math></div>
<p>and for every subfunctor we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><msub><mi>S</mi> <mi>F</mi></msub></mrow></msub><mo>=</mo><mi>F</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  F_{S_F} = F
  \,.

</annotation></semantics></math></div></div>

<div class="num_remark">
<h6 id="remarks">Remarks</h6>

<ul>
<li>
<p>The construction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>F</mi></msub></mrow><annotation encoding="application/x-tex">S_F</annotation></semantics></math> makes sense for every morphism of presheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F \to Y(c)</annotation></semantics></math>. The sieve is sensitive precisely to the <a class="existingWikiWord" href="/nlab/show/image">image</a> of this map,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>F</mi></msub><mo>=</mo><msub><mi>S</mi> <mrow><mi>im</mi><mo stretchy="false">(</mo><mi>F</mi><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msub><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
S_{F} = S_{im (F \to Y(c))}
\,.

</annotation></semantics></math></div></li>

<li>
<p>In the presence of a <a class="existingWikiWord" href="/nlab/show/Grothendieck+topology">Grothendieck topology</a> a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F \to Y(c)</annotation></semantics></math> is sometimes called a <a class="existingWikiWord" href="/nlab/show/local+epimorphism">local epimorphism</a> if the sieve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>F</mi></msub></mrow><annotation encoding="application/x-tex">S_F</annotation></semantics></math> is a covering sieve. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F \to Y(c)</annotation></semantics></math> is actually a subfunctor, then it is called a <a class="existingWikiWord" href="/nlab/show/dense+monomorphism">dense monomorphism</a>.</p>
</li>

<li>
<p>The <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of a subfunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><msub><mi>F</mi> <mi>S</mi></msub><mo>↪</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i: F_S \hookrightarrow Y(c) = \hom(-, c)</annotation></semantics></math> along any morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>g</mi><mo stretchy="false">)</mo><mo>:</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>d</mi><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hom(-, g): \hom(-, d) \to \hom(-, c)</annotation></semantics></math> is again a subfunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>g</mi> <mo>*</mo></msup><mi>F</mi></mrow><annotation encoding="application/x-tex">g^* F</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math>, hence sieves are closed under pulling back. Concretely,</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>g</mi> <mo>*</mo></msup><mi>S</mi><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">⋃</mo> <mrow><mi>e</mi><mo>∈</mo><mi>Ob</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow></munder><mo stretchy="false">{</mo><mi>f</mi><mo>:</mo><mi>e</mi><mo>→</mo><mi>d</mi><mo>:</mo><mi>g</mi><mi>f</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">g^* S = \bigcup_{e \in Ob(C)} \{f: e \to d: g f \in S\}
\,.
</annotation></semantics></math></div></li>

<li>
<p>A sieve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>S</mi> <mi>F</mi></msub></mrow><annotation encoding="application/x-tex">S_F</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>, for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><mi>F</mi><mo>↪</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i: F \hookrightarrow \hom(-, c)</annotation></semantics></math> a subfunctor, may be described as a function which assigns to each object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math> a collection of morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f: d \to c</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math>. Naturality of the inclusion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math> means that whenever <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f: d \to c</annotation></semantics></math> belongs to the sieve and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>g</mi><mo>:</mo><mi>e</mi><mo>→</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">g: e \to d</annotation></semantics></math> is any morphism, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi><mi>g</mi><mo>:</mo><mi>e</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f g: e \to c</annotation></semantics></math> also belongs to the sieve.</p>
</li>
</ul>
</div>

<div class="num_lemma">
<h6 id="lemma_2">Lemma</h6>

<p>The subfunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>S</mi></msub><mo>↪</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">F_S \hookrightarrow X</annotation></semantics></math> corresponding to a sieve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/coimage">coimage</a> of the morphism out of the disjoint union of all objects (regarded as representable presheaves) in the sieve:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>U</mi><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mo stretchy="false">(</mo><msub><mi>U</mi> <mi>α</mi></msub><mo>→</mo><mi>X</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>S</mi></mrow></munder><msub><mi>U</mi> <mi>α</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">
 (U = \coprod_{(U_\alpha \to X) \in S} U_\alpha)  \to X

</annotation></semantics></math></div>
<p>in that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>S</mi></msub><mo>→</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>colim</mi><mo stretchy="false">(</mo><mi>U</mi><msub><mo>×</mo> <mi>X</mi></msub><mi>U</mi><mover><mo>→</mo><mo>→</mo></mover><mi>U</mi><mo stretchy="false">)</mo><mo>→</mo><mi>X</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  (F_S \to X) = ((colim(U \times_X U \stackrel{\to}{\to} U)   \to X)
  \,.

</annotation></semantics></math></div></div>

<p>If the sieve is generated by (is the saturation of) a collection of morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>U</mi> <mi>α</mi></msub><mo>→</mo><mi>U</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{U_\alpha \to U\}</annotation></semantics></math> then the same statement remains true with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> being the coproduct over just these <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>α</mi></msub></mrow><annotation encoding="application/x-tex">U_\alpha</annotation></semantics></math>.</p>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>As described at <a class="existingWikiWord" href="/nlab/show/limits+and+colimits+by+example">limits and colimits by example</a>, the colimit of presheaves may be computed objectwise in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Set</mi></mrow><annotation encoding="application/x-tex">Set</annotation></semantics></math>. Doing so and using the <a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a> tells us that for each object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" columnalign="right left right left right left right left right left" columnspacing="0em"><mtr><mtd><mi>colim</mi><mo stretchy="false">(</mo><mi>U</mi><msub><mo>×</mo> <mi>X</mi></msub><mi>U</mi><mover><mo>→</mo><mo>→</mo></mover><mi>U</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>≃</mo><mi>colim</mi><mo stretchy="false">(</mo><mi>Hom</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>U</mi><msub><mo>×</mo> <mi>X</mi></msub><mi>U</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mo>→</mo></mover><mi>Hom</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>U</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>≃</mo><mi>colim</mi><mo stretchy="false">(</mo><mi>Hom</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>U</mi><mo stretchy="false">)</mo><msub><mo>×</mo> <mrow><mi>Hom</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></msub><mi>Hom</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>U</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mo>→</mo></mover><mi>Hom</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>U</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \begin{aligned}
    colim(U \times_X U \stackrel{\to}{\to} U)(V)
    &amp; \simeq
    colim(Hom(V,U \times_X U) \stackrel{\to}{\to} Hom(V,U))
    \\
    &amp; \simeq
    colim( Hom(V,U) \times_{Hom(V,X)} Hom(V,U)  \stackrel{\to}{\to} Hom(V,U))
  \end{aligned}

</annotation></semantics></math></div>
<p>where all objects appearing (at least in the first lines) are implicitly regarded as presheaves under the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a>.</p>

<p>But this colimit now manifestly computes the set</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mtext>maps from </mtext><mspace width="thinmathspace"></mspace><mi>V</mi><mspace width="thinmathspace"></mspace><mtext> to </mtext><mspace width="thinmathspace"></mspace><mi>X</mi><mspace width="thinmathspace"></mspace><mtext> that factor through </mtext><mspace width="thinmathspace"></mspace><mi>U</mi><msub><mo stretchy="false">}</mo> <mo>∼</mo></msub></mrow><annotation encoding="application/x-tex">
  \{\text{maps from }\,V\,\text{ to }\,X\,\text{ that factor through }\,U\}_\sim

</annotation></semantics></math></div>
<p>where the equivalence relation is</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>f</mi><mo>→</mo><mi>U</mi><mo>→</mo><mi>X</mi><mo stretchy="false">)</mo><mo>∼</mo><mo stretchy="false">(</mo><mi>g</mi><mo>→</mo><mi>U</mi><mo>→</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>f</mi><mspace width="thinmathspace"></mspace><mtext> and </mtext><mspace width="thinmathspace"></mspace><mi>g</mi><mspace width="thinmathspace"></mspace><mtext> coincide as maps to </mtext><mspace width="thinmathspace"></mspace><mi>X</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  ((f \to U \to X) \sim (g \to U \to X))
  \Leftrightarrow
  (f\,\text{ and }\,g\,\text{ coincide as maps to }\,X)
  \,.

</annotation></semantics></math></div>
<p>So the set is just the set of maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> that factor through one of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>α</mi></msub></mrow><annotation encoding="application/x-tex">U_\alpha</annotation></semantics></math>, which is precisely the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>S</mi></msub><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_S(V)</annotation></semantics></math> assigned by the subfunctor corresponding to the sieve.</p>
</div>

<h3 id="sieves_as_covers">Sieves as covers</h3>

<h4 id="introduction_and_overview">Introduction and overview</h4>

<p>The following is a pedagogical step-by-step description of the crucial aspects of sieves as covers.</p>

<p>To start with the simplest example that already contains in it all the relevant aspects, consider a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> with an open subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">V \subset X</annotation></semantics></math> that is covered by two open subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>U</mi> <mn>2</mn></msub><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">U_1, U_2 \subset X</annotation></semantics></math> in that the <a class="existingWikiWord" href="/nlab/show/union">union</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>∪</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1 \cup U_2</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> coincides with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>∪</mo><msub><mi>U</mi> <mn>2</mn></msub><mo>=</mo><mi>V</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  U_1 \cup U_2 = V
  \,.

</annotation></semantics></math></div>
<p>This is the <a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a> in the <a class="existingWikiWord" href="/nlab/show/category+of+open+subsets">category of open subsets</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, but that behaves very differently from the <a class="existingWikiWord" href="/nlab/show/disjoint+coproducts">disjoint coproducts</a> that we are used to from categories like <a class="existingWikiWord" href="/nlab/show/Set">Set</a>. On the other hand, when one comes to a category of <a class="existingWikiWord" href="/nlab/show/presheaves">presheaves</a> or <a class="existingWikiWord" href="/nlab/show/sheaves">sheaves</a> (a <a class="existingWikiWord" href="/nlab/show/Grothendieck+topos">Grothendieck topos</a>), this <a class="existingWikiWord" href="/nlab/show/topos">topos</a> <em>does</em> have disjoint coproducts.</p>

<p>Another way to think of this is obtained by first forming the <a class="existingWikiWord" href="/nlab/show/fiber+product">fiber product</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">U_1</annotation></semantics></math> with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_2</annotation></semantics></math> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math>, which is the intersection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1 \cap U_2</annotation></semantics></math> sitting in the <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><msub><mi>U</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><msub><mi>U</mi> <mn>2</mn></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>V</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">  
  \array{
    U_1 \times_V U_2 &amp;\to&amp; U_1
    \\
    \downarrow &amp;&amp; \downarrow
    \\
    U_2 &amp;\to&amp; V
  }

</annotation></semantics></math></div>
<p>in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math>.</p>

<p>The union <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>∪</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1 \cup U_2</annotation></semantics></math> is again obtained from this by removing in the above diagram the bottom right corner and then forming the <a class="existingWikiWord" href="/nlab/show/pushout">pushout</a> over the resulting diagram: this is again <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, i.e. the diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><msub><mi>U</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><msub><mi>U</mi> <mn>2</mn></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><msub><mi>U</mi> <mn>1</mn></msub><mo>∪</mo><msub><mi>U</mi> <mn>2</mn></msub><mo>=</mo><mi>V</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">  
  \array{
    U_1 \times_V U_2 &amp;\to&amp; U_1
    \\
    \downarrow &amp;&amp; \downarrow
    \\
    U_2 &amp;\to&amp; U_1 \cup U_2 = V
  }

</annotation></semantics></math></div>
<p>is not only a <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> also a <a class="existingWikiWord" href="/nlab/show/pushout">pushout</a> diagram.</p>

<p>The important point about (covering) sieves is that they show up when the above situation is sent via the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math> to <a class="existingWikiWord" href="/nlab/show/presheaf">presheaves</a> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math>. The crucial aspect here that gives rise to the peculiarities of sieves is that</p>

<ul>
<li>the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a> preserves <a class="existingWikiWord" href="/nlab/show/limits">limits</a>, but not, in general, <a class="existingWikiWord" href="/nlab/show/colimits">colimits</a></li>
</ul>

<p>As a result, the above discussion goes through equivalently for the <a class="existingWikiWord" href="/nlab/show/presheaf">presheaves</a> <a class="existingWikiWord" href="/nlab/show/representable+functor">represented</a> by our open subsets all the way up to the last pushout. In <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math> that last pushout reproduced the open subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>. In <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PSh</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">PSh(X) = [Op(X)^{op}, Set]</annotation></semantics></math> it instead reproduces the <em>sieve</em> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> generated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">U_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_2</annotation></semantics></math>.</p>

<p>Let’s go through this in detail. First of all notice that in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PSh</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PSh(X)</annotation></semantics></math> all limits and colimits do exist (see <a class="existingWikiWord" href="/nlab/show/limits+and+colimits+by+example">limits and colimits by example</a> for more on that); in particular the coproduct</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  Y(U_1) \amalg Y(U_2)

</annotation></semantics></math></div>
<p>exists. Here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> denotes the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a> which we here indicate explicitly, even though often and elsewhere, notably elsewhere in this entry here, it is notationally suppressed.</p>

<p>For the following it is helpful to say explicitly what the presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(U_1) \amalg Y(U_2)</annotation></semantics></math> is like. Since, as described at <a class="existingWikiWord" href="/nlab/show/limits+and+colimits+by+example">limits and colimits by example</a>, colimits of presheaves are computed objectwise, we know that this presheaf evaluated on any open set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">W \subset X</annotation></semantics></math> yields the set</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable displaystyle="true" columnalign="right left right left right left right left right left" columnspacing="0em"><mtr><mtd><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd></mtd> <mtd><mo>=</mo><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \begin{aligned}
   (Y(U_1) \amalg Y(U_2))(W) 
   &amp;= 
    Y(U_1)(W) \amalg Y(U_2)(W)
   \\
   &amp;=
   Hom(W,U_1) \amalg Hom(W, U_2)
  \end{aligned}

</annotation></semantics></math></div>
<p>where the coproducts on the right are just those in <a class="existingWikiWord" href="/nlab/show/Set">Set</a> which are just ordinary disjoint unions of sets.</p>

<p>So this says that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(U_1) \amalg Y(U_2)</annotation></semantics></math> is the presheaf that assigns to any open set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> the disjoint union of the collections of maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">U_1</annotation></semantics></math> and those from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_2</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. (Since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/poset">poset</a> there is either none or one such map in each case, but it is helpful to speak generally of “sets of all maps”, since that is the general intuition useful for presheaf categories. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math> just happens to be a particularly simple example.)</p>

<p>Notice that in particular a given map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">W \to V</annotation></semantics></math> which factors both through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_1 \to V</annotation></semantics></math> as well as through <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_2 \to V</annotation></semantics></math> will appear as two distinct elements in the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Y(U_1) \amalg Y(U_2))(W)</annotation></semantics></math>. This we’ll come back to in a minute.</p>

<p>But first consider the fiber product from before, now after having applied the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a>. Since we know from general nonsense that this preserves fiber products, we know that the <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(U_1) \times_{Y(V)} Y(U_2)</annotation></semantics></math> in</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
   Y(U_1) \times_{Y(V)} Y(U_2) &amp;\to&amp; Y(U_2)
   \\
   \downarrow &amp;&amp; \downarrow
   \\
   Y(U_1)
   &amp;\to&amp;
   Y(V)
  }

</annotation></semantics></math></div>
<p>is the same as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(U_1 \times_V U_2) = Y(U_1 \cap U_2)</annotation></semantics></math>.</p>

<p>But this is also easily checked explicitly. We go through this because this kind of reasoning for computing limits and colimits of presheaves will be needed throughout here: since for any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> the covariant <a class="existingWikiWord" href="/nlab/show/hom-functor">hom-functor</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Psh</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mi>Psh</mi><mo>→</mo><mi>PSh</mi></mrow><annotation encoding="application/x-tex">Psh(Y(W),-) : Psh \to PSh</annotation></semantics></math> preserves limits (by the very definition of <a class="existingWikiWord" href="/nlab/show/limit">limit</a>!) we have for every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> a pullback diagram of sets</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
 \array{
  Hom(Y(W),Y(U_1) \times_{Y(V)} Y(U_2))
   &amp;\to&amp; Hom(Y(W),Y(U_2))
  \\
  \downarrow &amp;&amp; \downarrow
  \\
  Hom(Y(W),Y(U_1))
  &amp;\to&amp;
  Hom(Y(W),Y(V))
 }

</annotation></semantics></math></div>
<p>Again by the <a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda lemma</a> this is simply</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><mi>V</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
 \array{
  (Y(U_1) \times_{Y(V)} Y(U_2) )(W)
   &amp;\to&amp; 
   Hom(W,U_2)
  \\
  \downarrow &amp;&amp; \downarrow
  \\
  Hom(W,U_1)
  &amp;\to&amp;
  Hom(W,V)
 }
  \,.

</annotation></semantics></math></div>
<p>This being a pullback diagram now says in words:</p>

<blockquote>
<p>The set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Y(U_1) \times_{Y(V)} Y(U_2) )(W)</annotation></semantics></math> is the set of those pairs of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">W \to U_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">W \to U_2</annotation></semantics></math> that coincide as maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>1</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">W \to U_1 \to V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>2</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">W \to U_2 \to V</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>.</p>
</blockquote>

<p>Clearly, this set is the same as the set of maps into the intersection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1 \cap U_2</annotation></semantics></math>, so indeed</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  Y(U_1) \times_{Y(V)} Y(U_2) = Y(U_1 \times_V U_2)
  = Y(U_1 \cap U_2)
  \,.

</annotation></semantics></math></div>
<p>So far so long-winded. Now let’s see what happens when we now form the pushout over</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    Y(U_1 \times_V U_2) &amp;\to&amp; Y(U_2) 
    \\
    \downarrow
    \\
    Y(U_1)
  }

</annotation></semantics></math></div>
<p>that will go, for a moment, by its canonical but lengthy name <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  Y(U_1) \coprod_{Y(U_1 \times_V U_2)} Y(U_2)
</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></munder><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
    Y(U_1 \times_V U_2) &amp;\to&amp; Y(U_2) 
    \\
    \downarrow &amp;&amp; \downarrow
    \\
    Y(U_1)
    &amp;\to&amp;
    Y(U_1) \coprod_{Y(U_1 \times_V U_2)} Y(U_2)
  }
  \,.

</annotation></semantics></math></div>
<p>Again, we can figure out what this presheaf is by computing objectwise what it does to any open subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math>: since colimits of presheaves are computed objectwise, the diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>Hom</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></munder><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    Hom(W, U_1 \times_V U_2)
    &amp;\to&amp; 
    Hom(W, U_2) 
    \\
    \downarrow &amp;&amp; \downarrow
    \\
    Hom(W,U_1)
    &amp;\to&amp;
    (Y(U_1) \coprod_{Y(U_1 \times_V U_2)} Y(U_2))(W)
  }

</annotation></semantics></math></div>
<p>must be a colimit in <a class="existingWikiWord" href="/nlab/show/Set">Set</a>. Again, this is easily read out in words:</p>

<blockquote>
<p>The set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Y(U_1) \coprod_{Y(U_1 \times_V U_2)} Y(U_2))(W)</annotation></semantics></math> is the quotient of the disjoint union of the collection of maps from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">U_1</annotation></semantics></math> and those from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_2</annotation></semantics></math>, by the equivalence relation which identifies two such maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">W \to U_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">W \to U_2</annotation></semantics></math> if they both factor through a map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>X</mi></msub><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">W \to U_1 \times_X U_2</annotation></semantics></math>, i.e. if they both land in the intersection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>∩</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_1 \cap U_2</annotation></semantics></math> and coincide there.</p>
</blockquote>

<p>But this just means that contrary to the plain coproduct <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(U_1) \amalg Y(U_2)</annotation></semantics></math>, two maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">W \to U_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">W \to U_2</annotation></semantics></math> that coincide as maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">W \to X</annotation></semantics></math> are no longer regarded as different elements of our set given by the pushout presheaf, but are regarded as being the same.</p>

<p>So this means we find that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></munder><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>W</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mtext> maps </mtext><mspace width="thinmathspace"></mspace><mi>W</mi><mo>→</mo><mi>V</mi><mspace width="thinmathspace"></mspace><mtext> that factor through either </mtext><mspace width="thinmathspace"></mspace><msub><mi>U</mi> <mn>1</mn></msub><mspace width="thinmathspace"></mspace><mtext> or </mtext><mspace width="thinmathspace"></mspace><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">}</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  (Y(U_1) \coprod_{Y(U_1 \times_V U_2)} Y(U_2))(W)
  =
  \{
    \text{ maps } \,W \to V \,\text{ that factor through either }\, U_1
    \,\text{ or }\, U_2
  \}
  \,.

</annotation></semantics></math></div>
<p>But this is by definition the assignment of the subfunctor corresponding to the sieve on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> generated by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_1 \to V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_2 \to V</annotation></semantics></math>.</p>

<p>So we find that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>sieve</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><msub><mo>×</mo> <mi>V</mi></msub><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></munder><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  F_{sieve(U_1,U_2)}
  = 
  Y(U_1) \coprod_{Y(U_1 \times_V U_2)} Y(U_2)
  \,.

</annotation></semantics></math></div>
<p>Given that we made it to this point, we should go one small step further that will be very useful.</p>

<p>In the present simple example we worked with a cover given by just two objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">U_1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_2</annotation></semantics></math>. Of course in general the cover will consist of more than just two objects. Then the above kind of notation becomes a bit cumbersome. But there is a simple reformulation that makes everything look nice again.</p>

<p>Namely, let’s come back to the observation that the coproduct <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>⨿</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y(U_1) \amalg Y(U_2)</annotation></semantics></math> does exist. Let’s just call this presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>U</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math> (not in general a <a class="existingWikiWord" href="/nlab/show/representable+functor">representable</a>!).</p>

<p>Then it is easy to see by the same kind of objectwise reasoning that the colimiting presheaf that we are after is equivalently the colimit over the pair of <a class="existingWikiWord" href="/nlab/show/parallel+morphisms">parallel morphisms</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><mover><mover><mo>→</mo><mrow><msub><mi>p</mi> <mn>1</mn></msub></mrow></mover><mover><mo>→</mo><mrow><msub><mi>p</mi> <mn>2</mn></msub></mrow></mover></mover><mstyle mathvariant="bold"><mi>U</mi></mstyle></mrow><annotation encoding="application/x-tex">
  \mathbf{U} \times_{Y(V)} \mathbf{U}
  \stackrel{\stackrel{p_2}{\to}}{\stackrel{p_1}{\to}}
  \mathbf{U}

</annotation></semantics></math></div>
<p>in that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>sieve</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>U</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow></msub><mo>≃</mo><mi>colim</mi><mo stretchy="false">(</mo><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><mover><mover><mo>→</mo><mrow><msub><mi>p</mi> <mn>1</mn></msub></mrow></mover><mover><mo>→</mo><mrow><msub><mi>p</mi> <mn>2</mn></msub></mrow></mover></mover><mstyle mathvariant="bold"><mi>U</mi></mstyle><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  F_{sieve(U_1,U_2)} \simeq
  colim ( 
   \mathbf{U} \times_{Y(V)} \mathbf{U}
   \stackrel{\stackrel{p_2}{\to}}{\stackrel{p_1}{\to}}
   \mathbf{U}
  )
  \,.

</annotation></semantics></math></div>
<p>This description now has an evident direct generalization to the case where instead of just <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>1</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_1 \to V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mn>2</mn></msub><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_2 \to V</annotation></semantics></math> we have an arbitrary collection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>→</mo><mi>V</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{U_i \to V\}</annotation></semantics></math> of open sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math> covering <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>. One finds again with</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>U</mi></mstyle><mo>:</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></munder><mi>Y</mi><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  \mathbf{U} := \coprod_i Y(U(i))

</annotation></semantics></math></div>
<p>that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>sieve</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow></msub><mo>≃</mo><mi>colim</mi><mo stretchy="false">(</mo><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><mover><mover><mo>→</mo><mrow><msub><mi>p</mi> <mn>1</mn></msub></mrow></mover><mover><mo>→</mo><mrow><msub><mi>p</mi> <mn>2</mn></msub></mrow></mover></mover><mstyle mathvariant="bold"><mi>U</mi></mstyle><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  F_{sieve(\{U_i\})} \simeq
  colim ( 
   \mathbf{U} \times_{Y(V)} \mathbf{U}
   \stackrel{\stackrel{p_2}{\to}}{\stackrel{p_1}{\to}}
   \mathbf{U}
  )

</annotation></semantics></math></div>
<p>is the presheaf that to every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> assigns the set of all maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">W \to V</annotation></semantics></math> that factor through any one of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math>.</p>

<p>It is in this way that sieves and their associated subfunctors encapsulate the notion of <em>cover</em> of an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>: they tell us which of all the maps into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> do factor through the cover.</p>

<p>And, to end this pedagogical piece with an outlook to indicate the gain in understanding this achieves:</p>

<p>once we start forming <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><mover><mo>→</mo><mo>→</mo></mover><mstyle mathvariant="bold"><mi>U</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbf{U} \times_{Y(V)} \mathbf{U} \stackrel{\to}{\to} \mathbf{U}</annotation></semantics></math> there is no stopping. We can keep forming higher and higher such fiber products</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>⋯</mi><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><mover><mover><mover><mo>→</mo><mo>→</mo></mover><mo>→</mo></mover><mo>→</mo></mover><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><mover><mover><mo>→</mo><mo>→</mo></mover><mo>→</mo></mover><mstyle mathvariant="bold"><mi>U</mi></mstyle><msub><mo>×</mo> <mrow><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></msub><mstyle mathvariant="bold"><mi>U</mi></mstyle><mover><mo>→</mo><mo>→</mo></mover><mstyle mathvariant="bold"><mi>U</mi></mstyle><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
 \cdots
\mathbf{U} \times_{Y(V)} \mathbf{U}
 \times_{Y(V)} \mathbf{U}
 \times_{Y(V)} \mathbf{U}
\stackrel{\to}{\stackrel{\to}{\stackrel{\to}{\to}}}
\mathbf{U} \times_{Y(V)} \mathbf{U}
 \times_{Y(V)} \mathbf{U}
\stackrel{\to}{\stackrel{\to}{\to}}
\mathbf{U} \times_{Y(V)} \mathbf{U} \stackrel{\to}{\to} \mathbf{U}
  \,.

</annotation></semantics></math></div>
<p>When one passes from just presheaves to <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-presheaves">(∞,1)-presheaves</a>, then <a class="existingWikiWord" href="/nlab/show/cover">cover</a>ing presheaves will be given by the right kind of colimit over these <a class="existingWikiWord" href="/nlab/show/simplicial+object">simplicial</a> diagrams (namely the <a class="existingWikiWord" href="/nlab/show/homotopy+limit">homotopy colimit</a>). More on that is at <a class="existingWikiWord" href="/nlab/show/descent">descent</a>.</p>

<h4 id="the_sheaf_condition_from_morphisms_out_of_a_sieve">The sheaf condition from morphisms out of a sieve</h4>

<p>We now show that the subfunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mi>S</mi></msub></mrow><annotation encoding="application/x-tex">F_S</annotation></semantics></math> associated with a sieve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> coming from a cover <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>→</mo><mi>X</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{U_i \to X\}</annotation></semantics></math> is the <em>right</em> kind of morphism to require a <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a> to be a <a class="existingWikiWord" href="/nlab/show/local+object">local object</a> for, by demonstrating that using it the usual <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf condition</a> on a presheaf with respect to the cover <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></msub><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\coprod_i U_i</annotation></semantics></math> is reproduced:</p>

<p>From the above detailed discussion, recall that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>F</mi> <mrow><mi>sieve</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">F_{sieve(\{U_i\})}</annotation></semantics></math> is precisely the <a class="existingWikiWord" href="/nlab/show/coequalizer">coequalizer</a> of the obvious pair of morphisms</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mover><mo>→</mo><mo>→</mo></mover><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  \coprod_{i, j} \hom(-, U_i \cap U_j)
    \stackrel{\to}{\to}
  \coprod_i hom(-, U_i)

</annotation></semantics></math></div>
<p>with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hom(-, U_i) := Y(U_i)</annotation></semantics></math> denoting the presheaf <a class="existingWikiWord" href="/nlab/show/representable+functor">represented</a> under the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math>, as usual.</p>

<p>Here the domain of this parallel pair is the <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a> of the evident map <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></msub><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\coprod_i hom(-, U_i) \to hom(-,X)</annotation></semantics></math><br />along itself, and the two parallel arrows are the projection maps out of this pullback:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>j</mi></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
     \coprod_{i,j} hom(-,U_i \cap U_j)
     &amp;\to&amp;
     \coprod_j hom(-, U_j)
     \\
     \downarrow &amp;&amp; \downarrow
     \\
     \coprod_i hom(-, U_i)
     &amp;\to&amp;
     hom(-,X)
  }

</annotation></semantics></math></div>
<p>Thus for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> any <a class="existingWikiWord" href="/nlab/show/presheaf">presheaf</a>, maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \to G</annotation></semantics></math> are precisely the same as maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></msub><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\coprod_i \hom(-, U_i) \to G</annotation></semantics></math> which coequalize the parallel pair. Applying <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Hom</mi> <mrow><msup><mi>Set</mi> <mrow><msup><mi>C</mi> <mi>op</mi></msup></mrow></msup></mrow></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hom_{Set^{C^{op}}}(-,G)</annotation></semantics></math> to the colimit diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mover><mo>→</mo><mo>→</mo></mover><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">
  \coprod_{i, j} \hom(-, U_i \cap U_j)
    \stackrel{\to}{\to}
  \coprod_i hom(-, U_i)
  \to
  F

</annotation></semantics></math></div>
<p>yields the limit diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo>,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Hom</mi><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mi>G</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mo>→</mo></mover><mi>Hom</mi><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></munder><mi>hom</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo>,</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  Hom(F, G)
  \to 
  Hom(\coprod_i hom(-, U_i), G)
  \stackrel{\to}{\to}
  Hom(\coprod_{i, j} \hom(-, U_i \cap U_j), G)

</annotation></semantics></math></div>
<p>which using <a class="existingWikiWord" href="/nlab/show/Yoneda+lemma">Yoneda</a> is the equalizer diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo>,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>→</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mi>i</mi></munder><mi>G</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mover><mo>→</mo><mo>→</mo></mover><munder><mo lspace="thinmathspace" rspace="thinmathspace">∏</mo> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></munder><mi>G</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  Hom(F,G)
  \to
 \prod_i G(U_i) \stackrel{\to}{\to} \prod_{i, j} G(U_i \cap U_j)

</annotation></semantics></math></div>
<p>and hence identifies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Hom</mi><mo stretchy="false">(</mo><mi>F</mi><mo>,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Hom(F,G)</annotation></semantics></math> indeed as the set of <a class="existingWikiWord" href="/nlab/show/descent">descent</a> data for the <a class="existingWikiWord" href="/nlab/show/sheaf">sheaf</a> condition on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>.</p>

<h2 id="examples">Examples</h2>

<ul>
<li>
<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a> let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math> be the <a class="existingWikiWord" href="/nlab/show/category+of+open+subsets">category of open subsets</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> and consider presheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>PSh</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mo stretchy="false">[</mo><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">PSh(X) := [Op(X)^{op}, Set]</annotation></semantics></math> on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>. For any open subset <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>=</mo><mi>V</mi><mo>∈</mo><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c = V \in Op(X)</annotation></semantics></math> let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>d</mi> <mi>i</mi></msub><mo stretchy="false">}</mo><mo>=</mo><mo stretchy="false">{</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{d_i\} = \{U_i\}</annotation></semantics></math> be a cover of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> by open subsets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math> in the ordinary sense (i.e. each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math> is an open subset of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> and their joint union is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">⋃</mo> <mi>i</mi></msub><msub><mi>U</mi> <mi>i</mi></msub><mo>=</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\bigcup_i U_i = V</annotation></semantics></math>), then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>π</mi><mo>:</mo><mo stretchy="false">(</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover><mo>→</mo><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mi>i</mi></msub><msub><mi>U</mi> <mi>i</mi></msub><msub><mo>↪</mo> <mi>i</mi></msub><mi>X</mi></mrow></mover><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi : (\coprod_i Y(U_i)) \stackrel{\coprod_i U_i \hookrightarrow_i X}{\to} Y(V)</annotation></semantics></math> (with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math> the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a>) is a <a class="existingWikiWord" href="/nlab/show/local+epimorphism">local epimorphism</a> of presheaves on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> and its <a class="existingWikiWord" href="/nlab/show/image">image</a> – or equivalently its <a class="existingWikiWord" href="/nlab/show/coimage">coimage</a> – is the subfunctor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo>:</mo><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">⋃</mo> <mi>i</mi></msub><mi>Y</mi><mo stretchy="false">(</mo><msub><mi>U</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>↪</mo><mi>Y</mi><mo stretchy="false">(</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F := \bigcup_i Y(U_i)) \hookrightarrow Y(V)</annotation></semantics></math> that sends each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>∈</mo><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W \in Op(X)</annotation></semantics></math> to the set of maps <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">W \to V</annotation></semantics></math> that factor through one of the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math>. The collection of all such maps for all choice of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> is the corresponding <em>covering sieve</em> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>f</mi><mo>:</mo><mi>W</mi><mo>→</mo><mi>V</mi><mo>∈</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mo stretchy="false">|</mo><mspace width="thickmathspace"></mspace><mi>f</mi><mo>=</mo><mi>W</mi><mo>→</mo><msub><mi>U</mi> <mi>i</mi></msub><mo>→</mo><mi>V</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ f : W \to V  \in Mor(S) \;|\; f = W \to U_i \to V  \}</annotation></semantics></math>.</p>
</li>

<li>
<p>The situation for more general <a class="existingWikiWord" href="/nlab/show/sites">sites</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math> other than <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math> is literally the same as above, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>U</mi> <mi>i</mi></msub><mo>,</mo><mi>W</mi><mo>,</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U_i, W, V</annotation></semantics></math> etc. objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p>
</li>
</ul>

<h2 id="references">References</h2>

<p>A standard textbook account on sieves in <a class="existingWikiWord" href="/nlab/show/category+theory">category theory</a> is in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Peter+Johnstone">Peter Johnstone</a>, <em><a class="existingWikiWord" href="/nlab/show/Sketches+of+an+Elephant">Sketches of an Elephant</a></em>.</li>
</ul>

<p>In the context of <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-categories">(∞,1)-categories</a> sieves are discussed around def. 6.2.2.1 of</p>

<ul id="Lurie">
<li><a class="existingWikiWord" href="/nlab/show/Jacob+Lurie">Jacob Lurie</a>, <em><a class="existingWikiWord" href="/nlab/show/Higher+Topos+Theory">Higher Topos Theory</a></em></li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on March 16, 2023 at 06:34:44.
    See the <a href="/nlab/history/sieve" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/sieve" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/2534/#Item_11">Discuss</a><span class="backintime"><a href="/nlab/revision/sieve/50" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/sieve" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/sieve" accesskey="S" class="navlink" id="history" rel="nofollow">History (50 revisions)</a>
  <a href="/nlab/show/sieve/cite" style="color: black">Cite</a>
  <a href="/nlab/print/sieve" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/sieve" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
