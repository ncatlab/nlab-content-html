
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      homotopy limit in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link href="/stylesheets/instiki.css?1553353531" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/nlab.css?1592003439" media="all" rel="stylesheet" type="text/css" />
  <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css"/>

  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #226622;
    }
    a:visited.existingWikiWord {
      color: #164416;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #226622;
}

a.existingWikiWord:visited {
color: #226622;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    <span style="float: left; margin: 0.5em 0.25em -0.25em 0">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.872em" height="1.8em" viewBox="0 0 190 181">
        <path fill="#226622" d="M72.8 145c-1.6 17.3-15.7 10-23.6 20.2-5.6 7.3 4.8 15 11.4 15 11.5-.2 19-13.4 26.4-20.3 3.3-3 8.2-4 11.2-7.2a14 14 0 0 0 2.9-11.1c-1.4-9.6-12.4-18.6-16.9-27.2-5-9.6-10.7-27.4-24.1-27.7-17.4-.3-.4 26 4.7 30.7 2.4 2.3 5.4 4.1 7.3 6.9 1.6 2.3 2.1 5.8-1 7.2-5.9 2.6-12.4-6.3-15.5-10-8.8-10.6-15.5-23-26.2-31.8-5.2-4.3-11.8-8-18-3.7-7.3 4.9-4.2 12.9.2 18.5a81 81 0 0 0 30.7 23c3.3 1.5 12.8 5.6 10 10.7-2.5 5.2-11.7 3-15.6 1.1-8.4-3.8-24.3-21.3-34.4-13.7-3.5 2.6-2.3 7.6-1.2 11.1 2.8 9 12.2 17.2 20.9 20.5 17.3 6.7 34.3-8 50.8-12.1z"/>
        <path fill="#a41e32" d="M145.9 121.3c-.2-7.5 0-19.6-4.5-26-5.4-7.5-12.9-1-14.1 5.8-1.4 7.8 2.7 14.1 4.8 21.3 3.4 12 5.8 29-.8 40.1-3.6-6.7-5.2-13-7-20.4-2.1-8.2-12.8-13.2-15.1-1.9-2 9.7 9 21.2 12 30.1 1.2 4 2 8.8 6.4 10.3 6.9 2.3 13.3-4.7 17.7-8.8 12.2-11.5 36.6-20.7 43.4-36.4 6.7-15.7-13.7-14-21.3-7.2-9.1 8-11.9 20.5-23.6 25.1 7.5-23.7 31.8-37.6 38.4-61.4 2-7.3-.8-29.6-13-19.8-14.5 11.6-6.6 37.6-23.3 49.2z"/>
        <path fill="#193c78" d="M86.3 47.5c0-13-10.2-27.6-5.8-40.4 2.8-8.4 14.1-10.1 17-1 3.8 11.6-.3 26.3-1.8 38 11.7-.7 10.5-16 14.8-24.3 2.1-4.2 5.7-9.1 11-6.7 6 2.7 7.4 9.2 6.6 15.1-2.2 14-12.2 18.8-22.4 27-3.4 2.7-8 6.6-5.9 11.6 2 4.4 7 4.5 10.7 2.8 7.4-3.3 13.4-16.5 21.7-16 14.6.7 12 21.9.9 26.2-5 1.9-10.2 2.3-15.2 3.9-5.8 1.8-9.4 8.7-15.7 8.9-6.1.1-9-6.9-14.3-9-14.4-6-33.3-2-44.7-14.7-3.7-4.2-9.6-12-4.9-17.4 9.3-10.7 28 7.2 35.7 12 2 1.1 11 6.9 11.4 1.1.4-5.2-10-8.2-13.5-10-11.1-5.2-30-15.3-35-27.3-2.5-6 2.8-13.8 9.4-13.6 6.9.2 13.4 7 17.5 12C70.9 34 75 43.8 86.3 47.4z"/>
      </svg>
    </span>
      <span class="webName">nLab</span><br />
      homotopy limit
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <span style="display:inline-block; width: 0.3em;"></span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/10163/#Item_1" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             style="display:inline-block; float: left;"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Contents</title></head>
<body>
<div class="rightHandSide">
<div class="toc clickDown" tabindex="0">
<h3 id="context">Context</h3>

<h4 id="homotopy_theory">Homotopy theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/homotopy+theory">homotopy theory</a>, <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category+theory">(∞,1)-category theory</a>, <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a></strong></p>

<p>flavors: <a class="existingWikiWord" href="/nlab/show/stable+homotopy+theory">stable</a>, <a class="existingWikiWord" href="/nlab/show/equivariant+homotopy+theory">equivariant</a>, <a class="existingWikiWord" href="/nlab/show/rational+homotopy+theory">rational</a>, <a class="existingWikiWord" href="/nlab/show/p-adic+homotopy+theory">p-adic</a>, <a class="existingWikiWord" href="/nlab/show/proper+homotopy+theory">proper</a>, <a class="existingWikiWord" href="/nlab/show/geometric+homotopy+theory">geometric</a>, <a class="existingWikiWord" href="/nlab/show/cohesive+homotopy+theory">cohesive</a>, <a class="existingWikiWord" href="/nlab/show/directed+homotopy+theory">directed</a>…</p>

<p>models: <a class="existingWikiWord" href="/nlab/show/topological+homotopy+theory">topological</a>, <a class="existingWikiWord" href="/nlab/show/simplicial+homotopy+theory">simplicial</a>, <a class="existingWikiWord" href="/nlab/show/localic+homotopy+theory">localic</a>, …</p>

<p>see also <strong><a class="existingWikiWord" href="/nlab/show/algebraic+topology">algebraic topology</a></strong></p>

<p><strong>Introductions</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Introduction+to+Topology+--+2">Introduction to Basic Homotopy Theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Introduction+to+Homotopy+Theory">Introduction to Abstract Homotopy Theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometry+of+physics+--+homotopy+types">geometry of physics – homotopy types</a></p>
</li>
</ul>

<p><strong>Definitions</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy">homotopy</a>, <a class="existingWikiWord" href="/nlab/show/higher+homotopy">higher homotopy</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+type">homotopy type</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Pi-algebra">Pi-algebra</a>, <a class="existingWikiWord" href="/nlab/show/spherical+object+and+Pi%28A%29-algebra">spherical object and Pi(A)-algebra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+coherent+category+theory">homotopy coherent category theory</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopical+category">homotopical category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+category">model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/category+of+fibrant+objects">category of fibrant objects</a>, <a class="existingWikiWord" href="/nlab/show/cofibration+category">cofibration category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Waldhausen+category">Waldhausen category</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Ho%28Top%29">Ho(Top)</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/homotopy+category+of+an+%28%E2%88%9E%2C1%29-category">homotopy category of an (∞,1)-category</a></li>
</ul>
</li>
</ul>

<p><strong>Paths and cylinders</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/left+homotopy">left homotopy</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/cylinder+object">cylinder object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cone">mapping cone</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/right+homotopy">right homotopy</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/path+object">path object</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cocone">mapping cocone</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/generalized+universal+bundle">universal bundle</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/interval+object">interval object</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+localization">homotopy localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/infinitesimal+interval+object">infinitesimal interval object</a></p>
</li>
</ul>
</li>
</ul>

<p><strong>Homotopy groups</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+group">homotopy group</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+group">fundamental group</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+group+of+a+topos">fundamental group of a topos</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Brown-Grossman+homotopy+group">Brown-Grossman homotopy group</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/categorical+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">categorical homotopy groups in an (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/geometric+homotopy+groups+in+an+%28%E2%88%9E%2C1%29-topos">geometric homotopy groups in an (∞,1)-topos</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid">fundamental ∞-groupoid</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+groupoid">fundamental groupoid</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/path+groupoid">path groupoid</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+in+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">fundamental ∞-groupoid in a locally ∞-connected (∞,1)-topos</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%E2%88%9E-groupoid+of+a+locally+%E2%88%9E-connected+%28%E2%88%9E%2C1%29-topos">fundamental ∞-groupoid of a locally ∞-connected (∞,1)-topos</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+%28%E2%88%9E%2C1%29-category">fundamental (∞,1)-category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+category">fundamental category</a></li>
</ul>
</li>
</ul>

<p><strong>Basic facts</strong></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fundamental+group+of+the+circle+is+the+integers">fundamental group of the circle is the integers</a></li>
</ul>

<p><strong>Theorems</strong></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fundamental+theorem+of+covering+spaces">fundamental theorem of covering spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Freudenthal+suspension+theorem">Freudenthal suspension theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Blakers-Massey+theorem">Blakers-Massey theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/higher+homotopy+van+Kampen+theorem">higher homotopy van Kampen theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/nerve+theorem">nerve theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Whitehead%27s+theorem">Whitehead's theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Hurewicz+theorem">Hurewicz theorem</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Galois+theory">Galois theory</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+hypothesis">homotopy hypothesis</a>-theorem</p>
</li>
</ul>
</div></div>

<h4 id="model_category_theory">Model category theory</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/model+category">model category</a></strong></p>

<h2 id="definitions">Definitions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">category with weak equivalences</a></p>

<p>(<a class="existingWikiWord" href="/nlab/show/relative+category">relative category</a>, <a class="existingWikiWord" href="/nlab/show/homotopical+category">homotopical category</a>)</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/fibration">fibration</a>, <a class="existingWikiWord" href="/nlab/show/cofibration">cofibration</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/weak+factorization+system">weak factorization system</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/resolution">resolution</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cell+complex">cell complex</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+%28as+an+operation%29">homotopy</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mspace width="thickmathspace"></mspace></mrow><annotation encoding="application/x-tex">\;</annotation></semantics></math><a class="existingWikiWord" href="/nlab/show/homotopy+category+of+a+model+category">of a model category</a></p>
</li>
</ul>

<h2 id="morphisms">Morphisms</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Quillen+adjunction">Quillen adjunction</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a></p>
</li>
</ul>
</li>
</ul>

<h2 id="universal_constructions">Universal constructions</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+Kan+extension">homotopy Kan extension</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+limit">homotopy limit</a>/<a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a></p>

<p><a class="existingWikiWord" href="/nlab/show/homotopy+weighted+colimit">homotopy weighted (co)limit</a></p>

<p><a class="existingWikiWord" href="/nlab/show/homotopy+coend">homotopy (co)end</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bousfield-Kan+map">Bousfield-Kan map</a></p>
</li>
</ul>

<h2 id="refinements">Refinements</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/monoidal+model+category">monoidal model category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/monoidal+Quillen+adjunction">monoidal Quillen adjunction</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/enriched+model+category">enriched model category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/enriched+Quillen+adjunction">enriched Quillen adjunction</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/simplicial+Quillen+adjunction">simplicial Quillen adjunction</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cofibrantly+generated+model+category">cofibrantly generated model category</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/combinatorial+model+category">combinatorial model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cellular+model+category">cellular model category</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/algebraic+model+category">algebraic model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/compactly+generated+model+category">compactly generated model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/proper+model+category">proper model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/cartesian+closed+model+category">cartesian closed model category</a>, <a class="existingWikiWord" href="/nlab/show/locally+cartesian+closed+model+category">locally cartesian closed model category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/stable+model+category">stable model category</a></p>
</li>
</ul>

<h2 id="producing_new_model_structures">Producing new model structures</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/global+model+structures+on+functor+categories">on functor categories (global)</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Reedy+model+structure">Reedy model structure</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+an+overcategory">on slice categories</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/transferred+model+structure">transferred model structure</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebraic+fibrant+objects">on algebraic fibrant objects</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Grothendieck+construction+for+model+categories">Grothendieck construction for model categories</a></p>
</li>
</ul>

<h2 id="presentation_of_categories">Presentation of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/simplicial+localization">simplicial localization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-categorical+hom-space">(∞,1)-categorical hom-space</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/presentable+%28%E2%88%9E%2C1%29-category">presentable (∞,1)-category</a></p>
</li>
</ul>

<h2 id="model_structures">Model structures</h2>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Cisinski+model+structure">Cisinski model structure</a></li>
</ul>

<h3 id="for_groupoids">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groupoids</h3>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+%E2%88%9E-groupoids">for ∞-groupoids</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+topological+spaces">on topological spaces</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/classical+model+structure+on+topological+spaces">classical model structure</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+compactly+generated+topological+spaces">on compactly generated spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+Delta-generated+topological+spaces">on Delta-generated spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+diffeological+spaces">on diffeological spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Str%C3%B8m+model+structure">Strøm model structure</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Thomason+model+structure">Thomason model structure</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+presheaves+over+a+test+category">model structure on presheaves over a test category</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+sets">on simplicial sets</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+on+semi-simplicial+sets">on semi-simplicial sets</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/classical+model+structure+on+simplicial+sets">classical model structure</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/constructive+model+structure+on+simplicial+sets">constructive model structure</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+right+fibrations">for right/left fibrations</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+groupoids">model structure on simplicial groupoids</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+cubical+sets">on cubical sets</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+strict+%E2%88%9E-groupoids">on strict ∞-groupoids</a>, <a class="existingWikiWord" href="/nlab/show/natural+model+structure+on+groupoids">on groupoids</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+chain+complexes">on chain complexes</a>/<a class="existingWikiWord" href="/nlab/show/model+structure+on+cosimplicial+abelian+groups">model structure on cosimplicial abelian groups</a></p>

<p>related by the <a class="existingWikiWord" href="/nlab/show/Dold-Kan+correspondence">Dold-Kan correspondence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+cosimplicial+simplicial+sets">model structure on cosimplicial simplicial sets</a></p>
</li>
</ul>

<h3 id="for_equivariant_groupoids">for equivariant <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groupoids</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/fine+model+structure+on+topological+G-spaces">fine model structure on topological G-spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/coarse+model+structure+on+topological+G-spaces">coarse model structure on topological G-spaces</a></p>

<p>(<a class="existingWikiWord" href="/nlab/show/Borel+model+structure">Borel model structure</a>)</p>
</li>
</ul>

<h3 id="for_rational_groupoids">for rational <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groupoids</h3>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/model+structure+on+dgc-algebras">model structure on dgc-algebras</a></li>
</ul>

<h3 id="for_rational_equivariant_groupoids">for rational equivariant <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groupoids</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+equivariant+chain+complexes">model structure on equivariant chain complexes</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+equivariant+dgc-algebras">model structure on equivariant dgc-algebras</a></p>
</li>
</ul>

<h3 id="for_groupoids_2">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-groupoids</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+n-groupoids">for n-groupoids</a>/<a class="existingWikiWord" href="/nlab/show/model+structure+for+n-groupoids">for n-types</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+model+structure+on+groupoids">for 1-groupoids</a></p>
</li>
</ul>

<h3 id="for_groups">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-groups</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+groups">model structure on simplicial groups</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+reduced+simplicial+sets">model structure on reduced simplicial sets</a></p>
</li>
</ul>

<h3 id="for_algebras">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-algebras</h3>

<h4 id="general">general</h4>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+monoids">on monoids</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+T-algebras">on simplicial T-algebras</a>, on <a class="existingWikiWord" href="/nlab/show/homotopy+T-algebra">homotopy T-algebra</a>s</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebras+over+a+monad">on algebas over a monad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebras+over+an+operad">on algebras over an operad</a>,</p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+modules+over+an+algebra+over+an+operad">on modules over an algebra over an operad</a></p>
</li>
</ul>

<h4 id="specific">specific</h4>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-algebras">model structure on differential-graded commutative algebras</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+differential+graded-commutative+superalgebras">model structure on differential graded-commutative superalgebras</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-algebras+over+an+operad">on dg-algebras over an operad</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-algebras">on dg-algebras</a> and on <a class="existingWikiWord" href="/nlab/show/simplicial+ring">on simplicial rings</a>/<a class="existingWikiWord" href="/nlab/show/model+structure+on+cosimplicial+rings">on cosimplicial rings</a></p>

<p>related by the <a class="existingWikiWord" href="/nlab/show/monoidal+Dold-Kan+correspondence">monoidal Dold-Kan correspondence</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+L-%E2%88%9E+algebras">for L-∞ algebras</a>: <a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-Lie+algebras">on dg-Lie algebras</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-coalgebras">on dg-coalgebras</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+Lie+algebras">on simplicial Lie algebras</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-modules">model structure on dg-modules</a></p>
</li>
</ul>

<h3 id="for_stablespectrum_objects">for stable/spectrum objects</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+spectra">model structure on spectra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+ring+spectra">model structure on ring spectra</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+presheaves+of+spectra">model structure on presheaves of spectra</a></p>
</li>
</ul>

<h3 id="for_categories">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+categories+with+weak+equivalences">on categories with weak equivalences</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+quasi-categories">Joyal model for quasi-categories</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+sSet-categories">on sSet-categories</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+complete+Segal+spaces">for complete Segal spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+Cartesian+fibrations">for Cartesian fibrations</a></p>
</li>
</ul>

<h3 id="for_stable_categories">for stable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories</h3>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/model+structure+on+dg-categories">on dg-categories</a></li>
</ul>

<h3 id="for_operads">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-operads</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+operads">on operads</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+for+Segal+operads">for Segal operads</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+algebras+over+an+operad">on algebras over an operad</a>,</p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+modules+over+an+algebra+over+an+operad">on modules over an algebra over an operad</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+dendroidal+sets">on dendroidal sets</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+for+dendroidal+complete+Segal+spaces">for dendroidal complete Segal spaces</a>, <a class="existingWikiWord" href="/nlab/show/model+structure+for+dendroidal+Cartesian+fibrations">for dendroidal Cartesian fibrations</a></p>
</li>
</ul>

<h3 id="for_categories_2">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,r)</annotation></semantics></math>-categories</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Theta+space">for (n,r)-categories as ∞-spaces</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+weak+complicial+sets">for weak ∞-categories as weak complicial sets</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+cellular+sets">on cellular sets</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/canonical+model+structure">on higher categories in general</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+strict+%E2%88%9E-categories">on strict ∞-categories</a></p>
</li>
</ul>

<h3 id="for_sheaves__stacks">for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-sheaves / <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stacks</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+homotopical+presheaves">on homotopical presheaves</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">on simplicial presheaves</a></p>

<p><a class="existingWikiWord" href="/nlab/show/global+model+structure+on+simplicial+presheaves">global model structure</a>/<a class="existingWikiWord" href="/nlab/show/Cech+model+structure+on+simplicial+presheaves">Cech model structure</a>/<a class="existingWikiWord" href="/nlab/show/local+model+structure+on+simplicial+presheaves">local model structure</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+sheaves">on simplicial sheaves</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+presheaves+of+simplicial+groupoids">on presheaves of simplicial groupoids</a></p>

<p><a class="existingWikiWord" href="/nlab/show/model+structure+on+sSet-enriched+presheaves">on sSet-enriched presheaves</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/model+structure+for+%282%2C1%29-sheaves">model structure for (2,1)-sheaves</a>/for stacks</p>
</li>
</ul>
</div></div>

<h4 id="limits_and_colimits"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-Limits and colimits</h4>

<div class="hide"><div>

<p><strong><a class="existingWikiWord" href="/nlab/show/limit">limits and colimits</a></strong></p>

<h2 id="1categorical">1-Categorical</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/limit">limit and colimit</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/limits+and+colimits+by+example">limits and colimits by example</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/commutativity+of+limits+and+colimits">commutativity of limits and colimits</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/small+limit">small limit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/filtered+colimit">filtered colimit</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/directed+colimit">directed colimit</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/sequential+colimit">sequential colimit</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/sifted+colimit">sifted colimit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/connected+limit">connected limit</a>, <a class="existingWikiWord" href="/nlab/show/wide+pullback">wide pullback</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/preserved+limit">preserved limit</a>, <a class="existingWikiWord" href="/nlab/show/reflected+limit">reflected limit</a>, <a class="existingWikiWord" href="/nlab/show/created+limit">created limit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/product">product</a>, <a class="existingWikiWord" href="/nlab/show/fiber+product">fiber product</a>, <a class="existingWikiWord" href="/nlab/show/base+change">base change</a>, <a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a>, <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a>, <a class="existingWikiWord" href="/nlab/show/pushout">pushout</a>, <a class="existingWikiWord" href="/nlab/show/cobase+change">cobase change</a>, <a class="existingWikiWord" href="/nlab/show/equalizer">equalizer</a>, <a class="existingWikiWord" href="/nlab/show/coequalizer">coequalizer</a>, <a class="existingWikiWord" href="/nlab/show/join">join</a>, <a class="existingWikiWord" href="/nlab/show/meet">meet</a>, <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a>, <a class="existingWikiWord" href="/nlab/show/initial+object">initial object</a>, <a class="existingWikiWord" href="/nlab/show/direct+product">direct product</a>, <a class="existingWikiWord" href="/nlab/show/direct+sum">direct sum</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/finite+limit">finite limit</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/exact+functor">exact functor</a></li>
</ul>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Kan+extension">Kan extension</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Yoneda+extension">Yoneda extension</a></li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/end">end and coend</a></p>
</li>
</ul>

<h2 id="2categorical">2-Categorical</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/2-limit">2-limit</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/inserter">inserter</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/isoinserter">isoinserter</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/equifier">equifier</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/inverter">inverter</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/PIE-limit">PIE-limit</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/2-pullback">2-pullback</a>, <a class="existingWikiWord" href="/nlab/show/comma+object">comma object</a></p>
</li>
</ul>

<h2 id="1categorical_2">(∞,1)-Categorical</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-limit">(∞,1)-limit</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-pullback">(∞,1)-pullback</a></p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/fiber+sequence">fiber sequence</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<h3 id="modelcategorical">Model-categorical</h3>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+Kan+extension">homotopy Kan extension</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+limit">homotopy limit</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+product">homotopy product</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+equalizer">homotopy equalizer</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+fiber">homotopy fiber</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cone">mapping cone</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+pullback">homotopy pullback</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+totalization">homotopy totalization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+end">homotopy end</a></p>
</li>
</ul>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a></p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+coproduct">homotopy coproduct</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+coequalizer">homotopy coequalizer</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+cofiber">homotopy cofiber</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cocone">mapping cocone</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+pushout">homotopy pushout</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+realization">homotopy realization</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/homotopy+coend">homotopy coend</a></p>
</li>
</ul>
</li>
</ul>
<div>
<p>
  <a href="/nlab/edit/infinity-limits+-+contents">Edit this sidebar</a>
</p>
</div></div></div>
</div>
</div>

<h1 id="contents">Contents</h1>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#definitions'>Definitions</a></li>
<ul>
<li><a href='#GlobalDefinition'>Global definition</a></li>
<li><a href='#local_definition'>Local definition</a></li>
<li><a href='#global_versus_local'>Global versus local</a></li>
<ul>
<li><a href='#strictness'>Strictness</a></li>
</ul>
<li><a href='#Derivators'>Derivators</a></li>
</ul>
<li><a href='#computational_methods'>Computational methods</a></li>
<ul>
<li><a href='#ordinary_colimits_on_resolved_diagrams'>Ordinary (co)limits on resolved diagrams</a></li>
<li><a href='#ResolvedCoEnds'>Resolved (co)ends</a></li>
<li><a href='#BarConstruction'>Bar constructions</a></li>
</ul>
<li><a href='#homotopy_limits_versus_higher_categorical_limits'>Homotopy limits versus higher categorical limits</a></li>
<li><a href='#homotopy_limits_versus_limits_in_the_homotopy_category'>Homotopy limits versus limits in the homotopy category</a></li>
<li><a href='#Examples'>Examples</a></li>
<ul>
<li><a href='#WeightedColimitFormula'>General weighted colimit formula for homotopy colimits</a></li>
<ul>
<li><a href='#ingredients'>Ingredients</a></li>
<li><a href='#general_formula'>General formula</a></li>
<li><a href='#examples_2'>Examples</a></li>
<ul>
<li><a href='#homotopy_colimits_of_simplicial_diagrams'>Homotopy colimits of simplicial diagrams</a></li>
</ul>
<li><a href='#homotopy_pushouts'>Homotopy pushouts</a></li>
<ul>
<li><a href='#observation'>Observation</a></li>
<li><a href='#observation_2'>Observation</a></li>
</ul>
</ul>
<li><a href='#HomotopyPullbacks'>Homotopy pullbacks</a></li>
<ul>
<li><a href='#based_loop_objects'>Based loop objects</a></li>
<li><a href='#fibration_sequences'>Fibration sequences</a></li>
<li><a href='#GroupDeloop'>Homotopy pullback of a point over a group / universal bundles</a></li>
<li><a href='#DeloopedSubgroupOverGroup'>Homotopy pullback of a subgroup over a group</a></li>
<li><a href='#homotopy_span_traces'>Homotopy span traces</a></li>
</ul>
<li><a href='#OverSimplicialDiagrams'>Homotopy colimits of simplicial diagrams</a></li>
<li><a href='#homotopy_colimits_of_diagrams_of_spaces'>Homotopy colimits of diagrams of spaces</a></li>
<ul>
<li><a href='#by_geometric_realization'>By geometric realization</a></li>
<li><a href='#higher_homotopy_van_kampen_theorem'>Higher homotopy van Kampen theorem</a></li>
</ul>
<li><a href='#SequentialHocolims'>Sequential homotopy (co)limits</a></li>
<ul>
<li><a href='#general'>General</a></li>
<li><a href='#_and_milnor_sequences'><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>lim</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">\lim^1</annotation></semantics></math> and Milnor sequences</a></li>
</ul>
<li><a href='#descent_objects'>Descent objects</a></li>
<li><a href='#SimpSheaves'>Homotopy (co)limits of simplicial pre(sheaves)</a></li>
<ul>
<li><a href='#preservation_of_homotopy_pullback_by_inverse_images'>Preservation of homotopy pullback by inverse images</a></li>
</ul>
<li><a href='#more_examples_and_special_cases'>More examples and special cases</a></li>
</ul>
<li><a href='#related_concepts'>Related concepts</a></li>
<li><a href='#references'>References</a></li>
<ul>
<li><a href='#general_2'>General</a></li>
<li><a href='#in_homotopy_type_theory'>In homotopy type theory</a></li>
</ul>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>In great generality, a <em>homotopy limit</em> is a way of constructing appropriate sorts of <a class="existingWikiWord" href="/nlab/show/limit">limit</a>s in a <a class="existingWikiWord" href="/nlab/show/higher+category+theory">(weak) higher category</a> and in general and in <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a> theory in particular, using some <em>presentation</em> of that higher category by a <a class="existingWikiWord" href="/nlab/show/category+theory">1-categorical</a> structure. The general study of such presentations is <a class="existingWikiWord" href="/nlab/show/homotopy+theory">homotopy theory</a>.</p>

<p>In classical homotopy theory, the presentation is given by a <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">category with weak equivalences</a>, possibly satisfying extra axioms such as those of a <a class="existingWikiWord" href="/nlab/show/homotopical+category">homotopical category</a>, a <a class="existingWikiWord" href="/nlab/show/category+of+fibrant+objects">category of fibrant objects</a>, or a <a class="existingWikiWord" href="/nlab/show/model+category">model category</a>. Such structures are considered to present an <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a>, and homotopy limits give a way of constructing the appropriate sort of <a class="existingWikiWord" href="/nlab/show/limit+in+a+quasi-category">(∞,1)-categorical limits</a>.</p>

<p>In <a class="existingWikiWord" href="/nlab/show/enriched+homotopy+theory">enriched homotopy theory</a>, the presentation is given by an <a class="existingWikiWord" href="/nlab/show/enriched+model+category">enriched model category</a> or an <a class="existingWikiWord" href="/nlab/show/enriched+homotopical+category">enriched homotopical category</a>, and it may presents an “enriched <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-category” or be a more powerful presentation of a bare <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-category (notably if the enrichment is over <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a>). In the <a class="existingWikiWord" href="/nlab/show/enriched+category+theory">enriched category theory</a> context the appropriate notion is a <a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted</a> homotopy limit, which may construct “weighted <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-limits” in the presented “enriched <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-category” or may be a more powerful tool for constructing plain <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categorical limits (in particular if the enrichment is over <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a>). Note that as yet, no fully general notion of “enriched <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-category” exists; see <a class="existingWikiWord" href="/nlab/show/homotopical+enrichment">homotopical enrichment</a>.</p>

<p>Maybe the most commonly encountered setup for homotopy limits is that where the <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a> in question is <a class="existingWikiWord" href="/nlab/show/presentable+%28%E2%88%9E%2C1%29-category">presented</a> by a <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a>. See also <a class="existingWikiWord" href="/nlab/show/homotopy+Kan+extension">homotopy Kan extension</a>, of which (globally defined) homotopy (co)limits are a special case.</p>

<h2 id="definitions">Definitions</h2>

<p>As for ordinary <a class="existingWikiWord" href="/nlab/show/limit">limit</a>s, there are two ways to define homotopy limits:</p>

<ul>
<li>
<p>with explicit constructions that satisfy a <em>local</em> universal property: the homotopy limit object “represents homotopy-coherent cones up to homotopy.”</p>
</li>

<li>
<p>as <a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a>s of a <a class="existingWikiWord" href="/nlab/show/homotopy+Kan+extension">homotopy Kan extension</a> that satisfy a <em>global</em> universal property: the homotopy limit <em>functor</em> is “universal among homotopical approximations to the strict limit functor.”</p>
</li>
</ul>

<p>One of the central theorems of the subject is that in good cases, the two give equivalent results; see below.</p>

<h3 id="GlobalDefinition">Global definition</h3>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">category with weak equivalences</a> and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> be a (small) <a class="existingWikiWord" href="/nlab/show/diagram">diagram</a> category. Make the <a class="existingWikiWord" href="/nlab/show/functor+category">functor category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D,C]</annotation></semantics></math> into a category with weak equivalences by taking the weak equivalences to be those <a class="existingWikiWord" href="/nlab/show/natural+transformation">natural transformation</a>s which are objectwise weak equivalences in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>The ordinary <a class="existingWikiWord" href="/nlab/show/limit">limit</a> and <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a> operations on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>-diagrams are (as described there) the right and left <a class="existingWikiWord" href="/nlab/show/adjoint+functor">adjoints</a> of the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>const</mi><mo>:</mo><mi>C</mi><mo>→</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">const : C \to [D,C]</annotation></semantics></math>, or equivalently left and right <a class="existingWikiWord" href="/nlab/show/Kan+extension">Kan extension</a> along the unique functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>!</mo><mo lspace="verythinmathspace">:</mo><mi>D</mi><mo>→</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">!\colon D\to *</annotation></semantics></math> to the terminal category.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mover><munder><mo>→</mo><mrow><mi>lim</mi><mo>=</mo><msub><mi>Ran</mi> <mo>!</mo></msub></mrow></munder><mover><mover><mo>←</mo><mi>const</mi></mover><mover><mo>⟶</mo><mrow><mi>colim</mi><mo>=</mo><msub><mi>Lan</mi> <mo>!</mo></msub></mrow></mover></mover></mover><mi>C</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  [D,C]
  \stackrel{\stackrel{\overset{colim = Lan_!}{\longrightarrow}}{\overset{const}{\leftarrow}}}{\underset{lim = Ran_!}{\to}}
  C
  \,.

</annotation></semantics></math></div>
<p>The (globally defined) <em>homotopy limit</em> and <em>colimit</em> are accordingly the right and left <a class="existingWikiWord" href="/nlab/show/homotopy+Kan+extension">homotopy Kan extension</a> along <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>!</mo><mo lspace="verythinmathspace">:</mo><mi>D</mi><mo>→</mo><mo>*</mo></mrow><annotation encoding="application/x-tex">!\colon D\to *</annotation></semantics></math>:</p>

<ul>
<li>
<p>The <strong>homotopy limit</strong> of a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : D \to C</annotation></semantics></math> is, if it exists, the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> under the right <a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a> of the <a class="existingWikiWord" href="/nlab/show/limit">limit</a> functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>lim</mi> <mi>D</mi></msub><mo>:</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">lim_D : [D,C] \to C</annotation></semantics></math> with respect to the given weak equivalences on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and the objectwise weak equivalences on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D,C]</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>holim</mi> <mi>D</mi></msub><mi>F</mi><mo>:</mo><mo>=</mo><mo stretchy="false">(</mo><mi>ℝ</mi><msub><mi>lim</mi> <mi>D</mi></msub><mo stretchy="false">)</mo><mi>F</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
holim_D F := (\mathbb{R} lim_D)F
\,.

</annotation></semantics></math></div></li>

<li>
<p>The <strong>homotopy colimit</strong> of a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : D \to C</annotation></semantics></math> is, if it exists, the image of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> under the left <a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a> of the <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a> functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>colim</mi> <mi>D</mi></msub><mo>:</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">colim_D : [D,C] \to C</annotation></semantics></math> with respect to the given weak equivalences on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and the objectwise weak equivalences on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D,C]</annotation></semantics></math>:</p>
</li>
</ul>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>hocolim</mi> <mi>D</mi></msub><mi>F</mi><mo>:</mo><mo>=</mo><mo stretchy="false">(</mo><mi>𝕃</mi><msub><mi>colim</mi> <mi>D</mi></msub><mo stretchy="false">)</mo><mi>F</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  hocolim_D F := (\mathbb{L} colim_D)F
  \,.

</annotation></semantics></math></div>
<p>Alternative definitions can be formulated at the level of the homotopy category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>W</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mi>C</mi></mrow><annotation encoding="application/x-tex">W^{-1} C</annotation></semantics></math> one defines a localized version <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mover><mi>Δ</mi><mo stretchy="false">¯</mo></mover> <mi>I</mi></msup><mo>:</mo><msup><mi>W</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup><mi>C</mi><mo>→</mo><msubsup><mi>W</mi> <mi>I</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msubsup><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">\bar{\Delta}^I : W^{-1} C\to W_I^{-1} C^I</annotation></semantics></math> of the <a class="existingWikiWord" href="/nlab/show/diagonal">diagonal</a> functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Δ</mi> <mi>I</mi></msup><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">\Delta^I : C\to C^I</annotation></semantics></math> and define the homotopy limits and colimits as the adjoints of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mover><mi>Δ</mi><mo stretchy="false">¯</mo></mover> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">\bar{\Delta}^I</annotation></semantics></math> (at least at the points where the adjoints are defined). Here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>W</mi> <mi>I</mi></msub><mo>⊂</mo><mi>Mor</mi><mo stretchy="false">(</mo><msup><mi>C</mi> <mi>I</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W_I\subset Mor(C^I)</annotation></semantics></math> are the morphisms of diagrams whose all components are in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>⊂</mo><mi>Mor</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W\subset Mor(C)</annotation></semantics></math>. The above definitions via derived functors (Kan extensions) follow once one applies the general theorem that the derived functors of a pair of adjoint functors are also adjoint and noticing that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>Δ</mi> <mi>I</mi></msup><mo>,</mo><msup><mover><mi>Δ</mi><mo stretchy="false">¯</mo></mover> <mi>I</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Delta^I,\bar{\Delta}^I)</annotation></semantics></math> is a morphism of localizers (and in particular that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mover><mi>Δ</mi><mo stretchy="false">¯</mo></mover> <mi>I</mi></msup></mrow><annotation encoding="application/x-tex">\bar{\Delta}^I</annotation></semantics></math> with the identity 2-cell is a Kan extension (simultaneously left and right)).</p>

<p>In the enriched case, this must be suitably modified to deal with <a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limits</a> as well as enrichment of both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math>.</p>

<p>In particular, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is equipped with the extra structure of a <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> is an (small) <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a>-<a class="existingWikiWord" href="/nlab/show/enriched+category">enriched category</a> we may also hope to equip the <a class="existingWikiWord" href="/nlab/show/enriched+functor">enriched functor</a> category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D,C]</annotation></semantics></math> with the structure of a simplicial model category. There are two different “canonical” such structures:</p>

<ul>
<li>
<p>the <em>projective</em> <a class="existingWikiWord" href="/nlab/show/model+structure+on+functors">model structure on functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">[D,C]_{proj}</annotation></semantics></math>;</p>
</li>

<li>
<p>the <em>injective</em> <a class="existingWikiWord" href="/nlab/show/model+structure+on+functors">model structure on functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">[D,C]_{inj}</annotation></semantics></math></p>
</li>
</ul>

<p>(both of which have the same objectwise weak equivalences and are in fact <a class="existingWikiWord" href="/nlab/show/Quillen+equivalence">Quillen equivalent</a>). When these model structures exist (as they do when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is <a class="existingWikiWord" href="/nlab/show/combinatorial+model+category">combinatorial</a>), limit and colimit constitute then two <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>sSet</mi></mrow><annotation encoding="application/x-tex">sSet</annotation></semantics></math>-enriched <a class="existingWikiWord" href="/nlab/show/Quillen+adjunction">Quillen adjunction</a>s</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub><mover><munder><mo>⟵</mo><mi>const</mi></munder><mover><mo>⟶</mo><mi>colim</mi></mover></mover><mi>C</mi></mrow><annotation encoding="application/x-tex">
  [D,C]_{proj}
   \stackrel{\overset{colim}{\longrightarrow}}{\underset{const}{\longleftarrow}} 
  C

</annotation></semantics></math></div>
<p>and</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub><mover><munder><mo>⟶</mo><mi>lim</mi></munder><mover><mo>⟵</mo><mi>const</mi></mover></mover><mi>C</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  [D,C]_{inj}
   \stackrel{\overset{const}{\longleftarrow}}{\underset{lim}{\longrightarrow}} 
  C
  \,.

</annotation></semantics></math></div>
<p>(All proofs and other technical details on this are at <a class="existingWikiWord" href="/nlab/show/homotopy+Kan+extension">homotopy Kan extension</a>.)</p>

<p>These present directly the corresponding <a class="existingWikiWord" href="/nlab/show/adjoint+%28%E2%88%9E%2C1%29-functor">adjoint (∞,1)-functor</a>s (as described there)</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mi>Func</mi><mo stretchy="false">(</mo><mi>D</mi><mo>,</mo><msup><mi>C</mi> <mo>∘</mo></msup><mo stretchy="false">)</mo><mover><mover><mo>⟶</mo><mo>←</mo></mover><mo>⟶</mo></mover><msup><mi>C</mi> <mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">
  (\infty,1)Func(D,C^\circ)
  \stackrel{\longrightarrow}{\stackrel{\leftarrow}{\longrightarrow}}
  C^\circ

</annotation></semantics></math></div>
<p>by precomposition with a cofibrant replacement functor (for the colimit) and a fibrant replacement functor (for the limit).</p>

<h3 id="local_definition">Local definition</h3>

<p>The local definition requires making precise the notion of a <em><a class="existingWikiWord" href="/nlab/show/homotopy">homotopy</a> commutative cone</em> on a diagram.</p>

<p>For the case of <a class="existingWikiWord" href="/nlab/show/SimpSet">SimpSet</a>-<a class="existingWikiWord" href="/nlab/show/enriched+category">enrichment</a> one elegant way to do so is in terms of suitable <a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a>s as described in the example section at <a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a>: a homotopy commutative cone with tip <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">c \in C</annotation></semantics></math> on a diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>K</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : K \to C</annotation></semantics></math> in an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">Simp</mo><mo lspace="0em" rspace="thinmathspace">Set</mo></mrow><annotation encoding="application/x-tex">\Simp\Set</annotation></semantics></math>-enriched category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>⇒</mo><mi>C</mi><mo stretchy="false">(</mo><mi>c</mi><mo>,</mo><mi>F</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>:</mo><mi>K</mi><mo>→</mo><mo lspace="0em" rspace="thinmathspace">Simp</mo><mo lspace="0em" rspace="thinmathspace">Set</mo></mrow><annotation encoding="application/x-tex">W \Rightarrow C(c,F(-)) : K \to \Simp\Set</annotation></semantics></math> where the <em>weight</em> functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> is not constant on the point, as for ordinary limits, but is given by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>:</mo><mi>k</mi><mo>↦</mo><mi>N</mi><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">/</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W : k \mapsto N(K/k)</annotation></semantics></math>.</p>

<p>The same idea works if we are enriched over a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> that is not <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">SimpSet</mo></mrow><annotation encoding="application/x-tex">\SimpSet</annotation></semantics></math> but is itself enriched over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">Simp</mo><mo lspace="0em" rspace="thinmathspace">Set</mo></mrow><annotation encoding="application/x-tex">\Simp\Set</annotation></semantics></math>, such as <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>s or <a class="existingWikiWord" href="/nlab/show/spectrum">spectra</a>, since then any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-category becomes a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">Simp</mo><mo lspace="0em" rspace="thinmathspace">Set</mo></mrow><annotation encoding="application/x-tex">\Simp\Set</annotation></semantics></math>-category as well in a natural way. Finally, although a general <a class="existingWikiWord" href="/nlab/show/model+category">model category</a> need not be enriched over anything, it is always “almost” enriched over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">Simp</mo><mo lspace="0em" rspace="thinmathspace">Set</mo></mrow><annotation encoding="application/x-tex">\Simp\Set</annotation></semantics></math>, and so one can still make sense of this using the techniques of <em>framings</em> and <em>resolutions</em>; see the books of Hirschhorn and Hovey.</p>

<p>Following the reasoning described in Example 1 of <a class="existingWikiWord" href="/nlab/show/representable+functor">representable functor</a> one then defines the homotopy limit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math> of a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>K</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F: K \to C</annotation></semantics></math> to be a representing object for such homotopy cones, in the sense that we have a (weak) equivalence</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Map</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>L</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>HoCones</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> Map(X,L) \simeq HoCones(X,F)</annotation></semantics></math></div>
<p>of <a class="existingWikiWord" href="/nlab/show/hom-objects">hom-objects</a> (spaces or simplicial sets in the classical context; enriched hom-objects in the enriched context).</p>

<h3 id="global_versus_local">Global versus local</h3>

<p>The global definition is formulated in terms of <a class="existingWikiWord" href="/nlab/show/weak+equivalence">weak equivalences</a> only, while the local definition is formulated in terms of <a class="existingWikiWord" href="/nlab/show/homotopy">homotopies</a> only. However, in practical cases, derived functors exist because their input objects (in this case, the diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>) can be replaced by “good” (fibrant and/or cofibrant) objects in such a way that weak equivalences become <em>homotopy</em> equivalences. The derived functor of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>lim</mi></mrow><annotation encoding="application/x-tex">lim</annotation></semantics></math> at the input object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is then computed by applying the ordinary functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>lim</mi></mrow><annotation encoding="application/x-tex">lim</annotation></semantics></math> to a good replacement <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R F</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>.</p>

<p>It then turns out that the “good” (precisely, “fibrant”) replacement <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R F</annotation></semantics></math> “builds in” precisely the right homotopies so that an ordinary cone on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R F</annotation></semantics></math> is the same as a homotopy-commutative cone on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>. Therefore, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>lim</mi><mo stretchy="false">(</mo><mi>R</mi><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lim (R F)</annotation></semantics></math>, which is the global homotopy-limit of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>, is a representing object for homotopy-commutative cones on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>, and thus is also a local homotopy-limit of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>. There is a dual argument for colimits using cofibrant replacements.</p>

<p>Formal versions of this argument can be found in many places. Perhaps the original statement can be found in XI.8.1 of:</p>

<ul>
<li>A. K. Bousfield and D. M. Kan, <em>Homotopy limits, completions, and localizations</em>.</li>
</ul>

<p>(As was often the case with Kan’s papers at that time, there are some details omitted from that treatment, but most are, as he claimed, quite easy to complete.) For another approach in an algebraic context, there is a description in Illusie’s thesis.</p>

<p>An abstract version in modern language, with proof, can be found in</p>

<ul>
<li>Michael Shulman, <a href="http://arxiv.org/abs/math/0610194">Homotopy limits and colimits and enriched homotopy theory</a>.</li>
</ul>

<h4 id="strictness">Strictness</h4>

<p>Another notable difference between the local and global definitions is that the global definition can only ever define the homotopy limit up to weak equivalence (isomorphism in the homotopy category), while in the local definition we <em>could</em> require, if we wanted to, an actual isomorphism</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>Map</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>L</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>HoCones</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> Map(X,L) \cong HoCones(X,F)</annotation></semantics></math></div>
<p>of hom-objects, rather than merely a weak equivalence. By analogy with <a class="existingWikiWord" href="/nlab/show/strict+2-limit">strict 2-limits</a>, we may call such an object a <strong>strict homotopy limit</strong>.</p>

<p>Frequently a strict homotopy limit does in fact exist, and can be constructed as a <a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a> in the ordinary (enriched) category in question. In such cases, the strict homotopy limit may be easier to compute with than an arbitrary homotopy limit merely known to have the up-to-weak-equivalence universal property. Thus, sometimes when people say <a class="existingWikiWord" href="/nlab/show/generalized+the">the</a> homotopy limit they refer mean a <em>strict</em> homotopy limit.</p>

<p>When a strict homotopy limit exists, an arbitrary homotopy limit may be defined as an object which is (weakly) equivalent to the strict homotopy limit.</p>

<h3 id="Derivators">Derivators</h3>

<p>It is noteworthy that the homotopy limit and colimit in a <a class="existingWikiWord" href="/nlab/show/category+with+weak+equivalences">category with weak equivalences</a> are drastically different from the ordinary <a class="existingWikiWord" href="/nlab/show/limit">limit</a> and colimit in the corresponding <a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a>: the universal property of the full <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categorical limits and colimits crucially does take into account the explicit higher cells and does not work just up to any higher cells.</p>

<p>This (obvious) observation is a very old one and can be seen to be one of the driving forces behind the insight that just working with <a class="existingWikiWord" href="/nlab/show/homotopy+categories">homotopy categories</a> misses crucial information, something which today is understood as the statement that a homotopy category is just the <a class="existingWikiWord" href="/nlab/show/decategorification">decategorification</a> of an <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-category">(∞,1)-category</a>.</p>

<p>While the full theory of <a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-categories">(∞,1)-categories</a> is one way to impose the correct notion of higher categorical limits, there are other ways to deal with issue. Due to <a class="existingWikiWord" href="/nlab/show/Alexander+Grothendieck">Alexander Grothendieck</a> is the technique of using <strong><a class="existingWikiWord" href="/nlab/show/derivator">derivator</a>s</strong> for keeping track of homotopy limits.</p>

<p>Roughly, the idea of a derivator is that while the single <a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ho</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ho(C)</annotation></semantics></math> of a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> with weak equivalences is not sufficient information, the homotopy limit of a diagram in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D,C]</annotation></semantics></math> <em>is</em> encoded in the homotopy category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ho</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ho([D,C])</annotation></semantics></math> of that <a class="existingWikiWord" href="/nlab/show/functor+category">functor category</a> (this is after all the domain of the plain 1-categorical <a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a> of the limit functor). Accordingly, what is called the <a class="existingWikiWord" href="/nlab/show/derivator">derivator</a> of a category with weak equivalences <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a collection of <em>all</em> the homotopy categories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ho</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ho([D,C])</annotation></semantics></math> of <em>all</em> the possible <a class="existingWikiWord" href="/nlab/show/diagram">diagram</a> categories <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D,C]</annotation></semantics></math>, as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> runs over all small categories. See there for more details.</p>

<h2 id="computational_methods">Computational methods</h2>

<p>Above we defined homotopy (co)limits in general. There are various more specific formulas and algorithms for computing homotopy (co)limits. Here we discuss some of these</p>

<h3 id="ordinary_colimits_on_resolved_diagrams">Ordinary (co)limits on resolved diagrams</h3>

<p>The direct prescription for computing the value of a right or left <a class="existingWikiWord" href="/nlab/show/derived+functor">derived functor</a> between <a class="existingWikiWord" href="/nlab/show/model+categories">model categories</a> is by evaluating the original functor on a fibrant or cofibrant <a class="existingWikiWord" href="/nlab/show/resolution">resolution</a> of the given object.</p>

<p>For the derived functors of limit and colimit</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mover><mover><munder><mo>⟶</mo><mrow><munder><mi>lim</mi> <mo>⟶</mo></munder></mrow></munder><mover><mo>⟵</mo><mi>const</mi></mover></mover><mover><mo>⟶</mo><mrow><munder><mi>lim</mi> <mo>⟵</mo></munder></mrow></mover></mover><mi>C</mi></mrow><annotation encoding="application/x-tex">
  [D,C] \stackrel{\overset{\lim_\longleftarrow}{\longrightarrow}}{\stackrel{\overset{const}{\longleftarrow}}{\underset{\lim_\longrightarrow}{\longrightarrow}}}
  C

</annotation></semantics></math></div>
<p>let for instance</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Q</mi> <mi>proj</mi></msub><mo>:</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Q_{proj} : [D,C] \to [D,C]</annotation></semantics></math> be a cofibrant replacement for the projective <a class="existingWikiWord" href="/nlab/show/model+structure+on+functors">model structure on functors</a>, so that for any diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> the diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Q</mi> <mi>proj</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">Q_{proj} F</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/projectively+cofibrant+diagram">projectively cofibrant diagram</a> (see there for more details). Then the homotopy colimit is presented by the ordinary colimit on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Q</mi> <mi>proj</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">Q_{proj} F</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>𝕃</mi><munder><mi>lim</mi><mo>→</mo></munder><mo stretchy="false">)</mo><mi>F</mi><mo>≃</mo><munder><mo lspace="0em" rspace="thinmathspace">limt</mo><mo>→</mo></munder><msub><mi>Q</mi> <mi>proj</mi></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  (\mathbb{L}\underset{\to}{\lim}) F \simeq \underset{\to}{\limt} Q_{proj}(F)
  \,.

</annotation></semantics></math></div>
<p>This is sometimes called the <strong>Quillen formula</strong> for computing homotopy colimits. Analogously with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>P</mi> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">P_{inj}</annotation></semantics></math> a fibrant replacement functor for the injective model structure, we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>holim</mi><mi>F</mi><mo>≃</mo><mi>lim</mi><msub><mi>P</mi> <mi>inj</mi></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  holim F \simeq lim P_{inj}(F)
  \,.

</annotation></semantics></math></div>
<p>Often, however, it is inconvenient to produce a resolution of a diagram. Because often all the work is in finding the resolution, while it is easy to evaluate the original functor on it. Therefore one wants ways to slightly change the setup of the problem such that the computation of the resolutions becomes more systematic. One such way is the use of derived (co)ends, discussed <a href="ResolvedCoEnds">below</a>.</p>

<h3 id="ResolvedCoEnds">Resolved (co)ends</h3>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi><msub><mo>′</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">Q'_{proj}</annotation></semantics></math> a cofibrant replacement functor for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">[D^{op}, sSet_{Quillen}]_{proj}</annotation></semantics></math> (notice the <a class="existingWikiWord" href="/nlab/show/opposite+category">opposite category</a>) and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Q</mi> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">Q_{inj}</annotation></semantics></math> one for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">[D,C]_{inj}</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>*</mo><mo>∈</mo><mo stretchy="false">[</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">* \in [D^op,sSet]</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/simplicial+presheaf">simplicial presheaf</a> constant on the terminal simplicial set and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi><msub><mo>′</mo> <mi>proj</mi></msub><mo stretchy="false">(</mo><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q'_{proj}(')</annotation></semantics></math> its projective cofibrant replacement.</p>

<p>Then we also have the <a class="existingWikiWord" href="/nlab/show/coend">coend</a> expression</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>F</mi><mo>≃</mo><msup><mo>∫</mo> <mi>D</mi></msup><mi>Q</mi><msub><mo>′</mo> <mi>proj</mi></msub><mo stretchy="false">(</mo><mo>*</mo><mo stretchy="false">)</mo><mo>⋅</mo><msub><mi>Q</mi> <mi>inj</mi></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  hocolim F \simeq \int^{D}
  Q'_{proj}(*) \cdot Q_{inj}(F)
  \,,

</annotation></semantics></math></div>
<p>where in the integrand we have the <a class="existingWikiWord" href="/nlab/show/copower">tensoring</a> of the <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> over <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a>.</p>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> happens to be a <a class="existingWikiWord" href="/nlab/show/Reedy+model+category">Reedy model category</a> we can equivalently use in this expression also the <a class="existingWikiWord" href="/nlab/show/Reedy+model+structure">Reedy model structure</a>s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[D,C]_{Reedy}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[D^{op}, C]_{Reedy}</annotation></semantics></math> and obtain the homotopy colimit as</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>F</mi><mo>≃</mo><msup><mo>∫</mo> <mi>D</mi></msup><mi>Q</mi><msub><mo>′</mo> <mi>Reedy</mi></msub><mo stretchy="false">(</mo><mo>*</mo><mo stretchy="false">)</mo><mo>⋅</mo><msub><mi>Q</mi> <mi>Reedy</mi></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  hocolim F \simeq \int^{D}
  Q'_{Reedy}(*) \cdot Q_{Reedy}(F)
  \,,

</annotation></semantics></math></div>
<p>This formula is sometimes called the <strong>Bousfield-Kan formula</strong> (see also <a class="existingWikiWord" href="/nlab/show/Bousfield-Kan+map">Bousfield-Kan map</a>). The coend is a <a class="existingWikiWord" href="/nlab/show/weighted+limit">weighted limit</a> and this formula for the plain homotopy colimit can be understood the left derived <em>weighted</em> colimit which trivial weight (the underived weight is trivial, but becomes non-trivial after derivation – this extra complexity helps reduce the complexity for the replacement for the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> itself).</p>

<p>In detail, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/monoidal+model+category">monoidal model category</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/enriched+model+category">enriched model category</a> (for instance <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>=</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub></mrow><annotation encoding="application/x-tex">V = sSet_{Quillen}</annotation></semantics></math> as in the above discussion). Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> be a small <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/enriched+category">enriched category</a>. Then for a any given <a class="existingWikiWord" href="/nlab/show/weighted+limit">weight</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>:</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>→</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">
  W : D^{op} \to V

</annotation></semantics></math></div>
<p>we have a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/adjunction">adjunction</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><munderover><mrow><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mo>⊥</mo><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace><mspace width="thickmathspace"></mspace></mrow><munder><mo>⟵</mo><mrow><mi>const</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><msup><mo stretchy="false">)</mo> <mi>W</mi></msup></mrow></munder><mover><mo>⟶</mo><mrow><mi>W</mi><msub><mo>⊗</mo> <mi>D</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo></mrow></mover></munderover><mi>D</mi><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  [D,C]
  \underoverset
    {\underset{const(-)^{W}}{\longleftarrow}}
    {\overset{W \otimes_D (-)}{\longrightarrow}}
    {\;\;\;\bot\;\;\;}
  D
  \,,

</annotation></semantics></math></div>
<p>where the <a class="existingWikiWord" href="/nlab/show/left+adjoint">left adjoint</a> is the weighted colimit given by the <a class="existingWikiWord" href="/nlab/show/coend">coend</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>W</mi><msub><mo>⊗</mo> <mi>D</mi></msub><mi>F</mi><mo>=</mo><msup><mo>∫</mo> <mrow><mi>d</mi><mo>∈</mo><mi>D</mi></mrow></msup><mi>W</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>F</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  W \otimes_D F = \int^{d \in D} W(d) \otimes F(d)

</annotation></semantics></math></div>
<p>(with the <a class="existingWikiWord" href="/nlab/show/copower">tensoring</a> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> in the integran) and where the <a class="existingWikiWord" href="/nlab/show/right+adjoint">right adjoint</a> is formed using the <a class="existingWikiWord" href="/nlab/show/power">cotensor</a> over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>.</p>

<p>The crux now is that as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> varies, the left adjoint here is a left <a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∫</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>,</mo><mi>V</mi><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo>→</mo><mi>C</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \int (-)\cdot (-)
  :
  [D^{op}, V] \times [D,C]
  \to 
  C
  \,.

</annotation></semantics></math></div>
<p>For details on this see <a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a> or around page 9 of (<a href="#Gambino10">Gambino 10</a>).</p>

<p>From the fact that this is a Quillen bifunctor and using the observation that for the <em>trivial</em> weight <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi><mo>=</mo><mi>const</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">W = const 1</annotation></semantics></math> the weighted colimit reduces to an ordinary colimit, follows the above Bousfield-Kan-type formula for the homotopy colimit.</p>

<h3 id="BarConstruction">Bar constructions</h3>

<p>A general way of obtaining resolutions that compute homotopy (co)limits involves <a class="existingWikiWord" href="/nlab/show/bar+construction">bar construction</a>s. (…)</p>

<h2 id="homotopy_limits_versus_higher_categorical_limits">Homotopy limits versus higher categorical limits</h2>

<p>As a special case of enriched homotopy theory, we may consider model categories or homotopical categories that are enriched over a notion of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-category as presentations for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n+1)</annotation></semantics></math>-categories. (Here we allow <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> to also be of the form <a class="existingWikiWord" href="/nlab/show/%28n%2Cr%29-category">(n,r)</a>, with the obvious convention that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,r)+1 = (n+1,r+1)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty+1=\infty</annotation></semantics></math>.) For example:</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/simplicial+set">simplicial set</a>s are models for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-<a class="existingWikiWord" href="/nlab/show/infinity-groupoid">groupoids</a> (<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,0)</annotation></semantics></math>-categories), so <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model categories</a> are presentations for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories. Of course, arbitrary model categories are also presentations for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories, but simplicial model categories are easier to work with, and in particular easier to construct homotopy limits in.</p>
</li>

<li>
<p>A <a class="existingWikiWord" href="/nlab/show/Cat">Cat</a>-enriched category is just a <a class="existingWikiWord" href="/nlab/show/strict+2-category">strict 2-category</a>, so a <a class="existingWikiWord" href="/nlab/show/model+2-category">model 2-category</a> or <span class="newWikiWord">homotopical 2-category<a href="/nlab/new/homotopical+2-category">?</a></span> is a presentation of a weak <a class="existingWikiWord" href="/nlab/show/2-category">2-category</a> (or <a class="existingWikiWord" href="/nlab/show/bicategory">bicategory</a>).</p>
</li>

<li>
<p>A <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>Cat</mi><mo>,</mo><msub><mo>⊗</mo> <mi>Gray</mi></msub></mrow><annotation encoding="application/x-tex">(2Cat,\otimes_{Gray}</annotation></semantics></math>)-enriched category is a <a class="existingWikiWord" href="/nlab/show/Gray-category">Gray-category</a>, and a <span class="newWikiWord">model Gray-category<a href="/nlab/new/model+Gray-category">?</a></span> or <span class="newWikiWord">homotopical Gray-category<a href="/nlab/new/homotopical+Gray-category">?</a></span> is a presentation of a weak <a class="existingWikiWord" href="/nlab/show/3-category">3-category</a> (or <a class="existingWikiWord" href="/nlab/show/tricategory">tricategory</a>).</p>
</li>
</ul>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a category enriched over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1)</annotation></semantics></math>-categories and we are considering it to <em>be</em> an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-category (which happens to be strict at the bottom level), it is natural to define a “weak equivalence” in the underlying ordinary category of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> to be a morphism that is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-category-theoretic <a class="existingWikiWord" href="/nlab/show/equivalence+of+categories">equivalence</a>. We call this the <em>natural</em> or <em>trivial</em> homotopical structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. In certain cases (such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=2)</annotation></semantics></math> it can be made into a model structure, also called <em>natural</em> or <em>trivial</em>.</p>

<p>Since higher categorical limits are generally defined as representing objects for cones that commute up to <a class="existingWikiWord" href="/nlab/show/equivalence">equivalence</a>, it is unsurprising that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> has a natural homotopical structure, locally-defined homotopy limits and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-limits coincide. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math> this is trivial. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math> it is proven in (<a href="#Gambino10">Gambino 10</a>) (particularly section 6). For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=(\infty,1)</annotation></semantics></math> it is proven in (among other places) Lurie’s book, section 4.2.4. The case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n=3</annotation></semantics></math> ought to be approachable in theory, but doesn’t seem to have been done (probably partly because the general theory of 3-limits is fairly nonexistent).</p>

<p>On the other hand, we may also consider a category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> enriched over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-categories with a <em>larger</em> class of weak equivalences than just the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-categorical equivalences. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> presents an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-category (its “homotopy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-category”) obtained by formally turing these weak equivalences into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-categorical equivalences. Homotopy limits in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> with this homotopical structure should then present <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-limits in its homotopy <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>-category. In the case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=(\infty,1)</annotation></semantics></math> this is also essentially in Lurie’s book; for other values of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math> it may not be in the literature.</p>

<h2 id="homotopy_limits_versus_limits_in_the_homotopy_category">Homotopy limits versus limits in the homotopy category</h2>

<p>It is important to note that homotopy limits and limits in the <a class="existingWikiWord" href="/nlab/show/homotopy+category">homotopy category</a> are, in general, incomparable. A homotopy limit need not be a limit in the homotopy category, while a limit in the homotopy category need not be a homotopy limit.</p>

<p>It is generally true that homotopy <em>products</em> (and coproducts) are also products and coproducts in the homotopy category. Some other homotopy limits induce the corresponding notion of <a class="existingWikiWord" href="/nlab/show/weak+limit">weak limit</a> in the homotopy category; for instance, homotopy pullbacks become weak pullbacks in the homotopy category. However, even this is not true for all types of homotopy limit.</p>

<p>On the other hand, homotopy categories do not <em>usually</em> have many limits and colimits at all (aside from products and coproducts). An explicit proof that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ho</mi><mo stretchy="false">(</mo><mi>Cat</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ho(Cat)</annotation></semantics></math> does not have pullbacks can be found <a href="/nlab/show/Ho%28Cat%29#OtherLimits">here</a>. But even if a homotopy category <em>does</em> happen to have limits and colimits, these need not be the same as homotopy limits.</p>

<p>For instance, every <a class="existingWikiWord" href="/nlab/show/chain+complex">chain complex</a> over a <a class="existingWikiWord" href="/nlab/show/field">field</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is quasi-isomorphic to its <a class="existingWikiWord" href="/nlab/show/homology">homology</a>, regarded as a chain complex with zero differentials; and between chain complexes of the latter form, quasi-isomorphisms are just isomorphisms. Thus, the homotopy category of chain complexes over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is equivalent to the category of graded <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>-vector-spaces. This is complete and cocomplete as a category, but its limits and colimits are not the same as the homotopy limits and colimits arising from its presentation as the homotopy category of chain complexes. In particular, chain complexes are a <a class="existingWikiWord" href="/nlab/show/stable+%28infinity%2C1%29-category">stable (infinity,1)-category</a>, so every homotopy pullback square is also a homotopy pushout square and vice versa; but nothing of the sort is true in graded vector spaces as a 1-category.</p>

<h2 id="Examples">Examples</h2>

<h3 id="WeightedColimitFormula">General weighted colimit formula for homotopy colimits</h3>

<p>Let</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/combinatorial+model+category">combinatorial</a> <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial</a> <a class="existingWikiWord" href="/nlab/show/model+category">model category</a></p>
</li>

<li>
<p>let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/small+category">small</a> <a class="existingWikiWord" href="/nlab/show/simplicially+enriched+category">simplicially enriched category</a></p>

<p>(possibly an ordinary <a class="existingWikiWord" href="/nlab/show/locally+small+category">locally small category</a> regarded as a <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a>-<a class="existingWikiWord" href="/nlab/show/enriched+category">enriched category</a> in the tautological way)</p>
</li>

<li>
<p>and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : D \to C</annotation></semantics></math> be an <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a>-<a class="existingWikiWord" href="/nlab/show/enriched+functor">enriched functor</a>.</p>
</li>
</ul>

<p>There is a general formula for the homotopy colimit over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> in terms of a <a class="existingWikiWord" href="/nlab/show/coend">coend</a> or <a class="existingWikiWord" href="/nlab/show/weighted+colimit">weighted colimit</a> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, using the following ingredients:</p>

<h4 id="ingredients">Ingredients</h4>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/combinatorial+simplicial+model+category">combinatorial simplicial model category</a> as above and for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> any <a class="existingWikiWord" href="/nlab/show/simplicially+enriched+category">simplicially enriched category</a> there is the projective and the injective <a class="existingWikiWord" href="/nlab/show/global+model+structure+on+functors">global model structure on functors</a> on the <a class="existingWikiWord" href="/nlab/show/enriched+functor+category">enriched functor category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D,C]</annotation></semantics></math>.</p>

<ul>
<li>
<p>In the projective model structure <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">[D,C]_{proj}</annotation></semantics></math> the fibrations and the local equivalences are objectwise those of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></p>
</li>

<li>
<p>In the injective model structure <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">[D,C]_{inj}</annotation></semantics></math> the cofibrations and the local equivalences are objectwise those of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
</li>
</ul>

<p>Each of these is itself a <a class="existingWikiWord" href="/nlab/show/combinatorial+simplicial+model+category">combinatorial simplicial model category</a>, so in particular the <a class="existingWikiWord" href="/nlab/show/small+object+argument">small object argument</a> applies in these using which one obtains cofibrant replacement functors</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>Q</mi> <mi>proj</mi></msub><mo>:</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
  Q_{proj} : [D, C] \to [D, C]

</annotation></semantics></math></div>
<p>and</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msub><mi>Q</mi> <mi>inj</mi></msub><mo>:</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mo>→</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  Q_{inj} : [D, C] \to [D, C]
  \,.

</annotation></semantics></math></div>
<p>That <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/simplicial+model+category">simplicial model category</a> implies in particular that it is <a class="existingWikiWord" href="/nlab/show/copower">tensored</a> over <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a> and that the tensoring functor</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>⊗</mo><mo>:</mo><mi>C</mi><mo>×</mo><mi>sSet</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">
  \otimes : C \times sSet \to C

</annotation></semantics></math></div>
<p>is a left <a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a>. By the properties of Quillen bifunctors discussed there, it follows that the <a class="existingWikiWord" href="/nlab/show/coend">coend</a>s over the <a class="existingWikiWord" href="/nlab/show/copower">tensor</a> in the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mo>∫</mo> <mi>D</mi></msup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>⊗</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub><mo>×</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">
  \int^D (-) \otimes (-) : [D^{op},sSet]_{proj} \times [D,C]_{inj} \to C

</annotation></semantics></math></div>
<p>and in the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mo>∫</mo> <mi>D</mi></msup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>⊗</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub><mo>×</mo><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">
  \int^D (-) \otimes (-) : [D^{op},sSet]_{inj} \times [D,C]_{proj} \to C

</annotation></semantics></math></div>
<p>both themselves left <a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a>s.</p>

<p>Write</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>*</mo><mo>:</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>→</mo><mi>sSet</mi></mrow><annotation encoding="application/x-tex">
  {*} : D^{op} \to sSet

</annotation></semantics></math></div>
<p>for the functor that sends everything to the identity on the singleton set. This is the tensor unit in the <a class="existingWikiWord" href="/nlab/show/monoidal+category">monoidal category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>D</mi> <mi>op</mi></msup><mo>,</mo><mi>sSet</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[D^{op},sSet]</annotation></semantics></math>.</p>

<h4 id="general_formula">General formula</h4>

<div class="num_theorem">
<h6 id="theorem">Theorem</h6>

<p>With the above assumptions and ingredients, the homotopy colimit over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : D \to C</annotation></semantics></math> is given either by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>F</mi><mo>=</mo><msup><mo>∫</mo> <mi>D</mi></msup><msub><mi>Q</mi> <mi>proj</mi></msub><mo stretchy="false">(</mo><mo>*</mo><mo stretchy="false">)</mo><mo>⊗</mo><msub><mi>Q</mi> <mi>inj</mi></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  hocolim F = \int^D Q_{proj}({*}) \otimes Q_{inj}(F) 

</annotation></semantics></math></div>
<p>or by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>F</mi><mo>=</mo><msup><mo>∫</mo> <mi>D</mi></msup><msub><mi>Q</mi> <mi>inj</mi></msub><mo stretchy="false">(</mo><mo>*</mo><mo stretchy="false">)</mo><mo>⊗</mo><msub><mi>Q</mi> <mi>proj</mi></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  hocolim F = \int^D Q_{inj}({*}) \otimes Q_{proj}(F) 
  \,.

</annotation></semantics></math></div></div>

<div class="proof">
<h6 id="proof">Proof</h6>

<p>By the fact that the <a class="existingWikiWord" href="/nlab/show/coend">coend</a> over the <a class="existingWikiWord" href="/nlab/show/copower">tensor</a> appearing here is a <a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a>.</p>

<p>This is disucssed for instance in section 4 of (<a href="#Gambino10">Gambino 10</a>).</p>
</div>

<h4 id="examples_2">Examples</h4>

<h5 id="homotopy_colimits_of_simplicial_diagrams">Homotopy colimits of simplicial diagrams</h5>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>=</mo><msup><mi>Δ</mi> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">D = \Delta^{op}</annotation></semantics></math> be the <a class="existingWikiWord" href="/nlab/show/opposite+category">opposite category</a> of the <a class="existingWikiWord" href="/nlab/show/simplex+category">simplex category</a>.</p>

<div class="num_prop">
<h6 id="proposition">Proposition</h6>

<p>A cofibrant replacement of the <a class="existingWikiWord" href="/nlab/show/terminal+object">terminal object</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>*</mo></mrow><annotation encoding="application/x-tex">{*}</annotation></semantics></math> in the projective <a class="existingWikiWord" href="/nlab/show/global+model+structure+on+functors">global model structure on functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><mi>sSet</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\Delta, sSet]</annotation></semantics></math> is the the <a class="existingWikiWord" href="/nlab/show/fat+simplex">fat simplex</a>-functor that assigns to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math> the <a class="existingWikiWord" href="/nlab/show/nerve">nerve</a> of <a class="existingWikiWord" href="/nlab/show/opposite+category">opposite category</a> of the <a class="existingWikiWord" href="/nlab/show/undercategory">undercategory</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Δ</mi> <mi>op</mi></msup></mrow><annotation encoding="application/x-tex">\Delta^{op}</annotation></semantics></math> under <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">/</mo><msup><mi>Δ</mi> <mi>op</mi></msup><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>:</mo><mi>Δ</mi><mo>→</mo><mi>sSet</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  N(-/\Delta^{op})^{op} : \Delta \to sSet
  \,.

</annotation></semantics></math></div></div>

<div class="proof">
<h6 id="proof_2">Proof</h6>

<p>For instance prop 14.8.8 in</p>

<ul>
<li>Hirschhorn, <em>Model categories and their localization</em></li>
</ul>
</div>

<p>Notice that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : \Delta^{op} \to C</annotation></semantics></math> takes values in cofibrant objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, then it is itself cofibrant as an object of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta^{op},C]_{inj}</annotation></semantics></math>. In that case no further cofibrant replacement of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is necessary and it therefore follows with the general formula and the above proposition that the homotopy colimit over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is given by the formulas</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>F</mi><mo>=</mo><msup><mo>∫</mo> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>Δ</mi></mrow></msup><mi>N</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">/</mo><mi>Δ</mi><msup><mo stretchy="false">)</mo> <mi>op</mi></msup><mo>⊗</mo><mi>F</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  hocolim F = \int^{[n] \in \Delta} N([n]/\Delta)^{op} \otimes F(n)
  \,.

</annotation></semantics></math></div>
<p>This is famously the formula introduced and used by Bousfield and Kan (but there originally missing the necessary condition that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> be objectwise cofibrant). See <a class="existingWikiWord" href="/nlab/show/Bousfield-Kan+map">Bousfield-Kan map</a>.</p>

<h4 id="homotopy_pushouts">Homotopy pushouts</h4>

<p>Let in the above general formula <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo>←</mo><mi>c</mi><mo>→</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D = \{a \leftarrow c \to b\}</annotation></semantics></math> be the <a class="existingWikiWord" href="/nlab/show/walking">walking</a> <a class="existingWikiWord" href="/nlab/show/span">span</a>. Ordinary <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a>s parameterized by such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> are <a class="existingWikiWord" href="/nlab/show/pushout">pushout</a>s. Homotopy colimits over such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> are <strong>homotopy pushouts</strong>.</p>

<p>In this simple case, we have the following simple observation:</p>

<div class="num_lemma">
<h6 id="observation">Observation</h6>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> as above, the terminal functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>*</mo><mo>:</mo><mi>D</mi><mo>→</mo><mi>sSet</mi></mrow><annotation encoding="application/x-tex">{*} : D \to sSet</annotation></semantics></math> is already cofibrant in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>sSet</mi><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">[D,sSet]_{inj}</annotation></semantics></math>.</p>
</div>

<p>Moreover</p>

<div class="num_lemma">
<h6 id="observation_2">Observation</h6>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> as above, a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : D \to C</annotation></semantics></math> is cofibrant in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">[D,C]_{proj}</annotation></semantics></math> if</p>

<ul>
<li>
<p>it sends both morphisms <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">c \to a</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">c \to b</annotation></semantics></math> to cofibrations</p>
</li>

<li>
<p>it sends <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> (and hence also <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math>) to cofibrant objects in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
</li>
</ul>
</div>

<p>Since a coend <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>∫</mo><mo>*</mo><mo>⊗</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\int {* } \otimes F</annotation></semantics></math> over a tensor product where the first factor in the integrand in the tensor unit is just an ordinary <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a> over the remaining <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math>, it follows that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is of the form of the above observation, then the ordinary colimit over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> already computes the homotopy pushout:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>F</mi><mo>=</mo><munder><mi>lim</mi> <mo>→</mo></munder><mi>F</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  hocolim F = \lim_\to F
  \,.

</annotation></semantics></math></div>
<p>The dual version of this statement (for homotopy limits and homotopy pullbacks) is discussed in more detail in the examples below.</p>

<h3 id="HomotopyPullbacks">Homotopy pullbacks</h3>

<p>Here we consider special cases of <a class="existingWikiWord" href="/nlab/show/homotopy+pullback">homotopy pullback</a> in more detail.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo>→</mo><mn>0</mn><mo>←</mo><mn>2</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D = \{ 1\to 0 \leftarrow 2\}</annotation></semantics></math> be the pullback <a class="existingWikiWord" href="/nlab/show/diagram">diagram</a>, so that limits over it compute <a class="existingWikiWord" href="/nlab/show/pullback">pullback</a>s, and assume that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : D \to C</annotation></semantics></math> is such that</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>←</mo><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  F(1) \to F(0) \leftarrow F(2)

</annotation></semantics></math></div>
<p>satisfies</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math> is fibrant for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math>;</li>

<li>and either <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(1) \to F(0)</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(2) \to F(0)</annotation></semantics></math> is a fibration;</li>
</ul>

<p>then</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>holim</mi> <mi>D</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">holim_D F</annotation></semantics></math> exists;</li>

<li>and is weakly equivalent to the ordinary limit <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>holim</mi> <mi>D</mi></msub><mi>F</mi><mover><mo>⟶</mo><mo>≃</mo></mover><msub><mi>lim</mi> <mi>D</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">holim_D F \stackrel{\simeq}{\longrightarrow} lim_D F</annotation></semantics></math>.</li>
</ul>

<p>Conversely this means that on an arbitrary pullback diagram <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>holim</mi> <mi>D</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">holim_D F</annotation></semantics></math> can be computed by finding a natural transformation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>⇒</mo><mi>R</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">F \Rightarrow R F</annotation></semantics></math> whose component morphisms are weak equivalences and such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>R</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R F</annotation></semantics></math> satisfies the above conditions.</p>

<h4 id="based_loop_objects">Based loop objects</h4>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> any <a class="existingWikiWord" href="/nlab/show/pointed+object">pointed object</a> with point <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pt</mi><mover><mo>⟶</mo><mrow><msub><mi>pt</mi> <mi>B</mi></msub></mrow></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">pt \stackrel{pt_B}{\longrightarrow} B</annotation></semantics></math> the homotopy pullback of the point along itself is the <a class="existingWikiWord" href="/nlab/show/loop+space+object">loop space object</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>Ω</mi> <mi>pt</mi></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><mo>*</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mo>*</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>B</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">

  \array{
    \Omega_{pt} &amp;\to&amp; {*}
    \\
    \downarrow &amp;&amp; \downarrow
    \\
    {*} &amp;\to&amp; B
  }
  \,,

</annotation></semantics></math></div>
<p>i.e.</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>holim</mi><mo stretchy="false">(</mo><mi>pt</mi><mover><mo>⟶</mo><mrow><msub><mi>pt</mi> <mi>B</mi></msub></mrow></mover><mi>B</mi><mover><mo>←</mo><mrow><msub><mi>pt</mi> <mi>B</mi></msub></mrow></mover><mi>pt</mi><mo stretchy="false">)</mo><mspace width="thickmathspace"></mspace><mover><mo>⟶</mo><mo>≃</mo></mover><mspace width="thickmathspace"></mspace><msub><mi>Ω</mi> <mi>pt</mi></msub><mi>B</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  holim(  pt \stackrel{pt_B}{\longrightarrow}  B \stackrel{pt_B}{\leftarrow} pt)
  \;\stackrel{\simeq}{\longrightarrow}\;
  \Omega_{pt} B
  \,.

</annotation></semantics></math></div>
<p>One way to compute this using the above prescription by noticing that the <a class="existingWikiWord" href="/nlab/show/generalized+universal+bundle">generalized universal bundle</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mi>pt</mi></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathbf{E}_{pt} B</annotation></semantics></math> provides a fibrant replacement of the pullback diagram in that we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>pt</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>B</mi></mtd> <mtd><mo>←</mo></mtd> <mtd><mi>pt</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mo>≃</mo></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mi>Id</mi></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mi>Id</mi></msup></mtd></mtr> <mtr><mtd><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mi>pt</mi></msub><mi>B</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>B</mi></mtd> <mtd><mo>←</mo></mtd> <mtd><mi>pt</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
     pt &amp;\to&amp; B &amp;\leftarrow&amp; pt
     \\
     \downarrow^{\simeq} &amp;&amp; \downarrow^{Id} &amp;&amp; \downarrow^{Id}
     \\
    \mathbf{E}_{pt}B &amp;\to&amp; B &amp;\leftarrow&amp; pt
  }

</annotation></semantics></math></div>
<p>with all vertical morphisms weak equivalences and with the left bottom horizontal morphism a fibration.</p>

<p>More on that in the further examples below.</p>

<h4 id="fibration_sequences">Fibration sequences</h4>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/pointed+object">pointed object</a>, with point <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>*</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">{*} \to C</annotation></semantics></math>, then for a homotopy pullback of the form</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>A</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mo>*</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>B</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>C</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
     A &amp;\to&amp; {*}
     \\
     \downarrow &amp;&amp; \downarrow
     \\
     B &amp;\to&amp; C
  }

</annotation></semantics></math></div>
<p>the sequence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A \to B \to C</annotation></semantics></math> is called a <a class="existingWikiWord" href="/nlab/show/fibration+sequence">fibration sequence</a>. The object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is the <em>homotopy kernel</em> or <em>homotopy fiber</em> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">B \to C</annotation></semantics></math>. Since homotopy pullback squares compose to homotopy pullback squares, the homotopy kernel of a homotopy kernel is not trivial, but is a <a class="existingWikiWord" href="/nlab/show/loop+space+object">loop space object</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>Ω</mi><mi>C</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>A</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mo>*</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mo>*</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>B</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>C</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
     \Omega C &amp;\to&amp; A &amp;\to&amp; {*}
     \\
     \downarrow &amp;&amp; \downarrow &amp;&amp; \downarrow
     \\
     {*} &amp;\to&amp; B &amp;\to&amp; C
  }
  \,.

</annotation></semantics></math></div>
<h4 id="GroupDeloop">Homotopy pullback of a point over a group / universal bundles</h4>

<p>As a special case of the above general example we get the following.</p>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">C =</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/Grpd">Grpd</a> equipped with the <a class="existingWikiWord" href="/nlab/show/canonical+model+structure">canonical model structure</a>. Write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> for a <a class="existingWikiWord" href="/nlab/show/group">group</a> regarded as a discrete monoidal groupoid (elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> are the objects of the groupoids and all morphisms are identities) and write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}G</annotation></semantics></math> for the corresponding one-object <a class="existingWikiWord" href="/nlab/show/groupoid">groupoid</a> (single object, one morphism per element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>). Write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pt</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math> for the terminal groupoid (one object, no nontrivial morphism). Notice that there is a unique functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pt</mi><mo>→</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">pt \to \mathbf{B}G</annotation></semantics></math>. Then we have</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>holim</mi><mrow><mo>(</mo><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mi>pt</mi></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>pt</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mo>)</mo></mrow><mover><mo>⟶</mo><mo>≃</mo></mover><mi>G</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  holim
  \left(
    \array{
       &amp;&amp; pt
       \\
       &amp;&amp; \downarrow
       \\
       pt &amp;\to&amp; \mathbf{B}G
    }
  \right)
  \stackrel{\simeq}{\longrightarrow}
  G
  \,.

</annotation></semantics></math></div>
<p>To see this, we compute using the above prescription by finding a weakly equivalent pullback diagram such that one of its morphisms is a fibration. This is achieved in particular by the <a class="existingWikiWord" href="/nlab/show/generalized+universal+bundle">generalized universal bundle</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pt</mi><mover><mo>⟶</mo><mo>≃</mo></mover><mstyle mathvariant="bold"><mi>E</mi></mstyle><mi>G</mi><mo>→</mo><mo>&gt;</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">pt \stackrel{\simeq}{\longrightarrow} \mathbf{E}G \to\gt \mathbf{B}G</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathbf{E}G</annotation></semantics></math> is the <a class="existingWikiWord" href="/nlab/show/action+groupoid">action groupoid</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi><mo stretchy="false">/</mo><mo stretchy="false">/</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">G//G</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> acting on itself by multiplication from one side. So we have a weak equivalence of pullback diagrams</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>pt</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd> <mtd><mo>←</mo></mtd> <mtd><mi>pt</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mo>≃</mo></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mo>=</mo></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mo>=</mo></msup></mtd></mtr> <mtr><mtd><mstyle mathvariant="bold"><mi>E</mi></mstyle><mi>G</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd> <mtd><mo>←</mo></mtd> <mtd><mi>pt</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
     pt &amp;\to&amp; \mathbf{B}G &amp;\leftarrow&amp; pt
     \\
     \downarrow^{\simeq} &amp;&amp; \downarrow^= &amp;&amp;
     \downarrow^= 
     \\
     \mathbf{E}G &amp;\to&amp; \mathbf{B}G &amp;\leftarrow&amp; pt 
  }

</annotation></semantics></math></div>
<p>and the homotopy limit in question is weakly equivalent to the ordinary limit over the lower diagram. That is directly seen to be <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Disc</mi><mo stretchy="false">(</mo><mi>Obj</mi><mo stretchy="false">(</mo><mstyle mathvariant="bold"><mi>E</mi></mstyle><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>Disc</mi><mo stretchy="false">(</mo><mi>Obj</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">/</mo><mo stretchy="false">/</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>Disc</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Disc(Obj(\mathbf{E}G)) = Disc(Obj(G//G)) = Disc(G)</annotation></semantics></math> which we just write as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>holim</mi><mrow><mo>(</mo><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mi>pt</mi></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>pt</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mo>)</mo></mrow><mover><mo>⟶</mo><mo>≃</mo></mover><mi>lim</mi><mrow><mo>(</mo><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mi>pt</mi></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mstyle mathvariant="bold"><mi>E</mi></mstyle><mi>G</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mo>)</mo></mrow><mo>=</mo><mi>G</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  holim 
  \left(
    \array{
       &amp;&amp; pt
       \\
       &amp;&amp; \downarrow
       \\
       pt &amp;\to&amp; \mathbf{B}G
    }
  \right)
  \stackrel{\simeq}{\longrightarrow}
  lim
  \left(
    \array{
       &amp;&amp; pt
       \\
       &amp;&amp; \downarrow
       \\
       \mathbf{E}G &amp;\to&amp; \mathbf{B}G
    }
  \right)  
  = G
  \,.

</annotation></semantics></math></div>
<p>This example is important in the context of <a class="existingWikiWord" href="/nlab/show/groupoidification">groupoidification</a> and <a class="existingWikiWord" href="/nlab/show/geometric+function+theory">geometric function theory</a>, as described there. A closely related example is the following: a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ρ</mi><mo>:</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><mo>→</mo><mi>Top</mi></mrow><annotation encoding="application/x-tex">\rho:\mathbf{B}G\to {Top}</annotation></semantics></math> is the datum of a toplogical space <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> equipped with an action of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math>. Then, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>colim</mi><mo stretchy="false">(</mo><mi>ρ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>X</mi><mo stretchy="false">/</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">colim(\rho)=X/G</annotation></semantics></math> whereas <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mo stretchy="false">(</mo><mi>ρ</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle mathvariant="bold"><mi>E</mi></mstyle><mi>G</mi><msub><mo>×</mo> <mi>G</mi></msub><mi>X</mi></mrow><annotation encoding="application/x-tex">hocolim(\rho)=\mathbf{E}G\times_G X</annotation></semantics></math>, see <a class="existingWikiWord" href="/nlab/show/equivariant+cohomology">equivariant cohomology</a>.</p>

<h4 id="DeloopedSubgroupOverGroup">Homotopy pullback of a subgroup over a group</h4>

<p>The above example generalizes straightforwardly to the case where the trivial inclusion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pt</mi><mo>→</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">pt \to \mathbf{B}G</annotation></semantics></math> is replaced by any inclusion <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi><mo>↪</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}H \hookrightarrow \mathbf{B}G</annotation></semantics></math> of any subgroup <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> pretty much literally by replacing <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>pt</mi></mrow><annotation encoding="application/x-tex">pt</annotation></semantics></math> by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}H</annotation></semantics></math> throughout.</p>

<p>One finds</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>holim</mi><mrow><mo>(</mo><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mo>)</mo></mrow><mover><mo>⟶</mo><mo>≃</mo></mover><mi>H</mi><mo>\</mo><mo>\</mo><mi>G</mi><mo stretchy="false">/</mo><mo stretchy="false">/</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">
  holim\left(
   \array{
     &amp;&amp; \mathbf{B}H
     \\
     &amp;&amp; \downarrow
     \\
     \mathbf{B}H &amp;\to&amp; \mathbf{B}G
   }
  \right)
  \stackrel{\simeq}{\longrightarrow}  H \backslash\backslash G//H

</annotation></semantics></math></div>
<p>where on the right we have the <a class="existingWikiWord" href="/nlab/show/action+groupoid">action groupoid</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>H</mi><mo>×</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">H \times H</annotation></semantics></math> acting on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math> by multiplication from the left (first factor) and the right (second factor). (See for instance at <em><a class="existingWikiWord" href="/nlab/show/Hecke+category">Hecke category</a></em> for an application.)</p>

<p>To see this, we again build a fibrant replacement of the pullback diagram. Following the constructions at <a class="existingWikiWord" href="/nlab/show/generalized+universal+bundle">generalized universal bundle</a> consider first the groupoid <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mrow></msub><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathbf{E}_{\mathbf{B}H}G</annotation></semantics></math> given by the pullback diagram</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mrow></msub><mi>G</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">[</mo><mi>I</mi><mo>,</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><mo stretchy="false">]</mo></mtd> <mtd><mover><mo>→</mo><mrow><msub><mi>d</mi> <mn>0</mn></msub></mrow></mover></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr> <mtr><mtd><msup><mo stretchy="false">↓</mo> <mrow><msub><mi>d</mi> <mn>1</mn></msub></mrow></msup></mtd></mtr> <mtr><mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \array{
    \mathbf{E}_{\mathbf{B}H}G &amp;\to&amp; \mathbf{B}H
    \\
    \downarrow &amp;&amp; \downarrow
    \\
    [I, \mathbf{B}G] &amp;\stackrel{d_0}{\to}&amp; \mathbf{B}G
    \\
    \downarrow^{d_1} 
    \\
    \mathbf{B}G
  }
  \,.

</annotation></semantics></math></div>
<p>As at <a class="existingWikiWord" href="/nlab/show/generalized+universal+bundle">generalized universal bundle</a> one proves that the left vertical morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mrow></msub><mi>G</mi><mo>→</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathbf{E}_{\mathbf{B}H}G \to \mathbf{B}G</annotation></semantics></math> is a fibration.</p>

<p>Now, notice (which was implicit in the above example) that since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>I</mi><mo>,</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[I,\mathbf{B}G]</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/path+object">path object</a> in a <a class="existingWikiWord" href="/nlab/show/category+of+fibrant+objects">category of fibrant objects</a> we have a <a class="existingWikiWord" href="/nlab/show/section">section</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><msup><mover><mo>→</mo><mo>≃</mo></mover> <mi>σ</mi></msup><mo stretchy="false">[</mo><mi>I</mi><mo>,</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">
  \mathbf{B}G \stackrel{\simeq}{\to}^\sigma  [I, \mathbf{B}G] 
</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>I</mi><mo>,</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><mo stretchy="false">]</mo><mover><mo>→</mo><mrow><msub><mi>d</mi> <mn>0</mn></msub></mrow></mover><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mrow><annotation encoding="application/x-tex">[I,\mathbf{B}G] \stackrel{d_0}{\to} \mathbf{B}G</annotation></semantics></math>. In the above pullback diagram this induces a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi><mover><mo>→</mo><mi>σ</mi></mover><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mrow></msub><mi>G</mi></mrow><annotation encoding="application/x-tex">
  \mathbf{B}H \stackrel{\sigma}{\to} \mathbf{E}_{\mathbf{B}H}G
</annotation></semantics></math> making the obvious diagram commute. Now, the latter morphism, being the pullback of an acyclic fibration is an acyclic fibration, so its right inverse <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is a weak equivalence. This way we obtain the morphism of pullback diagrams</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd> <mtd><mo>←</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd></mtr> <mtr><mtd><msup><mrow></mrow> <mo>≃</mo></msup><msup><mo stretchy="false">↓</mo> <mi>σ</mi></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mi>Id</mi></msup></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mi>Id</mi></msup></mtd></mtr> <mtr><mtd><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mrow></msub><mi>G</mi></mtd> <mtd><mo>→</mo><mo>&gt;</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd> <mtd><mo>←</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
  \array{
    \mathbf{B}H &amp;\to&amp; \mathbf{B}G &amp;\leftarrow&amp; \mathbf{B}H
    \\
    {}^\simeq\downarrow^{\sigma} &amp;&amp; \downarrow^{Id} 
     &amp;&amp; \downarrow^{Id} 
    \\
    \mathbf{E}_{\mathbf{B}H}G &amp;\to \gt&amp; \mathbf{B}G &amp;\leftarrow&amp; \mathbf{B}H
  }

</annotation></semantics></math></div>
<p>which is objectwise a weak equivalence and such that the horizontal morphism on the bottom left is a fibration. By the above statement the ordinary limit of the lower horizontal diagram is weakly equivalent to the homotopy limit we are looking for. But this is manifestly the desired action groupoid:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>holim</mi><mrow><mo>(</mo><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mo>)</mo></mrow><mover><mo>→</mo><mo>≃</mo></mover><mi>lim</mi><mrow><mo>(</mo><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><msub><mstyle mathvariant="bold"><mi>E</mi></mstyle> <mrow><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mrow></msub><mi>G</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mo>)</mo></mrow><mo>≃</mo><mi>lim</mi><mrow><mo>(</mo><mrow><mtable><mtr><mtd></mtd> <mtd></mtd> <mtd><mo stretchy="false">[</mo><mi>I</mi><mo>,</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd></mtd> <mtd></mtd> <mtd><msup><mo stretchy="false">↓</mo> <mrow><msub><mi>d</mi> <mn>0</mn></msub><mo>×</mo><msub><mi>d</mi> <mn>1</mn></msub></mrow></msup></mtd></mtr> <mtr><mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi><mo>×</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>H</mi></mtd> <mtd><mo>→</mo></mtd> <mtd><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi><mo>×</mo><mstyle mathvariant="bold"><mi>B</mi></mstyle><mi>G</mi></mtd></mtr></mtable></mrow><mo>)</mo></mrow><mo>=</mo><mi>H</mi><mo>\</mo><mo>\</mo><mi>G</mi><mo stretchy="false">/</mo><mo stretchy="false">/</mo><mi>H</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  holim\left(
   \array{
     &amp;&amp; \mathbf{B}H
     \\
     &amp;&amp; \downarrow
     \\
     \mathbf{B}H &amp;\to&amp; \mathbf{B}G
   }
  \right)
  \stackrel{\simeq}{\to}
  \lim\left(
   \array{
     &amp;&amp; \mathbf{B}H
     \\
     &amp;&amp; \downarrow
     \\
     \mathbf{E}_{\mathbf{B}H} G &amp;\to&amp; \mathbf{B}G
   }
  \right)
  \simeq
  \lim\left(
   \array{
     &amp;&amp; [I,\mathbf{B}G]
     \\
     &amp;&amp; \downarrow^{d_0 \times d_1}
     \\
     \mathbf{B}H \times \mathbf{B}H 
     &amp;\to&amp; \mathbf{B}G \times \mathbf{B}G
   }
  \right)
  =
  H \backslash\backslash G//H
  \,.

</annotation></semantics></math></div>
<p>This example, too, is important at <a class="existingWikiWord" href="/nlab/show/geometric+function+theory">geometric function theory</a>.</p>

<h4 id="homotopy_span_traces">Homotopy span traces</h4>

<ul>
<li>see the homotopy span traces discussed at <a class="existingWikiWord" href="/nlab/show/span+trace">span trace</a> for more examples of homotopy pullbacks</li>
</ul>

<h3 id="OverSimplicialDiagrams">Homotopy colimits of simplicial diagrams</h3>

<p>Recall that every <a class="existingWikiWord" href="/nlab/show/simplicial+set">simplicial set</a> is the <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a> of its <a class="existingWikiWord" href="/nlab/show/category+of+elements">elements</a> (<a href="simplicial+set#SimplicialSetIsColimitOfItsSimplices">this Prop.</a>). The following says that this is in fact a homotopy colimit, up to equivalence.</p>

<div class="num_prop" id="SimplicialSetIsHomotopyColimitOverItself">
<h6 id="proposition_2">Proposition</h6>

<p><strong>(<a class="existingWikiWord" href="/nlab/show/simplicial+set">simplicial set</a> is <a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a> of its cells)</strong></p>

<p>Every <a class="existingWikiWord" href="/nlab/show/simplicial+set">simplicial set</a> is the <a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a> over its cells.</p>

<p>Precisely: for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>∈</mo></mrow><annotation encoding="application/x-tex">X \in </annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a> a <a class="existingWikiWord" href="/nlab/show/simplicial+set">simplicial set</a>, let</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mover><mi>X</mi><mo stretchy="false">˜</mo></mover><mspace width="thickmathspace"></mspace><mo lspace="verythinmathspace">:</mo><mspace width="thickmathspace"></mspace><msup><mi>Δ</mi> <mi>op</mi></msup><mover><mo>→</mo><mspace width="thickmathspace"></mspace></mover><mi>Set</mi><mover><mo>↪</mo><mspace width="thickmathspace"></mspace></mover><mi>sSet</mi></mrow><annotation encoding="application/x-tex">
  \tilde X 
  \;\colon\; 
  \Delta^{op} 
    \xrightarrow{\;} 
   Set 
    \xhookrightarrow{\;} 
   sSet

</annotation></semantics></math></div>
<p>be the corresponding <a class="existingWikiWord" href="/nlab/show/bisimplicial+set">bisimplicial set</a> which in degree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math> is the the constant simplicial set on the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>k</mi></msub></mrow><annotation encoding="application/x-tex">X_k</annotation></semantics></math> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math>-simplices.</p>

<p>For the standard homotopical structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>sSet</mi> <mrow><msup><mi>Δ</mi> <mi>op</mi></msup></mrow></msup></mrow><annotation encoding="application/x-tex">sSet^{\Delta^{op}}</annotation></semantics></math>, the homotopy colimit over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>X</mi><mo stretchy="false">˜</mo></mover></mrow><annotation encoding="application/x-tex">\tilde X</annotation></semantics></math> is equivalent to the origianal <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mover><mi>X</mi><mo stretchy="false">˜</mo></mover><mover><mo>→</mo><mo>≃</mo></mover><mi>X</mi></mrow><annotation encoding="application/x-tex">
  hocolim \tilde X \stackrel{\simeq}{\to} X

</annotation></semantics></math></div>
<p>in the standard <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+sets">model structure on simplicial sets</a>.</p>
</div>

<div class="proof">
<h6 id="proof_3">Proof</h6>

<p>Use the <a class="existingWikiWord" href="/nlab/show/Reedy+model+structure">Reedy model structure</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta^{op}, sSet_{Quillen}]_{Reedy}</annotation></semantics></math>. With the coend recipe for the hocolim discussed above, it follows that the hocolim is the <a class="existingWikiWord" href="/nlab/show/coend">coend</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mo>∫</mo> <mrow><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>Δ</mi></mrow></msup><mi>Q</mi><msub><mo>′</mo> <mi>Reedy</mi></msub><mo stretchy="false">(</mo><mo>*</mo><mo stretchy="false">)</mo><mo>×</mo><msub><mi>Q</mi> <mi>Reedy</mi></msub><mo stretchy="false">(</mo><mover><mi>X</mi><mo stretchy="false">˜</mo></mover><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \int^{[k] \in \Delta} Q'_{Reedy}(*) \times Q_{Reedy}(\tilde X)
  \,,

</annotation></semantics></math></div>
<p>where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Q</mi><msub><mo>′</mo> <mi>Reedy</mi></msub><mo stretchy="false">(</mo><mi>⋯</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q'_{Reedy}(\cdots)</annotation></semantics></math> is a cofibrant resolution in the Reedy model structure <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta,sSet_{Quillen}]_{Reedy}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Q</mi> <mi>Reedy</mi></msub><mo stretchy="false">(</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q_{Reedy}(...)</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta^{op}, sSet_{Quillen}]_{Reedy}</annotation></semantics></math>. But by the discussion at <a href="http://ncatlab.org/nlab/show/Reedy+model+structure#SimplexCategory">Reedy model structure – simplex category</a> we have that</p>

<ul>
<li>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>X</mi><mo stretchy="false">˜</mo></mover></mrow><annotation encoding="application/x-tex">\tilde X</annotation></semantics></math> is always cofibrant in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta^{op},sSet_{Quillen}]_{Reedy}</annotation></semantics></math>;</p>
</li>

<li>
<p>a cofibrant resolution of the point in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta, sSet_{Quillen}]_{Reedy}</annotation></semantics></math> is given by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">]</mo><mo>:</mo><mi>Δ</mi><mo>→</mo><mi>sSet</mi></mrow><annotation encoding="application/x-tex">\Delta[-] : \Delta \to sSet</annotation></semantics></math>.</p>
</li>
</ul>

<p>It follows that the hocolim is given by</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mo>∫</mo> <mrow><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>Δ</mi></mrow></msup><mi>Δ</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>×</mo><msub><mi>X</mi> <mi>k</mi></msub><mspace width="thickmathspace"></mspace><mo>≃</mo><mspace width="thickmathspace"></mspace><mi>X</mi><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  \int^{[k] \in \Delta} \Delta[k] \times X_k
  \;\simeq\;
  X
  \,.

</annotation></semantics></math></div>
<p>which is the expression of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is an ordinary <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a> of its elements (<a href="simplicial+set#SimplicialSetIsColimitOfItsSimplices">this Prop.</a>, the “<a class="existingWikiWord" href="/nlab/show/co-Yoneda+lemma">co-Yoneda lemma</a>”).</p>
</div>

<div class="num_remark">
<h6 id="remark">Remark</h6>

<p>More generally with this kind of argument it follows that generally the homotopy colimit over a simplicial diagram of simplicial sets is represented by the <a href="bisimplicial+set#Diagonal">diagonal simplicial set</a> of the corresponding <a class="existingWikiWord" href="/nlab/show/bisimplicial+set">bisimplicial set</a>.</p>
</div>

<div class="num_remark">
<h6 id="remark_2">Remark</h6>

<p>This kind of argument has many immediate generalizations. For instance for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>=</mo><mo stretchy="false">[</mo><msup><mi>K</mi> <mi>op</mi></msup><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>inj</mi></msub></mrow><annotation encoding="application/x-tex">C = [K^{op}, sSet_{Quillen}]_{inj}</annotation></semantics></math> the injective <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">model structure on simplicial presheaves</a> over any small category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math>, or any of its left <a class="existingWikiWord" href="/nlab/show/Bousfield+localization+of+model+categories">Bousfield localizations</a>, we have that the cofibrations are objectwise those of simplicial sets, hence objectwise monomorphisms, hence it follows that every <a class="existingWikiWord" href="/nlab/show/simplicial+presheaf">simplicial presheaf</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> is the hocolim over its simplicial diagram of component presheaves.</p>
</div>

<p>For the following write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>Δ</mi></mstyle><mo>:</mo><mi>Δ</mi><mo>→</mo><mi>sSet</mi></mrow><annotation encoding="application/x-tex">\mathbf{\Delta} : \Delta \to sSet</annotation></semantics></math> for the <a class="existingWikiWord" href="/nlab/show/fat+simplex">fat simplex</a>.</p>

<p>
<div class='num_lemma'>
<h6>Lemma</h6>
<p>The fat simplex is Reedy cofibrant.</p>
</div>
</p>

<div class="proof">
<h6 id="proof_4">Proof</h6>

<p>By the discussion at <a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a>, the fat simplex is cofibrant in the projective <a class="existingWikiWord" href="/nlab/show/model+structure+on+functors">model structure on functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta, sSet_{Quillen}]_{proj}</annotation></semantics></math>. By the <a href="#Properties">general properties</a> of Reedy model structures, the identity functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub><mo>→</mo><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta, sSet_{Quillen}]_{proj} \to [\Delta, sSet_{Quillen}]_{Reedy}</annotation></semantics></math> is a <a class="existingWikiWord" href="/nlab/show/Quillen+adjunction">left Quillen functor</a>, hence preserves cofibrant objects.</p>
</div>

<div class="num_prop">
<h6 id="corollary">Corollary</h6>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>∈</mo><mo stretchy="false">[</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mo>,</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X \in [\Delta^{op}, C]</annotation></semantics></math> a Reedy cofibrant object, the <a class="existingWikiWord" href="/nlab/show/Bousfield-Kan+map">Bousfield-Kan map</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mo>∫</mo> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msup><mstyle mathvariant="bold"><mi>Δ</mi></mstyle><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>⋅</mo><msub><mi>X</mi> <mi>n</mi></msub><mo>→</mo><msup><mo>∫</mo> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msup><mi>Δ</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>⋅</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">
  \int^{[n]} \mathbf{\Delta}[n] \cdot X_n
  \to
  \int^{[n]} \Delta[n] \cdot X_n  

</annotation></semantics></math></div>
<p>is a weak equivalence in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
</div>

<div class="proof">
<h6 id="proof_5">Proof</h6>

<p>The <a class="existingWikiWord" href="/nlab/show/coend">coend</a> over the <a class="existingWikiWord" href="/nlab/show/copower">tensor</a> is a left <a class="existingWikiWord" href="/nlab/show/Quillen+bifunctor">Quillen bifunctor</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mo>∫</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub><mo>×</mo><mo stretchy="false">[</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">
  \int (-)\cdot (-) : [\Delta,sSet_{Quillen}]_{Reedy} \times
    [\Delta^{op}, C]_{Reedy}

</annotation></semantics></math></div>
<p>(as discussed there). Therefore with its second argument fixed and cofibrant it is a <a class="existingWikiWord" href="/nlab/show/Quillen+adjunction">left Quillen functor</a> in the remaining argument. As such, it preserves weak equivalences between cofibrant objects (by the <a class="existingWikiWord" href="/nlab/show/factorization+lemma">factorization lemma</a>). By the above discussion, both <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>Δ</mi></mstyle><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{\Delta}[n]</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\Delta[-]</annotation></semantics></math> are indeed cofibrant in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>Δ</mi><mo>,</mo><msub><mi>sSet</mi> <mi>Quillen</mi></msub><msub><mo stretchy="false">]</mo> <mi>Reedy</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta,sSet_{Quillen}]_{Reedy}</annotation></semantics></math>. Clearly the functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="bold"><mi>Δ</mi></mstyle><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">]</mo><mo>→</mo><mi>Δ</mi><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">−</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{\Delta}[-] \to \Delta[-]</annotation></semantics></math> is objectwise a weak equivalence in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>sSet</mi> <mi>Quillen</mi></msub></mrow><annotation encoding="application/x-tex">sSet_{Quillen}</annotation></semantics></math>, hence is a weak equivalence.</p>
</div>

<div class="num_prop">
<h6 id="proposition_3">Proposition</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>i</mi><mo>:</mo><msub><mi>Δ</mi> <mi>f</mi></msub><mo>↪</mo><mi>Δ</mi></mrow><annotation encoding="application/x-tex"> i : \Delta_f  \hookrightarrow \Delta</annotation></semantics></math> be the inclusion into the <a class="existingWikiWord" href="/nlab/show/simplex+category">simplex category</a> of all the monomorphisms (all the face maps).</p>

<p>This inclusion is a homotopy-<a class="existingWikiWord" href="/nlab/show/initial+functor">initial functor</a>. As a consequence, homotopy colimits of shape <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math> can equivalently be computed after their restriction to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>Δ</mi> <mi>f</mi></msub></mrow><annotation encoding="application/x-tex">\Delta_f</annotation></semantics></math></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mo stretchy="false">(</mo><msup><mi>Δ</mi> <mi>op</mi></msup><mover><mo>→</mo><mi>F</mi></mover><mi>C</mi><mo stretchy="false">)</mo><mo>≃</mo><mi>hocolim</mi><mo stretchy="false">(</mo><msubsup><mi>Δ</mi> <mi>f</mi> <mi>op</mi></msubsup><mover><mo>→</mo><mrow><msup><mi>i</mi> <mi>op</mi></msup></mrow></mover><msup><mi>Δ</mi> <mi>op</mi></msup><mover><mo>→</mo><mi>F</mi></mover><mi>C</mi><mo stretchy="false">)</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
  hocolim(  \Delta^{op} \stackrel{F}{\to} C)
  \simeq
  hocolim( \Delta_f^{op} \stackrel{i^{op}}{\to} \Delta^{op} \stackrel{F}{\to} C)
  \,.

</annotation></semantics></math></div></div>

<p>See (<a href="#Dugger">Dugger, example 18.2</a>).</p>

<h3 id="homotopy_colimits_of_diagrams_of_spaces">Homotopy colimits of diagrams of spaces</h3>

<h4 id="by_geometric_realization">By geometric realization</h4>

<p>The following is sometimes in the literature taken as the definition of homotopy colimits of diagrams of spaces. It is one of the earliest formulas for there.</p>

<div class="num_defn">
<h6 id="definition">Definition</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/category">category</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo></mrow><annotation encoding="application/x-tex">F : D \to</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/Top">Top</a> a <a class="existingWikiWord" href="/nlab/show/functor">functor</a>.</p>

<p>Define a <a class="existingWikiWord" href="/nlab/show/simplicial+topological+space">simplicial topological space</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>sF</mi></mrow><annotation encoding="application/x-tex">sF</annotation></semantics></math> by setting</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>sF</mi><mo>:</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>↦</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">∐</mo> <mrow><msub><mi>d</mi> <mn>0</mn></msub><mo>←</mo><msub><mi>d</mi> <mn>1</mn></msub><mo>←</mo><mi>⋯</mi><mo>←</mo><msub><mi>d</mi> <mi>n</mi></msub></mrow></munder><mi>F</mi><mo stretchy="false">(</mo><msub><mi>d</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  sF : [n] \mapsto \coprod_{d_0 \leftarrow d_1 \leftarrow \cdots \leftarrow d_n} F(d_n) 

</annotation></semantics></math></div>
<p>and using the obvious face and degeneracy maps: face maps act by mapping components of the <a class="existingWikiWord" href="/nlab/show/coproduct">coproduct</a>s of one sequence of morphisms to one obtained by deleting outer arrows or composing inner arrows. If the rightmost arrow is deleted, then the component map is not the identity but is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>d</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>d</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(d_n) \to F(d_{n-1})</annotation></semantics></math>. The degeneracy maps similarly introduce identity morphisms.</p>
</div>

<div class="num_theorem">
<h6 id="theorem_2">Theorem</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/category">category</a> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>D</mi><mo>→</mo></mrow><annotation encoding="application/x-tex">F : D \to</annotation></semantics></math> <a class="existingWikiWord" href="/nlab/show/Top">Top</a> a <a class="existingWikiWord" href="/nlab/show/functor">functor</a>. Then the homotopy colimit of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math> is equivalent to the <a class="existingWikiWord" href="/nlab/show/geometric+realization+of+simplicial+topological+spaces">geometric realization of simplicial topological spaces</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">s F</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>F</mi><mo>≃</mo><mo stretchy="false">|</mo><mi>sF</mi><mo stretchy="false">|</mo><mspace width="thinmathspace"></mspace><mo>.</mo></mrow><annotation encoding="application/x-tex">
   hocolim F \simeq \vert sF \vert
  \,.

</annotation></semantics></math></div></div>

<p>This is an application of the <a href="BarConstruction">bar-construction method</a>.</p>

<p>See for instance (<a href="#Dugger">Dugger, part 1</a>) for an exposition.</p>

<h4 id="higher_homotopy_van_kampen_theorem">Higher homotopy van Kampen theorem</h4>

<div class="num_theorem">
<h6 id="theorem_3">Theorem</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/topological+space">topological space</a>, write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Op(X)</annotation></semantics></math> for its <a class="existingWikiWord" href="/nlab/show/category+of+open+subsets">category of open subsets</a> and let</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>χ</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>Op</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
  \chi : C \to Op(C)

</annotation></semantics></math></div>
<p>a <a class="existingWikiWord" href="/nlab/show/functor">functor</a> out of a <a class="existingWikiWord" href="/nlab/show/small+category">small category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> such that</p>

<ul>
<li>for each point <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x\in X</annotation></semantics></math> the <a class="existingWikiWord" href="/nlab/show/full+subcategory">full subcategory</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>C</mi> <mi>x</mi></msub></mrow><annotation encoding="application/x-tex">C_x</annotation></semantics></math> of objects <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math> such that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>χ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\chi(x)</annotation></semantics></math> contains <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> has a <a class="existingWikiWord" href="/nlab/show/weak+homotopy+equivalence">weakly</a> <a class="existingWikiWord" href="/nlab/show/contractible">contractible</a> <a class="existingWikiWord" href="/nlab/show/nerve">nerve</a>.</li>
</ul>

<p>Then:</p>

<p>the canonical morphism in <a class="existingWikiWord" href="/nlab/show/sSet">sSet</a> out of the <a class="existingWikiWord" href="/nlab/show/colimit">colimit</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><munder><mi>lim</mi> <mo>→</mo></munder></mrow><mi>Sing</mi><mo>∘</mo><mi>χ</mi><mo>→</mo><mi>Sing</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
   {\lim_\to} Sing \circ \chi \to Sing(X)

</annotation></semantics></math></div>
<p>into the <a class="existingWikiWord" href="/nlab/show/singular+simplicial+complex">singular simplicial complex</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> exhibits <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sing</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Sing(X)</annotation></semantics></math> as the <a class="existingWikiWord" href="/nlab/show/homotopy+colimit">homotopy colimit</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>hocolim</mi><mi>Sing</mi><mo>∘</mo><mi>χ</mi></mrow><annotation encoding="application/x-tex">hocolim Sing \circ \chi</annotation></semantics></math>.</p>
</div>

<p>See <a class="existingWikiWord" href="/nlab/show/higher+homotopy+van+Kampen+theorem">higher homotopy van Kampen theorem</a> for details.</p>

<h3 id="SequentialHocolims">Sequential homotopy (co)limits</h3>

<h4 id="general">General</h4>

<p>For</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>D</mi><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo>→</mo><mn>1</mn><mo>→</mo><mn>2</mn><mo>→</mo><mi>⋯</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">
  D = \{0 \to 1 \to 2 \to \cdots\}

</annotation></semantics></math></div>
<p>the cotower category, a colimit of shape <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math> is called a <a class="existingWikiWord" href="/nlab/show/sequential+colimit">sequential colimit</a>. For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> a <a class="existingWikiWord" href="/nlab/show/combinatorial+model+category">combinatorial model category</a> it is easy to characterize the cofibrant objects in the projective <a class="existingWikiWord" href="/nlab/show/model+structure+on+functors">model structure on functors</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>D</mi><mo>,</mo><mi>C</mi><msub><mo stretchy="false">]</mo> <mi>proj</mi></msub></mrow><annotation encoding="application/x-tex">[D, C]_{proj}</annotation></semantics></math>: these are those cotower diagrams all whose morphisms are cofibrations and whose 0th object (and hence all objects) are cofibrant.</p>

<p>So given a cotower with such a property, its homotopy colimit is just the ordinary sequential colimit in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>

<p>Dually for sequential limits of a tower diagram.</p>

<p>A standard application for this is for instance the construction of the <a class="existingWikiWord" href="/nlab/show/classifying+space">classifying space</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mi>U</mi><mo>=</mo><munder><mi>lim</mi><mrow><msub><mo>→</mo> <mi>n</mi></msub></mrow></munder><mi>B</mi><mi>U</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B U = \underset{\to_n}{\lim} B U(n)</annotation></semantics></math> for reduced <a class="existingWikiWord" href="/nlab/show/topological+K-theory">topological K-theory</a>. See there for more.</p>

<h4 id="_and_milnor_sequences"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>lim</mi> <mn>1</mn></msup></mrow><annotation encoding="application/x-tex">\lim^1</annotation></semantics></math> and Milnor sequences</h4>

<p>See at <em><a class="existingWikiWord" href="/nlab/show/lim%5E1+and+Milnor+sequences">lim^1 and Milnor sequences</a></em></p>

<h3 id="descent_objects">Descent objects</h3>

<p><em>Descent objects</em> as they appear in <a class="existingWikiWord" href="/nlab/show/descent">descent and codescent</a> are naturally conceived as homotopy limits. See also <a class="existingWikiWord" href="/nlab/show/infinity-stack">infinity-stack</a>.</p>

<h3 id="SimpSheaves">Homotopy (co)limits of simplicial pre(sheaves)</h3>

<p>The local <a class="existingWikiWord" href="/nlab/show/model+structure+on+simplicial+presheaves">model structure on simplicial presheaves</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SPSh</mi><mo stretchy="false">(</mo><mi>C</mi><msubsup><mo stretchy="false">)</mo> <mrow><mi>proj</mi><mo stretchy="false">/</mo><mi>inj</mi></mrow> <mi>loc</mi></msubsup></mrow><annotation encoding="application/x-tex">SPSh(C)_{proj/inj}^{loc}</annotation></semantics></math> over a <a class="existingWikiWord" href="/nlab/show/site">site</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> serve as <a class="existingWikiWord" href="/nlab/show/models+for+%E2%88%9E-stack+%28%E2%88%9E%2C1%29-toposes">models for ∞-stack (∞,1)-toposes</a>.</p>

<p>Here we discuss some properties of homotopy limits and colimits in such model categories of simplicial presheaves.</p>

<h4 id="preservation_of_homotopy_pullback_by_inverse_images">Preservation of homotopy pullback by inverse images</h4>

<p>For <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>,</mo><mi>C</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">C, C'</annotation></semantics></math> two <a class="existingWikiWord" href="/nlab/show/site">site</a>s, a <a class="existingWikiWord" href="/nlab/show/geometric+morphism">geometric morphism</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>Sh</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mo>←</mo></mover><mi>Sh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p : Sh(C) \stackrel{\leftarrow}{\to} Sh(C')</annotation></semantics></math> of <a class="existingWikiWord" href="/nlab/show/Grothendieck+topos">sheaf topos</a>es induces correspondingly an <a class="existingWikiWord" href="/nlab/show/adjunction">adjunction</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mover><mo>→</mo><mo>←</mo></mover><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo><mo>:</mo><msup><mi>p</mi> <mo>*</mo></msup></mrow><annotation encoding="application/x-tex">
  p : SSh(C) \stackrel{\leftarrow}{\to} SSh(C') : p^*

</annotation></semantics></math></div>
<p>of simplicial (pre)sheaves. One would like this to extend to a <a class="existingWikiWord" href="/nlab/show/Quillen+adjunction">Quillen adjunction</a> that recalls the fact that it came from a geometric morphism by the fact that the <a class="existingWikiWord" href="/nlab/show/left+adjoint">left adjoint</a> <a class="existingWikiWord" href="/nlab/show/inverse+image">inverse image</a> functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo><mo>→</mo><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SSh(C') \to SSh(C)</annotation></semantics></math> preserves finite homotopy limits.</p>

<p>In particular, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">C'</annotation></semantics></math> have the same underlying category but <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">C'</annotation></semantics></math> the trivial <a class="existingWikiWord" href="/nlab/show/coverage">coverage</a>, then the <a class="existingWikiWord" href="/nlab/show/geometric+morphism">geometric morphism</a> in question is the inclusion of a <a class="existingWikiWord" href="/nlab/show/reflective+subcategory">reflective subcategory</a> which typically induces a <a class="existingWikiWord" href="/nlab/show/Bousfield+localization">Bousfield localization</a> of model categories that models the injection of a <a class="existingWikiWord" href="/nlab/show/reflective+%28%E2%88%9E%2C1%29-subcategory">reflective (∞,1)-subcategory</a> of <a class="existingWikiWord" href="/nlab/show/%E2%88%9E-stack">∞-stack</a>s into <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-presheaves. Here the morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>SPSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo><mo>→</mo><mi>SPSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">SPSh(C') \to SPSh(C)</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>∞</mn></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math>-stackification and should preserve finite homotopy limits.</p>

<p>The following result says that a strong version of this statement is true, at least for the preservation of homotopy pullbacks.</p>

<div class="num_theorem">
<h6 id="theorem_4">Theorem</h6>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>p</mi><mo>:</mo><mi>Sh</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Sh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p : Sh(C) \to Sh(C')</annotation></semantics></math> be a <a class="existingWikiWord" href="/nlab/show/geometric+morphism">geometric morphism</a> of <a class="existingWikiWord" href="/nlab/show/Grothendieck+topos">Grothendieck topos</a>es. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>p</mi> <mo>*</mo></msup><mo>:</mo><mi>Sh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo><mo>→</mo><mi>Sh</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p^* : Sh(C') \to Sh(C)</annotation></semantics></math> be the corresponding <a class="existingWikiWord" href="/nlab/show/inverse+image">inverse image</a> functor and let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><msup><mi>p</mi> <mo>*</mo></msup><mo>:</mo><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><mo stretchy="false">)</mo><mo>→</mo><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s p^* : SSh(C') \to SSh(C)</annotation></semantics></math> be its degreewise extension to functor of <a class="existingWikiWord" href="/nlab/show/simplicial+presheaf">simplicial sheaf</a> categories.</p>

<p>Regarded as a functor between the corresponding <a class="existingWikiWord" href="/nlab/show/local+model+structure+on+simplicial+sheaves">local injective model structures on simplicial sheaves</a> on both sides</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mi>s</mi><msup><mi>p</mi> <mo>*</mo></msup><mo>:</mo><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><mo>′</mo><msubsup><mo stretchy="false">)</mo> <mi>inj</mi> <mi>loc</mi></msubsup><mo>→</mo><mi>SSh</mi><mo stretchy="false">(</mo><mi>C</mi><msubsup><mo stretchy="false">)</mo> <mi>inj</mi> <mi>loc</mi></msubsup></mrow><annotation encoding="application/x-tex">
  s p^* : SSh(C')_{inj}^{loc} \to SSh(C)_{inj}^{loc}

</annotation></semantics></math></div>
<p>this functor preserves homotopy pullbacks.</p>
</div>

<div class="proof">
<h6 id="proof_6">Proof</h6>

<p>This appears as theorem 1.5 in</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Charles+Rezk">Charles Rezk</a>, <em>Fibrations and homotopy colimits of simplicial sheaves</em> (<a href="http://arxiv.org/abs/math/9811038">arXiv</a>)</li>
</ul>
</div>

<h3 id="more_examples_and_special_cases">More examples and special cases</h3>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/filtered+homotopy+colimit">filtered homotopy colimit</a></li>
</ul>

<h2 id="related_concepts">Related concepts</h2>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/%28%E2%88%9E%2C1%29-limit">(∞,1)-limit</a><a class="existingWikiWord" href="/nlab/show/lax+%28%E2%88%9E%2C1%29-colimit">lax (∞,1)-colimit</a></p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/mapping+cone">mapping cone</a>, <a class="existingWikiWord" href="/nlab/show/mapping+telescope">mapping telescope</a></p>
</li>
</ul>

<h2 id="references">References</h2>

<h3 id="general_2">General</h3>

<p>The classical references are</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Aldridge+Bousfield">Aldridge Bousfield</a>, <a class="existingWikiWord" href="/nlab/show/Dan+Kan">Dan Kan</a>, <em>Homotopy limits, completions, and localizations</em>, Springer LNM <strong>304</strong>, (see in particular chapter XI)</li>
</ul>

<p>and</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/R.+M.+Vogt">R. M. Vogt</a>, <em>Homotopy limits and colimits</em>, Math. Z., 134 (1973) 11-52.</li>
</ul>

<p>See</p>

<ul>
<li id="Adams74"><a class="existingWikiWord" href="/nlab/show/Frank+Adams">Frank Adams</a>, part III, section 8 of <em><a class="existingWikiWord" href="/nlab/show/Stable+homotopy+and+generalised+homology">Stable homotopy and generalised homology</a></em>, 1974</li>
</ul>

<p>More recently one has:</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/William+Dwyer">William Dwyer</a>, <a class="existingWikiWord" href="/nlab/show/Philip+Hirschhorn">Philip Hirschhorn</a>, <a class="existingWikiWord" href="/nlab/show/Daniel+Kan">Daniel Kan</a>,
<p><a class="existingWikiWord" href="/nlab/show/Jeff+Smith">Jeff Smith</a>, <em><a class="existingWikiWord" href="/nlab/show/Homotopy+Limit+Functors+on+Model+Categories+and+Homotopical+Categories">Homotopy Limit Functors on Model Categories and Homotopical Categories</a></em>, Mathematical Surveys and Monographs <strong>113</strong></p>
</li>
</ul>

<p>An introduction is</p>

<ul>
<li id="Dugger"><a class="existingWikiWord" href="/nlab/show/Daniel+Dugger">Daniel Dugger</a>, <em>A primer on homotopy colimits</em> (<a href="http://math.uoregon.edu/~ddugger/hocolim.pdf">pdf</a>)</li>
</ul>

<p>A general overview via universal properties is in the</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Georges+Maltsiniotis">Georges Maltsiniotis</a> lectures, Sevilla (2008)</p>

<p>I, localizers, (<a href="http://people.math.jussieu.fr/~maltsin/Seville/Lecture_I_Localizers.pdf">pdf</a>);</p>

<p>II, <a class="existingWikiWord" href="/nlab/show/model+categories">model categories</a>, (<a href="http://people.math.jussieu.fr/~maltsin/Seville/Lecture_II_Model_Categories.pdf">pdf</a>);</p>

<p>III, <a class="existingWikiWord" href="/nlab/show/derivator">derivator</a>s, (<a href="http://people.math.jussieu.fr/~maltsin/Seville/Lecture_III_Derivators.pdf">pdf</a>):</p>

<p>IV, summary on derivators (<a href="http://people.math.jussieu.fr/~maltsin/Seville/Summary_on_Derivators.pdf">pdf</a>)</p>
</li>
</ul>

<p>In</p>

<ul>
<li>Wojciech Chacholski and Jerome Scherer, <em>Homotopy theory of diagrams</em> (<a href="http://arxiv.org/abs/math.AT/0110316">arXiv</a>)</li>
</ul>

<p>is given a global definition of homotopy (co)limit as <a href="http://arxiv.org/PS_cache/math/pdf/0110/0110316v1.pdf#page=19">4.1, p. 14</a>, and it is discussed how to compute homotopy (co)limits concretely using local constructions. For instance the above statement on the computation of homotopy pullbacks is proposition <a href="http://arxiv.org/PS_cache/math/pdf/0110/0110316v1.pdf#page=20">2.5, p. 15</a></p>

<p>A nice discussion of the expression of homotopy colimits in terms of coends is in</p>

<ul>
<li id="Gambino10"><a class="existingWikiWord" href="/nlab/show/Nicola+Gambino">Nicola Gambino</a>, <em>Weighted limits in simplicial homotopy theory</em>, Journal of Pure and Applied Algebra Volume 214, Issue 7, July 2010, Pages 1193–1199 (<a href="http://www.crm.cat/Publications/08/Pr790.pdf">pdf</a>, <a href="http://www.sciencedirect.com/science/article/pii/S0022404909002412">publisher</a>).</li>
</ul>

<p>A collection of examples and exercises is in</p>

<ul>
<li id="Isaacson"><a class="existingWikiWord" href="/nlab/show/Samuel+Isaacson">Samuel Isaacson</a>, <em>Excercises in homotopy colimits</em> (<a href="http://www-math.mit.edu/~mbehrens/TAGS/Isaacson_exer.pdf">pdf</a>)</li>
</ul>

<p>See also</p>

<ul>
<li><a class="existingWikiWord" href="/nlab/show/Samuel+Isaacson">Samuel Isaacson</a>, <em>A note on unenriched homotopy coends</em> (<a href="http://www.ma.utexas.edu/users/isaacson/PDFs/coends.pdf">pdf</a>)</li>
</ul>

<p>Homotopy limits for <a class="existingWikiWord" href="/nlab/show/triangulated+categories">triangulated categories</a> are studied in</p>

<ul>
<li>Marcel Bökstedt, <a class="existingWikiWord" href="/nlab/show/Amnon+Neeman">Amnon Neeman</a>, <em>Homotopy limits in triangulated categories</em>, Compositio Math. <strong>86</strong> (1993), no. 2, 209–234, <a href="http://www.ams.org/mathscinet-getitem?mr=1214458">MR94f:18008</a>, <a href="http://www.numdam.org/item?id=CM_1993__86_2_209_0">numdam</a></li>
</ul>

<p>Other references are</p>

<ul>
<li>
<p>Philip Hirschhorn, <em>Model categories and their localizations</em>. Defines and studies (local) homotopy limits in model categories.</p>
</li>

<li>
<p>Dwyer, Hirschhorn, Kan, Smith, <em>Homotopy limit functors in model categories and homotopical categories</em>. Defines global homotopy limits in homotopical categories and computes them using local constructions.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Michael+Shulman">Michael Shulman</a>, <em>Homotopy limits and colimits and enriched homotopy theory</em>, <a href="http://arxiv.org/abs/math/0610194">math.CT/0610194</a>. Constructs and compares local and global weighted homotopy limits in enriched homotopical categories, where the domain category is also allowed to be enriched.</p>
</li>

<li>
<p>Sergey Arkhipov, Sebastian Ørsted, <em>Homotopy (co)limits via homotopy (co)ends in general combinatorial model categories</em>, <a href="https://arxiv.org/abs/1807.03266">arxiv</a>. A version of <a href="#Gambino10">Weighted limits in simplicial homotopy theory</a> that doesn’t require simplicial enrichment.</p>
</li>

<li>
<p>Nicola Gambino, <em>Homotopy limits for 2-categories</em> (<a href="http://www.lacim.uqam.ca/~gambino/homotopy.pdf">pdf</a>), published as: Mathematical Proceedings of the Cambridge Philosophical Society 145 (2008) 43-63.) Proves that homotopy limits in a 2-category with its natural model structure coincide with 2-categorical <a class="existingWikiWord" href="/nlab/show/strict+2-limit">pseudo-limits</a>, and hence give <a class="existingWikiWord" href="/nlab/show/2-limits">2-limits</a>.</p>
</li>

<li>
<p><a class="existingWikiWord" href="/nlab/show/Jacob+Lurie">Jacob Lurie</a>, <a class="existingWikiWord" href="/nlab/show/Higher+Topos+Theory">Higher Topos Theory</a>. Lots of stuff about <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,1)</annotation></semantics></math>-categories, including the computation of homotopy limits (section 4.2.4).</p>
</li>

<li>
<p>Andre Hirschowitz, <a class="existingWikiWord" href="/nlab/show/Carlos+Simpson">Carlos Simpson</a>, <a href="http://arxiv.org/abs/math.AG/9807049">Descent pour les n-champs</a>. Probably there is some good stuff in here about homotopy limits and limits in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mn>∞</mn><mo>,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\infty,n)</annotation></semantics></math>-categories.</p>
</li>

<li>
<p>Beatriz Rodriguez Gonzalez, <em>Realizable homotopy colimits</em> (<a href="http://arxiv.org/abs/1104.0646">arXiv:1104.0646</a>)</p>
</li>

<li>
<p>MathOverflow question: <a href="http://mathoverflow.net/questions/38047/what-is-the-universal-problem-that-motivates-the-definition-of-homotopy-limits">universal-problem-that-motivates-the-definition-of-homotopy-limits</a></p>
</li>
</ul>

<p>Discussion in the context of the <a class="existingWikiWord" href="/nlab/show/%28infinity%2C1%29-Grothendieck+construction">(infinity,1)-Grothendieck construction</a> is in</p>

<ul>
<li id="HeutsMoerdijk13"><a class="existingWikiWord" href="/nlab/show/Gijs+Heuts">Gijs Heuts</a>, <a class="existingWikiWord" href="/nlab/show/Ieke+Moerdijk">Ieke Moerdijk</a>, <em>Left fibrations and homotopy colimits</em> (<a href="http://arxiv.org/abs/1308.0704">arXiv:1308.0704</a>)</li>
</ul>

<h3 id="in_homotopy_type_theory">In homotopy type theory</h3>

<p>A formalization of some aspects of homotopy limits in terms of <a class="existingWikiWord" href="/nlab/show/homotopy+type+theory">homotopy type theory</a> is <a class="existingWikiWord" href="/nlab/show/Coq">Coq</a>-coded in</p>

<ul>
<li>
<p><a class="existingWikiWord" href="/nlab/show/Guillaume+Brunerie">Guillaume Brunerie</a>, <em><a href="https://github.com/guillaumebrunerie/HoTT/tree/master/Coq/Limits">HoTT/Coq/Limits</a></em></p>
</li>

<li>
<p>Jeremy Avigad, <a class="existingWikiWord" href="/nlab/show/Chris+Kapulkin">Chris Kapulkin</a>, <a class="existingWikiWord" href="/nlab/show/Peter+LeFanu+Lumsdaine">Peter LeFanu Lumsdaine</a>, <em>Homotopy limits in Coq</em> (<a href="http://arxiv.org/abs/1304.0680">arXiv:1304.0680</a>)</p>
</li>
</ul>
</body></html>

</div>

<div class="revisedby">
    <p>
    Last revised on September 24, 2021 at 11:15:10.
    See the <a href="https://ncatlab.org/nlab/history/homotopy limit" style="color: #005c19">history</a> of this page for a list of all contributions to it.
    </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/homotopy+limit" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a><a href="https://nforum.ncatlab.org/discussion/10163/#Item_1">Discuss</a><span class="backintime"><a href="/nlab/revision/homotopy+limit/96" accesskey="B" class="navlinkbackintime" id="to_previous_revision" rel="nofollow">Previous revision</a></span><a href="/nlab/show/diff/homotopy+limit" accesskey="C" class="navlink" id="see_changes" rel="nofollow">Changes from previous revision</a><a href="/nlab/history/homotopy+limit" accesskey="S" class="navlink" id="history" rel="nofollow">History (96 revisions)</a>
  <a href="https://ncatlab.org/nlab/show/homotopy limit/cite" style="color: black">Cite</a>
  <a href="/nlab/print/homotopy+limit" accesskey="p" id="view_print" rel="nofollow">Print</a>
    <a href="/nlab/source/homotopy+limit" id="view_source" rel="nofollow">Source</a>

  


</div>


</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
